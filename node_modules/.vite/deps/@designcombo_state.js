import {
  ir,
  or,
  sr
} from "./chunk-6MWGUGVM.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/.pnpm/@designcombo+state@5.1.0_@designcombo+events@1.0.2_@designcombo+types@5.1.0/node_modules/@designcombo/state/dist/index.es.js
var Fs = Object.defineProperty;
var Ls = (t, r, e) => r in t ? Fs(t, r, { enumerable: true, configurable: true, writable: true, value: e }) : t[r] = e;
var Nt = (t, r, e) => Ls(t, typeof r != "symbol" ? r + "" : r, e);
var bn = function(t, r) {
  return bn = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, n) {
    e.__proto__ = n;
  } || function(e, n) {
    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
  }, bn(t, r);
};
function tr(t, r) {
  if (typeof r != "function" && r !== null)
    throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
  bn(t, r);
  function e() {
    this.constructor = t;
  }
  t.prototype = r === null ? Object.create(r) : (e.prototype = r.prototype, new e());
}
function kn(t) {
  var r = typeof Symbol == "function" && Symbol.iterator, e = r && t[r], n = 0;
  if (e) return e.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t };
    }
  };
  throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function vn(t, r) {
  var e = typeof Symbol == "function" && t[Symbol.iterator];
  if (!e) return t;
  var n = e.call(t), i, o = [], c;
  try {
    for (; (r === void 0 || r-- > 0) && !(i = n.next()).done; ) o.push(i.value);
  } catch (u) {
    c = { error: u };
  } finally {
    try {
      i && !i.done && (e = n.return) && e.call(n);
    } finally {
      if (c) throw c.error;
    }
  }
  return o;
}
function _n(t, r, e) {
  if (e || arguments.length === 2) for (var n = 0, i = r.length, o; n < i; n++)
    (o || !(n in r)) && (o || (o = Array.prototype.slice.call(r, 0, n)), o[n] = r[n]);
  return t.concat(o || Array.prototype.slice.call(r));
}
function xt(t) {
  return typeof t == "function";
}
function as(t) {
  var r = function(n) {
    Error.call(n), n.stack = new Error().stack;
  }, e = t(r);
  return e.prototype = Object.create(Error.prototype), e.prototype.constructor = e, e;
}
var pn = as(function(t) {
  return function(e) {
    t(this), this.message = e ? e.length + ` errors occurred during unsubscription:
` + e.map(function(n, i) {
      return i + 1 + ") " + n.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = e;
  };
});
function Sn(t, r) {
  if (t) {
    var e = t.indexOf(r);
    0 <= e && t.splice(e, 1);
  }
}
var Ar = function() {
  function t(r) {
    this.initialTeardown = r, this.closed = false, this._parentage = null, this._finalizers = null;
  }
  return t.prototype.unsubscribe = function() {
    var r, e, n, i, o;
    if (!this.closed) {
      this.closed = true;
      var c = this._parentage;
      if (c)
        if (this._parentage = null, Array.isArray(c))
          try {
            for (var u = kn(c), p = u.next(); !p.done; p = u.next()) {
              var h = p.value;
              h.remove(this);
            }
          } catch (k) {
            r = { error: k };
          } finally {
            try {
              p && !p.done && (e = u.return) && e.call(u);
            } finally {
              if (r) throw r.error;
            }
          }
        else
          c.remove(this);
      var m = this.initialTeardown;
      if (xt(m))
        try {
          m();
        } catch (k) {
          o = k instanceof pn ? k.errors : [k];
        }
      var I = this._finalizers;
      if (I) {
        this._finalizers = null;
        try {
          for (var d = kn(I), b = d.next(); !b.done; b = d.next()) {
            var w = b.value;
            try {
              Un(w);
            } catch (k) {
              o = o ?? [], k instanceof pn ? o = _n(_n([], vn(o)), vn(k.errors)) : o.push(k);
            }
          }
        } catch (k) {
          n = { error: k };
        } finally {
          try {
            b && !b.done && (i = d.return) && i.call(d);
          } finally {
            if (n) throw n.error;
          }
        }
      }
      if (o)
        throw new pn(o);
    }
  }, t.prototype.add = function(r) {
    var e;
    if (r && r !== this)
      if (this.closed)
        Un(r);
      else {
        if (r instanceof t) {
          if (r.closed || r._hasParent(this))
            return;
          r._addParent(this);
        }
        (this._finalizers = (e = this._finalizers) !== null && e !== void 0 ? e : []).push(r);
      }
  }, t.prototype._hasParent = function(r) {
    var e = this._parentage;
    return e === r || Array.isArray(e) && e.includes(r);
  }, t.prototype._addParent = function(r) {
    var e = this._parentage;
    this._parentage = Array.isArray(e) ? (e.push(r), e) : e ? [e, r] : r;
  }, t.prototype._removeParent = function(r) {
    var e = this._parentage;
    e === r ? this._parentage = null : Array.isArray(e) && Sn(e, r);
  }, t.prototype.remove = function(r) {
    var e = this._finalizers;
    e && Sn(e, r), r instanceof t && r._removeParent(this);
  }, t.EMPTY = function() {
    var r = new t();
    return r.closed = true, r;
  }(), t;
}();
var os = Ar.EMPTY;
function cs(t) {
  return t instanceof Ar || t && "closed" in t && xt(t.remove) && xt(t.add) && xt(t.unsubscribe);
}
function Un(t) {
  xt(t) ? t() : t.unsubscribe();
}
var Hs = {
  Promise: void 0
};
var Us = {
  setTimeout: function(t, r) {
    for (var e = [], n = 2; n < arguments.length; n++)
      e[n - 2] = arguments[n];
    return setTimeout.apply(void 0, _n([t, r], vn(e)));
  },
  clearTimeout: function(t) {
    return clearTimeout(t);
  },
  delegate: void 0
};
function js(t) {
  Us.setTimeout(function() {
    throw t;
  });
}
function jn() {
}
function kr(t) {
  t();
}
var us = function(t) {
  tr(r, t);
  function r(e) {
    var n = t.call(this) || this;
    return n.isStopped = false, e ? (n.destination = e, cs(e) && e.add(n)) : n.destination = Gs, n;
  }
  return r.create = function(e, n, i) {
    return new wn(e, n, i);
  }, r.prototype.next = function(e) {
    this.isStopped || this._next(e);
  }, r.prototype.error = function(e) {
    this.isStopped || (this.isStopped = true, this._error(e));
  }, r.prototype.complete = function() {
    this.isStopped || (this.isStopped = true, this._complete());
  }, r.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = true, t.prototype.unsubscribe.call(this), this.destination = null);
  }, r.prototype._next = function(e) {
    this.destination.next(e);
  }, r.prototype._error = function(e) {
    try {
      this.destination.error(e);
    } finally {
      this.unsubscribe();
    }
  }, r.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, r;
}(Ar);
var Ws = function() {
  function t(r) {
    this.partialObserver = r;
  }
  return t.prototype.next = function(r) {
    var e = this.partialObserver;
    if (e.next)
      try {
        e.next(r);
      } catch (n) {
        br(n);
      }
  }, t.prototype.error = function(r) {
    var e = this.partialObserver;
    if (e.error)
      try {
        e.error(r);
      } catch (n) {
        br(n);
      }
    else
      br(r);
  }, t.prototype.complete = function() {
    var r = this.partialObserver;
    if (r.complete)
      try {
        r.complete();
      } catch (e) {
        br(e);
      }
  }, t;
}();
var wn = function(t) {
  tr(r, t);
  function r(e, n, i) {
    var o = t.call(this) || this, c;
    return xt(e) || !e ? c = {
      next: e ?? void 0,
      error: n ?? void 0,
      complete: i ?? void 0
    } : c = e, o.destination = new Ws(c), o;
  }
  return r;
}(us);
function br(t) {
  js(t);
}
function Bs(t) {
  throw t;
}
var Gs = {
  closed: true,
  next: jn,
  error: Bs,
  complete: jn
};
var Ys = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function Xs(t) {
  return t;
}
function Ks(t) {
  return t.length === 0 ? Xs : t.length === 1 ? t[0] : function(e) {
    return t.reduce(function(n, i) {
      return i(n);
    }, e);
  };
}
var Wn = function() {
  function t(r) {
    r && (this._subscribe = r);
  }
  return t.prototype.lift = function(r) {
    var e = new t();
    return e.source = this, e.operator = r, e;
  }, t.prototype.subscribe = function(r, e, n) {
    var i = this, o = Js(r) ? r : new wn(r, e, n);
    return kr(function() {
      var c = i, u = c.operator, p = c.source;
      o.add(u ? u.call(o, p) : p ? i._subscribe(o) : i._trySubscribe(o));
    }), o;
  }, t.prototype._trySubscribe = function(r) {
    try {
      return this._subscribe(r);
    } catch (e) {
      r.error(e);
    }
  }, t.prototype.forEach = function(r, e) {
    var n = this;
    return e = Bn(e), new e(function(i, o) {
      var c = new wn({
        next: function(u) {
          try {
            r(u);
          } catch (p) {
            o(p), c.unsubscribe();
          }
        },
        error: o,
        complete: i
      });
      n.subscribe(c);
    });
  }, t.prototype._subscribe = function(r) {
    var e;
    return (e = this.source) === null || e === void 0 ? void 0 : e.subscribe(r);
  }, t.prototype[Ys] = function() {
    return this;
  }, t.prototype.pipe = function() {
    for (var r = [], e = 0; e < arguments.length; e++)
      r[e] = arguments[e];
    return Ks(r)(this);
  }, t.prototype.toPromise = function(r) {
    var e = this;
    return r = Bn(r), new r(function(n, i) {
      var o;
      e.subscribe(function(c) {
        return o = c;
      }, function(c) {
        return i(c);
      }, function() {
        return n(o);
      });
    });
  }, t.create = function(r) {
    return new t(r);
  }, t;
}();
function Bn(t) {
  var r;
  return (r = t ?? Hs.Promise) !== null && r !== void 0 ? r : Promise;
}
function Vs(t) {
  return t && xt(t.next) && xt(t.error) && xt(t.complete);
}
function Js(t) {
  return t && t instanceof us || Vs(t) && cs(t);
}
var qs = as(function(t) {
  return function() {
    t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
});
var ls = function(t) {
  tr(r, t);
  function r() {
    var e = t.call(this) || this;
    return e.closed = false, e.currentObservers = null, e.observers = [], e.isStopped = false, e.hasError = false, e.thrownError = null, e;
  }
  return r.prototype.lift = function(e) {
    var n = new Gn(this, this);
    return n.operator = e, n;
  }, r.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new qs();
  }, r.prototype.next = function(e) {
    var n = this;
    kr(function() {
      var i, o;
      if (n._throwIfClosed(), !n.isStopped) {
        n.currentObservers || (n.currentObservers = Array.from(n.observers));
        try {
          for (var c = kn(n.currentObservers), u = c.next(); !u.done; u = c.next()) {
            var p = u.value;
            p.next(e);
          }
        } catch (h) {
          i = { error: h };
        } finally {
          try {
            u && !u.done && (o = c.return) && o.call(c);
          } finally {
            if (i) throw i.error;
          }
        }
      }
    });
  }, r.prototype.error = function(e) {
    var n = this;
    kr(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.hasError = n.isStopped = true, n.thrownError = e;
        for (var i = n.observers; i.length; )
          i.shift().error(e);
      }
    });
  }, r.prototype.complete = function() {
    var e = this;
    kr(function() {
      if (e._throwIfClosed(), !e.isStopped) {
        e.isStopped = true;
        for (var n = e.observers; n.length; )
          n.shift().complete();
      }
    });
  }, r.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true, this.observers = this.currentObservers = null;
  }, Object.defineProperty(r.prototype, "observed", {
    get: function() {
      var e;
      return ((e = this.observers) === null || e === void 0 ? void 0 : e.length) > 0;
    },
    enumerable: false,
    configurable: true
  }), r.prototype._trySubscribe = function(e) {
    return this._throwIfClosed(), t.prototype._trySubscribe.call(this, e);
  }, r.prototype._subscribe = function(e) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(e), this._innerSubscribe(e);
  }, r.prototype._innerSubscribe = function(e) {
    var n = this, i = this, o = i.hasError, c = i.isStopped, u = i.observers;
    return o || c ? os : (this.currentObservers = null, u.push(e), new Ar(function() {
      n.currentObservers = null, Sn(u, e);
    }));
  }, r.prototype._checkFinalizedStatuses = function(e) {
    var n = this, i = n.hasError, o = n.thrownError, c = n.isStopped;
    i ? e.error(o) : c && e.complete();
  }, r.prototype.asObservable = function() {
    var e = new Wn();
    return e.source = this, e;
  }, r.create = function(e, n) {
    return new Gn(e, n);
  }, r;
}(Wn);
var Gn = function(t) {
  tr(r, t);
  function r(e, n) {
    var i = t.call(this) || this;
    return i.destination = e, i.source = n, i;
  }
  return r.prototype.next = function(e) {
    var n, i;
    (i = (n = this.destination) === null || n === void 0 ? void 0 : n.next) === null || i === void 0 || i.call(n, e);
  }, r.prototype.error = function(e) {
    var n, i;
    (i = (n = this.destination) === null || n === void 0 ? void 0 : n.error) === null || i === void 0 || i.call(n, e);
  }, r.prototype.complete = function() {
    var e, n;
    (n = (e = this.destination) === null || e === void 0 ? void 0 : e.complete) === null || n === void 0 || n.call(e);
  }, r.prototype._subscribe = function(e) {
    var n, i;
    return (i = (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(e)) !== null && i !== void 0 ? i : os;
  }, r;
}(ls);
var Yn = function(t) {
  tr(r, t);
  function r(e) {
    var n = t.call(this) || this;
    return n._value = e, n;
  }
  return Object.defineProperty(r.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  }), r.prototype._subscribe = function(e) {
    var n = t.prototype._subscribe.call(this, e);
    return !n.closed && e.next(this._value), n;
  }, r.prototype.getValue = function() {
    var e = this, n = e.hasError, i = e.thrownError, o = e._value;
    if (n)
      throw i;
    return this._throwIfClosed(), o;
  }, r.prototype.next = function(e) {
    t.prototype.next.call(this, this._value = e);
  }, r;
}(ls);
var dt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Cn(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var vr = { exports: {} };
vr.exports;
(function(t, r) {
  var e = 200, n = "__lodash_hash_undefined__", i = 1, o = 2, c = 9007199254740991, u = "[object Arguments]", p = "[object Array]", h = "[object AsyncFunction]", m = "[object Boolean]", I = "[object Date]", d = "[object Error]", b = "[object Function]", w = "[object GeneratorFunction]", k = "[object Map]", S = "[object Number]", f = "[object Null]", y = "[object Object]", v = "[object Promise]", _ = "[object Proxy]", A = "[object RegExp]", E = "[object Set]", T = "[object String]", H = "[object Symbol]", P = "[object Undefined]", V = "[object WeakMap]", x = "[object ArrayBuffer]", F = "[object DataView]", tt = "[object Float32Array]", Bt = "[object Float64Array]", Gt = "[object Int8Array]", me = "[object Int16Array]", ge = "[object Int32Array]", ye = "[object Uint8Array]", Ie = "[object Uint8ClampedArray]", z = "[object Uint16Array]", be = "[object Uint32Array]", ke = /[\\^$.*+?()[\]{}|]/g, st = /^\[object .+?Constructor\]$/, Yt = /^(?:0|[1-9]\d*)$/, $ = {};
  $[tt] = $[Bt] = $[Gt] = $[me] = $[ge] = $[ye] = $[Ie] = $[z] = $[be] = true, $[u] = $[p] = $[x] = $[m] = $[F] = $[I] = $[d] = $[b] = $[k] = $[S] = $[y] = $[A] = $[E] = $[T] = $[V] = false;
  var Xt = typeof dt == "object" && dt && dt.Object === Object && dt, ve = typeof self == "object" && self && self.Object === Object && self, it = Xt || ve || Function("return this")(), Kt = r && !r.nodeType && r, Vt = Kt && true && t && !t.nodeType && t, Ot = Vt && Vt.exports === Kt, Ct = Ot && Xt.process, Jt = function() {
    try {
      return Ct && Ct.binding && Ct.binding("util");
    } catch {
    }
  }(), Pt = Jt && Jt.isTypedArray;
  function qt(s, a) {
    for (var l = -1, g = s == null ? 0 : s.length, O = 0, M = []; ++l < g; ) {
      var D = s[l];
      a(D, l, s) && (M[O++] = D);
    }
    return M;
  }
  function Rt(s, a) {
    for (var l = -1, g = a.length, O = s.length; ++l < g; )
      s[O + l] = a[l];
    return s;
  }
  function Zt(s, a) {
    for (var l = -1, g = s == null ? 0 : s.length; ++l < g; )
      if (a(s[l], l, s))
        return true;
    return false;
  }
  function _e(s, a) {
    for (var l = -1, g = Array(s); ++l < s; )
      g[l] = a(l);
    return g;
  }
  function Se(s) {
    return function(a) {
      return s(a);
    };
  }
  function vt(s, a) {
    return s.has(a);
  }
  function Dt(s, a) {
    return s == null ? void 0 : s[a];
  }
  function Qt(s) {
    var a = -1, l = Array(s.size);
    return s.forEach(function(g, O) {
      l[++a] = [O, g];
    }), l;
  }
  function te(s, a) {
    return function(l) {
      return s(a(l));
    };
  }
  function ct(s) {
    var a = -1, l = Array(s.size);
    return s.forEach(function(g) {
      l[++a] = g;
    }), l;
  }
  var _t = Array.prototype, we = Function.prototype, gt = Object.prototype, St = it["__core-js_shared__"], zt = we.toString, et = gt.hasOwnProperty, ee = function() {
    var s = /[^.]+$/.exec(St && St.keys && St.keys.IE_PROTO || "");
    return s ? "Symbol(src)_1." + s : "";
  }(), re = gt.toString, Te = RegExp(
    "^" + zt.call(et).replace(ke, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), $t = Ot ? it.Buffer : void 0, wt = it.Symbol, ir2 = it.Uint8Array, Ae = gt.propertyIsEnumerable, ne = _t.splice, ft = wt ? wt.toStringTag : void 0, Ee = Object.getOwnPropertySymbols, $e = $t ? $t.isBuffer : void 0, se = te(Object.keys, Object), Fe = At(it, "DataView"), ie = At(it, "Map"), Le = At(it, "Promise"), Ne = At(it, "Set"), He = At(it, "WeakMap"), Ft = At(Object, "create"), ar = rt(Fe), Tt = rt(ie), xr = rt(Le), Or = rt(Ne), Cr = rt(He), or2 = wt ? wt.prototype : void 0, Ue = or2 ? or2.valueOf : void 0;
  function G(s) {
    var a = -1, l = s == null ? 0 : s.length;
    for (this.clear(); ++a < l; ) {
      var g = s[a];
      this.set(g[0], g[1]);
    }
  }
  function Pr() {
    this.__data__ = Ft ? Ft(null) : {}, this.size = 0;
  }
  function Rr(s) {
    var a = this.has(s) && delete this.__data__[s];
    return this.size -= a ? 1 : 0, a;
  }
  function Dr(s) {
    var a = this.__data__;
    if (Ft) {
      var l = a[s];
      return l === n ? void 0 : l;
    }
    return et.call(a, s) ? a[s] : void 0;
  }
  function zr(s) {
    var a = this.__data__;
    return Ft ? a[s] !== void 0 : et.call(a, s);
  }
  function $r(s, a) {
    var l = this.__data__;
    return this.size += this.has(s) ? 0 : 1, l[s] = Ft && a === void 0 ? n : a, this;
  }
  G.prototype.clear = Pr, G.prototype.delete = Rr, G.prototype.get = Dr, G.prototype.has = zr, G.prototype.set = $r;
  function J(s) {
    var a = -1, l = s == null ? 0 : s.length;
    for (this.clear(); ++a < l; ) {
      var g = s[a];
      this.set(g[0], g[1]);
    }
  }
  function Fr() {
    this.__data__ = [], this.size = 0;
  }
  function Lr(s) {
    var a = this.__data__, l = Oe(a, s);
    if (l < 0)
      return false;
    var g = a.length - 1;
    return l == g ? a.pop() : ne.call(a, l, 1), --this.size, true;
  }
  function Nr(s) {
    var a = this.__data__, l = Oe(a, s);
    return l < 0 ? void 0 : a[l][1];
  }
  function Hr(s) {
    return Oe(this.__data__, s) > -1;
  }
  function Ur(s, a) {
    var l = this.__data__, g = Oe(l, s);
    return g < 0 ? (++this.size, l.push([s, a])) : l[g][1] = a, this;
  }
  J.prototype.clear = Fr, J.prototype.delete = Lr, J.prototype.get = Nr, J.prototype.has = Hr, J.prototype.set = Ur;
  function at(s) {
    var a = -1, l = s == null ? 0 : s.length;
    for (this.clear(); ++a < l; ) {
      var g = s[a];
      this.set(g[0], g[1]);
    }
  }
  function jr() {
    this.size = 0, this.__data__ = {
      hash: new G(),
      map: new (ie || J)(),
      string: new G()
    };
  }
  function Wr(s) {
    var a = pt(this, s).delete(s);
    return this.size -= a ? 1 : 0, a;
  }
  function Br(s) {
    return pt(this, s).get(s);
  }
  function Gr(s) {
    return pt(this, s).has(s);
  }
  function Yr(s, a) {
    var l = pt(this, s), g = l.size;
    return l.set(s, a), this.size += l.size == g ? 0 : 1, this;
  }
  at.prototype.clear = jr, at.prototype.delete = Wr, at.prototype.get = Br, at.prototype.has = Gr, at.prototype.set = Yr;
  function Me(s) {
    var a = -1, l = s == null ? 0 : s.length;
    for (this.__data__ = new at(); ++a < l; )
      this.add(s[a]);
  }
  function cr(s) {
    return this.__data__.set(s, n), this;
  }
  function xe(s) {
    return this.__data__.has(s);
  }
  Me.prototype.add = Me.prototype.push = cr, Me.prototype.has = xe;
  function yt(s) {
    var a = this.__data__ = new J(s);
    this.size = a.size;
  }
  function je() {
    this.__data__ = new J(), this.size = 0;
  }
  function Xr(s) {
    var a = this.__data__, l = a.delete(s);
    return this.size = a.size, l;
  }
  function Kr(s) {
    return this.__data__.get(s);
  }
  function Vr(s) {
    return this.__data__.has(s);
  }
  function Jr(s, a) {
    var l = this.__data__;
    if (l instanceof J) {
      var g = l.__data__;
      if (!ie || g.length < e - 1)
        return g.push([s, a]), this.size = ++l.size, this;
      l = this.__data__ = new at(g);
    }
    return l.set(s, a), this.size = l.size, this;
  }
  yt.prototype.clear = je, yt.prototype.delete = Xr, yt.prototype.get = Kr, yt.prototype.has = Vr, yt.prototype.set = Jr;
  function qr(s, a) {
    var l = Ce(s), g = !l && pr(s), O = !l && !g && Pe(s), M = !l && !g && !O && gr(s), D = l || g || O || M, R = D ? _e(s.length, String) : [], U = R.length;
    for (var L in s)
      et.call(s, L) && !(D && // Safari 9 has enumerable `arguments.length` in strict mode.
      (L == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      O && (L == "offset" || L == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      M && (L == "buffer" || L == "byteLength" || L == "byteOffset") || // Skip index properties.
      an(L, U))) && R.push(L);
    return R;
  }
  function Oe(s, a) {
    for (var l = s.length; l--; )
      if (fr(s[l][0], a))
        return l;
    return -1;
  }
  function We(s, a, l) {
    var g = a(s);
    return Ce(s) ? g : Rt(g, l(s));
  }
  function ae(s) {
    return s == null ? s === void 0 ? P : f : ft && ft in Object(s) ? Et(s) : dr(s);
  }
  function ur(s) {
    return bt(s) && ae(s) == u;
  }
  function lr(s, a, l, g, O) {
    return s === a ? true : s == null || a == null || !bt(s) && !bt(a) ? s !== s && a !== a : Zr(s, a, l, g, lr, O);
  }
  function Zr(s, a, l, g, O, M) {
    var D = Ce(s), R = Ce(a), U = D ? p : It(s), L = R ? p : It(a);
    U = U == u ? y : U, L = L == u ? y : L;
    var q = U == y, ot = L == y, j = U == L;
    if (j && Pe(s)) {
      if (!Pe(a))
        return false;
      D = true, q = false;
    }
    if (j && !q)
      return M || (M = new yt()), D || gr(s) ? Be(s, a, l, g, O, M) : rn(s, a, U, l, g, O, M);
    if (!(l & i)) {
      var Z = q && et.call(s, "__wrapped__"), Y = ot && et.call(a, "__wrapped__");
      if (Z || Y) {
        var Lt = Z ? s.value() : s, Mt = Y ? a.value() : a;
        return M || (M = new yt()), O(Lt, Mt, l, g, M);
      }
    }
    return j ? (M || (M = new yt()), nn(s, a, l, g, O, M)) : false;
  }
  function Qr(s) {
    if (!mr(s) || cn(s))
      return false;
    var a = hr(s) ? Te : st;
    return a.test(rt(s));
  }
  function tn(s) {
    return bt(s) && Ye(s.length) && !!$[ae(s)];
  }
  function en(s) {
    if (!un(s))
      return se(s);
    var a = [];
    for (var l in Object(s))
      et.call(s, l) && l != "constructor" && a.push(l);
    return a;
  }
  function Be(s, a, l, g, O, M) {
    var D = l & i, R = s.length, U = a.length;
    if (R != U && !(D && U > R))
      return false;
    var L = M.get(s);
    if (L && M.get(a))
      return L == a;
    var q = -1, ot = true, j = l & o ? new Me() : void 0;
    for (M.set(s, a), M.set(a, s); ++q < R; ) {
      var Z = s[q], Y = a[q];
      if (g)
        var Lt = D ? g(Y, Z, q, a, s, M) : g(Z, Y, q, s, a, M);
      if (Lt !== void 0) {
        if (Lt)
          continue;
        ot = false;
        break;
      }
      if (j) {
        if (!Zt(a, function(Mt, ce) {
          if (!vt(j, ce) && (Z === Mt || O(Z, Mt, l, g, M)))
            return j.push(ce);
        })) {
          ot = false;
          break;
        }
      } else if (!(Z === Y || O(Z, Y, l, g, M))) {
        ot = false;
        break;
      }
    }
    return M.delete(s), M.delete(a), ot;
  }
  function rn(s, a, l, g, O, M, D) {
    switch (l) {
      case F:
        if (s.byteLength != a.byteLength || s.byteOffset != a.byteOffset)
          return false;
        s = s.buffer, a = a.buffer;
      case x:
        return !(s.byteLength != a.byteLength || !M(new ir2(s), new ir2(a)));
      case m:
      case I:
      case S:
        return fr(+s, +a);
      case d:
        return s.name == a.name && s.message == a.message;
      case A:
      case T:
        return s == a + "";
      case k:
        var R = Qt;
      case E:
        var U = g & i;
        if (R || (R = ct), s.size != a.size && !U)
          return false;
        var L = D.get(s);
        if (L)
          return L == a;
        g |= o, D.set(s, a);
        var q = Be(R(s), R(a), g, O, M, D);
        return D.delete(s), q;
      case H:
        if (Ue)
          return Ue.call(s) == Ue.call(a);
    }
    return false;
  }
  function nn(s, a, l, g, O, M) {
    var D = l & i, R = oe(s), U = R.length, L = oe(a), q = L.length;
    if (U != q && !D)
      return false;
    for (var ot = U; ot--; ) {
      var j = R[ot];
      if (!(D ? j in a : et.call(a, j)))
        return false;
    }
    var Z = M.get(s);
    if (Z && M.get(a))
      return Z == a;
    var Y = true;
    M.set(s, a), M.set(a, s);
    for (var Lt = D; ++ot < U; ) {
      j = R[ot];
      var Mt = s[j], ce = a[j];
      if (g)
        var Hn = D ? g(ce, Mt, j, a, s, M) : g(Mt, ce, j, s, a, M);
      if (!(Hn === void 0 ? Mt === ce || O(Mt, ce, l, g, M) : Hn)) {
        Y = false;
        break;
      }
      Lt || (Lt = j == "constructor");
    }
    if (Y && !Lt) {
      var yr = s.constructor, Ir = a.constructor;
      yr != Ir && "constructor" in s && "constructor" in a && !(typeof yr == "function" && yr instanceof yr && typeof Ir == "function" && Ir instanceof Ir) && (Y = false);
    }
    return M.delete(s), M.delete(a), Y;
  }
  function oe(s) {
    return We(s, Xe, sn);
  }
  function pt(s, a) {
    var l = s.__data__;
    return on(a) ? l[typeof a == "string" ? "string" : "hash"] : l.map;
  }
  function At(s, a) {
    var l = Dt(s, a);
    return Qr(l) ? l : void 0;
  }
  function Et(s) {
    var a = et.call(s, ft), l = s[ft];
    try {
      s[ft] = void 0;
      var g = true;
    } catch {
    }
    var O = re.call(s);
    return g && (a ? s[ft] = l : delete s[ft]), O;
  }
  var sn = Ee ? function(s) {
    return s == null ? [] : (s = Object(s), qt(Ee(s), function(a) {
      return Ae.call(s, a);
    }));
  } : dn, It = ae;
  (Fe && It(new Fe(new ArrayBuffer(1))) != F || ie && It(new ie()) != k || Le && It(Le.resolve()) != v || Ne && It(new Ne()) != E || He && It(new He()) != V) && (It = function(s) {
    var a = ae(s), l = a == y ? s.constructor : void 0, g = l ? rt(l) : "";
    if (g)
      switch (g) {
        case ar:
          return F;
        case Tt:
          return k;
        case xr:
          return v;
        case Or:
          return E;
        case Cr:
          return V;
      }
    return a;
  });
  function an(s, a) {
    return a = a ?? c, !!a && (typeof s == "number" || Yt.test(s)) && s > -1 && s % 1 == 0 && s < a;
  }
  function on(s) {
    var a = typeof s;
    return a == "string" || a == "number" || a == "symbol" || a == "boolean" ? s !== "__proto__" : s === null;
  }
  function cn(s) {
    return !!ee && ee in s;
  }
  function un(s) {
    var a = s && s.constructor, l = typeof a == "function" && a.prototype || gt;
    return s === l;
  }
  function dr(s) {
    return re.call(s);
  }
  function rt(s) {
    if (s != null) {
      try {
        return zt.call(s);
      } catch {
      }
      try {
        return s + "";
      } catch {
      }
    }
    return "";
  }
  function fr(s, a) {
    return s === a || s !== s && a !== a;
  }
  var pr = ur(/* @__PURE__ */ function() {
    return arguments;
  }()) ? ur : function(s) {
    return bt(s) && et.call(s, "callee") && !Ae.call(s, "callee");
  }, Ce = Array.isArray;
  function Ge(s) {
    return s != null && Ye(s.length) && !hr(s);
  }
  var Pe = $e || fn;
  function ln(s, a) {
    return lr(s, a);
  }
  function hr(s) {
    if (!mr(s))
      return false;
    var a = ae(s);
    return a == b || a == w || a == h || a == _;
  }
  function Ye(s) {
    return typeof s == "number" && s > -1 && s % 1 == 0 && s <= c;
  }
  function mr(s) {
    var a = typeof s;
    return s != null && (a == "object" || a == "function");
  }
  function bt(s) {
    return s != null && typeof s == "object";
  }
  var gr = Pt ? Se(Pt) : tn;
  function Xe(s) {
    return Ge(s) ? qr(s) : en(s);
  }
  function dn() {
    return [];
  }
  function fn() {
    return false;
  }
  t.exports = ln;
})(vr, vr.exports);
var Zs = vr.exports;
var W = Cn(Zs);
var go = "add";
var Qs = "track";
var ti = "trackItems";
var yo = `${Qs}:changed`;
var Io = `${ti}:changed`;
var ei = "state";
var bo = `${ei}:changed`;
var ri = "bulk";
var Xn = `${ri}:edit`;
var Pn = "design";
var ni = `${Pn}:load`;
var si = `${Pn}:resize`;
var N = "add";
var ii = `${N}:text`;
var ai = `${N}:video`;
var oi = `${N}:audio`;
var ko = `${N}:placeholder`;
var ci = `${N}:image`;
var ui = `${N}:illustration`;
var li = `${N}:shape`;
var vo = `${N}:mask`;
var _o = `${N}:transition`;
var di = `${N}:animation`;
var fi = `${N}:caption`;
var pi = `${N}:template`;
var hi = `${N}:items`;
var mi = `${N}:composition`;
var gi = `${N}:progressBar`;
var yi = `${N}:progressFrame`;
var Ii = `${N}:radialAudioBars`;
var bi = `${N}:linealAudioBars`;
var ki = `${N}:waveAudioBars`;
var vi = `${N}:hillAudioBars`;
var _i = `${N}:rect`;
var Wt = "edit";
var Si = `${Wt}:object`;
var wi = `${Wt}:replaceMedia`;
var So = `${Wt}:text`;
var wo = `${Wt}:shape`;
var To = `${Wt}:templateItem`;
var Ao = `${Wt}:deleteTemplateItem`;
var Ti = `${Wt}:backgroundEditor`;
var Eo = "enterEditMode";
var De = "active";
var Mo = `${De}:set`;
var xo = `${De}:delete`;
var Ai = `${De}:paste`;
var Oo = `${De}:clone`;
var Ei = `${De}:split`;
var Q = "layer";
var Co = `${Q}:locked`;
var Po = `${Q}:hidden`;
var Ro = `${Q}:move`;
var Mi = `${Q}:select`;
var Do = `${Q}:selection`;
var zo = `${Q}:sendTo`;
var $o = `${Q}:rename`;
var Fo = `${Q}:editingName`;
var xi = `${Q}:copy`;
var Lo = `${Q}:paste`;
var Oi = `${Q}:clone`;
var No = `${Q}:split`;
var Ho = `${Q}:cut`;
var Ci = `${Q}:delete`;
var Pi = `${Q}:replace`;
var Er = "history";
var Ri = `${Er}:undo`;
var Di = `${Er}:redo`;
var Uo = `${Er}:reset`;
var ds = "scale";
var zi = `${ds}:changed`;
var _r = { exports: {} };
_r.exports;
(function(t, r) {
  var e = 200, n = "__lodash_hash_undefined__", i = 9007199254740991, o = "[object Arguments]", c = "[object Array]", u = "[object Boolean]", p = "[object Date]", h = "[object Error]", m = "[object Function]", I = "[object GeneratorFunction]", d = "[object Map]", b = "[object Number]", w = "[object Object]", k = "[object Promise]", S = "[object RegExp]", f = "[object Set]", y = "[object String]", v = "[object Symbol]", _ = "[object WeakMap]", A = "[object ArrayBuffer]", E = "[object DataView]", T = "[object Float32Array]", H = "[object Float64Array]", P = "[object Int8Array]", V = "[object Int16Array]", x = "[object Int32Array]", F = "[object Uint8Array]", tt = "[object Uint8ClampedArray]", Bt = "[object Uint16Array]", Gt = "[object Uint32Array]", me = /[\\^$.*+?()[\]{}|]/g, ge = /\w*$/, ye = /^\[object .+?Constructor\]$/, Ie = /^(?:0|[1-9]\d*)$/, z = {};
  z[o] = z[c] = z[A] = z[E] = z[u] = z[p] = z[T] = z[H] = z[P] = z[V] = z[x] = z[d] = z[b] = z[w] = z[S] = z[f] = z[y] = z[v] = z[F] = z[tt] = z[Bt] = z[Gt] = true, z[h] = z[m] = z[_] = false;
  var be = typeof dt == "object" && dt && dt.Object === Object && dt, ke = typeof self == "object" && self && self.Object === Object && self, st = be || ke || Function("return this")(), Yt = r && !r.nodeType && r, $ = Yt && true && t && !t.nodeType && t, Xt = $ && $.exports === Yt;
  function ve(s, a) {
    return s.set(a[0], a[1]), s;
  }
  function it(s, a) {
    return s.add(a), s;
  }
  function Kt(s, a) {
    for (var l = -1, g = s ? s.length : 0; ++l < g && a(s[l], l, s) !== false; )
      ;
    return s;
  }
  function Vt(s, a) {
    for (var l = -1, g = a.length, O = s.length; ++l < g; )
      s[O + l] = a[l];
    return s;
  }
  function Ot(s, a, l, g) {
    for (var O = -1, M = s ? s.length : 0; ++O < M; )
      l = a(l, s[O], O, s);
    return l;
  }
  function Ct(s, a) {
    for (var l = -1, g = Array(s); ++l < s; )
      g[l] = a(l);
    return g;
  }
  function Jt(s, a) {
    return s == null ? void 0 : s[a];
  }
  function Pt(s) {
    var a = false;
    if (s != null && typeof s.toString != "function")
      try {
        a = !!(s + "");
      } catch {
      }
    return a;
  }
  function qt(s) {
    var a = -1, l = Array(s.size);
    return s.forEach(function(g, O) {
      l[++a] = [O, g];
    }), l;
  }
  function Rt(s, a) {
    return function(l) {
      return s(a(l));
    };
  }
  function Zt(s) {
    var a = -1, l = Array(s.size);
    return s.forEach(function(g) {
      l[++a] = g;
    }), l;
  }
  var _e = Array.prototype, Se = Function.prototype, vt = Object.prototype, Dt = st["__core-js_shared__"], Qt = function() {
    var s = /[^.]+$/.exec(Dt && Dt.keys && Dt.keys.IE_PROTO || "");
    return s ? "Symbol(src)_1." + s : "";
  }(), te = Se.toString, ct = vt.hasOwnProperty, _t = vt.toString, we = RegExp(
    "^" + te.call(ct).replace(me, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), gt = Xt ? st.Buffer : void 0, St = st.Symbol, zt = st.Uint8Array, et = Rt(Object.getPrototypeOf, Object), ee = Object.create, re = vt.propertyIsEnumerable, Te = _e.splice, $t = Object.getOwnPropertySymbols, wt = gt ? gt.isBuffer : void 0, ir2 = Rt(Object.keys, Object), Ae = pt(st, "DataView"), ne = pt(st, "Map"), ft = pt(st, "Promise"), Ee = pt(st, "Set"), $e = pt(st, "WeakMap"), se = pt(Object, "create"), Fe = rt(Ae), ie = rt(ne), Le = rt(ft), Ne = rt(Ee), He = rt($e), Ft = St ? St.prototype : void 0, ar = Ft ? Ft.valueOf : void 0;
  function Tt(s) {
    var a = -1, l = s ? s.length : 0;
    for (this.clear(); ++a < l; ) {
      var g = s[a];
      this.set(g[0], g[1]);
    }
  }
  function xr() {
    this.__data__ = se ? se(null) : {};
  }
  function Or(s) {
    return this.has(s) && delete this.__data__[s];
  }
  function Cr(s) {
    var a = this.__data__;
    if (se) {
      var l = a[s];
      return l === n ? void 0 : l;
    }
    return ct.call(a, s) ? a[s] : void 0;
  }
  function or2(s) {
    var a = this.__data__;
    return se ? a[s] !== void 0 : ct.call(a, s);
  }
  function Ue(s, a) {
    var l = this.__data__;
    return l[s] = se && a === void 0 ? n : a, this;
  }
  Tt.prototype.clear = xr, Tt.prototype.delete = Or, Tt.prototype.get = Cr, Tt.prototype.has = or2, Tt.prototype.set = Ue;
  function G(s) {
    var a = -1, l = s ? s.length : 0;
    for (this.clear(); ++a < l; ) {
      var g = s[a];
      this.set(g[0], g[1]);
    }
  }
  function Pr() {
    this.__data__ = [];
  }
  function Rr(s) {
    var a = this.__data__, l = xe(a, s);
    if (l < 0)
      return false;
    var g = a.length - 1;
    return l == g ? a.pop() : Te.call(a, l, 1), true;
  }
  function Dr(s) {
    var a = this.__data__, l = xe(a, s);
    return l < 0 ? void 0 : a[l][1];
  }
  function zr(s) {
    return xe(this.__data__, s) > -1;
  }
  function $r(s, a) {
    var l = this.__data__, g = xe(l, s);
    return g < 0 ? l.push([s, a]) : l[g][1] = a, this;
  }
  G.prototype.clear = Pr, G.prototype.delete = Rr, G.prototype.get = Dr, G.prototype.has = zr, G.prototype.set = $r;
  function J(s) {
    var a = -1, l = s ? s.length : 0;
    for (this.clear(); ++a < l; ) {
      var g = s[a];
      this.set(g[0], g[1]);
    }
  }
  function Fr() {
    this.__data__ = {
      hash: new Tt(),
      map: new (ne || G)(),
      string: new Tt()
    };
  }
  function Lr(s) {
    return oe(this, s).delete(s);
  }
  function Nr(s) {
    return oe(this, s).get(s);
  }
  function Hr(s) {
    return oe(this, s).has(s);
  }
  function Ur(s, a) {
    return oe(this, s).set(s, a), this;
  }
  J.prototype.clear = Fr, J.prototype.delete = Lr, J.prototype.get = Nr, J.prototype.has = Hr, J.prototype.set = Ur;
  function at(s) {
    this.__data__ = new G(s);
  }
  function jr() {
    this.__data__ = new G();
  }
  function Wr(s) {
    return this.__data__.delete(s);
  }
  function Br(s) {
    return this.__data__.get(s);
  }
  function Gr(s) {
    return this.__data__.has(s);
  }
  function Yr(s, a) {
    var l = this.__data__;
    if (l instanceof G) {
      var g = l.__data__;
      if (!ne || g.length < e - 1)
        return g.push([s, a]), this;
      l = this.__data__ = new J(g);
    }
    return l.set(s, a), this;
  }
  at.prototype.clear = jr, at.prototype.delete = Wr, at.prototype.get = Br, at.prototype.has = Gr, at.prototype.set = Yr;
  function Me(s, a) {
    var l = Ge(s) || Ce(s) ? Ct(s.length, String) : [], g = l.length, O = !!g;
    for (var M in s)
      ct.call(s, M) && !(O && (M == "length" || on(M, g))) && l.push(M);
    return l;
  }
  function cr(s, a, l) {
    var g = s[a];
    (!(ct.call(s, a) && pr(g, l)) || l === void 0 && !(a in s)) && (s[a] = l);
  }
  function xe(s, a) {
    for (var l = s.length; l--; )
      if (pr(s[l][0], a))
        return l;
    return -1;
  }
  function yt(s, a) {
    return s && Be(a, Xe(a), s);
  }
  function je(s, a, l, g, O, M, D) {
    var R;
    if (g && (R = M ? g(s, O, M, D) : g(s)), R !== void 0)
      return R;
    if (!bt(s))
      return s;
    var U = Ge(s);
    if (U) {
      if (R = sn(s), !a)
        return en(s, R);
    } else {
      var L = Et(s), q = L == m || L == I;
      if (hr(s))
        return Oe(s, a);
      if (L == w || L == o || q && !M) {
        if (Pt(s))
          return M ? s : {};
        if (R = It(q ? {} : s), !a)
          return rn(s, yt(R, s));
      } else {
        if (!z[L])
          return M ? s : {};
        R = an(s, L, je, a);
      }
    }
    D || (D = new at());
    var ot = D.get(s);
    if (ot)
      return ot;
    if (D.set(s, R), !U)
      var j = l ? nn(s) : Xe(s);
    return Kt(j || s, function(Z, Y) {
      j && (Y = Z, Z = s[Y]), cr(R, Y, je(Z, a, l, g, Y, s, D));
    }), R;
  }
  function Xr(s) {
    return bt(s) ? ee(s) : {};
  }
  function Kr(s, a, l) {
    var g = a(s);
    return Ge(s) ? g : Vt(g, l(s));
  }
  function Vr(s) {
    return _t.call(s);
  }
  function Jr(s) {
    if (!bt(s) || un(s))
      return false;
    var a = Ye(s) || Pt(s) ? we : ye;
    return a.test(rt(s));
  }
  function qr(s) {
    if (!dr(s))
      return ir2(s);
    var a = [];
    for (var l in Object(s))
      ct.call(s, l) && l != "constructor" && a.push(l);
    return a;
  }
  function Oe(s, a) {
    if (a)
      return s.slice();
    var l = new s.constructor(s.length);
    return s.copy(l), l;
  }
  function We(s) {
    var a = new s.constructor(s.byteLength);
    return new zt(a).set(new zt(s)), a;
  }
  function ae(s, a) {
    var l = a ? We(s.buffer) : s.buffer;
    return new s.constructor(l, s.byteOffset, s.byteLength);
  }
  function ur(s, a, l) {
    var g = a ? l(qt(s), true) : qt(s);
    return Ot(g, ve, new s.constructor());
  }
  function lr(s) {
    var a = new s.constructor(s.source, ge.exec(s));
    return a.lastIndex = s.lastIndex, a;
  }
  function Zr(s, a, l) {
    var g = a ? l(Zt(s), true) : Zt(s);
    return Ot(g, it, new s.constructor());
  }
  function Qr(s) {
    return ar ? Object(ar.call(s)) : {};
  }
  function tn(s, a) {
    var l = a ? We(s.buffer) : s.buffer;
    return new s.constructor(l, s.byteOffset, s.length);
  }
  function en(s, a) {
    var l = -1, g = s.length;
    for (a || (a = Array(g)); ++l < g; )
      a[l] = s[l];
    return a;
  }
  function Be(s, a, l, g) {
    l || (l = {});
    for (var O = -1, M = a.length; ++O < M; ) {
      var D = a[O], R = void 0;
      cr(l, D, R === void 0 ? s[D] : R);
    }
    return l;
  }
  function rn(s, a) {
    return Be(s, At(s), a);
  }
  function nn(s) {
    return Kr(s, Xe, At);
  }
  function oe(s, a) {
    var l = s.__data__;
    return cn(a) ? l[typeof a == "string" ? "string" : "hash"] : l.map;
  }
  function pt(s, a) {
    var l = Jt(s, a);
    return Jr(l) ? l : void 0;
  }
  var At = $t ? Rt($t, Object) : dn, Et = Vr;
  (Ae && Et(new Ae(new ArrayBuffer(1))) != E || ne && Et(new ne()) != d || ft && Et(ft.resolve()) != k || Ee && Et(new Ee()) != f || $e && Et(new $e()) != _) && (Et = function(s) {
    var a = _t.call(s), l = a == w ? s.constructor : void 0, g = l ? rt(l) : void 0;
    if (g)
      switch (g) {
        case Fe:
          return E;
        case ie:
          return d;
        case Le:
          return k;
        case Ne:
          return f;
        case He:
          return _;
      }
    return a;
  });
  function sn(s) {
    var a = s.length, l = s.constructor(a);
    return a && typeof s[0] == "string" && ct.call(s, "index") && (l.index = s.index, l.input = s.input), l;
  }
  function It(s) {
    return typeof s.constructor == "function" && !dr(s) ? Xr(et(s)) : {};
  }
  function an(s, a, l, g) {
    var O = s.constructor;
    switch (a) {
      case A:
        return We(s);
      case u:
      case p:
        return new O(+s);
      case E:
        return ae(s, g);
      case T:
      case H:
      case P:
      case V:
      case x:
      case F:
      case tt:
      case Bt:
      case Gt:
        return tn(s, g);
      case d:
        return ur(s, g, l);
      case b:
      case y:
        return new O(s);
      case S:
        return lr(s);
      case f:
        return Zr(s, g, l);
      case v:
        return Qr(s);
    }
  }
  function on(s, a) {
    return a = a ?? i, !!a && (typeof s == "number" || Ie.test(s)) && s > -1 && s % 1 == 0 && s < a;
  }
  function cn(s) {
    var a = typeof s;
    return a == "string" || a == "number" || a == "symbol" || a == "boolean" ? s !== "__proto__" : s === null;
  }
  function un(s) {
    return !!Qt && Qt in s;
  }
  function dr(s) {
    var a = s && s.constructor, l = typeof a == "function" && a.prototype || vt;
    return s === l;
  }
  function rt(s) {
    if (s != null) {
      try {
        return te.call(s);
      } catch {
      }
      try {
        return s + "";
      } catch {
      }
    }
    return "";
  }
  function fr(s) {
    return je(s, true, true);
  }
  function pr(s, a) {
    return s === a || s !== s && a !== a;
  }
  function Ce(s) {
    return ln(s) && ct.call(s, "callee") && (!re.call(s, "callee") || _t.call(s) == o);
  }
  var Ge = Array.isArray;
  function Pe(s) {
    return s != null && mr(s.length) && !Ye(s);
  }
  function ln(s) {
    return gr(s) && Pe(s);
  }
  var hr = wt || fn;
  function Ye(s) {
    var a = bt(s) ? _t.call(s) : "";
    return a == m || a == I;
  }
  function mr(s) {
    return typeof s == "number" && s > -1 && s % 1 == 0 && s <= i;
  }
  function bt(s) {
    var a = typeof s;
    return !!s && (a == "object" || a == "function");
  }
  function gr(s) {
    return !!s && typeof s == "object";
  }
  function Xe(s) {
    return Pe(s) ? Me(s) : qr(s);
  }
  function dn() {
    return [];
  }
  function fn() {
    return false;
  }
  t.exports = fr;
})(_r, _r.exports);
var $i = _r.exports;
var C = Cn($i);
function Fi(t, r) {
  return t.filter((n) => {
    if (r.forEach((i) => {
      n.items.includes(i) && (n.items = n.items.filter((o) => o !== i));
    }), n.items.length !== 0 || n.static)
      return n;
  });
}
var K = (t) => Object.keys(t).reduce((r, e) => {
  const { display: n } = t[e];
  return Math.max(r, n.to);
}, 0);
function nt(t, r, e) {
  t.forEach((n) => {
    const i = Object.values(r).filter(
      (d) => n.items.includes(d.id)
    ), c = i.filter(
      (d) => !e.includes(d.id)
    ).sort(
      (d, b) => d.display.from - b.display.from
    ), u = c[c.length - 1];
    let p = (u == null ? void 0 : u.display.to) || 0;
    i.forEach((d) => {
      if (e.includes(d.id)) {
        const b = d.display.to - d.display.from;
        d.display = {
          from: p,
          to: p + b
        }, p = p + b;
      }
    });
    const m = i.sort(
      (d, b) => d.display.from - b.display.from
    ).map((d) => d.id);
    let I = 0;
    m.forEach((d) => {
      const b = [];
      let w = 0;
      if (b.forEach((k) => {
        k.forEach((S) => {
          S.type === "transition" && (w += S.duration);
        });
      }), r[d]) {
        const k = r[d].display.to - r[d].display.from;
        r[d].display = {
          from: I - w,
          to: I + k - w
        }, I += k;
      }
    });
  });
}
function Li(t, r, e) {
  const n = t.toId, i = e[n], o = r.find((c) => c.items.includes(n));
  o && (o.magnetic || o.items.forEach((c) => {
    const u = e[c];
    u.display.from > i.display.from && (u.display.from = u.display.from + t.duration, u.display.to = u.display.to + t.duration);
  }));
}
function Ni(t, r) {
  const e = C(t), n = r && r.length ? r : e.activeIds, i = n.map((y) => e.trackItemsMap[y]).filter((y) => !!y).map((y) => y.id), o = e.transitionIds.filter(
    (y) => {
      const v = e.transitionsMap[y];
      return i.includes(v.fromId) || i.includes(v.toId);
    }
  );
  i.push(...o);
  const c = {}, u = e.trackItemIds, p = e.transitionIds, h = C(e.tracks), m = C(e.structure);
  i.forEach((y) => {
    var _;
    const v = e.trackItemsMap[y] || e.transitionsMap[y];
    if (v.type === "template" || v.type === "composition") {
      const A = (_ = e.structure.find(
        (T) => T.id === v.id
      )) == null ? void 0 : _.items;
      i.push(...A);
      const E = m.findIndex(
        (T) => T.id === v.id
      );
      m.splice(E, 1);
    }
  }), i.forEach((y) => {
    m.forEach((v) => {
      v.items.includes(y) && (v.items = v.items.filter((_) => _ !== y));
    });
  });
  const I = u.filter(
    (y) => !i.includes(y)
  );
  p.forEach((y) => {
    n.includes(y) && n.length === 1 && (c[y] = C(e.transitionsMap[y]));
  });
  const d = p.filter(
    (y) => !i.includes(y) && !n.includes(y)
  ), b = Object.fromEntries(
    Object.entries(e.transitionsMap).filter(
      ([y]) => !i.includes(y)
    )
  );
  Object.keys(b).forEach((y) => {
    n.includes(y) && (b[y].kind = "none");
  });
  const w = Fi(
    e.tracks,
    i
  ), k = Object.fromEntries(
    Object.entries(e.trackItemsMap).filter(
      ([y]) => !i.includes(y)
    )
  ), S = h.filter((y) => y.magnetic);
  nt(S, k, []);
  const f = K(k);
  return Object.keys(c).forEach((y) => {
    Li(
      c[y],
      w,
      k
    );
  }), {
    trackItemIds: I,
    activeIds: [],
    trackItemsMap: k,
    tracks: w,
    duration: f,
    structure: m,
    transitionIds: d,
    transitionsMap: b
  };
}
var Hi = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var fs = (t = 21) => {
  let r = "", e = crypto.getRandomValues(new Uint8Array(t |= 0));
  for (; t--; )
    r += Hi[e[t] & 63];
  return r;
};
function le(t = 16) {
  const r = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", e = r.charAt(Math.floor(Math.random() * r.length));
  let n = fs(t - 1);
  return n = n.replace(/[^a-zA-Z0-9]/g, "").slice(0, t - 1), e + n;
}
var er = (t) => {
  const r = t.map((e) => new FontFace(e.fontFamily, `url(${e.url})`).load().catch((n) => n));
  return r.length === 0 ? Promise.resolve(true) : new Promise((e, n) => {
    Promise.all(r).then((i) => {
      i.forEach((o) => {
        o && o.family && (document.fonts.add(o), e(true));
      });
    }).catch((i) => n(i));
  });
};
async function Ui(t) {
  const r = localStorage.getItem("DesignComboTemp");
  if (!r) return {};
  const e = { ...t }, n = JSON.parse(r), i = {}, o = n.trackItemsMap, c = n.tracks, u = [], p = n.activeIds.map(async (h) => {
    const m = o[h];
    (m.type === "caption" || m.type === "text") && m.details.fontUrl && await er([
      {
        fontFamily: m.details.fontFamily,
        url: m.details.fontUrl
      }
    ]);
    const I = le();
    return i[h] = I, e.trackItemsMap[I] = {
      ...o[h],
      id: I,
      details: m.details
    }, e.trackItemIds.push(I), true;
  });
  return await Promise.all(p), c.forEach((h) => {
    const m = h.items.map((d) => i[d]), I = {
      ...h,
      magnetic: false,
      static: false,
      items: m,
      id: le()
    };
    u.push(I);
  }), e.tracks = [...u, ...e.tracks], {
    tracks: e.tracks,
    trackItemIds: e.trackItemIds,
    trackItemsMap: e.trackItemsMap
  };
}
var Sr = {
  cors: {
    audio: true,
    video: true,
    image: true
  },
  acceptsMap: {
    text: ["text", "caption", "composition"],
    image: ["image", "video"],
    video: ["video", "image"],
    audio: ["audio"],
    composition: ["composition"],
    caption: ["caption", "text", "composition"],
    template: ["template", "image", "video"],
    customTrack: ["video", "image", "template"],
    customTrack2: ["video", "image", "template"],
    illustration: ["illustration", "custom"],
    custom: ["custom", "video", "illustration"],
    main: ["video", "image", "template"],
    shape: ["shape", "custom", "illustration"],
    linealAudioBars: ["audio", "linealAudioBars"],
    radialAudioBars: ["audio", "radialAudioBars"],
    progressFrame: ["audio", "progressFrame"],
    progressBar: ["audio", "progressBar"],
    rect: ["rect"]
  }
};
var ji = (t) => {
  const r = Object.fromEntries(
    Object.entries(t).filter(([e, n]) => n !== void 0)
  );
  Sr = { ...Sr, ...r };
};
var Rn = () => Sr.cors;
var Wi = () => Sr.acceptsMap;
var ze = (t) => new Promise((r, e) => {
  const n = new Image();
  n.onload = () => {
    const o = n.width, c = n.height;
    r({ width: o, height: c });
  }, n.onerror = (o) => {
    e(o);
  }, Rn().image && (n.crossOrigin = "anonymous"), n.src = t;
});
var ps = (t) => new Promise((r, e) => {
  const n = new Audio();
  n.preload = "auto", n.addEventListener("loadedmetadata", () => {
    const o = n.duration * 1e3;
    r({ duration: o });
  }), n.addEventListener("error", (o) => {
    e(o);
  }), n.src = t, Rn().audio && (n.crossOrigin = "anonymous"), n.load();
});
var Dn = (t) => new Promise((r, e) => {
  const n = document.createElement("video");
  n.preload = "auto", n.addEventListener("loadedmetadata", () => {
    const o = n.duration * 1e3, c = n.videoWidth, u = n.videoHeight;
    r({ duration: o, width: c, height: u });
  }), n.addEventListener("error", (o) => {
    e(o);
  }), n.src = t, Rn().video && (n.crossOrigin = "anonymous"), n.load();
});
var Bi = async (t) => {
  var i, o;
  const r = t.duration, e = (i = t.details) == null ? void 0 : i.width, n = (o = t.details) == null ? void 0 : o.height;
  return r && e && n ? { duration: r, width: e, height: n } : Dn(t.details.src);
};
var hs = (t, r) => {
  const e = document.createElement("div");
  Object.keys(r).forEach((i) => {
    i !== "height" && (e.style[i] = r[i]);
  }), document.body.appendChild(e), e.textContent = t, e.style.whiteSpace = "normal", e.style.position = "absolute", e.style.visibility = "hidden", e.style.display = "inline-block", e.style.width = r.width + "px", e.style.fontSize = r.fontSize + "px";
  const n = getComputedStyle(e).height;
  return document.body.removeChild(e), parseFloat(n);
};
var Kn = (t, r) => {
  var u, p;
  const e = ((u = t.details.crop) == null ? void 0 : u.width) || t.details.width || 0, n = ((p = t.details.crop) == null ? void 0 : p.height) || t.details.height || 0;
  let i = r.width, o = r.height;
  const c = r.width / r.height;
  return e / n > c ? (i = e, o = e / c) : (o = n, i = n * c), {
    newWidth: i,
    newHeight: o,
    crop: {
      x: 0,
      y: 0,
      height: n,
      width: e
    }
  };
};
var Vn = (t, r) => {
  const e = C(t.trim), n = C(t.display);
  return r.duration < t.display.to && (n.to = r.duration, e && (e.to = r.duration)), {
    duration: r.duration,
    trim: e,
    display: n
  };
};
async function Gi(t, r) {
  const e = { ...t }, n = Object.keys(r)[0], i = Object.values(r)[0], o = e.trackItemsMap[n], c = { ...e.trackItemsMap[n] }, u = o.details;
  if (!i.details.src) return {};
  if (o.type === "image") {
    const p = await ze(i.details.src), { crop: h, newHeight: m, newWidth: I } = Kn(o, p);
    i.details.crop = h, i.details.height = m, i.details.width = I;
  } else if (o.type === "video") {
    const p = await Dn(i.details.src), h = e.trackItemsMap[n], { display: m, duration: I, trim: d } = Vn(h, p), { crop: b, newHeight: w, newWidth: k } = Kn(o, p);
    i.details.crop = b, i.details.height = w, i.details.width = k, c.display = m, c.duration = I, c.trim = d;
  } else if (o.type === "audio") {
    const p = await ps(i.details.src), h = e.trackItemsMap[n], { display: m, duration: I, trim: d } = Vn(h, p);
    c.display = m, c.duration = I, c.trim = d;
  }
  return o.details = { ...u, ...i.details }, e.trackItemsMap[n] = { ...c }, {
    trackItemsMap: {
      ...e.trackItemsMap,
      [n]: { ...c, details: { ...u, ...i.details } }
    }
  };
}
function Yi(t, r) {
  const e = C(t), n = {}, i = r && r.length ? r : e.activeIds;
  if (i.length === 0) return {};
  i.forEach((c) => {
    const u = e.trackItemsMap[c], p = le();
    e.trackItemsMap[p] = {
      ...C(u),
      id: p
    }, e.trackItemIds.push(p);
    const h = e.tracks.find(
      (m) => m.items.includes(c)
    );
    n[h.id] ? n[h.id].items.push(p) : n[h.id] = {
      ...h,
      id: le(),
      items: [p],
      static: false,
      magnetic: false
    };
  });
  const o = Object.values(n);
  return e.tracks = [...o, ...e.tracks], {
    trackItemsMap: e.trackItemsMap,
    tracks: e.tracks,
    trackItemIds: e.trackItemIds
  };
}
function Xi(t) {
  const r = /#([0-9a-fA-F]{3,6})\b/g, e = /rgb\(\s*(\d+),\s*(\d+),\s*(\d+)\s*\)/g, n = /rgba\(\s*(\d+),\s*(\d+),\s*(\d+),\s*([0-9.]+)\s*\)/g;
  function i(c) {
    return c.length === 3 ? `#${c[0]}${c[0]}${c[1]}${c[1]}${c[2]}${c[2]}`.toUpperCase() : `#${c.toUpperCase()}`;
  }
  function o(c, u, p) {
    return `#${(1 << 24 | c << 16 | u << 8 | p).toString(16).slice(1).toUpperCase()}`;
  }
  return t = t.replace(r, (c, u) => i(u)), t = t.replace(
    e,
    (c, u, p, h) => o(+u, +p, +h)
  ), t = t.replace(
    n,
    (c, u, p, h) => o(+u, +p, +h)
  ), t;
}
function X(t) {
  return /^#[0-9a-fA-F]{3}$/.test(t) ? "#" + t[1] + t[1] + t[2] + t[2] + t[3] + t[3] : t;
}
function ms(t, r) {
  let e = t;
  for (const n in r)
    if (Object.prototype.hasOwnProperty.call(r, n)) {
      const i = new RegExp(n, "g");
      e = e.replace(i, r[n]);
    }
  return e;
}
function gs(t) {
  const r = t.getAttribute("fill");
  if (r && r.trim() !== "" && r.trim() !== "none")
    return r.trim();
  const e = t.getAttribute("style");
  if (e) {
    const i = /fill\s*:\s*([^;]+);?/.exec(e);
    if (i) {
      const o = i[1].trim();
      if (o !== "" && o !== "none")
        return o;
    }
  }
  const n = t.parentElement;
  return n ? gs(n) : null;
}
function Ke(t) {
  return /^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$/.test(t);
}
var Ki = (t) => {
  const r = `.${t.split(".").filter((o) => o.includes("fill:")).join(".")}`, e = {}, n = /\.([\w-]+)\s*\{\s*([^}]+)\s*\}/g;
  let i;
  for (; (i = n.exec(r)) !== null; ) {
    const o = i[1], c = i[2], u = {}, p = /fill\s*:\s*([^;]+);?/.exec(c), h = /stroke\s*:\s*([^;]+);?/.exec(c);
    p && (u.fill = X(p[1].trim())), h && (u.stroke = X(h[1].trim())), e[o] = u;
  }
  return e;
};
function hn(t) {
  let r = t.parentElement;
  for (; r; ) {
    if (r.tagName.toLowerCase() === "mask")
      return true;
    r = r.parentElement;
  }
  return false;
}
function Vi(t, r, e = 300, n = 300) {
  const i = [], c = new DOMParser().parseFromString(t, "image/svg+xml"), u = c.documentElement;
  u.setAttribute("width", `${e}`), u.setAttribute("height", `${n}`);
  const p = u.querySelectorAll("style"), h = {};
  p.forEach((k) => {
    const S = k.textContent || "", f = Ki(S);
    Object.assign(h, f);
    const y = S.replace(/\.(st[\w-]+)/g, `.${r}-$1`).replace(/url\(#(.*?)\)/g, `url(#${r}-$1)`);
    k.textContent = y;
    const v = Array.from(c.querySelectorAll("*")), _ = /* @__PURE__ */ new Set();
    v.forEach((A) => {
      if (hn(A)) return;
      ["fill", "stroke", "stop-color"].forEach((H) => {
        const P = A.getAttribute(H);
        P && !["none", "transparent"].includes(P) && _.add(X(P));
      });
      const E = A.getAttribute("style");
      if (E) {
        const H = /fill\s*:\s*([^;]+);?/.exec(E), P = /stroke\s*:\s*([^;]+);?/.exec(E), V = /stop-color\s*:\s*([^;]+);?/.exec(E);
        if (H) {
          const x = H[1].trim();
          x && !["none", "transparent"].includes(x) && Ke(X(x)) && _.add(X(x));
        }
        if (P) {
          const x = P[1].trim();
          x && !["none", "transparent"].includes(x) && Ke(X(x)) && _.add(X(x));
        }
        if (V) {
          const x = V[1].trim();
          x && !["none", "transparent"].includes(x) && Ke(X(x)) && _.add(X(x));
        }
      }
      const T = A.getAttribute("class");
      T && T.split(" ").forEach((H) => {
        const P = h[H];
        P != null && P.fill && !["none", "transparent"].includes(P.fill) && _.add(X(P.fill)), P != null && P.stroke && !["none", "transparent"].includes(P.stroke) && _.add(X(P.stroke));
      });
    }), Array.from(_).forEach((A) => {
      Ke(A) && i.push(A);
    });
  });
  const m = Array.from(c.querySelectorAll("*")), I = /* @__PURE__ */ new Set();
  return m.forEach((k) => {
    if (hn(k)) return;
    const S = k.getAttribute("class");
    if (S) {
      const y = S.split(" ").map((v) => `${r}-${v}`).join(" ");
      k.setAttribute("class", y), y.split(" ").forEach((v) => {
        const _ = h[v];
        _ != null && _.fill && !["none", "transparent"].includes(_.fill) && I.add(X(_.fill)), _ != null && _.stroke && !["none", "transparent"].includes(_.stroke) && I.add(X(_.stroke));
      });
    }
    ["fill", "stroke", "stop-color"].forEach((y) => {
      const v = k.getAttribute(y);
      v && !["none", "transparent"].includes(v) && I.add(X(v));
    });
    const f = k.getAttribute("style");
    if (f) {
      const y = /fill\s*:\s*([^;]+);?/.exec(f), v = /stroke\s*:\s*([^;]+);?/.exec(f), _ = /stop-color\s*:\s*([^;]+);?/.exec(f);
      if (y) {
        const A = y[1].trim();
        A && !["none", "transparent"].includes(A) && I.add(X(A));
      }
      if (v) {
        const A = v[1].trim();
        A && !["none", "transparent"].includes(A) && I.add(X(A));
      }
      if (_) {
        const A = _[1].trim();
        A && !["none", "transparent"].includes(A) && I.add(X(A));
      }
    }
  }), I.forEach(
    (k) => !i.includes(k) && Ke(k) && i.push(k)
  ), Array.from(c.querySelectorAll("*")).forEach((k) => {
    if (k.hasAttribute("id")) {
      const S = k.getAttribute("id");
      k.setAttribute("id", `${r}-${S}`);
    }
    if (["fill", "stroke", "stop-color", "filter", "clip-path", "mask"].forEach(
      (S) => {
        const f = k.getAttribute(S);
        f && f.includes("url(#") && k.setAttribute(
          S,
          f.replace(/url\(#(.*?)\)/g, `url(#${r}-$1)`)
        );
      }
    ), k.hasAttribute("style")) {
      const S = k.getAttribute("style");
      S.includes("url(#") && k.setAttribute(
        "style",
        S.replace(/url\(#(.*?)\)/g, `url(#${r}-$1)`)
      );
    }
  }), Array.from(c.querySelectorAll("path")).forEach((k) => {
    if (hn(k)) return;
    !gs(k) && !k.getAttribute("class") && (k.setAttribute("fill", "#000000"), i.includes("#000000") || i.push("#000000"));
  }), { serializer: new XMLSerializer().serializeToString(c), colors: i };
}
var rr = {
  color: "#000000",
  x: 0,
  y: 0,
  blur: 0
};
var ht = (t, r) => {
  let e = r != null && r.trim ? r.trim.to - r.trim.from : (r == null ? void 0 : r.duration) || 5e3;
  const n = {
    from: 0,
    to: e
  };
  if (!t)
    return n;
  if (t.from < 0)
    return console.error(
      "'from' must be a non-negative number. Returning default display."
    ), n;
  if (t.from !== void 0 && t.to === void 0)
    return {
      from: t.from,
      to: t.from + e
    };
  if (t.to !== void 0) {
    if (t.to < 0)
      return console.error(
        "'to' must be a non-negative number. Returning default display."
      ), n;
    if (t.to < t.from)
      return console.error(
        "'to' must be greater than or equal to 'from'. Returning default display."
      ), n;
  }
  return t;
};
var ys = (t, r) => t ? t.from && !t.to ? {
  from: t.from,
  to: r.duration
} : t : {
  from: 0,
  to: r.duration
};
function Is(t, r) {
  const e = {
    x: t.size.width / 2,
    y: t.size.height / 2
  }, n = { x: r.width / 2, y: r.height / 2 }, i = e.x - n.x;
  return {
    top: `${e.y - n.y}px`,
    left: `${i}px`,
    transform: "none"
    // No scaling for text/captions
  };
}
function mt(t, r) {
  const e = t.scaleMode, n = {
    x: t.size.width / 2,
    y: t.size.height / 2
  }, i = { x: r.width / 2, y: r.height / 2 };
  let o;
  if (e === "fill")
    o = Math.max(
      t.size.width / r.width,
      t.size.height / r.height
    );
  else if (e === "fit") {
    const p = t.scaleAspectRatio || 1;
    o = Math.min(
      t.size.width / r.width,
      t.size.height / r.height
    ) * p;
  } else
    o = Math.min(
      t.size.width / r.width,
      t.size.height / r.height
    );
  const c = n.x - i.x;
  return {
    top: `${n.y - i.y}px`,
    left: `${c}px`,
    transform: `scale(${o})`
  };
}
var bs = async (t, r) => {
  const e = t.details.src, n = await Bi(t), i = mt(r, {
    ...n
  }), o = ys(t.trim, { duration: n.duration }), c = {
    width: n.width,
    height: n.height,
    opacity: 100,
    src: e,
    volume: t.details.volume ?? 100,
    // Default volume
    borderRadius: t.details.borderRadius ?? 0,
    // Default border radius
    borderWidth: t.details.borderWidth ?? 0,
    // Default border width
    borderColor: t.details.borderColor || "#000000",
    // Default border color
    boxShadow: t.details.boxShadow || rr,
    top: t.details.top || i.top || "0px",
    // Default top
    left: t.details.left || i.left || "0px",
    // Default left
    transform: t.details.transform || i.transform,
    // Default transform
    blur: t.details.blur || 0,
    brightness: t.details.brightness || 100,
    flipX: t.details.flipX || false,
    flipY: t.details.flipY || false,
    rotate: t.details.rotate || "0deg",
    visibility: t.details.visibility || "visible"
  };
  return {
    ...t,
    trim: o,
    type: "video",
    name: "video",
    details: c,
    playbackRate: t.playbackRate || 1,
    display: ht(t.display, { duration: n.duration, trim: o }),
    duration: n.duration
  };
};
var ks = async (t) => {
  const r = t.id, e = t.details, i = (await ps(e.src)).duration, o = ys(t.trim, { duration: i });
  return {
    id: r,
    name: t.name || "audio",
    type: "audio",
    display: ht(t.display, { duration: i, trim: o }),
    trim: o,
    playbackRate: t.playbackRate || 1,
    details: {
      src: e.src,
      volume: e.volume ?? 100
      // Default volume
    },
    metadata: { ...t.metadata },
    duration: i
  };
};
var Ji = async (t, r) => {
  var u, p;
  const e = t.id, n = {
    width: ((u = t.details) == null ? void 0 : u.width) || r.size.width,
    height: ((p = t.details) == null ? void 0 : p.height) || r.size.height
  }, i = t.details, o = mt(r, n), c = ht(t.display);
  return {
    id: e,
    name: t.type,
    type: t.type,
    display: c,
    details: {
      width: (i == null ? void 0 : i.width) || n.width,
      // Default width
      height: (i == null ? void 0 : i.height) || n.height,
      // Default height
      top: (i == null ? void 0 : i.top) || o.top,
      left: (i == null ? void 0 : i.left) || o.left,
      border: i.border || "none",
      // Default border
      borderRadius: i.borderRadius || 0,
      // Default border radius
      borderWidth: i.borderWidth || 0,
      // Default border width
      borderColor: i.borderColor || "#000000",
      // Default border color
      opacity: i.opacity || 100,
      // Default opacity
      flipX: i.flipX || false,
      flipY: i.flipY || false,
      inverted: i.inverted || false,
      backgroundColors: (i == null ? void 0 : i.backgroundColors) || [
        "rgba(128, 128, 128,0.5)",
        "rgba(128, 128, 128,1)"
      ]
    },
    metadata: {}
  };
};
var qi = async (t, r) => {
  var u, p;
  const e = t.id, n = {
    width: ((u = t.details) == null ? void 0 : u.width) || r.size.width,
    height: ((p = t.details) == null ? void 0 : p.height) || r.size.height
  }, i = t.details, o = mt(r, n), c = ht(t.display);
  return {
    id: e,
    name: t.type,
    type: t.type,
    display: c,
    details: {
      width: (i == null ? void 0 : i.width) || n.width,
      // Default width
      height: (i == null ? void 0 : i.height) || n.height,
      // Default height
      top: (i == null ? void 0 : i.top) || o.top,
      left: (i == null ? void 0 : i.left) || o.left,
      border: i.border || "none",
      // Default border
      borderRadius: i.borderRadius || 0,
      // Default border radius
      borderWidth: i.borderWidth || 0,
      // Default border width
      borderColor: i.borderColor || "#000000",
      // Default border color
      opacity: i.opacity || 100,
      // Default opacity
      flipX: i.flipX || false,
      flipY: i.flipY || false,
      inverted: i.inverted || false,
      backgroundColors: (i == null ? void 0 : i.backgroundColors) || [
        "rgba(128, 128, 128,0.5)",
        "rgba(128, 128, 128,1)"
      ],
      barThickness: i.barThickness || 10
    },
    metadata: {}
  };
};
var Zi = async (t, r) => {
  var u, p;
  const e = t.id, n = {
    width: ((u = t.details) == null ? void 0 : u.width) || r.size.width,
    height: ((p = t.details) == null ? void 0 : p.height) || r.size.height
  }, i = t.details, o = mt(r, n), c = ht(t.display);
  return {
    id: e,
    name: t.type,
    type: t.type,
    display: c,
    details: {
      width: (i == null ? void 0 : i.width) || n.width,
      // Default width
      height: (i == null ? void 0 : i.height) || n.height,
      // Default height
      top: (i == null ? void 0 : i.top) || o.top,
      left: (i == null ? void 0 : i.left) || o.left,
      radialBarColor: i.radialBarColor || "rgba(128, 128, 128,1)",
      border: i.border || "none",
      // Default border
      borderRadius: i.borderRadius || 0,
      // Default border radius
      borderWidth: i.borderWidth || 0,
      // Default border width
      borderColor: i.borderColor || "#000000",
      // Default border color
      opacity: i.opacity || 100,
      // Default opacity
      flipX: i.flipX || false,
      flipY: i.flipY || false
    },
    metadata: {}
  };
};
var mn = async (t, r) => {
  var c, u;
  const e = t.id, n = {
    width: ((c = t.details) == null ? void 0 : c.width) || r.size.width,
    height: ((u = t.details) == null ? void 0 : u.height) || r.size.height
  }, i = t.details, o = mt(r, n);
  return {
    id: e,
    name: t.type,
    type: t.type,
    display: {
      from: 0,
      to: t.duration || 1e4
    },
    details: {
      width: (i == null ? void 0 : i.width) || n.width,
      // Default width
      height: (i == null ? void 0 : i.height) || n.height,
      // Default height
      top: (i == null ? void 0 : i.top) || o.top,
      left: (i == null ? void 0 : i.left) || o.left,
      border: i.border || "none",
      // Default border
      borderRadius: i.borderRadius || 0,
      // Default border radius
      borderWidth: i.borderWidth || 0,
      // Default border width
      borderColor: i.borderColor || "#000000",
      // Default border color
      opacity: i.opacity || 100,
      // Default opacity
      flipX: i.flipX || false,
      flipY: i.flipY || false,
      inverted: i.inverted || false,
      linealBarColor: i.linealBarColor || "rgba(128, 128, 128,1)",
      lineThickness: i.lineThickness || 1,
      gapSize: i.gapSize || 1,
      roundness: i.roundness || 1,
      placement: i.placement || null,
      strokeColor: i.strokeColor || "#92E1B0",
      fillColor: i.fillColor || null,
      strokeWidth: i.strokeWidth || null,
      copies: i.copies || null,
      offsetPixelSpeed: i.offsetPixelSpeed || 0,
      lineColor: i.lineColor || "#92E1B0",
      lineGap: i.lineGap || 0,
      topRoundness: i.topRoundness || 0,
      bottomRoundness: i.bottomRoundness || 0,
      lines: i.lines || 0,
      sections: i.sections || 0
    },
    metadata: {}
  };
};
var vs = async (t, r) => {
  var I;
  const e = t.trackItemIds, n = t.size || {
    width: t.details.width,
    height: t.details.height
  }, i = Math.min(
    r.size.width / n.width,
    r.size.height / n.height
  ), o = ((I = t.details) == null ? void 0 : I.rotate) || 0, c = mt(r, n), u = t.display;
  let p = 1 / 0, h = 0;
  e.forEach((d) => {
    const b = t.trackItemsMap[d];
    b.display.from < p && (p = b.display.from), b.display.to > h && (h = b.display.to);
  });
  const m = t.trim || t.display || { from: p, to: h };
  return {
    id: t.id,
    type: "template",
    details: {
      ...n,
      transform: t.details.transform || c.transform,
      // Default transform
      top: t.details.top || c.top,
      left: t.details.left || c.left,
      scale: i,
      rotate: o,
      background: t.details.background || "transparent"
    },
    trim: m,
    display: u || { from: p, to: h },
    activeEdit: false
  };
};
var Qi = async (t, r) => {
  var m;
  const e = t.trackItemIds, n = t.size || {
    width: t.details.width,
    height: t.details.height
  }, i = Math.min(
    r.size.width / n.width,
    r.size.height / n.height
  ), o = ((m = t.details) == null ? void 0 : m.rotate) || 0, c = mt(r, n), u = t.display;
  let p = 1 / 0, h = 0;
  return e.forEach((I) => {
    const d = t.trackItemsMap[I];
    d.display.from < p && (p = d.display.from), d.display.to > h && (h = d.display.to);
  }), {
    id: t.id,
    type: "composition",
    details: {
      ...n,
      transform: t.details.transform || c.transform,
      // Default transform
      top: t.details.top || c.top,
      left: t.details.left || c.left,
      scale: i,
      rotate: o
    },
    display: u || { from: p, to: h }
  };
};
var _s = async (t, r) => {
  const e = t.details, n = ze(e.src), i = fetch(e.src), [o, c] = await Promise.all([
    n,
    i
  ]), u = await c.text(), p = mt(r, o), { serializer: h, colors: m } = Vi(
    Xi(u),
    t.id,
    Number(e.width || o.width),
    Number(e.height || o.height)
  ), I = t.details.colorMap || Object.fromEntries(m.map((d) => [d, d]));
  return {
    id: t.id,
    name: "illustration",
    type: t.type,
    display: ht(t.display),
    playbackRate: t.playbackRate || 1,
    details: {
      src: e.src || "",
      // Default source URL
      width: e.width || o.width || 100,
      // Default width
      height: e.height || o.height || 100,
      // Default height
      opacity: e.opacity ?? 100,
      // Default opacity
      transform: e.transform || p.transform,
      // Default transform
      border: e.border || "none",
      // Default border
      borderRadius: e.borderRadius || 0,
      // Default border radius
      top: e.top || p.top || "0px",
      // Default top
      left: e.left || p.left || "0px",
      // Default left
      borderWidth: e.borderWidth ?? 0,
      // Default border width
      borderColor: e.borderColor || "#000000",
      // Default border color
      flipX: e.flipX || false,
      flipY: e.flipY || false,
      rotate: e.rotate || "0deg",
      visibility: e.visibility || "visible",
      svgString: h,
      initialSvgString: C(h),
      colorMap: I
    },
    metadata: t.metadata || {}
  };
};
var ta = async (t, r) => {
  const e = t.details, n = ze(e.src), [i] = await Promise.all([n]), o = mt(r, i);
  return {
    id: t.id,
    name: "shape",
    type: t.type,
    display: ht(t.display),
    playbackRate: t.playbackRate || 1,
    details: {
      src: e.src || "",
      // Default source URL
      width: e.width || i.width || 100,
      // Default width
      height: e.height || i.height || 100,
      // Default height
      opacity: e.opacity ?? 100,
      // Default opacity
      transform: e.transform || o.transform,
      // Default transform
      border: e.border || "none",
      // Default border
      borderRadius: e.borderRadius || 0,
      // Default border radius
      top: e.top || o.top || "0px",
      // Default top
      left: e.left || o.left || "0px",
      // Default left
      borderWidth: e.borderWidth ?? 0,
      // Default border width
      borderColor: e.borderColor || "#000000",
      // Default border color
      flipX: e.flipX || false,
      flipY: e.flipY || false,
      rotate: e.rotate || "0deg",
      visibility: e.visibility || "visible",
      backgroundColor: e.backgroundColor || "#808080"
    },
    metadata: t.metadata || {}
  };
};
var ea = async (t, r) => {
  const e = t.details, n = mt(r, {
    width: e.width,
    height: e.height
  });
  return {
    id: t.id,
    name: "rect",
    type: t.type,
    display: ht(t.display),
    playbackRate: t.playbackRate || 1,
    details: {
      width: e.width || 100,
      // Default width
      height: e.height || 100,
      // Default height
      opacity: e.opacity ?? 100,
      // Default opacity
      transform: e.transform || n.transform,
      // Default transform
      border: e.border || "none",
      // Default border
      borderRadius: e.borderRadius || 0,
      // Default border radius
      top: e.top || n.top || "0px",
      // Default top
      left: e.left || n.left || "0px",
      // Default left
      borderWidth: e.borderWidth ?? 0,
      // Default border width
      borderColor: e.borderColor || "#000000",
      // Default border color
      flipX: e.flipX || false,
      flipY: e.flipY || false,
      rotate: e.rotate || "0deg",
      visibility: e.visibility || "visible",
      backgroundColor: e.backgroundColor || "#808080",
      boxShadow: e.boxShadow || rr,
      // Default box shadow
      blur: e.blur || 0,
      brightness: e.brightness || 100
    },
    metadata: t.metadata || {}
  };
};
var Ss = async (t, r) => {
  const e = t.details, n = await ze(e.src), i = mt(r, n);
  return {
    id: t.id,
    type: "image",
    name: "image",
    display: ht(t.display),
    playbackRate: t.playbackRate || 1,
    details: {
      src: e.src || "",
      // Default source URL
      width: e.width || n.width || 100,
      // Default width
      height: e.height || n.height || 100,
      // Default height
      opacity: e.opacity ?? 100,
      // Default opacity
      transform: e.transform || i.transform,
      // Default transform
      border: e.border || "none",
      // Default border
      borderRadius: e.borderRadius || 0,
      // Default border radius
      boxShadow: e.boxShadow || rr,
      // Default box shadow
      top: e.top || i.top || "0px",
      // Default top
      left: e.left || i.left || "0px",
      // Default left
      borderWidth: e.borderWidth ?? 0,
      // Default border width
      borderColor: e.borderColor || "#000000",
      // Default border color
      blur: e.blur || 0,
      brightness: e.brightness || 100,
      flipX: e.flipX || false,
      flipY: e.flipY || false,
      rotate: e.rotate || "0deg",
      visibility: e.visibility || "visible"
    },
    metadata: t.metadata || {}
  };
};
var ws = async (t, r) => {
  const e = t;
  e.details.fontUrl && await er([
    {
      fontFamily: e.details.fontFamily,
      url: e.details.fontUrl
    }
  ]);
  const n = e.id, i = e.details, o = As(i), c = i.height || hs(e.details.text, o), u = i.top != null && i.left != null ? {
    top: `${i.top}px`,
    left: `${i.left}px`
  } : Is(r, {
    width: o.width,
    height: c
  });
  return {
    id: n,
    name: "caption",
    type: "caption",
    display: ht(e.display),
    details: {
      ...e.details,
      ...o,
      text: i.text || "",
      // Default text content
      height: c,
      // Default height
      fontUrl: i.fontUrl,
      top: o.top || u.top,
      left: o.left || u.left,
      borderWidth: i.borderWidth || 0,
      borderColor: i.borderColor || "#000000",
      boxShadow: i.boxShadow || rr,
      words: i.words || [],
      appearedColor: i.appearedColor || i.color,
      activeColor: i.activeColor || i.color,
      activeFillColor: i.activeFillColor || "transparent"
    },
    metadata: t.metadata || {}
  };
};
var Ts = async (t, r) => {
  t.details.fontUrl && await er([
    {
      fontFamily: t.details.fontFamily,
      url: t.details.fontUrl
    }
  ]);
  const e = t.id, n = t.details, i = As(n), o = n.height || hs(t.details.text, i), c = n.top != null && n.left != null ? {
    top: `${n.top}px`,
    left: `${n.left}px`
  } : Is(r, {
    width: i.width,
    height: o
  });
  return {
    id: e,
    name: "text",
    type: "text",
    display: ht(t.display),
    details: {
      ...t.details,
      ...i,
      text: n.text || "",
      // Default text content
      height: o,
      // Default height
      fontUrl: n.fontUrl,
      top: i.top || c.top,
      left: i.left || c.left,
      borderWidth: n.borderWidth || 0,
      borderColor: n.borderColor || "#000000",
      boxShadow: n.boxShadow || rr
    },
    metadata: {}
  };
};
var As = (t) => ({
  fontFamily: t.fontFamily || "Arial",
  // Default font family
  fontSize: t.fontSize || "16px",
  // Default font size
  fontWeight: t.fontWeight || "normal",
  // Default font weight
  fontStyle: t.fontStyle || "normal",
  // Default font style
  textDecoration: t.textDecoration || "none",
  // Default text decoration
  textAlign: t.textAlign || "left",
  // Default text alignment
  lineHeight: t.lineHeight || "normal",
  // Default line height
  letterSpacing: t.letterSpacing || "normal",
  // Default letter spacing
  wordSpacing: t.wordSpacing || "normal",
  // Default word spacing
  color: t.color || "#ffffff",
  // Default text color (black)
  backgroundColor: t.backgroundColor || "transparent",
  // Default background color
  border: t.border || "none",
  // Default border
  textShadow: t.textShadow || "none",
  // Default text shadow
  text: t.text || "",
  // Default text content
  opacity: t.opacity ?? 100,
  // Default opacity
  width: t.width || 300,
  wordWrap: t.wordWrap || "normal",
  //'break-word'
  wordBreak: t.wordBreak || "normal",
  //'break-all',
  WebkitTextStrokeColor: t.WebkitTextStrokeColor || "#ffffff",
  WebkitTextStrokeWidth: t.WebkitTextStrokeWidth || "0px",
  top: t.top,
  left: t.left,
  textTransform: t.textTransform || "none",
  transform: t.transform || "none",
  skewX: t.skewX || 0,
  skewY: t.skewY || 0
});
var ra = async (t, r) => {
  switch (t.type) {
    case "video":
      return bs(t, r || {});
    case "audio":
      return ks(t);
    case "image":
      return Ss(t, r || {});
    case "text":
      return Ts(t, r || {});
    case "caption":
      return ws(t, r || {});
    case "template":
      return vs(t, {
        size: r == null ? void 0 : r.size
      });
    default:
      throw new Error("Unsupported track item");
  }
};
function Es(t, r) {
  return r.some(
    (e) => t.some((n) => n.id === e.id)
  );
}
var Ms = (t = [], r = []) => t.length === 0 ? r.map((n) => ({
  id: le(),
  items: [n.id],
  type: n.type,
  accepts: ["text", "image", "video", "audio", "caption", "template"]
})) : t.map((e) => ({
  ...e,
  items: e.items || [],
  accepts: ["audio", "video", "image", "text", "caption", "template"],
  type: e.type || "text",
  magnetic: e.magnetic || false,
  static: e.static || false,
  id: e.id || le()
}));
async function na(t, r) {
  var c, u, p;
  const e = r.trackItemsMap, n = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Map();
  for (const h in e) {
    const m = e[h];
    if (m.type === "text" || m.type === "caption") {
      if (m.details.fontUrl) {
        const I = {
          fontFamily: m.details.fontFamily,
          url: m.details.fontUrl
        };
        n.add(JSON.stringify(I));
      }
      (c = m.animations) != null && c.in && m.animations.in.composition.forEach(
        (I) => {
          var d;
          (d = I.details) != null && d.fonts && I.details.fonts.forEach(
            (b) => {
              n.add(JSON.stringify(b));
            }
          );
        }
      ), (u = m.animations) != null && u.loop && m.animations.loop.composition.forEach(
        (I) => {
          var d;
          (d = I.details) != null && d.fonts && I.details.fonts.forEach(
            (b) => {
              n.add(JSON.stringify(b));
            }
          );
        }
      ), (p = m.animations) != null && p.out && m.animations.out.composition.forEach(
        (I) => {
          var d;
          (d = I.details) != null && d.fonts && I.details.fonts.forEach(
            (b) => {
              n.add(JSON.stringify(b));
            }
          );
        }
      );
    } else m.type === "illustration" && i.set(h, {
      trackItem: m,
      details: m.details
    });
  }
  n.size > 0 && await er(
    Array.from(n).map((h) => JSON.parse(h))
  );
  for (const [h, m] of i) {
    const I = await _s(
      { ...m.trackItem, details: m.details },
      {
        size: { width: m.details.width, height: m.details.height }
      }
    ), d = ms(
      I.details.svgString,
      m.details.colorMap
    );
    I.details.svgString = d, e[h] = I;
  }
  const o = K(e);
  return {
    ...r,
    duration: o
  };
}
function sa(t) {
  const r = C(t);
  if (!r.activeIds.length) return;
  const e = r.activeIds, n = [], i = {
    activeIds: e,
    trackItemsMap: {},
    tracks: []
  };
  e.forEach((c) => {
    i.trackItemsMap[c] = r.trackItemsMap[c], n.push(r.tracks.find((u) => u.items.includes(c)));
  });
  const o = /* @__PURE__ */ new Set();
  n.filter((c) => o.has(c.id) ? false : (o.add(c.id), true)), i.tracks = Array.from(o), localStorage.setItem("DesignComboTemp", JSON.stringify(i));
}
function ia(t, r) {
  const e = C(t);
  if (e.activeIds.length !== 1) return {};
  const n = e.activeIds[0], i = C(e.trackItemsMap[n]);
  if (r >= i.display.to || r <= i.display.from)
    return {};
  const o = le(), c = {
    ...i,
    display: {
      from: i.display.from,
      to: r
    }
  }, u = {
    ...i,
    id: o,
    display: {
      from: r,
      to: i.display.to
    }
  }, p = Object.values(e.transitionsMap).find(
    (m) => m.fromId === i.id && m.kind !== "none"
  ), h = Object.values(e.transitionsMap).find(
    (m) => m.toId === i.id && m.kind !== "none"
  );
  if (i.type === "video" || i.type === "audio") {
    const m = r - c.display.from;
    c.trim = {
      from: i.trim.from,
      to: i.trim.from + m
    }, u.trim = {
      from: i.trim.from + m,
      to: i.trim.to
    };
  }
  if (h) {
    const m = c.display.to - c.display.from;
    if (h.duration / 2 > m) {
      e.transitionIds = e.transitionIds.filter(
        (d) => d !== h.id
      );
      const I = {};
      e.transitionIds.forEach(
        (d) => I[d] = e.transitionsMap[d]
      ), e.transitionsMap = I;
    }
  }
  if (p) {
    const m = u.display.to - u.display.from, I = {};
    p.duration / 2 > m ? (e.transitionIds = e.transitionIds.filter(
      (d) => d !== p.id
    ), e.transitionIds.forEach(
      (d) => I[d] = e.transitionsMap[d]
    ), e.transitionsMap = I) : (e.transitionIds = e.transitionIds.map((d) => e.transitionsMap[d].fromId === c.id ? d.replace(c.id, o) : d), Object.keys(e.transitionsMap).forEach((d) => {
      if (e.transitionsMap[d].fromId === c.id) {
        const w = d.replace(c.id, o);
        I[w] = {
          ...e.transitionsMap[d],
          id: w,
          fromId: o
        };
      } else
        I[d] = e.transitionsMap[d];
    }), e.transitionsMap = I);
  }
  return e.trackItemsMap[n] = c, e.trackItemsMap[o] = u, e.trackItemIds.push(o), e.tracks.forEach((m) => {
    m.items.includes(n) && m.items.push(o);
  }), {
    tracks: e.tracks,
    trackItemIds: e.trackItemIds,
    trackItemsMap: e.trackItemsMap,
    transitionsMap: e.transitionsMap,
    transitionIds: e.transitionIds
  };
}
async function aa(t, r) {
  const n = C(t).trackItemsMap, i = Object.keys(r);
  if (!i.length) return {};
  for (const c of i) {
    const u = r[c];
    if (u.details && (n[c].details = {
      ...n[c].details,
      ...u.details
    }, u.details.colorMap)) {
      const p = n[c].details.initialSvgString, h = ms(
        p,
        u.details.colorMap
      );
      n[c].details.svgString = h;
    }
    if (u.metadata && (n[c].metadata ? n[c].metadata = {
      ...n[c].metadata,
      ...u.metadata
    } : n[c].metadata = u.metadata), u.display || u.playbackRate) {
      const p = u.playbackRate, h = n[c].playbackRate || 1, m = n[c].display, b = (m.to - m.from) * h / p, w = {
        from: m.from,
        to: m.from + b
      };
      n[c].display = w, n[c].playbackRate = p;
    }
    u.animations && (n[c].animations = {
      ...n[c].animations,
      ...u.animations
    });
  }
  for (const c of i) {
    const u = r[c];
    if (n[c].type === "shape" && u.details.src) {
      const p = await ze(u.details.src);
      n[c].details.width = p.width, n[c].details.height = p.height;
    }
  }
  const o = K(n);
  return {
    trackItemsMap: { ...n },
    duration: o
  };
}
async function oa(t, r) {
  const e = C(t), n = Object.keys(r)[0], i = Object.values(r)[0], o = e.trackItemsMap[n], c = o.details;
  if (!i.details.src) return {};
  if (o.type === "image") {
    const u = await ze(i.details.src), p = o.details.width || 0, h = o.details.height || 0;
    let m = u.width, I = u.height;
    const d = u.width / u.height;
    p / h > d ? (m = p, I = p / d) : (I = h, m = h * d), c.crop = {
      x: 0,
      y: 0,
      height: c.height,
      width: c.width
    }, i.details.width = m, i.details.height = I;
  } else if (o.type === "video") {
    const u = await Dn(i.details.src), p = o.details.width || 0, h = o.details.height || 0;
    let m = u.width, I = u.height;
    const d = u.width / u.height;
    p / h > d ? (m = p, I = p / d) : (I = h, m = h * d), c.crop = {
      x: 0,
      y: 0,
      height: c.height,
      width: c.width
    }, i.details.width = m, i.details.height = I;
  }
  return i.details && (o.details = { ...c, ...i.details }, i.details = o.details), e.trackItemsMap[n] = {
    ...e.trackItemsMap[n],
    type: i.type
  }, {
    trackItemsMap: {
      ...e.trackItemsMap
    }
  };
}
function ca(t, r) {
  const e = C(t);
  return e.background.value = r.value, e.background.type = r.type || "color", {
    ...e
  };
}
async function ua(t, r, e = {}) {
  const n = C(t), i = r.trackItems.map(
    (b) => ra(b, {
      size: n.size
    })
  ), o = await Promise.all(i), c = Ms(r.tracks, r.trackItems), u = [], p = o.map((b) => b.id);
  r.trackItems.forEach((b) => {
    if (b.type !== "template") return;
    n.trackItemsMap = {
      ...n.trackItemsMap,
      ...b.trackItemsMap
    }, n.transitionsMap = {
      ...n.transitionsMap,
      ...b.transitionsMap
    };
    const w = {
      id: b.id,
      items: b.trackItemIds,
      transitions: b.transitionsIds || [],
      tracks: b.tracks
    };
    u.push(w);
  });
  const h = [], m = {};
  if (o.forEach((b) => {
    h.push(b.id), m[b.id] = b;
  }), Es(
    n.tracks,
    c
  ))
    n.tracks.forEach((b) => {
      c.forEach((w) => {
        b.id === w.id && (b.magnetic && nt(
          [b],
          n.trackItemsMap,
          p
        ), b.items.push(...h));
      });
    });
  else {
    const b = e.trackIndex || 0, w = Math.min(
      Math.max(b, 0),
      n.tracks.length
    );
    n.tracks.splice(w, 0, ...c);
  }
  n.trackItemsMap = {
    ...n.trackItemsMap,
    ...m
  }, n.trackItemIds = [
    ...n.trackItemIds,
    ...h
  ], n.structure = [...n.structure, ...u];
  const d = n.tracks.filter((b) => b.magnetic);
  return nt(d, n.trackItemsMap, p), n.duration = K(n.trackItemsMap), {
    trackItemIds: n.trackItemIds,
    trackItemsMap: n.trackItemsMap,
    tracks: n.tracks,
    duration: n.duration,
    structure: n.structure,
    transitionIds: n.transitionIds,
    transitionsMap: n.transitionsMap
  };
}
function kt(t, r, e = {}) {
  const n = r.map((c) => c.id), i = [], o = {};
  if (r.forEach((c) => {
    i.push(c.id), o[c.id] = c;
  }), e.targetTrackIndex !== void 0 || e.targetTrackId) {
    const c = e.targetTrackIndex || 0, u = e.targetTrackId;
    let p = t.tracks[c];
    if (u && (p = t.tracks.find((h) => h.id === u)), !p)
      throw new Error("Target track not found");
    p.items.push(...i);
  } else {
    const c = {
      id: fs(),
      accepts: Object.keys(Wi()),
      type: r[0].type,
      items: n,
      magnetic: false,
      static: false
    };
    t.tracks.splice(0, 0, c);
  }
  return t.trackItemsMap = {
    ...t.trackItemsMap,
    ...o
  }, t.trackItemIds = [
    ...t.trackItemIds,
    ...i
  ], t;
}
async function la(t, r, e = {}) {
  const n = C(t), i = [
    Ss(r, {
      size: n.size,
      scaleMode: e.scaleMode,
      scaleAspectRatio: e.scaleAspectRatio
    })
  ], o = await Promise.all(i), c = o.map((h) => h.id), u = kt(n, o, e), p = u.tracks.filter((h) => h.magnetic);
  return nt(p, u.trackItemsMap, c), u.duration = K(u.trackItemsMap), {
    trackItemIds: u.trackItemIds,
    trackItemsMap: u.trackItemsMap,
    tracks: u.tracks,
    duration: u.duration
  };
}
async function da(t, r, e = {}) {
  const n = C(t), i = [ks(r)], o = await Promise.all(i), c = o.map((h) => h.id), u = kt(n, o, e);
  u.duration = K(u.trackItemsMap);
  const p = u.tracks.filter((h) => h.magnetic);
  return nt(p, u.trackItemsMap, c), {
    trackItemIds: u.trackItemIds,
    trackItemsMap: u.trackItemsMap,
    tracks: u.tracks,
    duration: u.duration
  };
}
async function fa(t, r, e = {}) {
  const n = C(t), i = [
    bs(r, {
      size: n.size,
      scaleMode: e.scaleMode,
      scaleAspectRatio: e.scaleAspectRatio
    })
  ], o = await Promise.all(i), c = o.map((h) => h.id), u = kt(n, o, e);
  u.duration = K(u.trackItemsMap);
  const p = u.tracks.filter((h) => h.magnetic);
  return nt(p, u.trackItemsMap, c), {
    trackItemIds: u.trackItemIds,
    trackItemsMap: u.trackItemsMap,
    tracks: u.tracks,
    duration: u.duration
  };
}
async function pa(t, r, e = {}) {
  const n = C(t), i = [
    Ts(r, {
      size: e.size
    })
  ], o = await Promise.all(i), c = o.map((h) => h.id), u = kt(n, o, e);
  u.duration = K(u.trackItemsMap);
  const p = u.tracks.filter((h) => h.magnetic);
  return nt(p, u.trackItemsMap, c), {
    trackItemIds: u.trackItemIds,
    trackItemsMap: u.trackItemsMap,
    tracks: u.tracks,
    duration: u.duration
  };
}
async function ha(t, r, e = {}) {
  const n = C(t), i = [
    ta(r, {
      size: n.size,
      scaleMode: e.scaleMode,
      scaleAspectRatio: e.scaleAspectRatio
    })
  ], o = await Promise.all(i), c = o.map((h) => h.id), u = kt(n, o, e);
  u.duration = K(u.trackItemsMap);
  const p = u.tracks.filter((h) => h.magnetic);
  return nt(p, u.trackItemsMap, c), {
    trackItemIds: u.trackItemIds,
    trackItemsMap: u.trackItemsMap,
    tracks: u.tracks,
    duration: u.duration
  };
}
async function ma(t, r, e = {}) {
  const n = C(t), i = [
    _s(r, {
      size: n.size,
      scaleMode: e.scaleMode,
      scaleAspectRatio: e.scaleAspectRatio
    })
  ], o = await Promise.all(i), c = o.map((h) => h.id), u = kt(n, o, e);
  u.duration = K(u.trackItemsMap);
  const p = u.tracks.filter((h) => h.magnetic);
  return nt(p, u.trackItemsMap, c), {
    trackItemIds: u.trackItemIds,
    trackItemsMap: u.trackItemsMap,
    tracks: u.tracks,
    duration: u.duration
  };
}
async function ga(t, r, e = {}) {
  const n = C(t), i = "composition", o = r.trackItemsMap, c = r.trackItemIds, u = r.tracks || [], { details: p, ...h } = await Qi(r, {
    size: n.size,
    scaleMode: e.scaleMode,
    scaleAspectRatio: e.scaleAspectRatio
  }), m = {
    id: h.id,
    items: c,
    transitions: [],
    tracks: u
  }, d = [{
    ...h,
    type: i,
    details: p
  }], b = kt(n, d, e);
  b.trackItemsMap = {
    ...b.trackItemsMap,
    ...o,
    [h.id]: {
      ...h,
      type: i,
      details: p
    }
  }, b.structure = [...b.structure, m], b.duration = K(b.trackItemsMap);
  const w = b.tracks.filter((k) => k.magnetic);
  return nt(w, b.trackItemsMap, [h.id]), {
    trackItemIds: b.trackItemIds,
    trackItemsMap: b.trackItemsMap,
    tracks: b.tracks,
    duration: b.duration,
    structure: b.structure
  };
}
async function Re(t, r, e = {}, n) {
  const i = C(t), o = (I) => I.display ? I.display : {
    from: 0,
    to: i.duration
  }, c = [];
  n === "progress-bar" && c.push(
    Ji(r, {
      size: i.size,
      scaleMode: e.scaleMode,
      scaleAspectRatio: e.scaleAspectRatio
    })
  ), n === "progress-frame" && c.push(
    qi(r, {
      size: i.size,
      scaleMode: e.scaleMode,
      scaleAspectRatio: e.scaleAspectRatio
    })
  ), n === "radial-audio-bars" && (r.display = o(r), c.push(
    Zi(r, {
      size: i.size,
      scaleMode: e.scaleMode,
      scaleAspectRatio: e.scaleAspectRatio
    })
  )), n === "lineal-audio-bars" && (r.display = o(r), c.push(
    mn(r, {
      size: i.size,
      scaleMode: e.scaleMode,
      scaleAspectRatio: e.scaleAspectRatio
    })
  )), n === "wave-audio-bars" && (r.display = o(r), c.push(
    mn(r, {
      size: i.size,
      scaleMode: e.scaleMode,
      scaleAspectRatio: e.scaleAspectRatio
    })
  )), n === "hill-audio-bars" && (r.display = o(r), c.push(
    mn(r, {
      size: i.size,
      scaleMode: e.scaleMode,
      scaleAspectRatio: e.scaleAspectRatio
    })
  ));
  const u = await Promise.all(c), p = u.map((I) => I.id), h = kt(i, u, e);
  h.duration = K(h.trackItemsMap);
  const m = h.tracks.filter((I) => I.magnetic);
  return nt(m, h.trackItemsMap, p), {
    trackItemIds: h.trackItemIds,
    trackItemsMap: h.trackItemsMap,
    tracks: h.tracks,
    duration: h.duration
  };
}
async function ya(t, r, e = {}) {
  const n = C(t), i = "template", o = r.trackItemsMap, c = r.trackItemIds, u = r.transitionsMap, p = r.transitionIds || [], h = r.tracks || [], m = r.structure || [], { details: I, ...d } = await vs(r, {
    size: n.size,
    scaleMode: e.scaleMode,
    scaleAspectRatio: e.scaleAspectRatio
  }), b = {
    id: d.id,
    items: c,
    transitions: p,
    tracks: h
  }, k = [{
    ...d,
    type: i,
    details: I
  }], S = kt(n, k, e);
  S.transitionIds = [
    ...S.transitionIds,
    ...p
  ], S.transitionsMap = {
    ...S.transitionsMap,
    ...u
  }, S.trackItemsMap = {
    ...S.trackItemsMap,
    ...o,
    [d.id]: {
      ...d,
      type: i,
      details: I
    }
  }, S.structure = [
    ...S.structure,
    b,
    ...m
  ], S.duration = K(S.trackItemsMap);
  const f = S.tracks.filter((y) => y.magnetic);
  return nt(f, S.trackItemsMap, [d.id]), {
    trackItemIds: S.trackItemIds,
    trackItemsMap: S.trackItemsMap,
    tracks: S.tracks,
    duration: S.duration,
    structure: S.structure,
    transitionsMap: S.transitionsMap
  };
}
async function Ia(t, r, e = {}) {
  const n = C(t), i = r.trackItems.map(
    (I) => ws(I, {
      size: e.size
    })
  ), o = await Promise.all(i), c = Ms(r.tracks, r.trackItems), u = [], p = {};
  if (o.forEach((I) => {
    const { details: d, ...b } = I;
    u.push(I.id), p[I.id] = b;
  }), Es(
    n.tracks,
    c
  ))
    n.tracks.forEach((I) => {
      c.forEach((d) => {
        I.id === d.id && (I.magnetic && nt(
          [I],
          n.trackItemsMap,
          u
        ), I.items.push(...u));
      });
    });
  else {
    const I = e.trackIndex || 0, d = Math.min(
      Math.max(I, 0),
      n.tracks.length
    );
    n.tracks.splice(d, 0, ...c);
  }
  n.trackItemsMap = {
    ...n.trackItemsMap,
    ...p
  }, n.trackItemIds = [
    ...n.trackItemIds,
    ...u
  ], n.duration = K(n.trackItemsMap);
  const m = n.tracks.filter((I) => I.magnetic);
  return nt(
    m,
    n.trackItemsMap,
    u
  ), {
    trackItemIds: n.trackItemIds,
    trackItemsMap: n.trackItemsMap,
    tracks: n.tracks,
    duration: n.duration
  };
}
async function ba(t, r) {
  const e = C(t), n = e.trackItemsMap[r.id], i = [];
  if (!n) return {};
  let o = n.animations || {};
  return r.animations.loop ? r.animations.loop.composition.forEach(
    (c) => {
      var u;
      (u = c.details) != null && u.fonts && i.push(...c.details.fonts);
    }
  ) : r.animations.in ? r.animations.in.composition.forEach(
    (c) => {
      var u;
      (u = c.details) != null && u.fonts && i.push(...c.details.fonts);
    }
  ) : r.animations.out && r.animations.out.composition.forEach(
    (c) => {
      var u;
      (u = c.details) != null && u.fonts && i.push(...c.details.fonts);
    }
  ), i.length > 0 && await er(i), o.in && r.animations.in ? o.in = r.animations.in : o.out && r.animations.out ? o.out = r.animations.out : o.loop && r.animations.loop ? o.loop = r.animations.loop : !o.out && r.animations.out ? o.out = r.animations.out : !o.in && r.animations.in ? o.in = r.animations.in : !o.loop && r.animations.loop ? o.loop = r.animations.loop : o = r.animations, n.animations = o, {
    trackItemsMap: e.trackItemsMap
  };
}
async function ka(t, r, e = {}) {
  const n = C(t), i = [
    ea(r, {
      size: n.size,
      scaleMode: e.scaleMode,
      scaleAspectRatio: e.scaleAspectRatio
    })
  ], o = await Promise.all(i), c = o.map((h) => h.id), u = kt(n, o, e);
  u.duration = K(u.trackItemsMap);
  const p = u.tracks.filter((h) => h.magnetic);
  return nt(p, u.trackItemsMap, c), {
    trackItemIds: u.trackItemIds,
    trackItemsMap: u.trackItemsMap,
    tracks: u.tracks,
    duration: u.duration
  };
}
function va(t) {
  const r = ir.pipe(
    or(({ key: f }) => f.startsWith(Xn))
  ), e = ir.pipe(
    or(({ key: f }) => f.startsWith(Pn))
  ), n = ir.pipe(
    or(({ key: f }) => f.startsWith(N))
  ), i = ir.pipe(
    or(({ key: f }) => f.startsWith(Q))
  ), o = ir.pipe(
    or(({ key: f }) => f.startsWith(Er))
  ), c = ir.pipe(
    or(({ key: f }) => f.startsWith(De))
  ), u = ir.pipe(
    or(({ key: f }) => f.startsWith(Wt))
  ), p = ir.pipe(
    or(({ key: f }) => f.startsWith(ds))
  ), h = r.subscribe(async (f) => {
    var y;
    if (f.key === Xn) {
      const { actions: v } = (y = f.value) == null ? void 0 : y.payload;
      v.forEach((_) => {
        sr(_.type, _.payload && { payload: _.payload });
      });
    }
  }), m = e.subscribe(async (f) => {
    var y, v;
    if (f.key === ni) {
      const _ = (y = f.value) == null ? void 0 : y.payload, A = await na(t.getState(), _);
      t.updateState(A, {
        kind: "design:load",
        updateHistory: false
      });
    }
    if (f.key === si) {
      const _ = (v = f.value) == null ? void 0 : v.payload;
      t.updateState(
        {
          size: _
        },
        {
          kind: "design:resize",
          updateHistory: false
        }
      );
    }
  }), I = o.subscribe((f) => {
    if (f.key === Ri) return t.undo();
    if (f.key === Di) return t.redo();
  }), d = p.subscribe((f) => {
    var y;
    if (f.key === zi) {
      const v = (y = f.value) == null ? void 0 : y.payload.scale;
      t.updateState(
        {
          scale: v
        },
        {
          kind: "update",
          updateHistory: false
        }
      );
    }
  }), b = i.subscribe(async (f) => {
    var y, v, _, A;
    if (f.key === Mi) {
      const E = ((y = f.value) == null ? void 0 : y.payload.trackItemIds) || [];
      t.updateState(
        { activeIds: E },
        {
          kind: "update",
          updateHistory: false
        }
      );
    }
    if (f.key === xi && sa(t.getState()), f.key === Ci) {
      const E = (v = f.value) == null ? void 0 : v.payload.trackItemIds, T = Ni(t.getState(), E);
      t.updateState(T, { updateHistory: true, kind: "remove" });
    }
    if (f.key === Oi) {
      const E = Yi(
        t.getState(),
        (_ = f.value) == null ? void 0 : _.payload.trackItemIds
      );
      t.updateState(E, {
        updateHistory: true,
        kind: "update"
      });
    }
    if (f.key === Pi) {
      const E = (A = f.value) == null ? void 0 : A.payload, T = await Gi(t.getState(), E);
      t.updateState(T, {
        updateHistory: true,
        kind: "update:details"
      });
    }
  }), w = n.subscribe(async (f) => {
    var H, P, V, x, F, tt, Bt, Gt, me, ge, ye, Ie, z, be, ke, st, Yt, $, Xt, ve, it, Kt, Vt, Ot, Ct, Jt, Pt, qt, Rt, Zt, _e, Se, vt, Dt, Qt, te, ct, _t, we, gt, St, zt, et, ee, re, Te, $t, wt;
    const y = C(t.getState()), v = ((P = (H = f.value) == null ? void 0 : H.options) == null ? void 0 : P.isSelected) || false, _ = (x = (V = f.value) == null ? void 0 : V.options) == null ? void 0 : x.scaleMode, A = (tt = (F = f.value) == null ? void 0 : F.options) == null ? void 0 : tt.scaleAspectRatio, E = (Gt = (Bt = f.value) == null ? void 0 : Bt.options) == null ? void 0 : Gt.trackIndex;
    let T = {};
    f.key === di ? T = await ba(y, (me = f.value) == null ? void 0 : me.payload) : f.key === hi ? T = await ua(y, (ge = f.value) == null ? void 0 : ge.payload, {
      trackIndex: E
    }) : f.key === fi ? T = await Ia(y, (ye = f.value) == null ? void 0 : ye.payload, {
      trackIndex: E
    }) : f.key === ii ? T = await pa(y, (Ie = f.value) == null ? void 0 : Ie.payload, {
      targetTrackIndex: E,
      targetTrackId: (z = f.value) == null ? void 0 : z.options.targetTrackId,
      size: y.size
    }) : f.key === pi ? T = await ya(y, (be = f.value) == null ? void 0 : be.payload, {
      scaleMode: _,
      scaleAspectRatio: A,
      targetTrackIndex: E,
      targetTrackId: (st = (ke = f.value) == null ? void 0 : ke.options) == null ? void 0 : st.targetTrackId
    }) : f.key === ui ? T = await ma(y, (Yt = f.value) == null ? void 0 : Yt.payload, {
      scaleMode: _,
      scaleAspectRatio: A,
      targetTrackIndex: E,
      targetTrackId: ($ = f.value) == null ? void 0 : $.options.targetTrackId
    }) : f.key === li ? T = await ha(y, (Xt = f.value) == null ? void 0 : Xt.payload, {
      scaleMode: _,
      scaleAspectRatio: A,
      targetTrackIndex: E,
      targetTrackId: (ve = f.value) == null ? void 0 : ve.options.targetTrackId
    }) : f.key === _i ? T = await ka(y, (it = f.value) == null ? void 0 : it.payload, {
      scaleMode: _,
      scaleAspectRatio: A,
      targetTrackIndex: E,
      targetTrackId: (Kt = f.value) == null ? void 0 : Kt.options.targetTrackId
    }) : f.key === ci ? T = await la(y, (Vt = f.value) == null ? void 0 : Vt.payload, {
      scaleMode: _,
      scaleAspectRatio: A,
      targetTrackIndex: E,
      targetTrackId: (Ot = f.value) == null ? void 0 : Ot.options.targetTrackId
    }) : f.key === oi ? T = await da(y, (Ct = f.value) == null ? void 0 : Ct.payload, {
      targetTrackIndex: E,
      targetTrackId: (Jt = f.value) == null ? void 0 : Jt.options.targetTrackId
    }) : f.key === ai ? T = await fa(y, (Pt = f.value) == null ? void 0 : Pt.payload, {
      scaleMode: _,
      scaleAspectRatio: A,
      targetTrackIndex: E,
      targetTrackId: (qt = f.value) == null ? void 0 : qt.options.targetTrackId
    }) : f.key === mi ? T = await ga(y, (Rt = f.value) == null ? void 0 : Rt.payload, {
      scaleMode: _,
      scaleAspectRatio: A,
      targetTrackIndex: E,
      targetTrackId: (Zt = f.value) == null ? void 0 : Zt.options.targetTrackId
    }) : f.key === gi ? T = await Re(
      y,
      (_e = f.value) == null ? void 0 : _e.payload,
      {
        targetTrackIndex: E,
        targetTrackId: (vt = (Se = f.value) == null ? void 0 : Se.options) == null ? void 0 : vt.targetTrackId
      },
      "progress-bar"
    ) : f.key === yi ? T = await Re(
      y,
      (Dt = f.value) == null ? void 0 : Dt.payload,
      {
        targetTrackIndex: E,
        targetTrackId: (te = (Qt = f.value) == null ? void 0 : Qt.options) == null ? void 0 : te.targetTrackId
      },
      "progress-frame"
    ) : f.key === Ii ? T = await Re(
      y,
      (ct = f.value) == null ? void 0 : ct.payload,
      {
        targetTrackIndex: E,
        targetTrackId: (we = (_t = f.value) == null ? void 0 : _t.options) == null ? void 0 : we.targetTrackId
      },
      "radial-audio-bars"
    ) : f.key === bi ? T = await Re(
      y,
      (gt = f.value) == null ? void 0 : gt.payload,
      {
        targetTrackIndex: E,
        targetTrackId: (zt = (St = f.value) == null ? void 0 : St.options) == null ? void 0 : zt.targetTrackId
      },
      "lineal-audio-bars"
    ) : f.key === ki ? T = await Re(
      y,
      (et = f.value) == null ? void 0 : et.payload,
      {
        targetTrackIndex: E,
        targetTrackId: (re = (ee = f.value) == null ? void 0 : ee.options) == null ? void 0 : re.targetTrackId
      },
      "wave-audio-bars"
    ) : f.key === vi && (T = await Re(
      y,
      (Te = f.value) == null ? void 0 : Te.payload,
      {
        targetTrackIndex: E,
        targetTrackId: (wt = ($t = f.value) == null ? void 0 : $t.options) == null ? void 0 : wt.targetTrackId
      },
      "hill-audio-bars"
    )), v && T.trackItemIds && (T.activeIds = T.trackItemIds), t.updateState(T, {
      updateHistory: true,
      kind: "add"
    });
  }), k = c.subscribe(async (f) => {
    var y;
    if (f.key === Ei) {
      const v = (y = f.value) == null ? void 0 : y.options.time, _ = ia(t.getState(), v);
      Object.keys(_).length > 0 && t.updateState(_, {
        updateHistory: true,
        kind: "update"
      });
    }
    if (f.key === Ai) {
      const v = await Ui(t.getState());
      t.updateState(v, {
        updateHistory: true,
        kind: "update"
      });
    }
  }), S = u.subscribe(async (f) => {
    var y, v, _;
    if (f.key === Si) {
      const A = await aa(
        t.getState(),
        (y = f.value) == null ? void 0 : y.payload
      );
      t.updateState(A, {
        updateHistory: true,
        kind: "update:details"
      });
    }
    if (f.key === wi) {
      const A = await oa(
        t.getState(),
        (v = f.value) == null ? void 0 : v.payload
      );
      t.updateState(A, {
        updateHistory: true,
        kind: "update:details"
      });
    }
    if (f.key === Ti) {
      const A = ca(t.getState(), (_ = f.value) == null ? void 0 : _.payload);
      t.updateState(A, {
        updateHistory: true,
        kind: "update:details"
      });
    }
  });
  return {
    unsubscribe: () => {
      w.unsubscribe(), k.unsubscribe(), S.unsubscribe(), I.unsubscribe(), b.unsubscribe(), m.unsubscribe(), d.unsubscribe(), h.unsubscribe();
    }
  };
}
var _a = { Date: true, RegExp: true, String: true, Number: true };
function xs(t, r, e = { cyclesFix: true }, n = []) {
  var u, p;
  let i = [];
  const o = Array.isArray(t);
  for (const h in t) {
    const m = t[h], I = o ? +h : h;
    if (!(h in r)) {
      i.push({
        type: "REMOVE",
        path: [I],
        oldValue: t[h]
      });
      continue;
    }
    const d = r[h], b = typeof m == "object" && typeof d == "object" && Array.isArray(m) === Array.isArray(d);
    m && d && b && !_a[(p = (u = Object.getPrototypeOf(m)) == null ? void 0 : u.constructor) == null ? void 0 : p.name] && (!e.cyclesFix || !n.includes(m)) ? i.push.apply(i, xs(m, d, e, e.cyclesFix ? n.concat([m]) : []).map((w) => (w.path.unshift(I), w))) : m !== d && // treat NaN values as equivalent
    !(Number.isNaN(m) && Number.isNaN(d)) && !(b && (isNaN(m) ? m + "" == d + "" : +m == +d)) && i.push({
      path: [I],
      type: "CHANGE",
      value: d,
      oldValue: m
    });
  }
  const c = Array.isArray(r);
  for (const h in r)
    h in t || i.push({
      type: "CREATE",
      path: [c ? +h : h],
      value: r[h]
    });
  return i;
}
var zn = Symbol.for("immer-nothing");
var Ve = Symbol.for("immer-draftable");
var ut = Symbol.for("immer-state");
var Os = true ? [
  // All error codes, starting by 0:
  function(t) {
    return `The plugin for '${t}' has not been loaded into Immer. To enable the plugin, import and call \`enable${t}()\` when initializing your application.`;
  },
  function(t) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${t}'`;
  },
  "This object has been frozen and should not be mutated",
  function(t) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + t;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(t) {
    return `'current' expects a draft, got: ${t}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(t) {
    return `'original' expects a draft, got: ${t}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function B(t, ...r) {
  if (true) {
    const e = Os[t], n = typeof e == "function" ? e.apply(null, r) : e;
    throw new Error(`[Immer] ${n}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${t}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var de = Object.getPrototypeOf;
function fe(t) {
  return !!t && !!t[ut];
}
function jt(t) {
  var r;
  return t ? Cs(t) || Array.isArray(t) || !!t[Ve] || !!((r = t.constructor) != null && r[Ve]) || nr(t) || sr2(t) : false;
}
var Sa = Object.prototype.constructor.toString();
function Cs(t) {
  if (!t || typeof t != "object")
    return false;
  const r = de(t);
  if (r === null)
    return true;
  const e = Object.hasOwnProperty.call(r, "constructor") && r.constructor;
  return e === Object ? true : typeof e == "function" && Function.toString.call(e) === Sa;
}
function Je(t, r) {
  pe(t) === 0 ? Reflect.ownKeys(t).forEach((e) => {
    r(e, t[e], t);
  }) : t.forEach((e, n) => r(n, e, t));
}
function pe(t) {
  const r = t[ut];
  return r ? r.type_ : Array.isArray(t) ? 1 : nr(t) ? 2 : sr2(t) ? 3 : 0;
}
function qe(t, r) {
  return pe(t) === 2 ? t.has(r) : Object.prototype.hasOwnProperty.call(t, r);
}
function gn(t, r) {
  return pe(t) === 2 ? t.get(r) : t[r];
}
function Ps(t, r, e) {
  const n = pe(t);
  n === 2 ? t.set(r, e) : n === 3 ? t.add(e) : t[r] = e;
}
function wa(t, r) {
  return t === r ? t !== 0 || 1 / t === 1 / r : t !== t && r !== r;
}
function nr(t) {
  return t instanceof Map;
}
function sr2(t) {
  return t instanceof Set;
}
function ue(t) {
  return t.copy_ || t.base_;
}
function Tn(t, r) {
  if (nr(t))
    return new Map(t);
  if (sr2(t))
    return new Set(t);
  if (Array.isArray(t))
    return Array.prototype.slice.call(t);
  const e = Cs(t);
  if (r === true || r === "class_only" && !e) {
    const n = Object.getOwnPropertyDescriptors(t);
    delete n[ut];
    let i = Reflect.ownKeys(n);
    for (let o = 0; o < i.length; o++) {
      const c = i[o], u = n[c];
      u.writable === false && (u.writable = true, u.configurable = true), (u.get || u.set) && (n[c] = {
        configurable: true,
        writable: true,
        // could live with !!desc.set as well here...
        enumerable: u.enumerable,
        value: t[c]
      });
    }
    return Object.create(de(t), n);
  } else {
    const n = de(t);
    if (n !== null && e)
      return { ...t };
    const i = Object.create(n);
    return Object.assign(i, t);
  }
}
function $n(t, r = false) {
  return Mr(t) || fe(t) || !jt(t) || (pe(t) > 1 && (t.set = t.add = t.clear = t.delete = Ta), Object.freeze(t), r && Object.entries(t).forEach(([e, n]) => $n(n, true))), t;
}
function Ta() {
  B(2);
}
function Mr(t) {
  return Object.isFrozen(t);
}
var An = {};
function he(t) {
  const r = An[t];
  return r || B(0, t), r;
}
function Aa(t, r) {
  An[t] || (An[t] = r);
}
var Ze;
function Rs() {
  return Ze;
}
function Ea(t, r) {
  return {
    drafts_: [],
    parent_: t,
    immer_: r,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function Jn(t, r) {
  r && (he("Patches"), t.patches_ = [], t.inversePatches_ = [], t.patchListener_ = r);
}
function En(t) {
  Mn(t), t.drafts_.forEach(Ma), t.drafts_ = null;
}
function Mn(t) {
  t === Ze && (Ze = t.parent_);
}
function qn(t) {
  return Ze = Ea(Ze, t);
}
function Ma(t) {
  const r = t[ut];
  r.type_ === 0 || r.type_ === 1 ? r.revoke_() : r.revoked_ = true;
}
function Zn(t, r) {
  r.unfinalizedDrafts_ = r.drafts_.length;
  const e = r.drafts_[0];
  return t !== void 0 && t !== e ? (e[ut].modified_ && (En(r), B(4)), jt(t) && (t = wr(r, t), r.parent_ || Tr(r, t)), r.patches_ && he("Patches").generateReplacementPatches_(
    e[ut].base_,
    t,
    r.patches_,
    r.inversePatches_
  )) : t = wr(r, e, []), En(r), r.patches_ && r.patchListener_(r.patches_, r.inversePatches_), t !== zn ? t : void 0;
}
function wr(t, r, e) {
  if (Mr(r))
    return r;
  const n = r[ut];
  if (!n)
    return Je(
      r,
      (i, o) => Qn(t, n, r, i, o, e)
    ), r;
  if (n.scope_ !== t)
    return r;
  if (!n.modified_)
    return Tr(t, n.base_, true), n.base_;
  if (!n.finalized_) {
    n.finalized_ = true, n.scope_.unfinalizedDrafts_--;
    const i = n.copy_;
    let o = i, c = false;
    n.type_ === 3 && (o = new Set(i), i.clear(), c = true), Je(
      o,
      (u, p) => Qn(t, n, i, u, p, e, c)
    ), Tr(t, i, false), e && t.patches_ && he("Patches").generatePatches_(
      n,
      e,
      t.patches_,
      t.inversePatches_
    );
  }
  return n.copy_;
}
function Qn(t, r, e, n, i, o, c) {
  if (i === e && B(5), fe(i)) {
    const u = o && r && r.type_ !== 3 && // Set objects are atomic since they have no keys.
    !qe(r.assigned_, n) ? o.concat(n) : void 0, p = wr(t, i, u);
    if (Ps(e, n, p), fe(p))
      t.canAutoFreeze_ = false;
    else
      return;
  } else c && e.add(i);
  if (jt(i) && !Mr(i)) {
    if (!t.immer_.autoFreeze_ && t.unfinalizedDrafts_ < 1)
      return;
    wr(t, i), (!r || !r.scope_.parent_) && typeof n != "symbol" && Object.prototype.propertyIsEnumerable.call(e, n) && Tr(t, i);
  }
}
function Tr(t, r, e = false) {
  !t.parent_ && t.immer_.autoFreeze_ && t.canAutoFreeze_ && $n(r, e);
}
function xa(t, r) {
  const e = Array.isArray(t), n = {
    type_: e ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: r ? r.scope_ : Rs(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: r,
    // The base state.
    base_: t,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let i = n, o = Fn;
  e && (i = [n], o = Qe);
  const { revoke: c, proxy: u } = Proxy.revocable(i, o);
  return n.draft_ = u, n.revoke_ = c, u;
}
var Fn = {
  get(t, r) {
    if (r === ut)
      return t;
    const e = ue(t);
    if (!qe(e, r))
      return Oa(t, e, r);
    const n = e[r];
    return t.finalized_ || !jt(n) ? n : n === yn(t.base_, r) ? (In(t), t.copy_[r] = On(n, t)) : n;
  },
  has(t, r) {
    return r in ue(t);
  },
  ownKeys(t) {
    return Reflect.ownKeys(ue(t));
  },
  set(t, r, e) {
    const n = Ds(ue(t), r);
    if (n != null && n.set)
      return n.set.call(t.draft_, e), true;
    if (!t.modified_) {
      const i = yn(ue(t), r), o = i == null ? void 0 : i[ut];
      if (o && o.base_ === e)
        return t.copy_[r] = e, t.assigned_[r] = false, true;
      if (wa(e, i) && (e !== void 0 || qe(t.base_, r)))
        return true;
      In(t), xn(t);
    }
    return t.copy_[r] === e && // special case: handle new props with value 'undefined'
    (e !== void 0 || r in t.copy_) || // special case: NaN
    Number.isNaN(e) && Number.isNaN(t.copy_[r]) || (t.copy_[r] = e, t.assigned_[r] = true), true;
  },
  deleteProperty(t, r) {
    return yn(t.base_, r) !== void 0 || r in t.base_ ? (t.assigned_[r] = false, In(t), xn(t)) : delete t.assigned_[r], t.copy_ && delete t.copy_[r], true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(t, r) {
    const e = ue(t), n = Reflect.getOwnPropertyDescriptor(e, r);
    return n && {
      writable: true,
      configurable: t.type_ !== 1 || r !== "length",
      enumerable: n.enumerable,
      value: e[r]
    };
  },
  defineProperty() {
    B(11);
  },
  getPrototypeOf(t) {
    return de(t.base_);
  },
  setPrototypeOf() {
    B(12);
  }
};
var Qe = {};
Je(Fn, (t, r) => {
  Qe[t] = function() {
    return arguments[0] = arguments[0][0], r.apply(this, arguments);
  };
});
Qe.deleteProperty = function(t, r) {
  return isNaN(parseInt(r)) && B(13), Qe.set.call(this, t, r, void 0);
};
Qe.set = function(t, r, e) {
  return r !== "length" && isNaN(parseInt(r)) && B(14), Fn.set.call(this, t[0], r, e, t[0]);
};
function yn(t, r) {
  const e = t[ut];
  return (e ? ue(e) : t)[r];
}
function Oa(t, r, e) {
  var i;
  const n = Ds(r, e);
  return n ? "value" in n ? n.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (i = n.get) == null ? void 0 : i.call(t.draft_)
  ) : void 0;
}
function Ds(t, r) {
  if (!(r in t))
    return;
  let e = de(t);
  for (; e; ) {
    const n = Object.getOwnPropertyDescriptor(e, r);
    if (n)
      return n;
    e = de(e);
  }
}
function xn(t) {
  t.modified_ || (t.modified_ = true, t.parent_ && xn(t.parent_));
}
function In(t) {
  t.copy_ || (t.copy_ = Tn(
    t.base_,
    t.scope_.immer_.useStrictShallowCopy_
  ));
}
var Ca = class {
  constructor(t) {
    this.autoFreeze_ = true, this.useStrictShallowCopy_ = false, this.produce = (r, e, n) => {
      if (typeof r == "function" && typeof e != "function") {
        const o = e;
        e = r;
        const c = this;
        return function(p = o, ...h) {
          return c.produce(p, (m) => e.call(this, m, ...h));
        };
      }
      typeof e != "function" && B(6), n !== void 0 && typeof n != "function" && B(7);
      let i;
      if (jt(r)) {
        const o = qn(this), c = On(r, void 0);
        let u = true;
        try {
          i = e(c), u = false;
        } finally {
          u ? En(o) : Mn(o);
        }
        return Jn(o, n), Zn(i, o);
      } else if (!r || typeof r != "object") {
        if (i = e(r), i === void 0 && (i = r), i === zn && (i = void 0), this.autoFreeze_ && $n(i, true), n) {
          const o = [], c = [];
          he("Patches").generateReplacementPatches_(r, i, o, c), n(o, c);
        }
        return i;
      } else
        B(1, r);
    }, this.produceWithPatches = (r, e) => {
      if (typeof r == "function")
        return (c, ...u) => this.produceWithPatches(c, (p) => r(p, ...u));
      let n, i;
      return [this.produce(r, e, (c, u) => {
        n = c, i = u;
      }), n, i];
    }, typeof (t == null ? void 0 : t.autoFreeze) == "boolean" && this.setAutoFreeze(t.autoFreeze), typeof (t == null ? void 0 : t.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(t.useStrictShallowCopy);
  }
  createDraft(t) {
    jt(t) || B(8), fe(t) && (t = Pa(t));
    const r = qn(this), e = On(t, void 0);
    return e[ut].isManual_ = true, Mn(r), e;
  }
  finishDraft(t, r) {
    const e = t && t[ut];
    (!e || !e.isManual_) && B(9);
    const { scope_: n } = e;
    return Jn(n, r), Zn(void 0, n);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(t) {
    this.autoFreeze_ = t;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(t) {
    this.useStrictShallowCopy_ = t;
  }
  applyPatches(t, r) {
    let e;
    for (e = r.length - 1; e >= 0; e--) {
      const i = r[e];
      if (i.path.length === 0 && i.op === "replace") {
        t = i.value;
        break;
      }
    }
    e > -1 && (r = r.slice(e + 1));
    const n = he("Patches").applyPatches_;
    return fe(t) ? n(t, r) : this.produce(
      t,
      (i) => n(i, r)
    );
  }
};
function On(t, r) {
  const e = nr(t) ? he("MapSet").proxyMap_(t, r) : sr2(t) ? he("MapSet").proxySet_(t, r) : xa(t, r);
  return (r ? r.scope_ : Rs()).drafts_.push(e), e;
}
function Pa(t) {
  return fe(t) || B(10, t), zs(t);
}
function zs(t) {
  if (!jt(t) || Mr(t))
    return t;
  const r = t[ut];
  let e;
  if (r) {
    if (!r.modified_)
      return r.base_;
    r.finalized_ = true, e = Tn(t, r.scope_.immer_.useStrictShallowCopy_);
  } else
    e = Tn(t, true);
  return Je(e, (n, i) => {
    Ps(e, n, zs(i));
  }), r && (r.finalized_ = false), e;
}
function ts() {
  Os.push(
    'Sets cannot have "replace" patches.',
    function(d) {
      return "Unsupported patch operation: " + d;
    },
    function(d) {
      return "Cannot apply patch, path doesn't resolve: " + d;
    },
    "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
  );
  const r = "replace", e = "add", n = "remove";
  function i(d, b, w, k) {
    switch (d.type_) {
      case 0:
      case 2:
        return c(
          d,
          b,
          w,
          k
        );
      case 1:
        return o(d, b, w, k);
      case 3:
        return u(
          d,
          b,
          w,
          k
        );
    }
  }
  function o(d, b, w, k) {
    let { base_: S, assigned_: f } = d, y = d.copy_;
    y.length < S.length && ([S, y] = [y, S], [w, k] = [k, w]);
    for (let v = 0; v < S.length; v++)
      if (f[v] && y[v] !== S[v]) {
        const _ = b.concat([v]);
        w.push({
          op: r,
          path: _,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: I(y[v])
        }), k.push({
          op: r,
          path: _,
          value: I(S[v])
        });
      }
    for (let v = S.length; v < y.length; v++) {
      const _ = b.concat([v]);
      w.push({
        op: e,
        path: _,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: I(y[v])
      });
    }
    for (let v = y.length - 1; S.length <= v; --v) {
      const _ = b.concat([v]);
      k.push({
        op: n,
        path: _
      });
    }
  }
  function c(d, b, w, k) {
    const { base_: S, copy_: f } = d;
    Je(d.assigned_, (y, v) => {
      const _ = gn(S, y), A = gn(f, y), E = v ? qe(S, y) ? r : e : n;
      if (_ === A && E === r)
        return;
      const T = b.concat(y);
      w.push(E === n ? { op: E, path: T } : { op: E, path: T, value: A }), k.push(
        E === e ? { op: n, path: T } : E === n ? { op: e, path: T, value: I(_) } : { op: r, path: T, value: I(_) }
      );
    });
  }
  function u(d, b, w, k) {
    let { base_: S, copy_: f } = d, y = 0;
    S.forEach((v) => {
      if (!f.has(v)) {
        const _ = b.concat([y]);
        w.push({
          op: n,
          path: _,
          value: v
        }), k.unshift({
          op: e,
          path: _,
          value: v
        });
      }
      y++;
    }), y = 0, f.forEach((v) => {
      if (!S.has(v)) {
        const _ = b.concat([y]);
        w.push({
          op: e,
          path: _,
          value: v
        }), k.unshift({
          op: n,
          path: _,
          value: v
        });
      }
      y++;
    });
  }
  function p(d, b, w, k) {
    w.push({
      op: r,
      path: [],
      value: b === zn ? void 0 : b
    }), k.push({
      op: r,
      path: [],
      value: d
    });
  }
  function h(d, b) {
    return b.forEach((w) => {
      const { path: k, op: S } = w;
      let f = d;
      for (let A = 0; A < k.length - 1; A++) {
        const E = pe(f);
        let T = k[A];
        typeof T != "string" && typeof T != "number" && (T = "" + T), (E === 0 || E === 1) && (T === "__proto__" || T === "constructor") && B(19), typeof f == "function" && T === "prototype" && B(19), f = gn(f, T), typeof f != "object" && B(18, k.join("/"));
      }
      const y = pe(f), v = m(w.value), _ = k[k.length - 1];
      switch (S) {
        case r:
          switch (y) {
            case 2:
              return f.set(_, v);
            case 3:
              B(16);
            default:
              return f[_] = v;
          }
        case e:
          switch (y) {
            case 1:
              return _ === "-" ? f.push(v) : f.splice(_, 0, v);
            case 2:
              return f.set(_, v);
            case 3:
              return f.add(v);
            default:
              return f[_] = v;
          }
        case n:
          switch (y) {
            case 1:
              return f.splice(_, 1);
            case 2:
              return f.delete(_);
            case 3:
              return f.delete(w.value);
            default:
              return delete f[_];
          }
        default:
          B(17, S);
      }
    }), d;
  }
  function m(d) {
    if (!jt(d))
      return d;
    if (Array.isArray(d))
      return d.map(m);
    if (nr(d))
      return new Map(
        Array.from(d.entries()).map(([w, k]) => [w, m(k)])
      );
    if (sr2(d))
      return new Set(Array.from(d).map(m));
    const b = Object.create(de(d));
    for (const w in d)
      b[w] = m(d[w]);
    return qe(d, Ve) && (b[Ve] = d[Ve]), b;
  }
  function I(d) {
    return fe(d) ? m(d) : d;
  }
  Aa("Patches", {
    applyPatches_: h,
    generatePatches_: i,
    generateReplacementPatches_: p
  });
}
var lt = new Ca();
var Ra = lt.produce;
lt.produceWithPatches.bind(
  lt
);
lt.setAutoFreeze.bind(lt);
lt.setUseStrictShallowCopy.bind(lt);
var Da = lt.applyPatches.bind(lt);
lt.createDraft.bind(lt);
lt.finishDraft.bind(lt);
var za = 9007199254740991;
var $a = "[object Arguments]";
var Fa = "[object Function]";
var La = "[object GeneratorFunction]";
var Na = "[object Symbol]";
var Ha = typeof dt == "object" && dt && dt.Object === Object && dt;
var Ua = typeof self == "object" && self && self.Object === Object && self;
var ja = Ha || Ua || Function("return this")();
function Wa(t, r, e) {
  switch (e.length) {
    case 0:
      return t.call(r);
    case 1:
      return t.call(r, e[0]);
    case 2:
      return t.call(r, e[0], e[1]);
    case 3:
      return t.call(r, e[0], e[1], e[2]);
  }
  return t.apply(r, e);
}
function Ba(t, r) {
  for (var e = -1, n = t ? t.length : 0, i = Array(n); ++e < n; )
    i[e] = r(t[e], e, t);
  return i;
}
function Ga(t, r) {
  for (var e = -1, n = r.length, i = t.length; ++e < n; )
    t[i + e] = r[e];
  return t;
}
var Ln = Object.prototype;
var Ya = Ln.hasOwnProperty;
var Nn = Ln.toString;
var es = ja.Symbol;
var Xa = Ln.propertyIsEnumerable;
var rs = es ? es.isConcatSpreadable : void 0;
var ns = Math.max;
function Ka(t, r, e, n, i) {
  var o = -1, c = t.length;
  for (e || (e = Za), i || (i = []); ++o < c; ) {
    var u = t[o];
    e(u) ? Ga(i, u) : i[i.length] = u;
  }
  return i;
}
function Va(t, r) {
  return t = Object(t), Ja(t, r, function(e, n) {
    return n in t;
  });
}
function Ja(t, r, e) {
  for (var n = -1, i = r.length, o = {}; ++n < i; ) {
    var c = r[n], u = t[c];
    e(u, c) && (o[c] = u);
  }
  return o;
}
function qa(t, r) {
  return r = ns(r === void 0 ? t.length - 1 : r, 0), function() {
    for (var e = arguments, n = -1, i = ns(e.length - r, 0), o = Array(i); ++n < i; )
      o[n] = e[r + n];
    n = -1;
    for (var c = Array(r + 1); ++n < r; )
      c[n] = e[n];
    return c[r] = o, Wa(t, this, c);
  };
}
function Za(t) {
  return eo(t) || to(t) || !!(rs && t && t[rs]);
}
function Qa(t) {
  if (typeof t == "string" || oo(t))
    return t;
  var r = t + "";
  return r == "0" && 1 / t == -1 / 0 ? "-0" : r;
}
function to(t) {
  return no(t) && Ya.call(t, "callee") && (!Xa.call(t, "callee") || Nn.call(t) == $a);
}
var eo = Array.isArray;
function ro(t) {
  return t != null && io(t.length) && !so(t);
}
function no(t) {
  return $s(t) && ro(t);
}
function so(t) {
  var r = ao(t) ? Nn.call(t) : "";
  return r == Fa || r == La;
}
function io(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= za;
}
function ao(t) {
  var r = typeof t;
  return !!t && (r == "object" || r == "function");
}
function $s(t) {
  return !!t && typeof t == "object";
}
function oo(t) {
  return typeof t == "symbol" || $s(t) && Nn.call(t) == Na;
}
var co = qa(function(t, r) {
  return t == null ? {} : Va(t, Ba(Ka(r), Qa));
});
var uo = co;
var ss = Cn(uo);
var lo = {
  width: 1080,
  height: 1920
};
var fo = 30;
var po = {
  size: lo,
  fps: fo,
  tracks: [],
  trackItemIds: [],
  trackItemsMap: {},
  transitionIds: [],
  transitionsMap: {},
  scale: {
    // 1x distance (second 0 to second 5, 5 segments).
    index: 7,
    unit: 300,
    zoom: 1 / 300,
    segments: 5
  },
  duration: 0,
  activeIds: [],
  structure: [],
  background: {
    type: "color",
    value: "transparent"
  }
};
var is = [
  "tracks",
  "trackItemsMap",
  "transitionIds",
  "transitionsMap",
  "trackItemIds",
  "structure"
];
var jo = class {
  // Clean constructor with clear configuration interface
  constructor(r, e) {
    Nt(this, "stateSubject");
    Nt(this, "stateHistorySubject");
    Nt(this, "prevState");
    Nt(this, "background");
    Nt(this, "undos", []);
    Nt(this, "redos", []);
    Nt(this, "listener");
    const n = Object.assign(
      {},
      po,
      r,
      e != null && e.scale ? { scale: e.scale } : {}
    );
    this.stateSubject = new Yn(n), this.stateHistorySubject = new Yn({
      handleRedo: false,
      handleUndo: false
    }), this.background = n.background, this.prevState = n, (e != null && e.cors || e != null && e.acceptsMap) && ji({
      cors: e.cors,
      acceptsMap: e.acceptsMap
    }), this.initListeners();
  }
  initListeners() {
    va(this);
  }
  destroyListeners() {
    this.listener && this.listener.unsubscribe();
  }
  purge() {
    this.destroyListeners();
  }
  updateHistory(r, e) {
    const n = ss(r, is), i = ss(this.getState(), is), o = xs(i, n);
    o.length && (this.undos.push({ undos: o, type: e }), this.redos = []);
  }
  getStateHistory() {
    return this.stateHistorySubject.getValue();
  }
  subscribeHistory(r) {
    return this.stateHistorySubject.subscribe(r);
  }
  // Get the current state
  getState() {
    return this.stateSubject.getValue();
  }
  // Subscribe to state changes
  subscribe(r) {
    return this.stateSubject.subscribe(r);
  }
  // Update the state, emitting only if the part of the state has changed
  updateState(r, e = { updateHistory: false }) {
    const n = this.getState(), i = {
      ...C(n),
      ...C(r)
    };
    W(n, i) || (e.updateHistory && this.updateHistory(i, e.kind), this.prevState = n, this.stateSubject.next(i));
  }
  // emit changes for design size
  subscribeToUpdateStateDetails(r) {
    return this.stateSubject.asObservable().subscribe((e) => {
      (!W(e.size, this.prevState.size) || !W(e.background, this.prevState.background)) && r({
        size: e.size,
        background: e.background
      });
    });
  }
  // Selectively subscribe to scale changes
  subscribeToScale(r) {
    return this.stateSubject.asObservable().subscribe((e) => {
      W(e.scale, this.prevState.scale) || r({ scale: e.scale });
    });
  }
  // Selectively subscribe to fps changes
  subscribeToFps(r) {
    return this.stateSubject.asObservable().subscribe((e) => {
      e.fps !== this.prevState.fps && r({ fps: e.fps });
    });
  }
  subscribeToUpdateTrackItem(r) {
    return this.stateSubject.asObservable().subscribe((e) => {
      W(e.trackItemsMap, this.prevState.trackItemsMap) || r({ trackItemsMap: e.trackItemsMap });
    });
  }
  subscribeToUpdateAnimations(r) {
    return this.stateSubject.asObservable().subscribe((e) => {
      const n = Object.keys(e.trackItemsMap).filter(
        (i) => {
          const o = this.prevState.trackItemsMap[i], c = e.trackItemsMap[i];
          return o && c && !W(o.animations, c.animations);
        }
      );
      r({ trackItemsMap: e.trackItemsMap, changedAnimationIds: n });
    });
  }
  subscribeToUpdateTrackItemTiming(r) {
    return this.stateSubject.asObservable().subscribe((e) => {
      if (!W(e.trackItemsMap, this.prevState.trackItemsMap)) {
        const n = Object.keys(e.trackItemsMap).filter((o) => {
          const c = this.prevState.trackItemsMap[o], u = e.trackItemsMap[o];
          return c && u && !W(c.trim, u.trim);
        }), i = Object.keys(e.trackItemsMap).filter(
          (o) => {
            const c = this.prevState.trackItemsMap[o], u = e.trackItemsMap[o];
            return c && u && !W(c.display, u.display);
          }
        );
        r({
          trackItemsMap: e.trackItemsMap,
          changedTrimIds: n.length > 0 ? n : void 0,
          changedDisplayIds: i.length > 0 ? i : void 0
        });
      }
    });
  }
  subscribeToUpdateItemDetails(r) {
    return this.stateSubject.asObservable().subscribe((e) => {
      Object.keys(e.trackItemsMap).some((i) => {
        const o = this.prevState.trackItemsMap[i], c = e.trackItemsMap[i];
        return o && c && !W(o.details, c.details);
      }) && r({ trackItemsMap: e.trackItemsMap });
    });
  }
  // Selectively subscribe to duration changes
  subscribeToDuration(r) {
    return this.stateSubject.asObservable().subscribe((e) => {
      e.duration !== this.prevState.duration && r({ duration: e.duration });
    });
  }
  subscribeToHistory(r) {
    return this.stateHistorySubject.asObservable().subscribe((e) => {
      if (e.handleRedo) {
        const n = this.undos[this.undos.length - 1].type;
        r({ ...this.getState(), type: n }), this.stateHistorySubject.next({ handleRedo: false, handleUndo: false });
      }
      if (e.handleUndo) {
        const n = this.redos[this.redos.length - 1].type;
        r({ ...this.getState(), type: n }), this.stateHistorySubject.next({ handleRedo: false, handleUndo: false });
      }
    });
  }
  subscribeToAddOrRemoveItems(r) {
    return this.stateSubject.asObservable().subscribe((e) => {
      const n = [...e.trackItemIds].sort(), i = [...this.prevState.trackItemIds].sort(), o = [...e.transitionIds].sort(), c = [...this.prevState.transitionIds].sort();
      (!W(n, i) || !W(o, c)) && r({ trackItemIds: e.trackItemIds });
    });
  }
  // Selectively subscribe to activeIds changes
  subscribeToActiveIds(r) {
    return this.stateSubject.asObservable().subscribe((e) => {
      W(e.activeIds, this.prevState.activeIds) || r({ activeIds: e.activeIds });
    });
  }
  subscribeToTracks(r) {
    return this.stateSubject.asObservable().subscribe((e) => {
      const n = e.tracks, o = this.prevState.tracks.map((u) => u.id), c = n.filter(
        (u) => !o.includes(u.id)
      );
      c.length && r({
        tracks: e.tracks,
        changedTracks: c.map((u) => u.id)
      });
    });
  }
  // Selectively subscribe to multiple track-related properties
  subscribeToState(r) {
    return this.stateSubject.asObservable().subscribe((e) => {
      (!W(e.tracks, this.prevState.tracks) || !W(e.trackItemIds, this.prevState.trackItemIds) || !W(e.trackItemsMap, this.prevState.trackItemsMap) || !W(e.transitionIds, this.prevState.transitionIds) || !W(e.transitionsMap, this.prevState.transitionsMap) || !W(e.structure, this.prevState.structure)) && r({
        tracks: e.tracks,
        trackItemIds: e.trackItemIds,
        trackItemsMap: e.trackItemsMap,
        transitionIds: e.transitionIds,
        transitionsMap: e.transitionsMap,
        structure: e.structure
      });
    });
  }
  undo() {
    const r = this.undos.pop(), e = r == null ? void 0 : r.undos, n = r == null ? void 0 : r.type;
    if (!e || !n) return;
    ts();
    const {
      trackItemIds: i,
      tracks: o,
      transitionIds: c,
      transitionsMap: u,
      trackItemsMap: p,
      structure: h
    } = this.getState(), m = C({
      trackItemIds: i,
      tracks: o,
      transitionIds: c,
      transitionsMap: u,
      trackItemsMap: p,
      structure: h
    }), I = [], d = [], b = [], w = [], k = [], S = [];
    e.forEach((x) => {
      let F;
      const tt = x.path.slice(1);
      x.type === "CREATE" ? F = {
        path: tt,
        op: "remove",
        value: x.value
      } : x.type === "CHANGE" ? F = {
        path: tt,
        op: "replace",
        value: x.oldValue
      } : F = {
        path: tt,
        op: "add",
        value: x.oldValue
      }, x.path.includes("trackItemIds") ? b.push(F) : x.path.includes("transitionIds") ? d.push(F) : x.path.includes("trackItemsMap") ? k.push(F) : x.path.includes("transitionsMap") ? w.push(F) : x.path.includes("tracks") ? I.push(F) : x.path.includes("structure") && S.push(F);
    });
    const f = this.applyPatch(
      m.tracks,
      I
    ), y = this.applyPatch(
      m.transitionIds,
      d
    ), v = this.applyPatch(
      m.trackItemIds,
      b
    ), _ = this.applyPatch(
      m.transitionsMap,
      w
    ), A = this.applyPatch(
      m.trackItemsMap,
      k
    ), E = this.applyPatch(
      m.structure,
      S
    ), T = C({
      tracks: f,
      transitionIds: y,
      trackItemIds: v,
      transitionsMap: _,
      trackItemsMap: A,
      structure: E
    }), H = C(this.getState()), P = { ...H, ...T };
    this.prevState = H, this.redos.push({ redos: e, type: n });
    const V = K(P.trackItemsMap);
    this.stateSubject.next({ ...P, duration: V }), this.stateHistorySubject.next({ handleRedo: false, handleUndo: true }), this.updateState(P, { updateHistory: false });
  }
  applyPatch(r, e) {
    return e.reverse().reduce((n, i) => Ra(n, (o) => {
      Da(o, [i]);
    }), r);
  }
  redo() {
    const r = this.redos.pop(), e = r == null ? void 0 : r.redos, n = r == null ? void 0 : r.type;
    if (!e || !n) return;
    ts();
    const {
      trackItemIds: i,
      tracks: o,
      transitionIds: c,
      transitionsMap: u,
      trackItemsMap: p,
      structure: h
    } = this.getState(), m = C({
      trackItemIds: i,
      tracks: o,
      transitionIds: c,
      transitionsMap: u,
      trackItemsMap: p,
      structure: h
    }), I = [], d = [], b = [], w = [], k = [], S = [];
    e.forEach((x) => {
      let F;
      const tt = x.path.slice(1);
      x.type === "CREATE" ? F = {
        path: tt,
        op: "add",
        value: x.value
      } : x.type === "CHANGE" ? F = {
        path: tt,
        op: "replace",
        value: x.value
      } : F = {
        path: tt,
        op: "remove",
        value: x.oldValue
      }, x.path.includes("trackItemIds") ? b.push(F) : x.path.includes("transitionIds") ? d.push(F) : x.path.includes("trackItemsMap") ? k.push(F) : x.path.includes("transitionsMap") ? w.push(F) : x.path.includes("structure") ? S.push(F) : I.push(F);
    });
    const f = this.applyPatch(
      m.tracks,
      I
    ), y = this.applyPatch(
      m.transitionIds,
      d
    ), v = this.applyPatch(
      m.trackItemIds,
      b
    ), _ = this.applyPatch(
      m.transitionsMap,
      w
    ), A = this.applyPatch(
      m.trackItemsMap,
      k
    ), E = this.applyPatch(
      m.structure,
      S
    ), T = C({
      tracks: f,
      transitionIds: y,
      trackItemIds: v,
      transitionsMap: _,
      trackItemsMap: A,
      structure: E
    }), H = C(this.getState()), P = { ...H, ...T };
    this.prevState = H, this.undos.push({ undos: e, type: n });
    const V = K(P.trackItemsMap);
    this.stateSubject.next({ ...P, duration: V }), this.stateHistorySubject.next({ handleRedo: true, handleUndo: false }), this.updateState(P, { updateHistory: false });
  }
  toJSON() {
    const {
      fps: r,
      tracks: e,
      size: n,
      trackItemIds: i,
      transitionsMap: o,
      trackItemsMap: c,
      transitionIds: u
    } = this.getState();
    return {
      fps: r,
      tracks: e,
      size: n,
      trackItemIds: i,
      transitionsMap: o,
      trackItemsMap: c,
      transitionIds: u
    };
  }
};
export {
  Oo as ACTIVE_CLONE,
  xo as ACTIVE_DELETE,
  Ai as ACTIVE_PASTE,
  De as ACTIVE_PREFIX,
  Mo as ACTIVE_SET,
  Ei as ACTIVE_SPLIT,
  di as ADD_ANIMATION,
  oi as ADD_AUDIO,
  fi as ADD_CAPTIONS,
  mi as ADD_COMPOSITION,
  vi as ADD_HILL_AUDIO_BARS,
  ui as ADD_ILLUSTRATION,
  ci as ADD_IMAGE,
  hi as ADD_ITEMS,
  bi as ADD_LINEAL_AUDIO_BARS,
  vo as ADD_MASK,
  ko as ADD_PLACEHOLDER,
  N as ADD_PREFIX,
  gi as ADD_PROGRESS_BAR,
  yi as ADD_PROGRESS_FRAME,
  Ii as ADD_RADIAL_AUDIO_BARS,
  _i as ADD_RECT,
  li as ADD_SHAPE,
  go as ADD_SUFFIX,
  pi as ADD_TEMPLATE,
  ii as ADD_TEXT,
  _o as ADD_TRANSITION,
  ai as ADD_VIDEO,
  ki as ADD_WAVE_AUDIO_BARS,
  ri as BULK_PREFIX,
  Ao as DELETE_TEMPLATE_ITEM,
  ni as DESIGN_LOAD,
  Pn as DESIGN_PREFIX,
  si as DESIGN_RESIZE,
  Ti as EDIT_BACKGROUND_EDITOR,
  Xn as EDIT_BULK,
  Si as EDIT_OBJECT,
  Wt as EDIT_PREFIX,
  wo as EDIT_SHAPE,
  To as EDIT_TEMPLATE_ITEM,
  So as EDIT_TEXT,
  Eo as ENTER_EDIT_MODE,
  Er as HISTORY_PREFIX,
  Di as HISTORY_REDO,
  Uo as HISTORY_RESET,
  Ri as HISTORY_UNDO,
  Oi as LAYER_CLONE,
  xi as LAYER_COPY,
  Ho as LAYER_CUT,
  Ci as LAYER_DELETE,
  Fo as LAYER_EDITING_NAME,
  Po as LAYER_HIDDEN,
  Co as LAYER_LOCKED,
  Ro as LAYER_MOVE,
  Lo as LAYER_PASTE,
  Q as LAYER_PREFIX,
  $o as LAYER_RENAME,
  Pi as LAYER_REPLACE,
  Mi as LAYER_SELECT,
  Do as LAYER_SELECTION,
  zo as LAYER_SEND_TO,
  No as LAYER_SPLIT,
  wi as REPLACE_MEDIA,
  bo as STATE_CHANGED,
  ei as STATE_PREFIX,
  zi as TIMELINE_SCALE_CHANGED,
  ds as TIMELINE_SCALE_PREFIX,
  yo as TRACKS_CHANGED,
  Io as TRACK_ITEMS_CHANGED,
  ti as TRACK_ITEMS_PREFIX,
  Qs as TRACK_PREFIX,
  jo as default,
  Wi as getAcceptsMap
};
//# sourceMappingURL=@designcombo_state.js.map
