import {
  require_jsx_runtime
} from "./chunk-U3R7WRSZ.js";
import {
  require_react
} from "./chunk-XO35FAC6.js";
import {
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/.pnpm/@interactify+toolkit@1.0.0/node_modules/@interactify/toolkit/dist/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var ys = __toESM(require_react());
var import_react = __toESM(require_react());
var ia = Object.defineProperty;
var aa = (e, n, t) => n in e ? ia(e, n, { enumerable: true, configurable: true, writable: true, value: t }) : e[n] = t;
var b = (e, n, t) => aa(e, typeof n != "symbol" ? n + "" : n, t);
var ha = "function";
var da = "object";
var pa = "string";
var ga = "number";
var co = "undefined";
var lo = typeof window !== co;
var ma = [
  { open: "(", close: ")" },
  { open: '"', close: '"' },
  { open: "'", close: "'" },
  { open: '\\"', close: '\\"' },
  { open: "\\'", close: "\\'" }
];
var ht = 1e-7;
var sn = {
  cm: (e) => e * 96 / 2.54,
  mm: (e) => e * 96 / 254,
  in: (e) => e * 96,
  pt: (e) => e * 96 / 72,
  pc: (e) => e * 96 / 6,
  "%": (e, n) => e * n / 100,
  vw: (e, n = window.innerWidth) => e / 100 * n,
  vh: (e, n = window.innerHeight) => e / 100 * n,
  vmax: (e, n = Math.max(window.innerWidth, window.innerHeight)) => e / 100 * n,
  vmin: (e, n = Math.min(window.innerWidth, window.innerHeight)) => e / 100 * n
};
function hr(e) {
  const n = Sa(e), t = ft(n, e[0]), s = ft(n, e[1]);
  return t < s && s - t < Math.PI || t > s && s - t < -Math.PI ? 1 : -1;
}
function Sa(e) {
  return [0, 1].map((n) => cs(e.map((t) => t[n])));
}
function ft(e, n) {
  const t = n[0] - e[0], s = n[1] - e[1], r = Math.atan2(s, t);
  return r >= 0 ? r : r + Math.PI * 2;
}
function cs(e) {
  const n = e.length;
  let t = 0;
  for (let s = n - 1; s >= 0; --s)
    t += e[s];
  return n ? t / n : 0;
}
function Nt(e, n) {
  return Math.sqrt(
    Math.pow((n ? n[0] : 0) - e[0], 2) + Math.pow((n ? n[1] : 0) - e[1], 2)
  );
}
function Ut(e, n, t = -1) {
  const s = e.length;
  for (let r = 0; r < s; ++r)
    if (n(e[r], r, e))
      return r;
  return t;
}
function U(e, n) {
  if (!n)
    return e;
  const t = 1 / n;
  return Math.round(e / n) / t;
}
function dr(e, n) {
  return e.forEach((t, s) => {
    e[s] = U(e[s], n);
  }), e;
}
function yt(e, n, t) {
  const s = Ut(e, n);
  return s > -1 ? e[s] : t;
}
function Dt(e) {
  return e && typeof e === da;
}
function Yt(e) {
  return typeof e === pa;
}
function ct(e) {
  return Array.isArray(e);
}
function Dn(e) {
  return e.replace(
    /[\s-_]+([^\s-_])/g,
    (n, t) => t.toUpperCase()
  );
}
function xa(e, n = "-") {
  return e.replace(
    /([a-z])([A-Z])/g,
    (t, s, r) => `${s}${n}${r.toLowerCase()}`
  );
}
function Gn(e) {
  return typeof e === ha;
}
function Ps(e) {
  return typeof e === co;
}
function je(e) {
  return typeof e === ga;
}
function va(e, n) {
  const t = e === "" || e == " ";
  return (n === "" || n == " ") && t || e === n;
}
function At(e, n, t) {
  return Math.max(n, Math.min(e, t));
}
function ce(e) {
  const n = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(e);
  if (!n)
    return { prefix: "", unit: "", value: NaN };
  const t = n[1], s = n[2], r = n[3];
  return { prefix: t, unit: r, value: parseFloat(s) };
}
function ae(e) {
  return Is(e, ",");
}
function uo(e) {
  const n = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(e);
  return !n || n.length < 4 ? {} : { prefix: n[1], value: n[2], suffix: n[3] };
}
function _s(e, n, t, s) {
  if (!s)
    return e.map((f, h) => At(f, n[h], t[h]));
  let [r, o] = e;
  const i = s === true ? r / o : s, [a, c] = pr(e, n, false, i), [l, u] = pr(e, t, true, i);
  return r < a || o < c ? (r = a, o = c) : (r > l || o > u) && (r = l, o = u), [r, o];
}
function pr(e, n, t, s = e[0] / e[1]) {
  return [
    [
      U(n[0], ht),
      U(n[0] / s, ht)
    ],
    [
      U(n[1] * s, ht),
      U(n[1], ht)
    ]
  ].filter(
    (r) => r.every((o, i) => {
      const a = n[i], c = U(a, ht);
      return t ? o <= a || o <= c : o >= a || o >= c;
    })
  )[0] || e;
}
function Be(e) {
  return Object.keys(e);
}
var Ea = (() => {
  const e = lo && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);
  return e ? e.bind(window) : (n) => {
    clearTimeout(n);
  };
})();
var fo = (() => {
  const e = Ue(), n = lo && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);
  return n ? n.bind(window) : (t) => {
    const s = Ue();
    return setTimeout(() => {
      t(s - e);
    }, 1e3 / 60);
  };
})();
function Ue() {
  return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();
}
function ho(e, n, t, s, r) {
  return Os(e, n, t) ? t : Ca(
    e,
    n,
    t + 1,
    s,
    r
  );
}
function Os(e, n, t) {
  if (!e.ignore)
    return null;
  const s = n.slice(Math.max(t - 3, 0), t + 3).join("");
  return new RegExp(e.ignore).exec(s);
}
function Ca(e, n, t, s, r) {
  for (let o = t; o < s; ++o) {
    const i = n[o].trim();
    if (i === e.close && !Os(e, n, o))
      return o;
    let a = o;
    const c = yt(
      r,
      ({ open: l }) => l === i
    );
    if (c && (a = ho(
      c,
      n,
      o,
      s,
      r
    )), a === -1)
      break;
    o = a;
  }
  return -1;
}
function Is(e, n) {
  const {
    separator: t = ",",
    isSeparateFirst: s,
    isSeparateOnlyOpenClose: r,
    isSeparateOpenClose: o = r,
    openCloseCharacters: i = ma
  } = Yt(n) ? {
    separator: n
  } : n, a = i.map(({ open: g, close: m }) => g === m ? g : `${g}|${m}`).join("|"), c = `(\\s*${t}\\s*|${a}|\\s+)`, l = new RegExp(c, "g"), u = e.split(l).filter((g) => g && g !== "undefined"), f = u.length, h = [];
  let d = [];
  function p() {
    return d.length ? (h.push(d.join("")), d = [], true) : false;
  }
  for (let g = 0; g < f; ++g) {
    const m = u[g].trim();
    let S = g;
    const v = yt(
      i,
      ({ open: C }) => C === m
    ), x = yt(
      i,
      ({ close: C }) => C === m
    );
    if (v) {
      if (S = ho(
        v,
        u,
        g,
        f,
        i
      ), S !== -1 && o) {
        if (p() && s || (h.push(u.slice(g, S + 1).join("")), g = S, s))
          break;
        continue;
      }
    } else if (x && !Os(x, u, g)) {
      const C = [...i];
      return C.splice(
        i.indexOf(x),
        1
      ), Is(e, {
        separator: t,
        isSeparateFirst: s,
        isSeparateOnlyOpenClose: r,
        isSeparateOpenClose: o,
        openCloseCharacters: C
      });
    } else if (va(m, t) && !r) {
      if (p(), s)
        break;
      continue;
    }
    S === -1 && (S = f - 1), d.push(u.slice(g, S + 1).join("")), g = S;
  }
  return d.length && h.push(d.join("")), h;
}
function Qt(e) {
  return Is(e, "");
}
function bn(e, n, t, s) {
  return (e * s + n * t) / (t + s);
}
function Q(e, n) {
  const { value: t, unit: s } = ce(e);
  if (Dt(n)) {
    const r = n[s];
    if (r) {
      if (Gn(r))
        return r(t);
      if (sn[s])
        return sn[s](t, r);
    }
  } else if (s === "%")
    return t * n / 100;
  return sn[s] ? sn[s](t) : t;
}
function Da(e) {
  return e.reduce((n, t) => n.concat(t), []);
}
function ba(e) {
  const n = [];
  for (let t = 0; t < e; ++t)
    n.push(t);
  return n;
}
function dt(e, n) {
  return e.classList ? e.classList.contains(n) : !!e.className.match(new RegExp(`(\\s|^)${n}(\\s|$)`));
}
function qt(e, n) {
  e.classList ? e.classList.add(n) : e.className += ` ${n}`;
}
function po(e, n) {
  if (e.classList)
    e.classList.remove(n);
  else {
    const t = new RegExp(`(\\s|^)${n}(\\s|$)`);
    e.className = e.className.replace(t, " ");
  }
}
function Rt(e) {
  return (e == null ? void 0 : e.ownerDocument) || document;
}
function Bs(e) {
  return Rt(e).documentElement;
}
function ne(e) {
  return Rt(e).body;
}
function go(e) {
  return e && "postMessage" in e && "blur" in e && "self" in e;
}
function le(e) {
  return Dt(e) && e.nodeName && e.nodeType && "parentNode" in e && "ownerDocument" in e;
}
function Mt(e) {
  var n;
  return ((n = e == null ? void 0 : e.ownerDocument) == null ? void 0 : n.defaultView) || window;
}
function it(e, n, t, s) {
  e.addEventListener(n, t, s);
}
function st(e, n, t, s) {
  e.removeEventListener(n, t, s);
}
var Ae = class {
  constructor() {
    b(this, "_events", {});
  }
  /**
   * Add a listener to the registered event.
   * @param - Name of the event to be added
   * @param - listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add listener in "a" event
   * emitter.on("a", () => {
   * });
   * // Add listeners
   * emitter.on({
   *  a: () => {},
   *  b: () => {},
   * });
   */
  on(n, t) {
    if (Dt(n))
      for (const s in n)
        this.on(s, n[s]);
    else
      this._addEvent(n, t, {});
    return this;
  }
  /**
   * Remove listeners registered in the event target.
   * @param - Name of the event to be removed
   * @param - listener function of the event to be removed
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Remove all listeners.
   * emitter.off();
   *
   * // Remove all listeners in "A" event.
   * emitter.off("a");
   *
   *
   * // Remove "listener" listener in "a" event.
   * emitter.off("a", listener);
   */
  off(n, t) {
    if (!n)
      this._events = {};
    else if (Dt(n))
      for (const s in n)
        this.off(s);
    else if (!t)
      this._events[n] = [];
    else {
      const s = this._events[n];
      if (s) {
        const r = Ut(s, (o) => o.listener === t);
        r > -1 && s.splice(r, 1);
      }
    }
    return this;
  }
  /**
   * Add a disposable listener and Use promise to the registered event.
   * @param - Name of the event to be added
   * @param - disposable listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add a disposable listener in "a" event
   * emitter.once("a", () => {
   * });
   *
   * // Use Promise
   * emitter.once("a").then(e => {
   * });
   */
  once(n, t) {
    return t && this._addEvent(n, t, { once: true }), new Promise((s) => {
      this._addEvent(n, s, { once: true });
    });
  }
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */
  emit(n, t = {}) {
    const s = this._events[n];
    if (!n || !s)
      return true;
    let r = false;
    return t.eventType = n, t.stop = () => {
      r = true;
    }, t.currentTarget = this, [...s].forEach((o) => {
      o.listener(t), o.once && this.off(n, o.listener);
    }), !r;
  }
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */
  /**
  * Fires an event to call listeners.
  * @param - Event name
  * @param - Event parameter
  * @return If false, stop the event.
  * @example
  *
  * import EventEmitter from "@scena/event-emitter";
  *
  *
  * const emitter = new EventEmitter();
  *
  * emitter.on("a", e => {
  * });
  *
  * // emit
  * emitter.trigger("a", {
  *   a: 1,
  * });
  */
  trigger(n, t = {}) {
    return this.emit(n, t);
  }
  _addEvent(n, t, s) {
    const r = this._events;
    r[n] = r[n] || [], r[n].push({ listener: t, ...s });
  }
};
function wa(e, n) {
  const t = n[0] - e[0], s = n[1] - e[1], r = Math.atan2(s, t);
  return r >= 0 ? r : r + Math.PI * 2;
}
function qn(e) {
  return wa(
    [e[0].clientX, e[0].clientY],
    [e[1].clientX, e[1].clientY]
  ) / Math.PI * 180;
}
function Ma(e) {
  return e.touches && e.touches.length >= 2;
}
function rn(e) {
  return e ? e.touches ? Ra(e.touches) : [mo(e)] : [];
}
function Ta(e) {
  return e && (e.type.indexOf("mouse") > -1 || "button" in e);
}
function gr(e, n, t) {
  const s = t.length, { clientX: r, clientY: o, originalClientX: i, originalClientY: a } = Le(e, s), { clientX: c, clientY: l } = Le(
    n,
    s
  ), { clientX: u, clientY: f } = Le(
    t,
    s
  ), h = r - c, d = o - l, p = r - u, g = o - f;
  return {
    clientX: i,
    clientY: a,
    deltaX: h,
    deltaY: d,
    distX: p,
    distY: g
  };
}
function jn(e) {
  return Math.sqrt(
    Math.pow(e[0].clientX - e[1].clientX, 2) + Math.pow(e[0].clientY - e[1].clientY, 2)
  );
}
function Ra(e) {
  const n = Math.min(e.length, 2), t = [];
  for (let s = 0; s < n; ++s)
    t.push(mo(e[s]));
  return t;
}
function mo(e) {
  return {
    clientX: e.clientX,
    clientY: e.clientY
  };
}
function Le(e, n = e.length) {
  const t = {
    clientX: 0,
    clientY: 0,
    originalClientX: 0,
    originalClientY: 0
  }, s = Math.min(e.length, n);
  for (let r = 0; r < s; ++r) {
    const o = e[r];
    t.originalClientX += "originalClientX" in o ? o.originalClientX : o.clientX, t.originalClientY += "originalClientY" in o ? o.originalClientY : o.clientY, t.clientX += o.clientX, t.clientY += o.clientY;
  }
  return n ? {
    clientX: t.clientX / n,
    clientY: t.clientY / n,
    originalClientX: t.originalClientX / n,
    originalClientY: t.originalClientY / n
  } : t;
}
var Un = class {
  constructor(n) {
    b(this, "prevClients", []);
    b(this, "startClients", []);
    b(this, "movement", 0);
    b(this, "length", 0);
    this.startClients = n, this.prevClients = n, this.length = n.length;
  }
  getAngle(n = this.prevClients) {
    return qn(n);
  }
  getRotation(n = this.prevClients) {
    return qn(n) - qn(this.startClients);
  }
  getPosition(n = this.prevClients, t) {
    const s = gr(n || this.prevClients, this.prevClients, this.startClients), { deltaX: r, deltaY: o } = s;
    return this.movement += Math.sqrt(r * r + o * o), this.prevClients = n, s;
  }
  getPositions(n = this.prevClients) {
    const t = this.prevClients, s = this.startClients, r = Math.min(this.length, t.length), o = [];
    for (let i = 0; i < r; ++i)
      o[i] = gr([n[i]], [t[i]], [s[i]]);
    return o;
  }
  getMovement(n) {
    const t = this.movement;
    if (!n)
      return t;
    const s = Le(n, this.length), r = Le(this.prevClients, this.length), o = s.clientX - r.clientX, i = s.clientY - r.clientY;
    return Math.sqrt(o * o + i * i) + t;
  }
  getDistance(n = this.prevClients) {
    return jn(n);
  }
  getScale(n = this.prevClients) {
    return jn(n) / jn(this.startClients);
  }
  move(n, t) {
    this.startClients.forEach((s) => {
      s.clientX -= n, s.clientY -= t;
    }), this.prevClients.forEach((s) => {
      s.clientX -= n, s.clientY -= t;
    });
  }
};
var mr = ["textarea", "input"];
var $n = class extends Ae {
  /**
   *
   */
  constructor(t, s = {}) {
    super();
    b(this, "options", {});
    b(this, "flag", false);
    b(this, "pinchFlag", false);
    b(this, "data", {});
    b(this, "isDrag", false);
    b(this, "isPinch", false);
    b(this, "clientStores", []);
    b(this, "targets", []);
    b(this, "prevTime", 0);
    b(this, "doubleFlag", false);
    b(this, "_useMouse", false);
    b(this, "_useTouch", false);
    b(this, "_useDrag", false);
    b(this, "_dragFlag", false);
    b(this, "_isTrusted", false);
    b(this, "_isMouseEvent", false);
    b(this, "_isSecondaryButton", false);
    b(this, "_preventMouseEvent", false);
    b(this, "_prevInputEvent", null);
    b(this, "_isDragAPI", false);
    b(this, "_isIdle", true);
    b(this, "_preventMouseEventId", 0);
    b(this, "_window", window);
    b(this, "onDragStart", (t2, s2 = true) => {
      if (!this.flag && t2.cancelable === false)
        return;
      const r2 = t2.type.indexOf("drag") >= -1;
      if (this.flag && r2)
        return;
      this._isDragAPI = true;
      const {
        container: o2,
        pinchOutside: i2,
        preventWheelClick: a2,
        preventRightClick: c2,
        preventDefault: l,
        checkInput: u,
        dragFocusedInput: f,
        preventClickEventOnDragStart: h,
        preventClickEventOnDrag: d,
        preventClickEventByCondition: p
      } = this.options, g = this._useTouch, m = !this.flag;
      if (this._isSecondaryButton = t2.which === 3 || t2.button === 2, a2 && (t2.which === 2 || t2.button === 1) || c2 && (t2.which === 3 || t2.button === 2))
        return this.stop(), false;
      if (m) {
        const v = this._window.document.activeElement, x = t2.target;
        if (x) {
          const E = x.tagName.toLowerCase(), D = mr.indexOf(E) > -1, T = x.isContentEditable;
          if (D || T) {
            if (u || !f && v === x)
              return false;
            if (v && (v === x || T && v.isContentEditable && v.contains(x)))
              if (f)
                x.blur();
              else
                return false;
          } else if ((l || t2.type === "touchstart") && v) {
            const w = v.tagName.toLowerCase();
            (v.isContentEditable || mr.indexOf(w) > -1) && v.blur();
          }
          (h || d || p) && it(this._window, "click", this._onClick, true);
        }
        this.clientStores = [new Un(rn(t2))], this._isIdle = false, this.flag = true, this.isDrag = false, this._isTrusted = s2, this._dragFlag = true, this._prevInputEvent = t2, this.data = {}, this.doubleFlag = Ue() - this.prevTime < 200, this._isMouseEvent = Ta(t2), !this._isMouseEvent && this._preventMouseEvent && this._allowMouseEvent(), (this._preventMouseEvent || this.emit("dragStart", {
          data: this.data,
          datas: this.data,
          inputEvent: t2,
          isMouseEvent: this._isMouseEvent,
          isSecondaryButton: this._isSecondaryButton,
          isTrusted: s2,
          isDouble: this.doubleFlag,
          ...this.getCurrentStore().getPosition(),
          preventDefault() {
            t2.preventDefault();
          },
          preventDrag: () => {
            this._dragFlag = false;
          }
        })) === false && this.stop(), this._isMouseEvent && this.flag && l && t2.preventDefault();
      }
      if (!this.flag)
        return false;
      let S = 0;
      if (m ? (this._attchDragEvent(), g && i2 && (S = setTimeout(() => {
        it(o2, "touchstart", this.onDragStart, {
          passive: false
        });
      }))) : g && i2 && st(o2, "touchstart", this.onDragStart), this.flag && Ma(t2)) {
        if (clearTimeout(S), m && t2.touches.length !== t2.changedTouches.length)
          return;
        this.pinchFlag || this.onPinchStart(t2);
      }
    });
    b(this, "onDrag", (t2, s2) => {
      if (!this.flag)
        return;
      const { preventDefault: r2 } = this.options;
      !this._isMouseEvent && r2 && t2.preventDefault(), this._prevInputEvent = t2;
      const o2 = rn(t2), i2 = this.moveClients(o2, t2, false);
      if (this._dragFlag) {
        if ((this.pinchFlag || i2.deltaX || i2.deltaY) && (this._preventMouseEvent || this.emit("drag", {
          ...i2,
          isScroll: !!s2,
          inputEvent: t2
        })) === false) {
          this.stop();
          return;
        }
        this.pinchFlag && this.onPinch(t2, o2);
      }
      this.getCurrentStore().getPosition(o2, true);
    });
    b(this, "onDragEnd", (t2) => {
      if (!this.flag)
        return;
      const {
        pinchOutside: s2,
        container: r2,
        preventClickEventOnDrag: o2,
        preventClickEventOnDragStart: i2,
        preventClickEventByCondition: a2
      } = this.options, c2 = this.isDrag;
      (o2 || i2 || a2) && requestAnimationFrame(() => {
        this._allowClickEvent();
      }), !a2 && !i2 && o2 && !c2 && this._allowClickEvent(), this._useTouch && s2 && st(r2, "touchstart", this.onDragStart), this.pinchFlag && this.onPinchEnd(t2);
      const l = t2 != null && t2.touches ? rn(t2) : [];
      l.length === 0 || !this.options.keepDragging ? this.flag = false : this._addStore(new Un(l));
      const f = this._getPosition(), h = Ue(), d = !c2 && this.doubleFlag;
      this._prevInputEvent = null, this.prevTime = c2 || d ? 0 : h, this.flag || (this._dettachDragEvent(), this._preventMouseEvent || this.emit("dragEnd", {
        data: this.data,
        datas: this.data,
        isDouble: d,
        isDrag: c2,
        isClick: !c2,
        isMouseEvent: this._isMouseEvent,
        isSecondaryButton: this._isSecondaryButton,
        inputEvent: t2,
        isTrusted: this._isTrusted,
        ...f
      }), this.clientStores = [], this._isMouseEvent || (this._preventMouseEvent = true, clearTimeout(this._preventMouseEventId), this._preventMouseEventId = setTimeout(() => {
        this._preventMouseEvent = false;
      }, 200)), this._isIdle = true);
    });
    b(this, "onBlur", () => {
      this.onDragEnd();
    });
    b(this, "_allowClickEvent", () => {
      st(this._window, "click", this._onClick, true);
    });
    b(this, "_onClick", (t2) => {
      this._allowClickEvent(), this._allowMouseEvent();
      const s2 = this.options.preventClickEventByCondition;
      s2 != null && s2(t2) || (t2.stopPropagation(), t2.preventDefault());
    });
    b(this, "_onContextMenu", (t2) => {
      this.options.preventRightClick ? this.onDragEnd(t2) : t2.preventDefault();
    });
    b(this, "_passCallback", () => {
    });
    const r = [].concat(t), o = r[0];
    this._window = go(o) ? o : Mt(o), this.options = {
      checkInput: false,
      container: o && !("document" in o) ? Mt(o) : o,
      preventRightClick: true,
      preventWheelClick: true,
      preventClickEventOnDragStart: false,
      preventClickEventOnDrag: false,
      preventClickEventByCondition: null,
      preventDefault: true,
      checkWindowBlur: false,
      keepDragging: false,
      pinchThreshold: 0,
      events: ["touch", "mouse"],
      ...s
    };
    const { container: i, events: a, checkWindowBlur: c } = this.options;
    if (this._useDrag = a.indexOf("drag") > -1, this._useTouch = a.indexOf("touch") > -1, this._useMouse = a.indexOf("mouse") > -1, this.targets = r, this._useDrag && r.forEach((l) => {
      it(l, "dragstart", this.onDragStart);
    }), this._useMouse && (r.forEach((l) => {
      it(l, "mousedown", this.onDragStart), it(l, "mousemove", this._passCallback);
    }), it(i, "contextmenu", this._onContextMenu)), c && it(Mt(), "blur", this.onBlur), this._useTouch) {
      const l = {
        passive: false
      };
      r.forEach((u) => {
        it(u, "touchstart", this.onDragStart, l), it(u, "touchmove", this._passCallback, l);
      });
    }
  }
  /**
   * Stop Gesto's drag events.
   */
  stop() {
    this.isDrag = false, this.data = {}, this.clientStores = [], this.pinchFlag = false, this.doubleFlag = false, this.prevTime = 0, this.flag = false, this._isIdle = true, this._allowClickEvent(), this._dettachDragEvent(), this._isDragAPI = false;
  }
  /**
   * The total moved distance
   */
  getMovement(t) {
    return this.getCurrentStore().getMovement(t) + this.clientStores.slice(1).reduce((s, r) => s + r.movement, 0);
  }
  /**
   * Whether to drag
   */
  isDragging() {
    return this.isDrag;
  }
  /**
   * Whether the operation of gesto is finished and is in idle state
   */
  isIdle() {
    return this._isIdle;
  }
  /**
   * Whether to start drag
   */
  isFlag() {
    return this.flag;
  }
  /**
   * Whether to start pinch
   */
  isPinchFlag() {
    return this.pinchFlag;
  }
  /**
   * Whether to start double click
   */
  isDoubleFlag() {
    return this.doubleFlag;
  }
  /**
   * Whether to pinch
   */
  isPinching() {
    return this.isPinch;
  }
  /**
   * If a scroll event occurs, it is corrected by the scroll distance.
   */
  scrollBy(t, s, r, o = true) {
    this.flag && (this.clientStores[0].move(t, s), o && this.onDrag(r, true));
  }
  /**
   * Create a virtual drag event.
   */
  move([t, s], r) {
    const i = this.getCurrentStore().prevClients;
    return this.moveClients(
      i.map(({ clientX: a, clientY: c }) => ({
        clientX: a + t,
        clientY: c + s,
        originalClientX: a,
        originalClientY: c
      })),
      r,
      true
    );
  }
  /**
   * The dragStart event is triggered by an external event.
   */
  triggerDragStart(t) {
    this.onDragStart(t, false);
  }
  /**
   * Set the event data while dragging.
   */
  setEventData(t) {
    const s = this.data;
    for (const r in t)
      s[r] = t[r];
    return this;
  }
  /**
   * Set the event data while dragging.
   * Use `setEventData`
   * @deprecated
   */
  setEventDatas(t) {
    return this.setEventData(t);
  }
  /**
   * Get the current event state while dragging.
   */
  getCurrentEvent(t = this._prevInputEvent) {
    return {
      data: this.data,
      datas: this.data,
      ...this._getPosition(),
      movement: this.getMovement(),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: false,
      inputEvent: t
    };
  }
  /**
   * Get & Set the event data while dragging.
   */
  getEventData() {
    return this.data;
  }
  /**
   * Get & Set the event data while dragging.
   * Use getEventData method
   * @depreacated
   */
  getEventDatas() {
    return this.data;
  }
  /**
   * Unset Gesto
   */
  unset() {
    const t = this.targets, s = this.options.container;
    this.off(), st(this._window, "blur", this.onBlur), this._useDrag && t.forEach((r) => {
      st(r, "dragstart", this.onDragStart);
    }), this._useMouse && (t.forEach((r) => {
      st(r, "mousedown", this.onDragStart);
    }), st(s, "contextmenu", this._onContextMenu)), this._useTouch && (t.forEach((r) => {
      st(r, "touchstart", this.onDragStart);
    }), st(s, "touchstart", this.onDragStart)), this._prevInputEvent = null, this._allowClickEvent(), this._dettachDragEvent();
  }
  onPinchStart(t) {
    const { pinchThreshold: s } = this.options;
    if (this.isDrag && this.getMovement() > s)
      return;
    const r = new Un(rn(t));
    this.pinchFlag = true, this._addStore(r), this.emit("pinchStart", {
      data: this.data,
      datas: this.data,
      angle: r.getAngle(),
      touches: this.getCurrentStore().getPositions(),
      ...r.getPosition(),
      inputEvent: t,
      isTrusted: this._isTrusted,
      preventDefault() {
        t.preventDefault();
      },
      preventDrag: () => {
        this._dragFlag = false;
      }
    }) === false && (this.pinchFlag = false);
  }
  onPinch(t, s) {
    if (!this.flag || !this.pinchFlag || s.length < 2)
      return;
    const r = this.getCurrentStore();
    this.isPinch = true, this.emit("pinch", {
      data: this.data,
      datas: this.data,
      movement: this.getMovement(s),
      angle: r.getAngle(s),
      rotation: r.getRotation(s),
      touches: r.getPositions(s),
      scale: r.getScale(s),
      distance: r.getDistance(s),
      ...r.getPosition(s),
      inputEvent: t,
      isTrusted: this._isTrusted
    });
  }
  onPinchEnd(t) {
    if (!this.pinchFlag)
      return;
    const s = this.isPinch;
    this.isPinch = false, this.pinchFlag = false;
    const r = this.getCurrentStore();
    this.emit("pinchEnd", {
      data: this.data,
      datas: this.data,
      isPinch: s,
      touches: r.getPositions(),
      ...r.getPosition(),
      inputEvent: t
    });
  }
  getCurrentStore() {
    return this.clientStores[0];
  }
  moveClients(t, s, r) {
    const o = this._getPosition(t, r), i = this.isDrag;
    (o.deltaX || o.deltaY) && (this.isDrag = true);
    let a = false;
    return !i && this.isDrag && (a = true), {
      data: this.data,
      datas: this.data,
      ...o,
      movement: this.getMovement(t),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: false,
      isMouseEvent: this._isMouseEvent,
      isSecondaryButton: this._isSecondaryButton,
      inputEvent: s,
      isTrusted: this._isTrusted,
      isFirstDrag: a
    };
  }
  _addStore(t) {
    this.clientStores.splice(0, 0, t);
  }
  _getPosition(t, s) {
    const o = this.getCurrentStore().getPosition(t, s), { distX: i, distY: a } = this.clientStores.slice(1).reduce((c, l) => {
      const u = l.getPosition();
      return c.distX += u.distX, c.distY += u.distY, c;
    }, o);
    return {
      ...o,
      distX: i,
      distY: a
    };
  }
  _attchDragEvent() {
    const t = this._window, s = this.options.container, r = {
      passive: false
    };
    this._isDragAPI && (it(s, "dragover", this.onDrag, r), it(t, "dragend", this.onDragEnd)), this._useMouse && (it(s, "mousemove", this.onDrag), it(t, "mouseup", this.onDragEnd)), this._useTouch && (it(s, "touchmove", this.onDrag, r), it(t, "touchend", this.onDragEnd, r), it(t, "touchcancel", this.onDragEnd, r));
  }
  _dettachDragEvent() {
    const t = this._window, s = this.options.container;
    this._isDragAPI && (st(s, "dragover", this.onDrag), st(t, "dragend", this.onDragEnd)), this._useMouse && (st(s, "mousemove", this.onDrag), st(t, "mouseup", this.onDragEnd)), this._useTouch && (st(s, "touchstart", this.onDragStart), st(s, "touchmove", this.onDrag), st(t, "touchend", this.onDragEnd), st(t, "touchcancel", this.onDragEnd));
  }
  _allowMouseEvent() {
    this._preventMouseEvent = false, clearTimeout(this._preventMouseEventId);
  }
};
var ya = class {
  constructor() {
    b(this, "keys", []);
    b(this, "values", []);
  }
  get(n) {
    const t = this.keys.indexOf(n);
    return t !== -1 ? this.values[t] : void 0;
  }
  set(n, t) {
    const s = this.keys.indexOf(n);
    s === -1 ? (this.keys.push(n), this.values.push(t)) : this.values[s] = t;
  }
};
var za = class {
  constructor() {
    b(this, "object", {});
  }
  get(n) {
    return this.object[n];
  }
  set(n, t) {
    this.object[n] = t;
  }
};
var Pa = typeof Map == "function";
var _a = class {
  constructor() {
    b(this, "prev");
    b(this, "next");
  }
  connect(n, t) {
    this.prev = n, this.next = t, n && (n.next = this), t && (t.prev = this);
  }
  disconnect() {
    const { prev: n, next: t } = this;
    n && (n.next = t), t && (t.prev = n);
  }
  getIndex() {
    let n = -1, t = this;
    for (; t; )
      t = t.prev, ++n;
    return n;
  }
};
function Oa(e, n) {
  const t = [], s = [];
  return e.forEach(([r, o]) => {
    const i = new _a();
    t[r] = i, s[o] = i;
  }), t.forEach((r, o) => {
    r.connect(t[o - 1]);
  }), e.filter((r, o) => !n[o]).map(([r, o]) => {
    if (r === o)
      return [0, 0];
    const i = t[r], a = s[o - 1], c = i.getIndex();
    i.disconnect(), i.connect(a, a == null ? void 0 : a.next);
    const l = i.getIndex();
    return [c, l];
  });
}
var Ia = class {
  constructor(n, t, s, r, o, i, a, c) {
    b(this, "prevList");
    b(this, "list");
    b(this, "added");
    b(this, "removed");
    b(this, "changed");
    b(this, "maintained");
    b(this, "changedBeforeAdded");
    b(this, "fixed");
    b(this, "cacheOrdered");
    b(this, "cachePureChanged");
    this.prevList = n, this.list = t, this.added = s, this.removed = r, this.changed = o, this.maintained = i, this.changedBeforeAdded = a, this.fixed = c;
  }
  get ordered() {
    return this.cacheOrdered || this.calculateOrdered(), this.cacheOrdered;
  }
  get pureChanged() {
    return this.cachePureChanged || this.calculateOrdered(), this.cachePureChanged;
  }
  calculateOrdered() {
    const n = Oa(this.changedBeforeAdded, this.fixed), t = [];
    this.cacheOrdered = n.filter(([s, r], o) => {
      const [i, a] = this.changed[o];
      return s !== r ? (t.push([i, a]), true) : false;
    }), this.cachePureChanged = t;
  }
};
function wn(e, n, t) {
  const s = Pa ? Map : t ? za : ya, r = t || ((v) => v), o = [], i = [], a = [], c = e.map(r), l = n.map(r), u = new s(), f = new s(), h = [], d = [], p = {}, g = [];
  let m = 0, S = 0;
  return c.forEach((v, x) => {
    u.set(v, x);
  }), l.forEach((v, x) => {
    f.set(v, x);
  }), c.forEach((v, x) => {
    const C = f.get(v);
    C === void 0 ? (i.push(x), ++S) : p[C] = S;
  }), l.forEach((v, x) => {
    const C = u.get(v);
    C === void 0 ? (o.push(x), ++m) : (a.push([C, x]), S = p[x] || 0, h.push([
      C - S,
      x - m
    ]), d.push(x === C), C !== x && g.push([C, x]));
  }), i.reverse(), new Ia(
    e,
    n,
    o,
    i,
    g,
    a,
    h,
    d
  );
}
var So = class {
  constructor(n = [], t) {
    b(this, "findKeyCallback");
    b(this, "list");
    this.findKeyCallback = t, this.list = [...n];
  }
  update(n) {
    const t = [...n], s = wn(this.list, t, this.findKeyCallback);
    return this.list = t, s;
  }
};
b(So, "diff", wn);
var xo = typeof Map == "function" ? void 0 : /* @__PURE__ */ (() => {
  let e = 0;
  return (n) => n.__DIFF_KEY__ || (n.__DIFF_KEY__ = ++e);
})();
var vo = class extends So {
  /**
   * @param - Initializing Children <ko> 초기 설정할 자식 노드들</ko>
   */
  constructor(n = []) {
    super(n, xo);
  }
};
function Ce(e, n) {
  return wn(e, n, xo);
}
function Ba(e) {
  let n = e.container;
  return n === document.body ? [
    n.scrollLeft || document.documentElement.scrollLeft,
    n.scrollTop || document.documentElement.scrollTop
  ] : [n.scrollLeft, n.scrollTop];
}
function Sr(e, n) {
  return e.addEventListener("scroll", n), () => {
    e.removeEventListener("scroll", n);
  };
}
function on(e) {
  if (e) {
    if (Yt(e))
      return document.querySelector(e);
  } else return null;
  if (Gn(e))
    return e();
  if (e instanceof Element)
    return e;
  if ("current" in e)
    return e.current;
  if ("value" in e)
    return e.value;
}
var Eo = class extends Ae {
  constructor() {
    super(...arguments);
    b(this, "_startRect", null);
    b(this, "_startPos", []);
    b(this, "_prevTime", 0);
    b(this, "_timer", 0);
    b(this, "_prevScrollPos", [0, 0]);
    b(this, "_isWait", false);
    b(this, "_flag", false);
    b(this, "_currentOptions", null);
    b(this, "_lock", false);
    b(this, "_unregister", null);
    b(this, "_onScroll", () => {
      const t = this._currentOptions;
      this._lock || !t || this.emit("scrollDrag", {
        next: (s) => {
          this.checkScroll({
            container: t.container,
            inputEvent: s
          });
        }
      });
    });
  }
  /**
   */
  dragStart(t, s) {
    const r = on(s.container);
    if (!r) {
      this._flag = false;
      return;
    }
    let o = 0, i = 0, a = 0, c = 0;
    if (r === document.body)
      a = window.innerWidth, c = window.innerHeight;
    else {
      const l = r.getBoundingClientRect();
      o = l.top, i = l.left, a = l.width, c = l.height;
    }
    this._flag = true, this._startPos = [t.clientX, t.clientY], this._startRect = { top: o, left: i, width: a, height: c }, this._prevScrollPos = this._getScrollPosition([0, 0], s), this._currentOptions = s, this._registerScrollEvent(s);
  }
  drag(t, s) {
    if (clearTimeout(this._timer), !this._flag)
      return;
    const { clientX: r, clientY: o } = t, { threshold: i = 0 } = s, { _startRect: a, _startPos: c } = this;
    this._currentOptions = s;
    const l = [0, 0];
    return a.top > o - i ? (c[1] > a.top || o < c[1]) && (l[1] = -1) : a.top + a.height < o + i && (c[1] < a.top + a.height || o > c[1]) && (l[1] = 1), a.left > r - i ? (c[0] > a.left || r < c[0]) && (l[0] = -1) : a.left + a.width < r + i && (c[0] < a.left + a.width || r > c[0]) && (l[0] = 1), !l[0] && !l[1] ? false : this._continueDrag({
      ...s,
      direction: l,
      inputEvent: t,
      isDrag: true
    });
  }
  /**
   */
  checkScroll(t) {
    if (this._isWait)
      return false;
    const {
      prevScrollPos: s = this._prevScrollPos,
      direction: r,
      throttleTime: o = 0,
      inputEvent: i,
      isDrag: a
    } = t, c = this._getScrollPosition(r || [0, 0], t), l = c[0] - s[0], u = c[1] - s[1], f = r || [
      l ? Math.abs(l) / l : 0,
      u ? Math.abs(u) / u : 0
    ];
    return this._prevScrollPos = c, this._lock = false, !l && !u ? false : (this.emit("move", {
      offsetX: f[0] ? l : 0,
      offsetY: f[1] ? u : 0,
      inputEvent: i
    }), o && a && (clearTimeout(this._timer), this._timer = window.setTimeout(() => {
      this._continueDrag(t);
    }, o)), true);
  }
  /**
   *
   */
  dragEnd() {
    this._flag = false, this._lock = false, clearTimeout(this._timer), this._unregisterScrollEvent();
  }
  _getScrollPosition(t, s) {
    const { container: r, getScrollPosition: o = Ba } = s;
    return o({
      container: on(r),
      direction: t
    });
  }
  _continueDrag(t) {
    var d;
    const {
      container: s,
      direction: r,
      throttleTime: o,
      useScroll: i,
      isDrag: a,
      inputEvent: c
    } = t;
    if (!this._flag || a && this._isWait)
      return;
    const l = Ue(), u = Math.max(o + this._prevTime - l, 0);
    if (u > 0)
      return clearTimeout(this._timer), this._timer = window.setTimeout(() => {
        this._continueDrag(t);
      }, u), false;
    this._prevTime = l;
    const f = this._getScrollPosition(r, t);
    this._prevScrollPos = f, a && (this._isWait = true), i || (this._lock = true);
    const h = {
      container: on(s),
      direction: r,
      inputEvent: c
    };
    return (d = t.requestScroll) == null || d.call(t, h), this.emit("scroll", h), this._isWait = false, i || this.checkScroll({
      ...t,
      prevScrollPos: f,
      direction: r,
      inputEvent: c
    });
  }
  _registerScrollEvent(t) {
    this._unregisterScrollEvent();
    const s = t.checkScrollEvent;
    if (!s)
      return;
    const r = s === true ? Sr : s, o = on(t.container);
    s === true && (o === document.body || o === document.documentElement) ? this._unregister = Sr(window, this._onScroll) : this._unregister = r(o, this._onScroll);
  }
  _unregisterScrollEvent() {
    var t;
    (t = this._unregister) == null || t.call(this), this._unregister = null;
  }
};
function wt(e) {
  return U(e, ht);
}
function Aa(e, n) {
  return e.every(
    (t, s) => wt(t - n[s]) === 0
  );
}
function Ga(e, n) {
  return !wt(e[0] - n[0]) && !wt(e[1] - n[1]);
}
function We(e) {
  return e.length < 3 ? 0 : Math.abs(
    $a(
      e.map((n, t) => {
        const s = e[t + 1] || e[0];
        return n[0] * s[1] - s[0] * n[1];
      })
    )
  ) / 2;
}
function $a(e) {
  const n = e.length;
  let t = 0;
  for (let s = n - 1; s >= 0; --s)
    t += e[s];
  return t;
}
function ls(e, n) {
  return ka(e, n).map(({ pos: s }) => s);
}
function us(e) {
  return [...e.slice(1), e[0]].map((n, t) => [e[t], n]);
}
function Mn(e, n) {
  const [t, s] = e, [r, o] = n;
  let i = r - t, a = o - s;
  Math.abs(i) < ht && (i = 0), Math.abs(a) < ht && (a = 0);
  let c = 0, l = 0, u = 0;
  return i ? a ? (c = -a / i, l = 1, u = -c * t - s) : (l = 1, u = -s) : a && (c = -1, u = t), [c, l, u];
}
function ka(e, n) {
  const t = e.slice(), s = n.slice();
  hr(t) === -1 && t.reverse(), hr(s) === -1 && s.reverse();
  const r = us(t), o = us(s), i = r.map(
    (u) => Mn(u[0], u[1])
  ), a = o.map(
    (u) => Mn(u[0], u[1])
  ), c = [];
  i.forEach((u, f) => {
    const h = r[f], d = [];
    a.forEach((p, g) => {
      const m = As(
        u,
        p
      ), S = Co(m, [h, o[g]]);
      d.push(
        ...S.map((v) => ({
          index1: f,
          index2: g,
          pos: v,
          type: "intersection"
        }))
      );
    }), d.sort((p, g) => Nt(h[0], p.pos) - Nt(h[0], g.pos)), c.push(...d), Tn(h[1], s) && c.push({
      index1: f,
      index2: -1,
      pos: h[1],
      type: "inside"
    });
  }), o.forEach((u, f) => {
    if (!Tn(u[1], t))
      return;
    let h = false, d = Ut(c, ({ index2: p }) => p === f ? (h = true, false) : !!h);
    d === -1 && (h = false, d = Ut(c, ({ index1: p, index2: g }) => p === -1 && g + 1 === f ? (h = true, false) : !!h)), d === -1 ? c.push({
      index1: -1,
      index2: f,
      pos: u[1],
      type: "inside"
    }) : c.splice(d, 0, {
      index1: -1,
      index2: f,
      pos: u[1],
      type: "inside"
    });
  });
  const l = {};
  return c.filter(({ pos: u }) => {
    const f = `${u[0]}x${u[1]}`;
    return l[f] ? false : (l[f] = true, true);
  });
}
function As(e, n) {
  const [t, s, r] = e, [o, i, a] = n, c = t === 0 && o === 0, l = s === 0 && i === 0;
  let u = [];
  if (c && l)
    return [];
  if (c) {
    const f = -r / s, h = -a / i;
    return f !== h ? [] : [
      [-1 / 0, f],
      [1 / 0, f]
    ];
  } else if (l) {
    const f = -r / t, h = -a / o;
    return f !== h ? [] : [
      [f, -1 / 0],
      [f, 1 / 0]
    ];
  } else if (t === 0) {
    const f = -r / s;
    u = [[-(i * f + a) / o, f]];
  } else if (o === 0) {
    const f = -a / i;
    u = [[-(s * f + r) / t, f]];
  } else if (s === 0) {
    const f = -r / t, h = -(o * f + a) / i;
    u = [[f, h]];
  } else if (i === 0) {
    const f = -a / o, h = -(t * f + r) / s;
    u = [[f, h]];
  } else {
    const f = (s * a - i * r) / (i * t - s * o), h = -(t * f + r) / s;
    u = [[f, h]];
  }
  return u.map((f) => [f[0], f[1]]);
}
function Co(e, n) {
  const t = n.map(
    (r) => [0, 1].map((o) => [
      Math.min(r[0][o], r[1][o]),
      Math.max(r[0][o], r[1][o])
    ])
  );
  let s = [];
  if (e.length === 2) {
    const [r, o] = e[0];
    if (wt(r - e[1][0])) {
      if (!wt(o - e[1][1])) {
        const i = Math.max(...t.map((c) => c[0][0])), a = Math.min(...t.map((c) => c[0][1]));
        if (wt(i - a) > 0)
          return [];
        s = [
          [i, o],
          [a, o]
        ];
      }
    } else {
      const i = Math.max(...t.map((c) => c[1][0])), a = Math.min(...t.map((c) => c[1][1]));
      if (wt(i - a) > 0)
        return [];
      s = [
        [r, i],
        [r, a]
      ];
    }
  }
  return s.length || (s = e.filter((r) => {
    const [o, i] = r;
    return t.every((a) => 0 <= wt(o - a[0][0]) && 0 <= wt(a[0][1] - o) && 0 <= wt(i - a[1][0]) && 0 <= wt(a[1][1] - i));
  })), s.map((r) => [
    wt(r[0]),
    wt(r[1])
  ]);
}
function Tn(e, n, t) {
  const [s, r] = e, { minX: o, maxX: i } = ue(n), a = [
    [o, r],
    [i, r]
  ], c = Mn(a[0], a[1]), l = us(n), u = [];
  if (l.forEach((d) => {
    const p = Mn(d[0], d[1]), g = d[0];
    Aa(c, p) ? u.push({
      pos: e,
      line: d,
      type: "line"
    }) : Co(
      As(c, p),
      [a, d]
    ).forEach((S) => {
      d.some((v) => Ga(v, S)) ? u.push({
        pos: S,
        line: d,
        type: "point"
      }) : wt(g[1] - r) !== 0 && u.push({
        pos: S,
        line: d,
        type: "intersection"
      });
    });
  }), yt(u, (d) => d[0] === s))
    return true;
  let f = 0;
  const h = {};
  return u.forEach(({ pos: d, type: p, line: g }) => {
    if (!(d[0] > s))
      if (p === "intersection")
        ++f;
      else {
        if (p === "line")
          return;
        if (p === "point") {
          const m = yt(g, (x) => x[1] !== r), S = h[d[0]], v = m[1] > r ? 1 : -1;
          S ? S !== v && ++f : h[d[0]] = v;
        }
      }
  }), f % 2 === 1;
}
function ue(e) {
  const n = e.map((s) => s[0]), t = e.map((s) => s[1]);
  return {
    minX: Math.min(...n),
    minY: Math.min(...t),
    maxX: Math.max(...n),
    maxY: Math.max(...t)
  };
}
function fs(e, n) {
  const { width: t, height: s, left: r, top: o } = n, { minX: i, minY: a, maxX: c, maxY: l } = ue(e), u = t / (c - i), f = s / (l - a);
  return e.map((h) => [
    r + (h[0] - i) * u,
    o + (h[1] - a) * f
  ]);
}
function Xa(e, n) {
  const t = ls(e, n);
  return We(t);
}
function Ya(e, n, t, s, r, o) {
  for (let i = 0; i < r; ++i) {
    const a = t + i * r, c = s + i * r;
    e[a] += e[c] * o, n[a] += n[c] * o;
  }
}
function Fa(e, n, t, s, r) {
  for (let o = 0; o < r; ++o) {
    const i = t + o * r, a = s + o * r, c = e[i], l = n[i];
    e[i] = e[a], e[a] = c, n[i] = n[a], n[a] = l;
  }
}
function La(e, n, t, s, r) {
  for (let o = 0; o < s; ++o) {
    const i = t + o * s;
    e[i] /= r, n[i] /= r;
  }
}
function Do(e, n, t = Math.sqrt(e.length)) {
  const s = e.slice();
  for (let r = 0; r < t; ++r)
    s[r * t + n - 1] = 0, s[(n - 1) * t + r] = 0;
  return s[(n - 1) * (t + 1)] = 1, s;
}
function kt(e, n = Math.sqrt(e.length)) {
  const t = e.slice(), s = rt(n);
  for (let r = 0; r < n; ++r) {
    const o = n * r + r;
    if (!U(t[o], ht)) {
      for (let i = r + 1; i < n; ++i)
        if (t[n * r + i]) {
          Fa(t, s, r, i, n);
          break;
        }
    }
    if (!U(t[o], ht))
      return [];
    La(t, s, r, n, t[o]);
    for (let i = 0; i < n; ++i) {
      const a = i, c = i + r * n, l = t[c];
      !U(l, ht) || r === i || Ya(t, s, a, r, n, -l);
    }
  }
  return s;
}
function Wa(e, n = Math.sqrt(e.length)) {
  const t = [];
  for (let s = 0; s < n; ++s)
    for (let r = 0; r < n; ++r)
      t[r * n + s] = e[n * s + r];
  return t;
}
function bo(e, n = Math.sqrt(e.length)) {
  const t = [], s = e[n * n - 1];
  for (let r = 0; r < n - 1; ++r)
    t[r] = e[n * (n - 1) + r] / s;
  return t[n - 1] = 0, t;
}
function Na(e, n) {
  const t = rt(n);
  for (let s = 0; s < n - 1; ++s)
    t[n * (n - 1) + s] = e[s] || 0;
  return t;
}
function fe(e, n) {
  const t = e.slice();
  for (let s = e.length; s < n - 1; ++s)
    t[s] = 0;
  return t[n - 1] = 1, t;
}
function Xt(e, n = Math.sqrt(e.length), t) {
  if (n === t)
    return e;
  const s = rt(t), r = Math.min(n, t);
  for (let o = 0; o < r - 1; ++o) {
    for (let i = 0; i < r - 1; ++i)
      s[o * t + i] = e[o * n + i];
    s[(o + 1) * t - 1] = e[(o + 1) * n - 1], s[(t - 1) * t + o] = e[(n - 1) * n + o];
  }
  return s[t * t - 1] = e[n * n - 1], s;
}
function Rn(e, ...n) {
  let t = rt(e);
  return n.forEach((s) => {
    t = et(t, s, e);
  }), t;
}
function et(e, n, t = Math.sqrt(e.length)) {
  const s = [], r = e.length / t, o = n.length / r;
  if (r) {
    if (!o)
      return e;
  } else return n;
  for (let i = 0; i < t; ++i)
    for (let a = 0; a < o; ++a) {
      s[a * t + i] = 0;
      for (let c = 0; c < r; ++c)
        s[a * t + i] += e[c * t + i] * n[a * r + c];
    }
  return s;
}
function tt(e, n) {
  const t = Math.min(e.length, n.length), s = e.slice();
  for (let r = 0; r < t; ++r)
    s[r] = s[r] + n[r];
  return s;
}
function V(e, n) {
  const t = Math.min(e.length, n.length), s = e.slice();
  for (let r = 0; r < t; ++r)
    s[r] = s[r] - n[r];
  return s;
}
function Ha(e, n = e.length === 6) {
  return n ? [e[0], e[1], 0, e[2], e[3], 0, e[4], e[5], 1] : e;
}
function wo(e, n = e.length === 9) {
  return n ? [e[0], e[1], e[3], e[4], e[6], e[7]] : e;
}
function mt(e, n, t = n.length) {
  const s = et(e, n, t), r = s[t - 1];
  return s.map((o) => o / r);
}
function Va(e, n) {
  return et(
    e,
    [
      1,
      0,
      0,
      0,
      0,
      Math.cos(n),
      Math.sin(n),
      0,
      0,
      -Math.sin(n),
      Math.cos(n),
      0,
      0,
      0,
      0,
      1
    ],
    4
  );
}
function qa(e, n) {
  return et(
    e,
    [
      Math.cos(n),
      0,
      -Math.sin(n),
      0,
      0,
      1,
      0,
      0,
      Math.sin(n),
      0,
      Math.cos(n),
      0,
      0,
      0,
      0,
      1
    ],
    4
  );
}
function ja(e, n) {
  return et(e, Qe(n, 4));
}
function an(e, [n = 1, t = 1, s = 1]) {
  return et(
    e,
    [n, 0, 0, 0, 0, t, 0, 0, 0, 0, s, 0, 0, 0, 0, 1],
    4
  );
}
function Je(e, n) {
  return mt(Qe(n, 3), fe(e, 3));
}
function Zn(e, [n = 0, t = 0, s = 0]) {
  return et(
    e,
    [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, n, t, s, 1],
    4
  );
}
function hs(e, n) {
  return et(e, n, 4);
}
function Qe(e, n) {
  const t = Math.cos(e), s = Math.sin(e), r = rt(n);
  return r[0] = t, r[1] = s, r[n] = -s, r[n + 1] = t, r;
}
function rt(e) {
  const n = e * e, t = [];
  for (let s = 0; s < n; ++s)
    t[s] = s % (e + 1) ? 0 : 1;
  return t;
}
function Gs(e, n) {
  const t = rt(n), s = Math.min(e.length, n - 1);
  for (let r = 0; r < s; ++r)
    t[(n + 1) * r] = e[r];
  return t;
}
function he(e, n) {
  const t = rt(n), s = Math.min(e.length, n - 1);
  for (let r = 0; r < s; ++r)
    t[n * (n - 1) + r] = e[r];
  return t;
}
function $s(e, n, t, s, r, o, i, a) {
  const [c, l] = e, [u, f] = n, [h, d] = t, [p, g] = s, [m, S] = r, [v, x] = o, [C, E] = i, [D, T] = a, w = [
    c,
    0,
    u,
    0,
    h,
    0,
    p,
    0,
    l,
    0,
    f,
    0,
    d,
    0,
    g,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    c,
    0,
    u,
    0,
    h,
    0,
    p,
    0,
    l,
    0,
    f,
    0,
    d,
    0,
    g,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    -m * c,
    -S * c,
    -v * u,
    -x * u,
    -C * h,
    -E * h,
    -D * p,
    -T * p,
    -m * l,
    -S * l,
    -v * f,
    -x * f,
    -C * d,
    -E * d,
    -D * g,
    -T * g
  ], z = kt(w, 8);
  if (!z.length)
    return [];
  const M = et(z, [m, S, v, x, C, E, D, T], 8);
  return M[8] = 1, Xt(Wa(M), 3, 4);
}
function ks() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function ye(e, n = 0) {
  return Ee(ze(e, n));
}
function vn(e, n) {
  const t = mt(e, [n[0], n[1] || 0, n[2] || 0, 1], 4), s = t[3] || 1;
  return [t[0] / s, t[1] / s, t[2] / s];
}
function Ua(e, n = document.body) {
  let t = e, s = ks();
  for (; t; ) {
    const r = getComputedStyle(t).transform;
    if (s = hs(ye(r), s), t === n)
      break;
    t = t.parentElement;
  }
  return s = kt(s, 4), s[12] = 0, s[13] = 0, s[14] = 0, s;
}
function Ee(e) {
  let n = ks();
  return e.forEach((t) => {
    const { matrixFunction: s, functionValue: r } = t;
    s && (n = s(n, r));
  }), n;
}
function ze(e, n = 0) {
  return (ct(e) ? e : Qt(e)).map((s) => {
    const { prefix: r, value: o } = uo(s);
    let i = null, a = r, c = "";
    if (r === "translate" || r === "translateX" || r === "translate3d") {
      const l = Dt(n) ? {
        ...n,
        "o%": n["%"]
      } : {
        "%": n,
        "o%": n
      }, [u, f = 0, h = 0] = ae(o).map((d, p) => (p === 0 && "x%" in l ? l["%"] = n["x%"] : p === 1 && "y%" in l ? l["%"] = n["y%"] : l["%"] = n["o%"], Q(d, l)));
      i = Zn, c = [u, f, h];
    } else if (r === "translateY") {
      const l = Dt(n) ? {
        "%": n["y%"],
        ...n
      } : {
        "%": n
      }, u = Q(o, l);
      i = Zn, c = [0, u, 0];
    } else if (r === "translateZ") {
      const l = parseFloat(o);
      i = Zn, c = [0, 0, l];
    } else if (r === "scale" || r === "scale3d") {
      const [l, u = l, f = 1] = ae(o).map(
        (h) => parseFloat(h)
      );
      i = an, c = [l, u, f];
    } else if (r === "scaleX") {
      const l = parseFloat(o);
      i = an, c = [l, 1, 1];
    } else if (r === "scaleY") {
      const l = parseFloat(o);
      i = an, c = [1, l, 1];
    } else if (r === "scaleZ") {
      const l = parseFloat(o);
      i = an, c = [1, 1, l];
    } else if (r === "rotate" || r === "rotateZ" || r === "rotateX" || r === "rotateY") {
      const { unit: l, value: u } = ce(o), f = l === "rad" ? u : u * Math.PI / 180;
      r === "rotate" || r === "rotateZ" ? (a = "rotateZ", i = ja) : r === "rotateX" ? i = Va : r === "rotateY" && (i = qa), c = f;
    } else if (r === "matrix3d")
      i = hs, c = ae(o).map((l) => parseFloat(l));
    else if (r === "matrix") {
      const l = ae(o).map((u) => parseFloat(u));
      i = hs, c = [
        l[0],
        l[1],
        0,
        0,
        l[2],
        l[3],
        0,
        0,
        0,
        0,
        1,
        0,
        l[4],
        l[5],
        0,
        1
      ];
    } else
      a = "";
    return {
      name: r,
      functionName: a,
      value: o,
      matrixFunction: i,
      functionValue: c
    };
  });
}
function Za(e) {
  if ("touches" in e) {
    const n = e.touches[0] || e.changedTouches[0];
    return {
      clientX: n.clientX,
      clientY: n.clientY
    };
  } else
    return {
      clientX: e.clientX,
      clientY: e.clientY
    };
}
function Ka(e) {
  if (typeof Map > "u")
    return e.filter((t, s) => e.indexOf(t) === s);
  const n = /* @__PURE__ */ new Map();
  return e.filter((t) => n.has(t) ? false : (n.set(t, true), true));
}
function Ja(e, n, t) {
  const s = Rt(e);
  return s.elementFromPoint && s.elementFromPoint(n, t) || null;
}
function Qa(e) {
  return {
    tag: e.type,
    className: e.props.className,
    style: e.props.style || {},
    children: e.props.children || [],
    attributes: e.props
  };
}
function Mo(e, n, t) {
  const s = Qa(e), { tag: r, children: o, attributes: i, className: a, style: c } = s, l = n || Rt(t).createElement(r);
  for (const f in i)
    l.setAttribute(f, i[f]);
  const u = l.children;
  if (o.forEach((f, h) => {
    Mo(f, u[h], l);
  }), a && a.split(/\s+/g).forEach((f) => {
    f && !dt(l, f) && qt(l, f);
  }), c) {
    const f = l.style;
    for (const h in Object.keys(c))
      f[h] = c[h];
  }
  return !n && t && t.appendChild(l), l;
}
function Kn(e, n, t) {
  e !== n && t(e, n);
}
function xr(e, n, t = e.data.boundArea) {
  let { distX: s = 0, distY: r = 0 } = e;
  const { startX: o, startY: i } = e.data;
  if (n > 0) {
    const g = Math.sqrt(
      (s * s + r * r) / (1 + n * n)
    ), m = n * g;
    s = (s >= 0 ? 1 : -1) * m, r = (r >= 0 ? 1 : -1) * g;
  }
  let a = Math.abs(s), c = Math.abs(r);
  const l = s < 0 ? o - t.left : t.right - o, u = r < 0 ? i - t.top : t.bottom - i;
  [a, c] = _s(
    [a, c],
    [0, 0],
    [l, u],
    !!n
  ), s = (s >= 0 ? 1 : -1) * a, r = (r >= 0 ? 1 : -1) * c;
  const f = Math.min(0, s), h = Math.min(0, r), d = o + f, p = i + h;
  return {
    left: d,
    top: p,
    right: d + a,
    bottom: p + c,
    width: a,
    height: c
  };
}
function cn(e) {
  const n = e.getBoundingClientRect(), { left: t, top: s, width: r, height: o } = n;
  return {
    pos1: [t, s],
    pos2: [t + r, s],
    pos3: [t, s + o],
    pos4: [t + r, s + o]
  };
}
function vr(e, n, t) {
  const { list: s, prevList: r, added: o, removed: i, maintained: a } = Ce(
    e,
    n
  );
  return [
    ...o.map((c) => s[c]),
    ...i.map((c) => r[c]),
    ...t ? a.map(([, c]) => s[c]) : []
  ];
}
function Er(e) {
  let n = 0;
  const t = e.length;
  for (let s = 1; s < t; ++s)
    n = Math.max(Nt(e[s], e[s - 1]), n);
  return n;
}
function tc(e) {
  let n = 5381, t = e.length;
  for (; t; )
    n = n * 33 ^ e.charCodeAt(--t);
  return n >>> 0;
}
function ec(e) {
  return tc(e).toString(36);
}
function nc(e) {
  if (e && e.getRootNode) {
    const n = e.getRootNode();
    if (n.nodeType === 11)
      return n;
  }
}
function sc(e, n, t) {
  return t.original ? n : n.replace(/([^};{\s}][^};{]*|^\s*){/gm, (s, r) => {
    const o = r.trim();
    return (o ? ae(o) : [""]).map((i) => {
      const a = i.trim();
      return a.indexOf("@") === 0 ? a : a.indexOf(":global") > -1 ? a.replace(/\:global/g, "") : a.indexOf(":host") > -1 ? `${a.replace(/\:host/g, `.${e}`)}` : a ? `.${e} ${a}` : `.${e}`;
    }).join(", ") + " {";
  });
}
function rc(e, n, t, s, r) {
  const o = Rt(s), i = o.createElement("style");
  return i.setAttribute("type", "text/css"), i.setAttribute("data-styled-id", e), i.setAttribute("data-styled-count", "1"), t.nonce && i.setAttribute("nonce", t.nonce), i.innerHTML = sc(e, n, t), (r || o.head || o.body).appendChild(i), i;
}
function Xs(e) {
  const n = "rCS" + ec(e);
  return {
    className: n,
    inject(t, s = {}) {
      const r = nc(t);
      let o = (r || t.ownerDocument || document).querySelector(
        `style[data-styled-id="${n}"]`
      );
      if (!o)
        o = rc(
          n,
          e,
          s,
          t,
          r
        );
      else {
        const i = parseFloat(o.getAttribute("data-styled-count")) || 0;
        o.setAttribute("data-styled-count", `${i + 1}`);
      }
      return {
        destroy() {
          var a;
          const i = parseFloat(o.getAttribute("data-styled-count")) || 0;
          i <= 1 ? (o.remove ? o.remove() : (a = o.parentNode) == null || a.removeChild(o), o = null) : o.setAttribute(
            "data-styled-count",
            `${i - 1}`
          );
        }
      };
    }
  };
}
var To = Xs(`
:host {
    position: fixed;
    display: none;
    border: 1px solid rgba(16, 172, 132,1.0);
    background: rgba(16, 172, 132,0.25);
    pointer-events: none;
    will-change: transform;
    z-index: 100;
}
`);
var Jn = `selecto-selection ${To.className}`;
var oc = [
  "className",
  "boundContainer",
  "selectableTargets",
  "selectByClick",
  "selectFromInside",
  "continueSelect",
  "continueSelectWithoutDeselect",
  "toggleContinueSelect",
  "toggleContinueSelectWithoutDeselect",
  "keyContainer",
  "hitRate",
  "scrollOptions",
  "checkInput",
  "preventDefault",
  "ratio",
  "getElementRect",
  "preventDragFromInside",
  "rootContainer",
  "dragCondition",
  "clickBySelectEnd",
  "checkOverflow",
  "innerScrollOptions"
];
function ic(e) {
  const n = Object.getPrototypeOf(e);
  oc.forEach((t) => {
    const s = {
      enumerable: true,
      configurable: true,
      get() {
        return this.options[t];
      }
    }, r = Dn(`get ${t}`);
    n[r] ? s.get = function() {
      return this[r]();
    } : s.get = function() {
      return this.options[t];
    };
    const o = Dn(`set ${t}`);
    n[o] ? s.set = function(i) {
      this[o](i);
    } : s.set = function(i) {
      this.options[t] = i;
    }, Object.defineProperty(n, t, s);
  });
}
var Qu = class extends Ae {
  /**
   *
   */
  constructor(t = {}) {
    super();
    b(this, "options");
    b(this, "target");
    b(this, "dragContainer");
    b(this, "container");
    b(this, "gesto");
    b(this, "injectResult");
    b(this, "selectedTargets", []);
    b(this, "dragScroll", new Eo());
    b(this, "_keydownContinueSelect", false);
    b(this, "_keydownContinueSelectWithoutDeselection", false);
    b(this, "_handleKeyDown", (t2) => {
      t2.key === "Shift" && !this._keydownContinueSelect && (this._keydownContinueSelect = true, this.emit("keydown", {
        keydownContinueSelect: true,
        keydownContinueSelectWithoutDeselection: false
      }));
    });
    b(this, "_handleKeyUp", (t2) => {
      t2.key === "Shift" && this._keydownContinueSelect && (this._keydownContinueSelect = false, this.emit("keyup", {
        keydownContinueSelect: false,
        keydownContinueSelectWithoutDeselection: false
      }));
    });
    b(this, "_handleBlur", () => {
      this._keydownContinueSelect && (this._keydownContinueSelect = false, this.emit("keyup", {
        keydownContinueSelect: false,
        keydownContinueSelectWithoutDeselection: false
      }));
    });
    b(this, "_onDragStart", (t2, s2) => {
      const { data: r2, clientX: o, clientY: i, inputEvent: a } = t2, {
        selectFromInside: c,
        selectByClick: l,
        rootContainer: u,
        boundContainer: f,
        preventDragFromInside: h = true,
        clickBySelectEnd: d,
        dragCondition: p
      } = this.options;
      if (p && !p(t2)) {
        t2.stop();
        return;
      }
      r2.data = {};
      const g = Mt(this.container);
      r2.innerWidth = g.innerWidth, r2.innerHeight = g.innerHeight, this.findSelectableTargets(r2), r2.startSelectedTargets = this.selectedTargets, r2.scaleMatrix = ks(), r2.containerX = 0, r2.containerY = 0;
      const m = this.container;
      let S = {
        left: -1 / 0,
        top: -1 / 0,
        right: 1 / 0,
        bottom: 1 / 0
      };
      if (u) {
        const M = this.container.getBoundingClientRect();
        r2.containerX = M.left, r2.containerY = M.top, r2.scaleMatrix = Ua(this.container, u);
      }
      if (f) {
        const M = Dt(f) && "element" in f ? {
          left: true,
          top: true,
          bottom: true,
          right: true,
          ...f
        } : {
          element: f,
          left: true,
          top: true,
          bottom: true,
          right: true
        }, R = M.element;
        let P;
        if (R) {
          Yt(R) ? P = Rt(m).querySelector(R) : R === true ? P = this.container : P = R;
          const y = P.getBoundingClientRect();
          M.left && (S.left = y.left), M.top && (S.top = y.top), M.right && (S.right = y.right), M.bottom && (S.bottom = y.bottom);
        }
      }
      r2.boundArea = S;
      const v = {
        left: o,
        top: i,
        right: o,
        bottom: i,
        width: 0,
        height: 0
      };
      let x = [];
      const C = l && !d;
      let E = false;
      if (!c || C) {
        const M = this._findElement(
          s2 || a.target,
          // elementFromPoint(clientX, clientY),
          r2.selectableTargets
        );
        E = !!M, C && (x = M ? [M] : []);
      }
      const D = !c && E;
      if (D && !l)
        return t2.stop(), false;
      const T = a.type, w = T === "mousedown" || T === "touchstart";
      if (!(!t2.isClick && w ? this.emit("dragStart", { ...t2, data: r2.data }) : true))
        return t2.stop(), false;
      if (this.continueSelect ? (x = vr(
        this.selectedTargets,
        x,
        this.continueSelectWithoutDeselect
      ), r2.startPassedTargets = this.selectedTargets) : r2.startPassedTargets = [], this._select(
        x,
        v,
        t2,
        true,
        D && l && !d && h
      ), r2.startX = o, r2.startY = i, r2.selectFlag = false, r2.preventDragFromInside = false, a.target) {
        const M = vn(r2.scaleMatrix, [
          o - r2.containerX,
          i - r2.containerY
        ]);
        this.target.style.cssText += `position: ${u ? "absolute" : "fixed"};left:0px;top:0px;transform: translate(${M[0]}px, ${M[1]}px)`;
      }
      if (D && l && !d)
        a.preventDefault(), h && (this._selectEnd(
          r2.startSelectedTargets,
          r2.startPassedTargets,
          v,
          t2,
          true
        ), r2.preventDragFromInside = true);
      else {
        r2.selectFlag = true;
        const { scrollOptions: M, innerScrollOptions: R } = this.options;
        let P = false;
        if (R) {
          const k = t2.inputEvent.target;
          let _ = null, O = k;
          for (; O && O !== Rt(m).body; ) {
            if (getComputedStyle(O).overflow !== "visible") {
              _ = O;
              break;
            }
            O = O.parentElement;
          }
          _ && (r2.innerScrollOptions = {
            container: _,
            checkScrollEvent: true,
            ...R === true ? {} : R
          }, this.dragScroll.dragStart(t2, r2.innerScrollOptions), P = true);
        }
        !P && M && M.container && this.dragScroll.dragStart(t2, M), D && l && d && (r2.selectFlag = false, t2.preventDrag());
      }
      return true;
    });
    b(this, "_onDrag", (t2) => {
      if (t2.data.selectFlag) {
        const s2 = this.scrollOptions, r2 = t2.data.innerScrollOptions;
        if ((r2 || (s2 == null ? void 0 : s2.container)) && !t2.isScroll && this.dragScroll.drag(t2, r2 || s2))
          return;
      }
      this._checkSelected(t2);
    });
    b(this, "_onDragEnd", (t2) => {
      const { data: s2, inputEvent: r2 } = t2, o = xr(t2, this.options.ratio), i = s2.selectFlag, a = this.container;
      if (r2 && this.emit("dragEnd", {
        isDouble: !!t2.isDouble,
        isClick: !!t2.isClick,
        isDrag: false,
        isSelect: i,
        ...t2,
        data: s2.data,
        rect: o
      }), this.target.style.cssText += "display: none;", i)
        s2.selectFlag = false, this.dragScroll.dragEnd();
      else if (this.selectByClick && this.clickBySelectEnd) {
        const c = this._findElement(
          (r2 == null ? void 0 : r2.target) || Ja(a, t2.clientX, t2.clientY),
          s2.selectableTargets
        );
        this._select(c ? [c] : [], o, t2);
      }
      s2.preventDragFromInside || this._selectEnd(
        s2.startSelectedTargets,
        s2.startPassedTargets,
        o,
        t2
      );
    });
    b(this, "_onDocumentSelectStart", (t2) => {
      const s2 = Rt(this.container);
      if (!this.gesto.isFlag())
        return;
      let r2 = this.dragContainer;
      r2 === Mt(this.container) && (r2 = s2.documentElement);
      const o = le(r2) ? [r2] : [].slice.call(r2), i = t2.target;
      o.some((a) => {
        if (a === i || a.contains(i))
          return t2.preventDefault(), true;
      });
    });
    this.target = t.portalContainer;
    let s = t.container;
    this.options = {
      className: "",
      portalContainer: null,
      container: null,
      dragContainer: null,
      selectableTargets: [],
      selectByClick: true,
      selectFromInside: true,
      clickBySelectEnd: false,
      hitRate: 100,
      continueSelect: false,
      continueSelectWithoutDeselect: false,
      toggleContinueSelect: null,
      toggleContinueSelectWithoutDeselect: null,
      keyContainer: null,
      scrollOptions: null,
      checkInput: false,
      preventDefault: false,
      boundContainer: false,
      preventDragFromInside: true,
      dragCondition: null,
      rootContainer: null,
      checkOverflow: false,
      innerScrollOptions: false,
      getElementRect: cn,
      cspNonce: "",
      ratio: 0,
      ...t
    }, ic(this);
    const r = this.options.portalContainer;
    r && (s = r.parentElement), this.container = s || document.body, this.initElement(), this.initDragScroll(), this.setKeyController();
  }
  /**
   * You can set the currently selected targets.
   * selectByClick, continueSelect, and continueSelectWithoutDeselect are not applied.
   */
  setSelectedTargets(t) {
    const s = this.selectedTargets, { added: r, removed: o, prevList: i, list: a } = Ce(
      s,
      t
    );
    return this.selectedTargets = t, {
      added: r.map((c) => a[c]),
      removed: o.map((c) => i[c]),
      beforeSelected: s,
      selected: t
    };
  }
  /**
   * You can set the currently selected targets by points
   * selectByClick, continueSelect, and continueSelectWithoutDeselect are not applied.
   */
  setSelectedTargetsByPoints(t, s) {
    const r = Math.min(t[0], s[0]), o = Math.min(t[1], s[1]), i = Math.max(t[0], s[0]), a = Math.max(t[1], s[1]), c = {
      left: r,
      top: o,
      right: i,
      bottom: a,
      width: i - r,
      height: a - o
    }, l = { ignoreClick: true };
    this.findSelectableTargets(l);
    const u = this.hitTest(c, l, true, null);
    return {
      ...this.setSelectedTargets(u),
      rect: c
    };
  }
  /**
   * Select target by virtual drag from startPoint to endPoint.
   * The target of inputEvent is null.
   */
  selectTargetsByPoints(t, s) {
    const r = new MouseEvent("mousedown", {
      clientX: t[0],
      clientY: t[1],
      cancelable: true,
      bubbles: true
    }), o = new MouseEvent("mousemove", {
      clientX: s[0],
      clientY: s[1],
      cancelable: true,
      bubbles: true
    }), i = new MouseEvent("mousemove", {
      clientX: s[0],
      clientY: s[1],
      cancelable: true,
      bubbles: true
    }), a = this.gesto;
    a.onDragStart(r) !== false && (a.onDrag(o), a.onDragEnd(i));
  }
  /**
   * You can get the currently selected targets.
   */
  getSelectedTargets() {
    return this.selectedTargets;
  }
  /**
   * `OnDragStart` is triggered by an external event.
   * @param - external event
   * @example
   * import Selecto from "selecto";
   *
   * const selecto = new Selecto();
   *
   * window.addEventListener("mousedown", e => {
   *   selecto.triggerDragStart(e);
   * });
   */
  triggerDragStart(t) {
    return this.gesto.triggerDragStart(t), this;
  }
  /**
   * Destroy elements, properties, and events.
   */
  destroy() {
    var t;
    this.off(), this.gesto.unset(), this.injectResult.destroy(), this.dragScroll.dragEnd(), st(document, "selectstart", this._onDocumentSelectStart), this.options.portalContainer || (t = this.target.parentElement) == null || t.removeChild(this.target), window.removeEventListener("keydown", this._handleKeyDown), window.removeEventListener("keyup", this._handleKeyUp), window.removeEventListener("blur", this._handleBlur), this.gesto = null, this.injectResult = null, this.target = null, this.container = null, this.options = null;
  }
  getElementPoints(t) {
    const s = this.getElementRect || cn, r = s(t), o = [r.pos1, r.pos2, r.pos4, r.pos3];
    if (s !== cn) {
      const i = t.getBoundingClientRect();
      return fs(o, i);
    }
    return o;
  }
  /**
   * Get all elements set in `selectableTargets`.
   */
  getSelectableElements() {
    const t = this.container, s = [];
    return this.options.selectableTargets.forEach((r) => {
      if (Gn(r)) {
        const o = r();
        o && s.push(...[].slice.call(o));
      } else if (le(r))
        s.push(r);
      else if (Dt(r)) {
        const o = r.value || r.current;
        o && s.push(o);
      } else {
        const o = [].slice.call(
          Rt(t).querySelectorAll(r)
        );
        s.push(...o);
      }
    }), s;
  }
  /**
   * If scroll occurs during dragging, you can manually call this method to check the position again.
   */
  checkScroll() {
    if (!this.gesto.isFlag())
      return;
    const t = this.scrollOptions, s = this.gesto.getEventData().innerScrollOptions;
    (s || (t == null ? void 0 : t.container)) && this.dragScroll.checkScroll({
      inputEvent: this.gesto.getCurrentEvent(),
      ...s || t
    });
  }
  /**
   * Find for selectableTargets again during drag event
   * You can update selectable targets during an event.
   */
  findSelectableTargets(t = this.gesto.getEventData()) {
    const s = this.getSelectableElements(), r = s.map(
      (c) => this.getElementPoints(c)
    );
    t.selectableTargets = s, t.selectablePoints = r, t.selectableParentMap = null;
    const o = this.options, i = o.checkOverflow || o.innerScrollOptions, a = Rt(this.container);
    if (i) {
      const c = /* @__PURE__ */ new Map();
      t.selectableInnerScrollParentMap = c, t.selectableInnerScrollPathsList = s.map(
        (l, u) => {
          var p;
          let f = l.parentElement, h = [];
          const d = [];
          for (; f && f !== a.body; ) {
            let g = c.get(f);
            if (!g && getComputedStyle(f).overflow !== "visible") {
              const S = cn(f);
              g = {
                parentElement: f,
                indexes: [],
                points: [S.pos1, S.pos2, S.pos4, S.pos3],
                paths: [...d]
              }, h.push(f), h.forEach((v) => {
                c.set(v, g);
              }), h = [];
            }
            g ? (f = g.parentElement, (p = c.get(f)) == null || p.indexes.push(u), d.push(f)) : h.push(f), f = f.parentElement;
          }
          return d;
        }
      );
    }
    return o.checkOverflow || (t.selectableInners = s.map(() => true)), this._refreshGroups(t), s;
  }
  /**
   * External click or mouse events can be applied to the selecto.
   * @params - Extenal click or mouse event
   * @params - Specify the clicked target directly.
   */
  clickTarget(t, s) {
    const { clientX: r, clientY: o } = Za(t), i = {
      data: {
        selectFlag: false
      },
      clientX: r,
      clientY: o,
      inputEvent: t,
      isClick: true,
      isTrusted: false,
      stop: () => false
    };
    return this._onDragStart(i, s) && this._onDragEnd(i), this;
  }
  setKeyController() {
    window.addEventListener("keydown", this._handleKeyDown), window.addEventListener("keyup", this._handleKeyUp), window.addEventListener("blur", this._handleBlur);
  }
  setClassName(t) {
    this.options.className = t, this.target.setAttribute("class", `${Jn} ${t || ""}`);
  }
  setKeyEvent() {
    this.setKeyController();
  }
  // with getter, setter property
  setKeyContainer(t) {
    const s = this.options;
    Kn(s.keyContainer, t, () => {
      s.keyContainer = t, this.setKeyController();
    });
  }
  getContinueSelect() {
    return this._keydownContinueSelect;
  }
  getContinueSelectWithoutDeselect() {
    const {
      continueSelectWithoutDeselect: t,
      toggleContinueSelectWithoutDeselect: s
    } = this.options;
    return !s || !this._keydownContinueSelectWithoutDeselection ? t : !t;
  }
  setToggleContinueSelect(t) {
    const s = this.options;
    Kn(s.toggleContinueSelect, t, () => {
      s.toggleContinueSelect = t, this.setKeyEvent();
    });
  }
  setToggleContinueSelectWithoutDeselect(t) {
    const s = this.options;
    Kn(
      s.toggleContinueSelectWithoutDeselect,
      t,
      () => {
        s.toggleContinueSelectWithoutDeselect = t, this.setKeyEvent();
      }
    );
  }
  setPreventDefault(t) {
    this.gesto.options.preventDefault = t;
  }
  setCheckInput(t) {
    this.gesto.options.checkInput = t;
  }
  initElement() {
    const {
      dragContainer: t,
      checkInput: s,
      preventDefault: r,
      preventClickEventOnDragStart: o,
      preventClickEventOnDrag: i,
      preventClickEventByCondition: a,
      preventRightClick: c = true,
      className: l
    } = this.options, u = this.container;
    console.log({
      jsx: (0, import_jsx_runtime.jsx)("div", { className: `${Jn} ${l || ""}` })
    }), this.target = Mo(
      (0, import_jsx_runtime.jsx)("div", { className: `${Jn} ${l || ""}` }),
      this.target,
      u
    ), console.log(this.target);
    const f = this.target;
    this.dragContainer = typeof t == "string" ? [].slice.call(Rt(u).querySelectorAll(t)) : t || this.target.parentNode, this.gesto = new $n(this.dragContainer, {
      checkWindowBlur: true,
      container: Mt(u),
      checkInput: s,
      preventDefault: r,
      preventClickEventOnDragStart: o,
      preventClickEventOnDrag: i,
      preventClickEventByCondition: a,
      preventRightClick: c
    }).on("dragStart", this._onDragStart).on("drag", this._onDrag).on("dragEnd", this._onDragEnd), it(document, "selectstart", this._onDocumentSelectStart), this.injectResult = To.inject(f, {
      nonce: this.options.cspNonce
    });
  }
  hitTest(t, s, r, o) {
    const { hitRate: i, selectByClick: a } = this.options, { left: c, top: l, right: u, bottom: f } = t, h = s.innerGroups, d = s.innerWidth, p = s.innerHeight, g = o == null ? void 0 : o.clientX, m = o == null ? void 0 : o.clientY, S = s.ignoreClick, v = [
      [c, l],
      [u, l],
      [u, f],
      [c, f]
    ], x = (P, y) => {
      const k = ce(typeof i == "function" ? `${i(y)}` : `${i}`), _ = S ? false : Tn([g, m], P);
      if (!r && a && _)
        return true;
      const O = ls(v, P);
      if (!O.length)
        return false;
      let B = We(O), A = 0;
      return B === 0 && We(P) === 0 ? (A = Er(P), B = Er(O)) : A = We(P), k.unit === "px" ? B >= k.value : At(
        Math.round(B / A * 100),
        0,
        100
      ) >= Math.min(100, k.value);
    }, C = s.selectableTargets, E = s.selectablePoints, D = s.selectableInners;
    if (!h)
      return C.filter((P, y) => D[y] ? x(E[y], C[y]) : false);
    const T = [], w = Math.floor(c / d), z = Math.floor(u / d), M = Math.floor(l / p), R = Math.floor(f / p);
    for (let P = w; P <= z; ++P) {
      const y = h[P];
      if (y)
        for (let k = M; k <= R; ++k) {
          const _ = y[k];
          _ && _.forEach((O) => {
            const B = E[O], A = D[O], N = C[O];
            A && x(B, N) && T.push(N);
          });
        }
    }
    return Ka(T);
  }
  initDragScroll() {
    this.dragScroll.on("scrollDrag", ({ next: t }) => {
      t(this.gesto.getCurrentEvent());
    }).on("scroll", ({ container: t, direction: s }) => {
      this.gesto.getEventData().innerScrollOptions ? this.emit("innerScroll", {
        container: t,
        direction: s
      }) : this.emit("scroll", {
        container: t,
        direction: s
      });
    }).on("move", ({ offsetX: t, offsetY: s, inputEvent: r }) => {
      const o = this.gesto;
      if (!o || !o.isFlag())
        return;
      const i = this.gesto.getEventData(), a = i.boundArea;
      i.startX -= t, i.startY -= s;
      const c = this.gesto.getEventData().innerScrollOptions, l = c == null ? void 0 : c.container;
      let u = false;
      if (l) {
        const f = i.selectableInnerScrollParentMap, h = f.get(l);
        h && (h.paths.forEach((d) => {
          const p = f.get(d);
          p == null || p.points.forEach((g) => {
            g[0] -= t, g[1] -= s;
          });
        }), h.indexes.forEach((d) => {
          i.selectablePoints[d].forEach((p) => {
            p[0] -= t, p[1] -= s;
          });
        }), u = true);
      }
      u || i.selectablePoints.forEach((f) => {
        f.forEach((h) => {
          h[0] -= t, h[1] -= s;
        });
      }), this._refreshGroups(i), a.left -= t, a.right -= t, a.top -= s, a.bottom -= s, this.gesto.scrollBy(
        t,
        s,
        r.inputEvent
        // false
      ), this._checkSelected(this.gesto.getCurrentEvent());
    });
  }
  _select(t, s, r, o, i = false) {
    const a = r.inputEvent, c = r.data, l = this.setSelectedTargets(t), { added: u, removed: f, prevList: h, list: d } = Ce(
      c.startSelectedTargets,
      t
    ), p = {
      startSelected: h,
      startAdded: u.map((g) => d[g]),
      startRemoved: f.map((g) => h[g])
    };
    o && this.emit("selectStart", {
      ...l,
      ...p,
      rect: s,
      inputEvent: a,
      data: c.data,
      isTrusted: r.isTrusted,
      isDragStartEnd: i
    }), (l.added.length || l.removed.length) && this.emit("select", {
      ...l,
      ...p,
      rect: s,
      inputEvent: a,
      data: c.data,
      isTrusted: r.isTrusted,
      isDragStartEnd: i
    });
  }
  _selectEnd(t, s, r, o, i = false) {
    const { inputEvent: a, isDouble: c, data: l } = o, u = a && a.type, f = u === "mousedown" || u === "touchstart", { added: h, removed: d, prevList: p, list: g } = Ce(
      t,
      this.selectedTargets
    ), {
      added: m,
      removed: S,
      prevList: v,
      list: x
    } = Ce(s, this.selectedTargets);
    this.emit("selectEnd", {
      startSelected: t,
      beforeSelected: s,
      selected: this.selectedTargets,
      added: h.map((C) => g[C]),
      removed: d.map((C) => p[C]),
      afterAdded: m.map((C) => x[C]),
      afterRemoved: S.map((C) => v[C]),
      isDragStart: f && i,
      isDragStartEnd: f && i,
      isClick: !!o.isClick,
      isDouble: !!c,
      rect: r,
      inputEvent: a,
      data: l.data,
      isTrusted: o.isTrusted
    });
  }
  _checkSelected(t, s = xr(t, this.options.ratio)) {
    const { data: r } = t, { top: o, left: i, width: a, height: c } = s, l = r.selectFlag, { containerX: u, containerY: f, scaleMatrix: h } = r, d = vn(h, [
      i - u,
      o - f
    ]), p = vn(h, [a, c]);
    let g = [];
    if (l) {
      this.target.style.cssText += `display: block;left:0px;top:0px;transform: translate(${d[0]}px, ${d[1]}px);width:${p[0]}px;height:${p[1]}px;`;
      const S = this.hitTest(s, r, true, t);
      g = vr(
        r.startPassedTargets,
        S,
        this.continueSelect && this.continueSelectWithoutDeselect
      );
    }
    if (this.emit("drag", {
      ...t,
      data: r.data,
      isSelect: l,
      rect: s
    }) === false) {
      this.target.style.cssText += "display: none;", t.stop();
      return;
    }
    l && this._select(g, s, t);
  }
  _findElement(t, s) {
    let r = t;
    for (; r && !(s.indexOf(r) > -1); )
      r = r.parentElement;
    return r;
  }
  _refreshGroups(t) {
    var i;
    const s = t.innerWidth, r = t.innerHeight, o = t.selectablePoints;
    if (this.options.checkOverflow) {
      const a = (i = this.gesto.getEventData().innerScrollOptions) == null ? void 0 : i.container, c = t.selectableInnerScrollParentMap, l = t.selectableInnerScrollPathsList;
      t.selectableInners = l.map(
        (u, f) => {
          let h = false;
          return u.every((d) => {
            if (h)
              return true;
            if (d === a)
              return h = true, true;
            const p = c.get(d);
            if (p) {
              const g = o[f], m = p.points;
              if (!ls(g, m).length)
                return false;
            }
            return true;
          });
        }
      );
    }
    if (!s || !r)
      t.innerGroups = null;
    else {
      const a = t.selectablePoints, c = {};
      a.forEach((l, u) => {
        let f = 1 / 0, h = -1 / 0, d = 1 / 0, p = -1 / 0;
        l.forEach((g) => {
          const m = Math.floor(g[0] / s), S = Math.floor(g[1] / r);
          f = Math.min(m, f), h = Math.max(m, h), d = Math.min(S, d), p = Math.max(S, p);
        });
        for (let g = f; g <= h; ++g)
          for (let m = d; m <= p; ++m)
            c[g] = c[g] || {}, c[g][m] = c[g][m] || [], c[g][m].push(u);
      }), t.innerGroups = c;
    }
  }
};
function tn(e, n) {
  return {
    events: [],
    props: [],
    name: e,
    ...n
  };
}
function Ys(e, n) {
  for (var t = e.length, s = 0; s < t; ++s)
    if (n(e[s], s))
      return true;
  return false;
}
function Ro(e, n) {
  for (var t = e.length, s = 0; s < t; ++s)
    if (n(e[s], s))
      return e[s];
  return null;
}
function yo(e) {
  var n = e;
  if (typeof n > "u") {
    if (typeof navigator > "u" || !navigator)
      return "";
    n = navigator.userAgent || "";
  }
  return n.toLowerCase();
}
function Fs(e, n) {
  try {
    return new RegExp(e, "g").exec(n);
  } catch {
    return null;
  }
}
function ac() {
  if (typeof navigator > "u" || !navigator || !navigator.userAgentData)
    return false;
  var e = navigator.userAgentData, n = e.brands || e.uaList;
  return !!(n && n.length);
}
function cc(e, n) {
  var t = Fs("(" + e + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", n);
  return t ? t[3] : "";
}
function ds(e) {
  return e.replace(/_/g, ".");
}
function Xe(e, n) {
  var t = null, s = "-1";
  return Ys(e, function(r) {
    var o = Fs("(" + r.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", n);
    return !o || r.brand ? false : (t = r, s = o[3] || "-1", r.versionAlias ? s = r.versionAlias : r.versionTest && (s = cc(r.versionTest.toLowerCase(), n) || s), s = ds(s), true);
  }), {
    preset: t,
    version: s
  };
}
function ln(e, n) {
  var t = {
    brand: "",
    version: "-1"
  };
  return Ys(e, function(s) {
    var r = zo(n, s);
    return r ? (t.brand = s.id, t.version = s.versionAlias || r.version, t.version !== "-1") : false;
  }), t;
}
function zo(e, n) {
  return Ro(e, function(t) {
    var s = t.brand;
    return Fs("" + n.test, s.toLowerCase());
  });
}
var Po = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}];
var _o = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: true
}];
var ps = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}];
var Oo = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  // test webview
  test: "webview",
  id: "webview"
}];
var Io = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "win32|windows",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "macos|macintel|mac os x",
  id: "mac"
}, {
  test: "android|linux armv81",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];
function Bo(e) {
  return !!Xe(Oo, e).preset;
}
function lc(e) {
  var n = yo(e), t = !!/mobi/g.exec(n), s = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: Bo(n),
    chromium: false,
    chromiumVersion: "-1",
    webkit: false,
    webkitVersion: "-1"
  }, r = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  }, o = Xe(Po, n), i = o.preset, a = o.version, c = Xe(Io, n), l = c.preset, u = c.version, f = Xe(_o, n);
  if (s.chromium = !!f.preset, s.chromiumVersion = f.version, !s.chromium) {
    var h = Xe(ps, n);
    s.webkit = !!h.preset, s.webkitVersion = h.version;
  }
  return l && (r.name = l.id, r.version = u, r.majorVersion = parseInt(u, 10)), i && (s.name = i.id, s.version = a, s.webview && r.name === "ios" && s.name !== "safari" && (s.webview = false)), s.majorVersion = parseInt(s.version, 10), {
    browser: s,
    os: r,
    isMobile: t,
    isHints: false
  };
}
function uc(e) {
  var n = navigator.userAgentData, t = (n.uaList || n.brands).slice(), s = n.mobile || false, r = t[0], o = (n.platform || navigator.platform).toLowerCase(), i = {
    name: r.brand,
    version: r.version,
    majorVersion: -1,
    webkit: false,
    webkitVersion: "-1",
    chromium: false,
    chromiumVersion: "-1",
    webview: !!ln(Oo, t).brand || Bo(yo())
  }, a = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  i.webkit = !i.chromium && Ys(ps, function(h) {
    return zo(t, h);
  });
  var c = ln(_o, t);
  if (i.chromium = !!c.brand, i.chromiumVersion = c.version || "-1", !i.chromium) {
    var l = ln(ps, t);
    i.webkit = !!l.brand, i.webkitVersion = l.version || "-1";
  }
  var u = Ro(Io, function(h) {
    return new RegExp("" + h.test, "g").exec(o);
  });
  a.name = u ? u.id : "";
  {
    var f = ln(Po, t);
    i.name = f.brand || i.name, i.version = f.brand && e ? e.uaFullVersion : f.version;
  }
  return i.webkit && (a.name = s ? "ios" : "mac"), a.name === "ios" && i.webview && (i.version = "-1"), a.version = ds(a.version), i.version = ds(i.version), a.majorVersion = parseInt(a.version, 10), i.majorVersion = parseInt(i.version, 10), {
    browser: i,
    os: a,
    isMobile: s,
    isHints: true
  };
}
function Ao(e) {
  return ac() ? uc() : lc(e);
}
var fc = ["n", "w", "s", "e"];
var Ls = ["n", "w", "s", "e", "nw", "ne", "sw", "se"];
function hc(e, n) {
  return `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="${32 * e}px" height="${32 * e}px" viewBox="0 0 32 32" ><path d="M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z" stroke-linejoin="round" stroke-width="1.2" fill="black" stroke="white" style="transform:rotate(${n}deg);transform-origin: 16px 16px"></path></svg>`;
}
function dc(e) {
  const n = hc(1, e), t = Math.round(e / 45) * 45 % 180;
  let s = "ns-resize";
  return t === 135 ? s = "nwse-resize" : t === 45 ? s = "nesw-resize" : t === 90 && (s = "ew-resize"), `cursor:${s};cursor: url('${n}') 16 16, ${s};`;
}
var Ge = Ao();
var Go = Ge.browser.webkit;
var $o = Go && (() => {
  const e = typeof window > "u" ? { userAgent: "" } : window.navigator, n = /applewebkit\/([^\s]+)/g.exec(e.userAgent.toLowerCase());
  return n ? parseFloat(n[1]) < 605 : false;
})();
var ko = Ge.browser.name;
var Xo = parseInt(Ge.browser.version, 10);
var pc = ko === "chrome";
var gc = Ge.browser.chromium;
var mc = parseInt(Ge.browser.chromiumVersion, 10) || 0;
var Sc = pc && Xo >= 109 || gc && mc >= 109;
var xc = ko === "firefox";
var vc = parseInt(Ge.browser.webkitVersion, 10) >= 612 || Xo >= 15;
var Ws = "moveable-";
var Ec = Ls.map((e) => {
  let n = "", t = "", s = "center", r = "center";
  const o = "calc(var(--moveable-control-padding, 20) * -1px)";
  return e.indexOf("n") > -1 && (n = `top: ${o};`, r = "bottom"), e.indexOf("s") > -1 && (n = "top: 0px;", r = "top"), e.indexOf("w") > -1 && (t = `left: ${o};`, s = "right"), e.indexOf("e") > -1 && (t = "left: 0px;", s = "left"), `.around-control[data-direction*="${e}"] {
        ${t}${n}
        transform-origin: ${s} ${r};
    }`;
}).join(`
`);
var Cc = `
{
position: absolute;
width: 1px;
height: 1px;
left: 0;
top: 0;
z-index: 3000;
--moveable-color: #4af;
--zoom: 1;
--zoompx: 1px;
--moveable-line-padding: 0;
--moveable-control-padding: 0;
will-change: transform;
outline: 1px solid transparent;
}
.control-box {
z-index: 0;
}
.line, .control {
position: absolute;
left: 0;
top: 0;
will-change: transform;
}
.control {
width: 14px;
height: 14px;
border-radius: 50%;
border: 2px solid #fff;
box-sizing: border-box;
background: #4af;
background: var(--moveable-color);
margin-top: -7px;
margin-left: -7px;
border: 2px solid #fff;
z-index: 10;
}
.around-control {
position: absolute;
will-change: transform;
width: calc(var(--moveable-control-padding, 20) * 1px);
height: calc(var(--moveable-control-padding, 20) * 1px);
left: calc(var(--moveable-control-padding, 20) * -0.5px);
top: calc(var(--moveable-control-padding, 20) * -0.5px);
box-sizing: border-box;
background: transparent;
z-index: 8;
cursor: alias;
transform-origin: center center;
}
${Ec}
.padding {
position: absolute;
top: 0px;
left: 0px;
width: 100px;
height: 100px;
transform-origin: 0 0;
}
.line {
width: 1px;
height: 1px;
background: #4af;
background: var(--moveable-color);
transform-origin: 0px 50%;
}
.line.edge {
z-index: 1;
background: transparent;
}
.line.dashed {
box-sizing: border-box;
background: transparent;
}
.line.dashed.horizontal {
border-top: 1px dashed #4af;
border-top-color: #4af;
border-top-color: var(--moveable-color);
}
.line.dashed.vertical {
border-left: 1px dashed #4af;
border-left-color: #4af;
border-left-color: var(--moveable-color);
}
.line.vertical {
transform: translateX(-50%);
}
.line.horizontal {
transform: translateY(-50%);
}
.line.vertical.bold {
width: 2px;
}
.line.horizontal.bold {
height: 2px;
}

.control.origin {
border-color: #f55;
background: #fff;
width: 12px;
height: 12px;
margin-top: -6px;
margin-left: -6px;
pointer-events: none;
}
${[0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(
  (e) => `
.direction[data-rotation="${e}"], :global .view-control-rotation${e} {
${dc(e)}
}
`
).join(`
`)}

.line.direction:before {
content: "";
position: absolute;
width: 100%;
height: calc(var(--moveable-line-padding, 0) * 1px);
bottom: 0;
left: 0;
}
.group {
z-index: -1;
}
.area {
position: absolute;
}
.area-pieces {
position: absolute;
top: 0;
left: 0;
display: none;
}
.area.avoid, .area.pass {
pointer-events: none;
}
.area.avoid+.area-pieces {
display: block;
}
.area-piece {
position: absolute;
}

${$o ? `:global svg *:before {
content:"";
transform-origin: inherit;
}` : ""}
`;
var Dc = [
  [0, 1, 2],
  [1, 0, 3],
  [2, 0, 3],
  [3, 1, 2]
];
var gs = 1e-4;
var bt = 1e-7;
var un = 1e-9;
var ms = Math.pow(10, 10);
var Cr = -ms;
var bc = {
  n: [0, -1],
  e: [1, 0],
  s: [0, 1],
  w: [-1, 0],
  nw: [-1, -1],
  ne: [1, -1],
  sw: [-1, 1],
  se: [1, 1]
};
var Ns = {
  n: [0, 1],
  e: [1, 3],
  s: [3, 2],
  w: [2, 0],
  nw: [0],
  ne: [1],
  sw: [2],
  se: [3]
};
var Yo = {
  n: 0,
  s: 180,
  w: 270,
  e: 90,
  nw: 315,
  ne: 45,
  sw: 225,
  se: 135
};
var wc = [
  "isMoveableElement",
  "updateRect",
  "updateTarget",
  "destroy",
  "dragStart",
  "isInside",
  "hitTest",
  "setState",
  "getRect",
  "request",
  "isDragging",
  "getManager",
  "forceUpdate",
  "waitToChangeTarget",
  "updateSelectors",
  "getTargets",
  "stopDrag",
  "getControlBoxElement",
  "getMoveables",
  "getDragElement"
];
function Mc(e, ...n) {
  return n.map(
    (t) => t.split(" ").map((s) => s ? `${e}${s}` : "").join(" ")
  ).join(" ");
}
function _t(e, n) {
  return (t) => {
    t && (e[n] = t);
  };
}
function Fo(e, n, t) {
  return (s) => {
    s && (e[n][t] = s);
  };
}
function Lo(e, n) {
  return n.replace(/([^}{]*){/gm, (t, s) => `${s.replace(/\.([^{,\s\d.]+)/g, `.${e}$1`)}{`);
}
function en(e, n, t, s, r, o = "draggable") {
  var l;
  const i = ((l = n.gestos[o]) == null ? void 0 : l.move(t, e.inputEvent)) ?? {}, a = i.originalDatas || i.datas, c = a[o] || (a[o] = {});
  return {
    ...i,
    isPinch: !!s,
    parentEvent: true,
    datas: c,
    originalDatas: e.originalDatas
  };
}
var Pe = class {
  constructor(n = "draggable") {
    b(this, "prevX", 0);
    b(this, "prevY", 0);
    b(this, "startX", 0);
    b(this, "startY", 0);
    b(this, "isDrag", false);
    b(this, "isFlag", false);
    b(this, "datas", {
      draggable: {}
    });
    this.ableName = n, this.datas = {
      [n]: {}
    };
  }
  dragStart(n, t) {
    this.isDrag = false, this.isFlag = false;
    const s = t.originalDatas;
    return this.datas = s, s[this.ableName] || (s[this.ableName] = {}), {
      ...this.move(n, t.inputEvent),
      type: "dragstart"
    };
  }
  drag(n, t) {
    return this.move(
      [n[0] - this.prevX, n[1] - this.prevY],
      t
    );
  }
  move(n, t) {
    let s, r, o = false;
    if (!this.isFlag)
      this.prevX = n[0], this.prevY = n[1], this.startX = n[0], this.startY = n[1], s = n[0], r = n[1], this.isFlag = true;
    else {
      const i = this.isDrag;
      s = this.prevX + n[0], r = this.prevY + n[1], (n[0] || n[1]) && (this.isDrag = true), !i && this.isDrag && (o = true);
    }
    return this.prevX = s, this.prevY = r, {
      type: "drag",
      clientX: s,
      clientY: r,
      inputEvent: t,
      isFirstDrag: o,
      isDrag: this.isDrag,
      distX: s - this.startX,
      distY: r - this.startY,
      deltaX: n[0],
      deltaY: n[1],
      datas: this.datas[this.ableName],
      originalDatas: this.datas,
      parentEvent: true,
      parentGesto: this
    };
  }
};
function Te(e, n, t, s) {
  const o = e.length === 16 ? 4 : 3, i = me(e, t, s, o);
  let [[a, c], [l, u], [f, h], [d, p]] = i, [g, m] = at(e, n, o);
  const S = Math.min(a, l, f, d), v = Math.min(c, u, h, p), x = Math.max(a, l, f, d), C = Math.max(c, u, h, p);
  a = a - S || 0, l = l - S || 0, f = f - S || 0, d = d - S || 0, c = c - v || 0, u = u - v || 0, h = h - v || 0, p = p - v || 0, g = g - S || 0, m = m - v || 0;
  const E = e[0], D = e[o + 1], T = Et(E * D);
  return {
    left: S,
    top: v,
    right: x,
    bottom: C,
    origin: [g, m],
    pos1: [a, c],
    pos2: [l, u],
    pos3: [f, h],
    pos4: [d, p],
    direction: T
  };
}
function Wo(e, n) {
  const { clientX: t, clientY: s, datas: r } = n, { moveableClientRect: o, rootMatrix: i, is3d: a, pos1: c } = e.state, { left: l, top: u } = o, f = a ? 4 : 3, [h, d] = V(
    Ie(i, [t - l, s - u], f),
    c
  ), [p, g] = Vt({ datas: r, distX: h, distY: d });
  return [p, g];
}
function ge(e, { datas: n }) {
  const {
    allMatrix: t,
    beforeMatrix: s,
    is3d: r,
    left: o,
    top: i,
    origin: a,
    offsetMatrix: c,
    targetMatrix: l,
    transformOrigin: u
  } = e.state, f = r ? 4 : 3;
  n.is3d = r, n.matrix = t, n.targetMatrix = l, n.beforeMatrix = s, n.offsetMatrix = c, n.transformOrigin = u, n.inverseMatrix = kt(t, f), n.inverseBeforeMatrix = kt(s, f), n.absoluteOrigin = fe(tt([o, i], a), f), n.startDragBeforeDist = mt(
    n.inverseBeforeMatrix,
    n.absoluteOrigin,
    f
  ), n.startDragDist = mt(n.inverseMatrix, n.absoluteOrigin, f);
}
function Tc(e) {
  return Te(e.datas.beforeTransform, [50, 50], 100, 100).direction;
}
function kn(e, n, t) {
  const {
    datas: s,
    originalDatas: { beforeRenderable: r }
  } = n, o = s.transformIndex, i = r.nextTransforms, a = i.length, c = r.nextTransformAppendedIndexes;
  let l = -1;
  o === -1 ? (t === "translate" ? l = 0 : t === "rotate" && (l = Ut(i, (d) => d.match(/scale\(/g))), l === -1 && (l = i.length), s.transformIndex = l) : yt(
    c,
    (d) => d.index === o && d.functionName === t
  ) ? l = o : l = o + c.filter((d) => d.index < o).length;
  const u = Jl(
    i,
    e.state,
    l
  ), f = u.targetFunction, h = t === "rotate" ? "rotateZ" : t;
  s.beforeFunctionTexts = u.beforeFunctionTexts, s.afterFunctionTexts = u.afterFunctionTexts, s.beforeTransform = u.beforeFunctionMatrix, s.beforeTransform2 = u.beforeFunctionMatrix2, s.targetTansform = u.targetFunctionMatrix, s.afterTransform = u.afterFunctionMatrix, s.afterTransform2 = u.afterFunctionMatrix2, s.targetAllTransform = u.allFunctionMatrix, f.functionName === h ? (s.afterFunctionTexts.splice(0, 1), s.isAppendTransform = false) : a > l && (s.isAppendTransform = true, r.nextTransformAppendedIndexes = [
    ...c,
    {
      functionName: t,
      index: l,
      isAppend: true
    }
  ]);
}
function Xn(e, n, t) {
  return `${e.beforeFunctionTexts.join(" ")} ${e.isAppendTransform ? t : n} ${e.afterFunctionTexts.join(" ")}`;
}
function Rc({ datas: e, distX: n, distY: t }) {
  const [s, r] = Ho({ datas: e, distX: n, distY: t }), o = No(e, Na([s, r], 4));
  return mt(o, fe([0, 0, 0], 4), 4);
}
function No(e, n, t) {
  const {
    beforeTransform: s,
    afterTransform: r,
    beforeTransform2: o,
    afterTransform2: i,
    targetAllTransform: a
  } = e, c = t ? et(a, n, 4) : et(n, a, 4), l = et(
    kt(t ? o : s, 4),
    c,
    4
  );
  return et(
    l,
    kt(t ? i : r, 4),
    4
  );
}
function Ho({ datas: e, distX: n, distY: t }) {
  const { inverseBeforeMatrix: s, is3d: r, startDragBeforeDist: o, absoluteOrigin: i } = e, a = r ? 4 : 3;
  return V(
    mt(s, tt(i, [n, t]), a),
    o
  );
}
function Vt({ datas: e, distX: n, distY: t }, s) {
  const {
    inverseBeforeMatrix: r,
    inverseMatrix: o,
    is3d: i,
    startDragBeforeDist: a,
    startDragDist: c,
    absoluteOrigin: l
  } = e, u = i ? 4 : 3;
  return V(
    mt(
      s ? r : o,
      tt(l, [n, t]),
      u
    ),
    s ? a : c
  );
}
function yc({ datas: e, distX: n, distY: t }, s) {
  const {
    beforeMatrix: r,
    matrix: o,
    is3d: i,
    startDragBeforeDist: a,
    startDragDist: c,
    absoluteOrigin: l
  } = e, u = i ? 4 : 3;
  return V(
    mt(
      o,
      tt(c, [n, t]),
      u
    ),
    l
  );
}
function zc(e, n, t, s = n, r = t, o = [0, 0]) {
  return e ? e.map((i, a) => {
    const { value: c, unit: l } = ce(i), u = a ? r : s, f = a ? t : n;
    if (i === "%" || isNaN(c)) {
      const h = u ? o[a] / u : 0;
      return f * h;
    } else if (l !== "%")
      return c;
    return f * c / 100;
  }) : o;
}
function Vo(e) {
  const n = [];
  return e[1] >= 0 && (e[0] >= 0 && n.push(3), e[0] <= 0 && n.push(2)), e[1] <= 0 && (e[0] >= 0 && n.push(1), e[0] <= 0 && n.push(0)), n;
}
function Pc(e, n) {
  return Vo(n).map((t) => e[t]);
}
function Qn(e, n) {
  const t = (n + 1) / 2;
  return [
    bn(e[0][0], e[1][0], t, 1 - t),
    bn(e[0][1], e[1][1], t, 1 - t)
  ];
}
function gt(e, n) {
  const t = Qn([e[0], e[1]], n[0]), s = Qn([e[2], e[3]], n[0]);
  return Qn([t, s], n[1]);
}
function _c(e, n, t, s, r, o) {
  const i = me(n, t, s, r), a = gt(i, o), c = e[0] - a[0], l = e[1] - a[1];
  return [c, l];
}
function nn(e, n, t, s) {
  return et(e, He(n, s, t), s);
}
function Oc(e, n, t, s) {
  const { transformOrigin: r, offsetMatrix: o, is3d: i } = e, a = i ? 4 : 3;
  let c;
  if (Yt(t)) {
    const { beforeTransform: l, afterTransform: u } = n;
    s ? c = Xt(ye(t), 4, a) : c = Xt(
      et(
        et(l, ye([t]), 4),
        u,
        4
      ),
      4,
      a
    );
  } else
    c = t;
  return nn(o, c, r, a);
}
function Ic(e, n) {
  const {
    transformOrigin: t,
    offsetMatrix: s,
    is3d: r,
    targetMatrix: o,
    targetAllTransform: i
  } = e, a = r ? 4 : 3;
  return nn(
    s,
    et(
      i || o,
      Gs(n, a),
      a
    ),
    t,
    a
  );
}
function Yn(e, n) {
  const t = $e(n);
  return {
    setTransform: (s, r = -1) => {
      t.startTransforms = ct(s) ? s : Qt(s), Ss(e, n, r);
    },
    setTransformIndex: (s) => {
      Ss(e, n, s);
    }
  };
}
function Fn(e, n, t) {
  const r = $e(n).startTransforms;
  Ss(
    e,
    n,
    Ut(
      r,
      (o) => o.indexOf(`${t}(`) === 0
    )
  );
}
function Ss(e, n, t) {
  const s = $e(n), r = n.datas;
  if (r.transformIndex = t, t === -1)
    return;
  const o = s.startTransforms[t];
  if (!o)
    return;
  const i = e.state, a = ze([o], {
    "x%": (c) => c / 100 * i.offsetWidth,
    "y%": (c) => c / 100 * i.offsetHeight
  });
  r.startValue = a[0].functionValue;
}
function Hs(e, n) {
  const t = $e(e);
  t.nextTransforms = Qt(n);
}
function $e(e) {
  return e.originalDatas.beforeRenderable;
}
function yn(e) {
  const {
    originalDatas: { beforeRenderable: n }
  } = e;
  return n.nextTransforms;
}
function fn(e) {
  return (yn(e) || []).join(" ");
}
function hn(e) {
  return $e(e).nextStyle;
}
function qo(e, n, t, s, r) {
  Hs(r, n);
  const o = vt.drag(
    e,
    en(r, e.state, t, s)
  ), i = o ? o.transform : n;
  return {
    transform: n,
    drag: o,
    ...Ct(
      {
        transform: i
      },
      r
    ),
    afterTransform: i
  };
}
function Vs(e, n, t, s, r, o) {
  const i = Oc(
    e.state,
    r,
    n,
    o
  );
  return Gc(
    e,
    t,
    s,
    i
  );
}
function jo(e, n, t, s, r, o, i) {
  const a = Vs(
    e,
    n,
    t,
    r,
    o,
    i
  ), c = e.state, { left: l, top: u } = c, f = e.props.groupable, h = f ? l : 0, d = f ? u : 0, p = V(s, a);
  return V(p, [h, d]);
}
function Bc(e, n, t, s, r, o, i) {
  return jo(
    e,
    n,
    t,
    s,
    r,
    o,
    i
  );
}
function Ac(e, n, t) {
  return [
    n ? -1 + e[0] / (n / 2) : 0,
    t ? -1 + e[1] / (t / 2) : 0
  ];
}
function Gc(e, n, t, s = e.state.allMatrix) {
  const { width: r, height: o, is3d: i } = e.state, a = i ? 4 : 3, c = [
    r / 2 * (1 + n[0]) + t[0],
    o / 2 * (1 + n[1]) + t[1]
  ];
  return at(s, c, a);
}
function $c(e, n, t) {
  const s = t.fixedDirection, r = t.fixedPosition, o = t.fixedOffset;
  return jo(
    e,
    `rotate(${n}deg)`,
    s,
    r,
    o,
    t
  );
}
function kc(e, n, t, s, r, o) {
  const { groupable: i } = e.props, a = e.state, {
    transformOrigin: c,
    offsetMatrix: l,
    is3d: u,
    width: f,
    height: h,
    left: d,
    top: p
  } = a, g = o.fixedDirection, m = o.nextTargetMatrix || a.targetMatrix, S = u ? 4 : 3, v = zc(
    r,
    n,
    t,
    f,
    h,
    c
  ), x = i ? d : 0, C = i ? p : 0, E = nn(l, m, v, S), D = _c(
    s,
    E,
    n,
    t,
    S,
    g
  );
  return V(D, [x, C]);
}
function Xc(e, n) {
  return gt(Bt(e.state), n);
}
function Yc(e, n) {
  const t = e.targetGesto, s = e.controlGesto;
  let r;
  return t != null && t.isFlag() && (r = t.getEventData()[n]), !r && (s != null && s.isFlag()) && (r = s.getEventData()[n]), r || {};
}
function Fc(e) {
  if (e && e.getRootNode) {
    const n = e.getRootNode();
    if (n.nodeType === 11)
      return n;
  }
}
function Lc(e) {
  const n = e("scale"), t = e("rotate"), s = e("translate"), r = [];
  return s && s !== "0px" && s !== "none" && r.push(`translate(${s.split(/\s+/).join(",")})`), t && t !== "1" && t !== "none" && r.push(`rotate(${t})`), n && n !== "1" && n !== "none" && r.push(`scale(${n.split(/\s+/).join(",")})`), r;
}
function Uo(e, n, t) {
  let s = e;
  const r = [], o = Bs(e) || ne(e);
  let i = !t && e === n || e === o, a = i, c = false, l = 3, u, f, h, d = false, p = Ke(n, n, true).offsetParent, g = 1;
  for (; s && !a; ) {
    a = i;
    const m = Tt(s), S = m("position"), v = vi(s), x = S === "fixed", C = Lc(m);
    let E = Ha(Xl(v)), D, T = false, w = false, z = 0, M = 0, R = 0, P = 0, y = {
      hasTransform: false,
      fixedContainer: null
    };
    x && (d = true, y = Nl(s), p = y.fixedContainer);
    const k = E.length;
    !c && (k === 16 || C.length) && (c = true, l = 4, bs(r), h && (h = Xt(h, 3, 4))), c && k === 9 && (E = Xt(E, 3, 4));
    const {
      tagName: _,
      hasOffset: O,
      isSVG: B,
      origin: A,
      targetOrigin: N,
      offset: G
    } = Wl(s, e);
    let [Y, q] = G;
    _ === "svg" && !s.ownerSVGElement && h && (r.push({
      type: "target",
      target: s,
      matrix: Hl(s, l)
    }), r.push({
      type: "offset",
      target: s,
      matrix: rt(l)
    }));
    const X = parseFloat(m("zoom")) || 1;
    if (x)
      D = y.fixedContainer, T = true;
    else {
      const W = Ke(s, n, false, true, m), Z = W.offsetZoom;
      if (D = W.offsetParent, T = W.isEnd, w = W.isStatic, g *= Z, (W.isCustomElement || Z !== 1) && w)
        Y -= D.offsetLeft, q -= D.offsetTop;
      else if ((xc || Sc) && W.parentSlotElement) {
        let L = D, j = 0, ot = 0;
        for (; L && Fc(L); )
          j += L.offsetLeft, ot += L.offsetTop, L = L.offsetParent;
        Y -= j, q -= ot;
      }
    }
    if (Go && !vc && O && !B && w && (S === "relative" || S === "static") && (Y -= D.offsetLeft, q -= D.offsetTop, i = i || T), x)
      O && y.hasTransform && (R = D.clientLeft, P = D.clientTop);
    else if (O && p !== D && (z = D.clientLeft, M = D.clientTop), O && D === o) {
      const W = Ei(s, false);
      Y += W[0], q += W[1];
    }
    if (r.push({
      type: "target",
      target: s,
      matrix: He(E, l, A)
    }), C.length && (r.push({
      type: "offset",
      target: s,
      matrix: rt(l)
    }), r.push({
      type: "target",
      target: s,
      matrix: He(ye(C), l, A)
    })), O) {
      const W = s === e, Z = W ? 0 : s.scrollLeft, $ = W ? 0 : s.scrollTop;
      r.push({
        type: "offset",
        target: s,
        matrix: he(
          [
            Y - Z + z - R,
            q - $ + M - P
          ],
          l
        )
      });
    } else
      r.push({
        type: "offset",
        target: s,
        origin: A
      });
    if (X !== 1 && r.push({
      type: "zoom",
      target: s,
      matrix: He(
        Gs([X, X], l),
        l,
        [0, 0]
      )
    }), h || (h = E), u || (u = A), f || (f = N), a || x)
      break;
    s = D, i = T, (!t || s === o) && (a = i);
  }
  return h || (h = rt(l)), u || (u = [0, 0]), f || (f = [0, 0]), {
    zoom: g,
    offsetContainer: p,
    matrixes: r,
    targetMatrix: h,
    transformOrigin: u,
    targetOrigin: f,
    is3d: c,
    hasFixed: d
  };
}
var se = null;
var re = null;
var De = null;
function _e(e) {
  e ? (window.Map && (se = /* @__PURE__ */ new Map(), re = /* @__PURE__ */ new Map()), De = []) : (se = null, De = null, re = null);
}
function Wc(e) {
  const n = re == null ? void 0 : re.get(e);
  if (n)
    return n;
  const t = Ve(e, true);
  return re && re.set(e, t), t;
}
function Nc(e, n) {
  if (De) {
    const s = yt(
      De,
      (r) => r[0][0] == e && r[0][1] == n
    );
    if (s)
      return s[1];
  }
  const t = Uo(e, n, true);
  return De && De.push([[e, n], t]), t;
}
function Tt(e) {
  let n = se == null ? void 0 : se.get(e);
  if (!n) {
    const r = Mt(e).getComputedStyle(e);
    if (!se)
      return (o) => r[o];
    n = {
      style: r,
      cached: {}
    }, se.set(e, n);
  }
  const t = n.cached, s = n.style;
  return (r) => (r in t || (t[r] = s[r]), t[r]);
}
function $t(e, n, t) {
  const s = t.originalDatas;
  s.groupable = s.groupable || {};
  const r = s.groupable;
  r.childDatas = r.childDatas || [];
  const o = r.childDatas;
  return e.moveables.map((i, a) => (o[a] = o[a] || {}, o[a][n] = o[a][n] || {}, {
    ...t,
    isRequestChild: true,
    datas: o[a][n],
    originalDatas: o[a]
  }));
}
function ts(e, n, t, s, r, o, i) {
  const a = !!t.match(/Start$/g), c = !!t.match(/End$/g), l = r.isPinch, u = r.datas, f = $t(e, n.name, r), h = e.moveables, d = [], p = f.map((g, m) => {
    const S = h[m], v = S.state, x = v.gestos;
    let C = g;
    if (a)
      C = new Pe(i).dragStart(s, g), d.push(C);
    else {
      if (x[i] || (x[i] = u.childGestos[m]), !x[i])
        return;
      C = en(
        g,
        v,
        s,
        l,
        o,
        i
      ), d.push(C);
    }
    const E = n[t](S, {
      ...C,
      parentFlag: true
    });
    return c && (x[i] = null), E;
  });
  return a && (u.childGestos = h.map((g) => g.state.gestos[i])), {
    eventParams: p,
    childEvents: d
  };
}
function jt(e, n, t, s, r = (i, a) => a, o) {
  const i = !!t.match(/End$/g), a = $t(e, n.name, s), c = e.moveables;
  return a.map((u, f) => {
    const h = c[f];
    let d = u;
    d = r(h, u);
    const p = n[t](h, {
      ...d,
      parentFlag: true
    });
    return i && (h.state.gestos = {}), p;
  });
}
function zn(e, n, t, s) {
  const r = t.fixedDirection, o = t.fixedPosition, i = s.datas.startPositions || Bt(n.state), a = gt(i, r), [c, l] = mt(
    Qe(-e.rotation / 180 * Math.PI, 3),
    [a[0] - o[0], a[1] - o[1], 1],
    3
  );
  return s.datas.originalX = c, s.datas.originalY = l, s;
}
function Zo(e, n, t, s) {
  const { renderPoses: r, rotation: o, direction: i } = e.getState(), { zoom: a } = de(e.props, n), c = Ne(o / Math.PI * 180), l = {}, u = e.renderState;
  u.renderDirectionMap || (u.renderDirectionMap = {});
  const f = u.renderDirectionMap;
  t.forEach(({ dir: d }) => {
    l[d] = true;
  });
  const h = Et(i);
  return t.map(({ data: d, classNames: p, dir: g }) => {
    const m = Ns[g];
    if (!m || !l[g])
      return null;
    f[g] = true;
    const S = (U(c, 15) + h * Yo[g] + 720) % 180, v = {};
    return Be(d).forEach((x) => {
      v[`data-${x}`] = d[x];
    }), (0, import_react.createElement)(
      "div",
      {
        className: H("control", "direction", g, n, ...p),
        "data-rotation": S,
        "data-direction": g,
        ...v,
        key: `direction-${g}`,
        style: In(
          o,
          a,
          ...m.map((x) => r[x])
        )
      }
    );
  });
}
function Ko(e, n, t, s) {
  const {
    renderDirections: r = n,
    displayAroundControls: o
  } = de(e.props, t);
  if (!r)
    return [];
  const i = r === true ? Ls : r;
  return [
    ...o ? ei(e, s, t, i) : [],
    ...Zo(
      e,
      t,
      i.map((a) => ({
        data: {},
        classNames: [],
        dir: a
      }))
    )
  ];
}
function Ze(e, n, t, s, r, o, ...i) {
  const a = ft(t, s), c = n ? U(a / Math.PI * 180, 15) % 180 : -1;
  return (0, import_jsx_runtime.jsx)(
    "div",
    {
      className: H(
        "line",
        "direction",
        n ? "edge" : "",
        n,
        ...i
      ),
      "data-rotation": c,
      "data-line-key": o,
      "data-direction": n,
      style: Fe(t, s, r, a)
    },
    `line-${o}`
  );
}
function Jo(e, n, t, s, r) {
  return (t === true ? fc : t).map((i, a) => {
    const [c, l] = Ns[i];
    if (l != null)
      return Ze(
        e,
        i,
        s[c],
        s[l],
        r,
        `${n}Edge${a}`,
        n
      );
  }).filter(Boolean);
}
function Qo(e) {
  return (n, t) => {
    const s = de(n.props, e).edge;
    return s && (s === true || s.length) ? [
      ...Jo(
        t,
        e,
        s,
        n.getState().renderPoses,
        n.props.zoom
      ),
      ...Hc(n, e, t)
    ] : ti(n, e, t);
  };
}
function ti(e, n, t) {
  return Ko(e, Ls, n, t);
}
function Hc(e, n, t) {
  return Ko(
    e,
    ["nw", "ne", "sw", "se"],
    n,
    t
  );
}
function ei(e, n, t, s) {
  const r = e.renderState;
  r.renderDirectionMap || (r.renderDirectionMap = {});
  const { renderPoses: o, rotation: i, direction: a } = e.getState(), c = r.renderDirectionMap, { zoom: l } = e.props, u = Et(a), f = i / Math.PI * 180;
  return (s || Be(c)).map((h) => {
    const d = Ns[h];
    if (!d)
      return null;
    const p = (U(f, 15) + u * Yo[h] + 720) % 180, g = ["around-control"];
    return t && g.push("direction", t), (0, import_jsx_runtime.jsx)(
      "div",
      {
        className: H(...g),
        "data-rotation": p,
        "data-direction": h,
        style: In(
          i,
          l,
          ...d.map((m) => o[m])
        )
      },
      `direction-around-${h}`
    );
  });
}
function qs(e, n, t) {
  const {
    position: s = "client",
    left: r = -1 / 0,
    top: o = -1 / 0,
    right: i = 1 / 0,
    bottom: a = 1 / 0
  } = e || {}, c = {
    position: s,
    left: r,
    top: o,
    right: i,
    bottom: a
  };
  return {
    vertical: Dr(c, n, true),
    horizontal: Dr(c, t, false)
  };
}
function Ln(e, n) {
  const {
    containerClientRect: {
      clientHeight: t,
      clientWidth: s,
      clientLeft: r,
      clientTop: o
    },
    snapOffset: {
      left: i,
      top: a,
      right: c,
      bottom: l
    }
  } = e.state, u = n || e.props.bounds || {}, h = (u.position || "client") === "css", { left: d = -1 / 0, top: p = -1 / 0 } = u;
  let {
    right: g = h ? -1 / 0 : 1 / 0,
    bottom: m = h ? -1 / 0 : 1 / 0
  } = u;
  return h && (g = s + c - i - g, m = t + l - a - m), {
    left: d + i - r,
    right: g + i - r,
    top: p + a - o,
    bottom: m + a - o
  };
}
function Vc(e, n, t) {
  const { left: s, top: r, right: o, bottom: i } = Ln(e), [a, c] = t;
  let [l, u] = V(t, n);
  I(l) < bt && (l = 0), I(u) < bt && (u = 0);
  const f = u > 0, h = l > 0, d = {
    isBound: false,
    offset: 0,
    pos: 0
  }, p = {
    isBound: false,
    offset: 0,
    pos: 0
  };
  if (l === 0 && u === 0)
    return {
      vertical: d,
      horizontal: p
    };
  if (l === 0)
    f ? i < c && (p.pos = i, p.offset = c - i) : r > c && (p.pos = r, p.offset = c - r);
  else if (u === 0)
    h ? o < a && (d.pos = o, d.offset = a - o) : s > a && (d.pos = s, d.offset = a - s);
  else {
    const g = u / l, m = t[1] - g * a;
    let S = 0, v = 0, x = false;
    h && o <= a ? (S = g * o + m, v = o, x = true) : !h && a <= s && (S = g * s + m, v = s, x = true), x && (S < r || S > i) && (x = false), x || (f && i <= c ? (S = i, v = (S - m) / g, x = true) : !f && c <= r && (S = r, v = (S - m) / g, x = true)), x && (d.isBound = true, d.pos = v, d.offset = a - v, p.isBound = true, p.pos = S, p.offset = c - S);
  }
  return {
    vertical: d,
    horizontal: p
  };
}
function Dr(e, n, t) {
  const s = e[t ? "left" : "top"], r = e[t ? "right" : "bottom"], o = Math.min(...n), i = Math.max(...n), a = [];
  return s + 1 > o && a.push({
    direction: "start",
    isBound: true,
    offset: o - s,
    pos: s
  }), r - 1 < i && a.push({
    direction: "end",
    isBound: true,
    offset: i - r,
    pos: r
  }), a.length || a.push({
    isBound: false,
    offset: 0,
    pos: 0
  }), a.sort((c, l) => I(l.offset) - I(c.offset));
}
function br(e, n, t) {
  return (t ? e.map((r) => Je(r, t)) : e).some((r) => r[0] < n.left && I(r[0] - n.left) > 0.1 || r[0] > n.right && I(r[0] - n.right) > 0.1 || r[1] < n.top && I(r[1] - n.top) > 0.1 || r[1] > n.bottom && I(r[1] - n.bottom) > 0.1);
}
function qc(e, n, t) {
  const s = It(e), r = Math.sqrt(s * s - n * n) || 0;
  return [r, -r].sort((o, i) => I(o - e[t ? 0 : 1]) - I(i - e[t ? 0 : 1])).map((o) => ft([0, 0], t ? [o, n] : [n, o]));
}
function jc(e, n, t, s, r) {
  if (!e.props.bounds)
    return [];
  const o = r * Math.PI / 180, { left: i, top: a, right: c, bottom: l } = Ln(e), u = i - s[0], f = c - s[0], h = a - s[1], d = l - s[1], p = {
    left: u,
    top: h,
    right: f,
    bottom: d
  };
  if (!br(t, p, 0))
    return [];
  const g = [];
  return [
    [u, 0],
    [f, 0],
    [h, 1],
    [d, 1]
  ].forEach(([m, S]) => {
    t.forEach((v) => {
      const x = ft([0, 0], v);
      g.push(
        ...qc(v, m, S).map((C) => o + C - x).filter((C) => !br(n, p, C)).map((C) => U(C * 180 / Math.PI, bt))
      );
    });
  }), g;
}
var Uc = ["left", "right", "center"];
var Zc = ["top", "bottom", "middle"];
var wr = {
  left: "start",
  right: "end",
  center: "center",
  top: "start",
  bottom: "end",
  middle: "center"
};
var te = {
  start: "left",
  end: "right",
  center: "center"
};
var ee = {
  start: "top",
  end: "bottom",
  center: "middle"
};
function be() {
  return {
    left: false,
    top: false,
    right: false,
    bottom: false
  };
}
function ke(e, n) {
  const {
    props: {
      snappable: t,
      bounds: s,
      innerBounds: r,
      verticalGuidelines: o,
      horizontalGuidelines: i,
      snapGridWidth: a,
      snapGridHeight: c
    },
    state: { guidelines: l, enableSnap: u }
  } = e;
  return !t || !u || n && t !== true && t.indexOf(n) < 0 ? false : !!(a || c || s || r || l && l.length || o && o.length || i && i.length);
}
function js(e) {
  return e === false ? {} : e === true || !e ? { left: true, right: true, top: true, bottom: true } : e;
}
function Kc(e, n) {
  const t = js(e), s = {};
  for (const r in t)
    r in n && t[r] && (s[r] = n[r]);
  return s;
}
function Us(e, n) {
  const t = Kc(e, n), s = Zc.filter(
    (o) => o in t
  ), r = Uc.filter((o) => o in t);
  return {
    horizontalNames: s,
    verticalNames: r,
    horizontal: s.map((o) => t[o]),
    vertical: r.map((o) => t[o])
  };
}
function Jc(e, n, t) {
  const s = at(
    e,
    [n.clientLeft, n.clientTop],
    t
  );
  return [n.left + s[0], n.top + s[1]];
}
function Qc([e, n]) {
  let t = n[0] - e[0], s = n[1] - e[1];
  Math.abs(t) < ht && (t = 0), Math.abs(s) < ht && (s = 0);
  let r = 0, o = 0, i = 0;
  return t ? s ? (r = -s / t, o = 1, i = r * e[0] - e[1]) : (o = 1, i = -e[1]) : (r = -1, i = e[0]), [r, o, i].map((a) => U(a, ht));
}
var ni = "snapRotationThreshold";
var si = "snapRotationDegrees";
var ri = "snapHorizontalThreshold";
var oi = "snapVerticalThreshold";
function Wn(e, n, t, s = [], r = [], o, i) {
  var f;
  const a = e.props, c = ((f = e.state.snapThresholdInfo) == null ? void 0 : f.multiples) || [1, 1], l = Xr(
    i,
    a[ri],
    5
  ), u = Xr(
    o,
    a[oi],
    5
  );
  return ii(
    e.state.guidelines,
    n,
    t,
    s,
    r,
    l,
    u,
    c
  );
}
function ii(e, n, t, s, r, o, i, a) {
  return {
    vertical: Tr(
      e,
      "vertical",
      n,
      i * a[0],
      s
    ),
    horizontal: Tr(
      e,
      "horizontal",
      t,
      o * a[1],
      r
    )
  };
}
function tl(e, n, t) {
  const [s, r] = t, [o, i] = n;
  let [a, c] = V(t, n);
  const l = c > 0, u = a > 0;
  a = Bn(a), c = Bn(c);
  const f = {
    isSnap: false,
    offset: 0,
    pos: 0
  }, h = {
    isSnap: false,
    offset: 0,
    pos: 0
  };
  if (a === 0 && c === 0)
    return {
      vertical: f,
      horizontal: h
    };
  const { vertical: d, horizontal: p } = Wn(
    e,
    a ? [s] : [],
    c ? [r] : [],
    [],
    [],
    void 0,
    void 0
  );
  d.posInfos.filter(({ pos: E }) => u ? E >= o : E <= o), p.posInfos.filter(({ pos: E }) => l ? E >= i : E <= i), d.isSnap = d.posInfos.length > 0, p.isSnap = p.posInfos.length > 0;
  const { isSnap: g, guideline: m } = xs(d), { isSnap: S, guideline: v } = xs(p), x = S ? v.pos[1] : 0, C = g ? m.pos[0] : 0;
  if (a === 0)
    S && (h.isSnap = true, h.pos = v.pos[1], h.offset = r - h.pos);
  else if (c === 0)
    g && (f.isSnap = true, f.pos = C, f.offset = s - C);
  else {
    const E = c / a, D = t[1] - E * s;
    let T = 0, w = 0, z = false;
    g ? (w = C, T = E * w + D, z = true) : S && (T = x, w = (T - D) / E, z = true), z && (f.isSnap = true, f.pos = w, f.offset = s - w, h.isSnap = true, h.pos = T, h.offset = r - T);
  }
  return {
    vertical: f,
    horizontal: h
  };
}
function Kt(e) {
  let n = "";
  return e === -1 || e === "top" || e === "left" ? n = "start" : e === 0 || e === "center" || e === "middle" ? n = "center" : (e === 1 || e === "right" || e === "bottom") && (n = "end"), n;
}
function Mr(e, n, t, s) {
  const r = Us(e.props.snapDirections, n), o = Wn(
    e,
    r.vertical,
    r.horizontal,
    r.verticalNames.map((c) => Kt(c)),
    r.horizontalNames.map((c) => Kt(c)),
    t,
    s
  ), i = Kt(
    r.horizontalNames[o.horizontal.index]
  ), a = Kt(
    r.verticalNames[o.vertical.index]
  );
  return {
    vertical: {
      ...o.vertical,
      direction: a
    },
    horizontal: {
      ...o.horizontal,
      direction: i
    }
  };
}
function xs(e) {
  const n = e.isSnap;
  if (!n)
    return {
      isSnap: false,
      offset: 0,
      dist: -1,
      pos: 0,
      guideline: null
    };
  const t = e.posInfos[0], s = t.guidelineInfos[0], r = s.offset, o = s.dist, i = s.guideline;
  return {
    isSnap: n,
    offset: r,
    dist: o,
    pos: t.pos,
    guideline: i
  };
}
function Tr(e, n, t, s, r = []) {
  var l;
  if (!e || !e.length)
    return {
      isSnap: false,
      index: -1,
      direction: "",
      posInfos: []
    };
  const i = n === "vertical" ? 0 : 1, a = t.map((u, f) => {
    const h = r[f] || "", d = e.map((p) => {
      const { pos: g } = p, m = u - g[i];
      return {
        offset: m,
        dist: I(m),
        guideline: p,
        direction: h
      };
    }).filter(({ guideline: p, dist: g }) => {
      const { type: m } = p;
      return !(m !== n || g > s);
    }).sort((p, g) => p.dist - g.dist);
    return {
      pos: u,
      index: f,
      guidelineInfos: d,
      direction: h
    };
  }).filter((u) => u.guidelineInfos.length > 0).sort((u, f) => u.guidelineInfos[0].dist - f.guidelineInfos[0].dist), c = a.length > 0;
  return {
    isSnap: c,
    index: c ? a[0].index : -1,
    direction: ((l = a[0]) == null ? void 0 : l.direction) ?? "",
    posInfos: a
  };
}
function el(e, n, t, s, r) {
  let o = [];
  t[0] && t[1] ? o = [
    t,
    [-t[0], t[1]],
    [t[0], -t[1]]
  ] : !t[0] && !t[1] ? [
    [-1, -1],
    [1, -1],
    [1, 1],
    [-1, 1]
  ].forEach((h, d, p) => {
    const g = p[d + 1] || p[0];
    o.push(h), o.push([(h[0] + g[0]) / 2, (h[1] + g[1]) / 2]);
  }) : e.props.keepRatio ? o.push([-1, -1], [-1, 1], [1, -1], [1, 1], t) : (o.push(
    ...Pc(
      [
        [-1, -1],
        [1, -1],
        [-1, -1],
        [1, 1]
      ],
      t
    )
  ), o.length > 1 && o.push([
    (o[0][0] + o[1][0]) / 2,
    (o[0][1] + o[1][1]) / 2
  ]));
  const i = o.map((h) => gt(n, h)), a = i.map((h) => h[0]), c = i.map((h) => h[1]), l = Wn(
    e,
    a,
    c,
    o.map((h) => Kt(h[0])),
    o.map((h) => Kt(h[1])),
    s,
    r
  ), u = Kt(
    o.map((h) => h[0])[l.vertical.index]
  ), f = Kt(
    o.map((h) => h[1])[l.horizontal.index]
  );
  return {
    vertical: {
      ...l.vertical,
      direction: u
    },
    horizontal: {
      ...l.horizontal,
      direction: f
    }
  };
}
function ai(e, n) {
  const t = I(e.offset), s = I(n.offset);
  return e.isBound && n.isBound ? s - t : e.isBound ? -1 : n.isBound ? 1 : e.isSnap && n.isSnap ? s - t : e.isSnap ? -1 : n.isSnap || t < bt ? 1 : s < bt ? -1 : t - s;
}
function Pn(e, n) {
  return e.slice().sort((t, s) => {
    const r = t.sign[n], o = s.sign[n], i = t.offset[n], a = s.offset[n];
    if (r) {
      if (!o)
        return -1;
    } else return 1;
    return ai(
      { isBound: t.isBound, isSnap: t.isSnap, offset: i },
      { isBound: s.isBound, isSnap: s.isSnap, offset: a }
    );
  })[0];
}
function nl(e, n, t) {
  const s = [];
  if (t)
    I(n[0]) !== 1 || I(n[1]) !== 1 ? s.push(
      [n, [-1, -1]],
      [n, [-1, 1]],
      [n, [1, -1]],
      [n, [1, 1]]
    ) : s.push(
      [n, [e[0], -e[1]]],
      [n, [-e[0], e[1]]]
    ), s.push([n, e]);
  else if (e[0] && e[1] || !e[0] && !e[1]) {
    const r = e[0] ? e : [1, 1];
    [1, -1].forEach((o) => {
      [1, -1].forEach((i) => {
        const a = [
          o * r[0],
          i * r[1]
        ];
        n[0] === a[0] && n[1] === a[1] || s.push([n, a]);
      });
    });
  } else e[0] ? (I(n[0]) === 1 ? [1] : [1, -1]).forEach((o) => {
    s.push(
      [
        [n[0], -1],
        [o * e[0], -1]
      ],
      [
        [n[0], 0],
        [o * e[0], 0]
      ],
      [
        [n[0], 1],
        [o * e[0], 1]
      ]
    );
  }) : e[1] && (I(n[1]) === 1 ? [1] : [1, -1]).forEach((o) => {
    s.push(
      [
        [-1, n[1]],
        [-1, o * e[1]]
      ],
      [
        [0, n[1]],
        [0, o * e[1]]
      ],
      [
        [1, n[1]],
        [1, o * e[1]]
      ]
    );
  });
  return s;
}
function ci(e, n) {
  const t = cs([n[0][0], n[1][0]]), s = cs([n[0][1], n[1][1]]);
  return {
    vertical: t <= e[0],
    horizontal: s <= e[1]
  };
}
function Zs(e, [n, t]) {
  let s = t[0] - n[0], r = t[1] - n[1];
  I(s) < bt && (s = 0), I(r) < bt && (r = 0);
  let o, i;
  return s ? r ? (o = r / s * (e[0] - n[0]) + n[1], i = e[1]) : (o = n[1], i = e[1]) : (o = n[0], i = e[0]), o - i;
}
function li(e, n, t, s = bt) {
  return e.every((r) => {
    const o = Zs(r, n);
    return o <= 0 === t || I(o) <= s;
  });
}
function Rr(e, n, t, s, r = 0) {
  return s && n - r <= e || !s && e <= t + r ? {
    isBound: true,
    offset: s ? n - e : t - e
  } : {
    isBound: false,
    offset: 0
  };
}
function sl(e, {
  line: n,
  centerSign: t,
  verticalSign: s,
  horizontalSign: r,
  lineConstants: o
}) {
  const i = e.props.innerBounds;
  if (!i)
    return {
      isAllBound: false,
      isBound: false,
      isVerticalBound: false,
      isHorizontalBound: false,
      offset: [0, 0]
    };
  const { left: a, top: c, width: l, height: u } = i, f = [
    [a, c],
    [a, c + u]
  ], h = [
    [a, c],
    [a + l, c]
  ], d = [
    [a + l, c],
    [a + l, c + u]
  ], p = [
    [a, c + u],
    [a + l, c + u]
  ];
  if (li(
    [
      [a, c],
      [a + l, c],
      [a, c + u],
      [a + l, c + u]
    ],
    n,
    t
  ))
    return {
      isAllBound: false,
      isBound: false,
      isVerticalBound: false,
      isHorizontalBound: false,
      offset: [0, 0]
    };
  const g = Jt(
    n,
    o,
    h,
    s
  ), m = Jt(
    n,
    o,
    p,
    s
  ), S = Jt(
    n,
    o,
    f,
    r
  ), v = Jt(
    n,
    o,
    d,
    r
  ), x = g.isBound && m.isBound, C = g.isBound || m.isBound, E = S.isBound && v.isBound, D = S.isBound || v.isBound, T = Oe(g.offset, m.offset), w = Oe(
    S.offset,
    v.offset
  );
  let z = [0, 0], M = false, R = false;
  return I(w) < I(T) ? (z = [T, 0], M = C, R = x) : (z = [0, w], M = D, R = E), {
    isAllBound: R,
    isVerticalBound: C,
    isHorizontalBound: D,
    isBound: M,
    offset: z
  };
}
function Jt(e, [n, t], s, r, o, i) {
  const a = e[0], c = s[0], l = s[1], u = Bn(l[1] - c[1]), f = Bn(l[0] - c[0]), h = t, d = n, p = -n / t;
  if (f) {
    if (!u) {
      if (i && !h)
        return {
          isBound: false,
          offset: 0
        };
      if (d) {
        const g = (c[1] - a[1]) / p + a[0];
        return Rr(
          g,
          c[0],
          l[0],
          r,
          o
        );
      } else {
        const g = c[1] - a[1], m = I(g) <= (o || 0);
        return {
          isBound: m,
          offset: m ? g : 0
        };
      }
    }
  } else {
    if (i && !d)
      return {
        isBound: false,
        offset: 0
      };
    if (h) {
      const g = p * (c[0] - a[0]) + a[1];
      return Rr(
        g,
        c[1],
        l[1],
        r,
        o
      );
    } else {
      const g = c[0] - a[0], m = I(g) <= (o || 0);
      return {
        isBound: m,
        offset: m ? g : 0
      };
    }
  }
  return {
    isBound: false,
    offset: 0
  };
}
function ui(e, n, t) {
  return n.map((s) => {
    const { isBound: r, offset: o, isVerticalBound: i, isHorizontalBound: a } = sl(e, s), c = s.multiple, l = Vt({
      datas: t,
      distX: o[0],
      distY: o[1]
    }).map((u, f) => u * (c[f] ? 2 / c[f] : 0));
    return {
      sign: c,
      isBound: r,
      isVerticalBound: i,
      isHorizontalBound: a,
      isSnap: false,
      offset: l
    };
  });
}
function rl(e, n, t) {
  const s = Ks(e, n, [0, 0], false).map(
    (f) => ({
      ...f,
      multiple: f.multiple.map((h) => I(h) * 2)
    })
  ), r = ui(e, s, t), o = Pn(r, 0), i = Pn(r, 1);
  let a = 0, c = 0;
  const l = o.isVerticalBound || i.isVerticalBound, u = o.isHorizontalBound || i.isHorizontalBound;
  return (l || u) && ([a, c] = yc({
    datas: t,
    distX: -o.offset[0],
    distY: -i.offset[1]
  })), {
    vertical: {
      isBound: l,
      offset: a
    },
    horizontal: {
      isBound: u,
      offset: c
    }
  };
}
function ol(e, n) {
  const t = [], s = e[0], r = e[1];
  return s && r ? t.push(
    [[0, r * 2], e, [-s, r]],
    [[s * 2, 0], e, [s, -r]]
  ) : s ? (t.push([
    [s * 2, 0],
    [s, 1],
    [s, -1]
  ]), n && t.push(
    [
      [0, -1],
      [s, -1],
      [-s, -1]
    ],
    [
      [0, 1],
      [s, 1],
      [-s, 1]
    ]
  )) : r ? (t.push([
    [0, r * 2],
    [1, r],
    [-1, r]
  ]), n && t.push(
    [
      [-1, 0],
      [-1, r],
      [-1, -r]
    ],
    [
      [1, 0],
      [1, r],
      [1, -r]
    ]
  )) : t.push(
    [
      [-1, 0],
      [-1, -1],
      [-1, 1]
    ],
    [
      [1, 0],
      [1, -1],
      [1, 1]
    ],
    [
      [0, -1],
      [-1, -1],
      [1, -1]
    ],
    [
      [0, 1],
      [-1, 1],
      [1, 1]
    ]
  ), t;
}
function Ks(e, n, t, s) {
  const { allMatrix: r, is3d: o } = e.state, i = me(r, 100, 100, o ? 4 : 3), a = gt(i, [0, 0]);
  return ol(t, s).map(
    ([c, l, u]) => {
      const f = [
        gt(i, l),
        gt(i, u)
      ], h = Qc(f), { vertical: d, horizontal: p } = ci(a, f), g = Zs(a, f) <= 0;
      return {
        multiple: c,
        centerSign: g,
        verticalSign: d,
        horizontalSign: p,
        lineConstants: h,
        line: [gt(n, l), gt(n, u)]
      };
    }
  );
}
function yr(e, n, t, s) {
  const r = s ? e.map((o) => Je(o, s)) : e;
  return [
    [r[0], r[1]],
    [r[1], r[3]],
    [r[3], r[2]],
    [r[2], r[0]]
  ].some((o) => {
    const i = Zs(t, o) <= 0;
    return !li(n, o, i);
  });
}
function il([e, n]) {
  const t = n[0] - e[0], s = n[1] - e[1];
  if (!t)
    return I(e[0]);
  if (!s)
    return I(e[1]);
  const r = s / t;
  return I((-r * e[0] + e[1]) / Math.sqrt(Math.pow(r, 2) + 1));
}
function al([e, n]) {
  const t = n[0] - e[0], s = n[1] - e[1];
  if (!t)
    return [e[0], 0];
  if (!s)
    return [0, e[1]];
  const r = s / t, o = -r * e[0] + e[1];
  return [-o / (r + 1 / r), o / (r * r + 1)];
}
function cl(e, n, t, s, r) {
  const o = e.props.innerBounds, i = r * Math.PI / 180;
  if (!o)
    return [];
  const { left: a, top: c, width: l, height: u } = o, f = a - s[0], h = a + l - s[0], d = c - s[1], p = c + u - s[1], g = [
    [f, d],
    [h, d],
    [f, p],
    [h, p]
  ], m = gt(t, [0, 0]);
  if (!yr(t, g, m, 0))
    return [];
  const S = [], v = g.map((x) => [It(x), ft([0, 0], x)]);
  return [
    [t[0], t[1]],
    [t[1], t[3]],
    [t[3], t[2]],
    [t[2], t[0]]
  ].forEach((x) => {
    const C = ft([0, 0], al(x)), E = il(x);
    S.push(
      ...v.filter(([D]) => D && E <= D).map(([D, T]) => {
        const w = Math.acos(D ? E / D : 0), z = T + w, M = T - w;
        return [i + z - C, i + M - C];
      }).reduce((D, T) => (D.push(...T), D), []).filter((D) => !yr(n, g, m, D)).map((D) => U(D * 180 / Math.PI, bt))
    );
  }), S;
}
function ll(e) {
  const n = e.props.innerBounds, t = be();
  if (!n)
    return {
      boundMap: t,
      vertical: [],
      horizontal: []
    };
  const { pos1: s, pos2: r, pos3: o, pos4: i } = e.getRect(), a = [s, r, o, i], c = gt(a, [0, 0]), { left: l, top: u, width: f, height: h } = n, d = [
    [l, u],
    [l, u + h]
  ], p = [
    [l, u],
    [l + f, u]
  ], g = [
    [l + f, u],
    [l + f, u + h]
  ], m = [
    [l, u + h],
    [l + f, u + h]
  ], S = Ks(e, a, [0, 0], false), v = [], x = [];
  return S.forEach((C) => {
    const { line: E, lineConstants: D } = C, { horizontal: T, vertical: w } = ci(c, E), z = Jt(
      E,
      D,
      p,
      w,
      1,
      true
    ), M = Jt(
      E,
      D,
      m,
      w,
      1,
      true
    ), R = Jt(
      E,
      D,
      d,
      T,
      1,
      true
    ), P = Jt(
      E,
      D,
      g,
      T,
      1,
      true
    );
    z.isBound && !t.top && (v.push(u), t.top = true), M.isBound && !t.bottom && (v.push(u + h), t.bottom = true), R.isBound && !t.left && (x.push(l), t.left = true), P.isBound && !t.right && (x.push(l + f), t.right = true);
  }), {
    boundMap: t,
    horizontal: v,
    vertical: x
  };
}
function ul(e, n, t, s) {
  let r = n[0] - e[0], o = n[1] - e[1];
  if (I(r) < ht && (r = 0), I(o) < ht && (o = 0), !r)
    return s ? [0, 0] : [0, t];
  if (!o)
    return s ? [t, 0] : [0, 0];
  const i = o / r, a = e[1] - i * e[0];
  if (s) {
    const c = i * (n[0] + t) + a;
    return [t, c - n[1]];
  } else
    return [(n[1] + t - a) / i - n[0], t];
}
function vs(e, n, t, s, r) {
  const o = ul(e, n, t, s);
  if (!o)
    return {
      isOutside: false,
      offset: [0, 0]
    };
  const i = Nt(e, n), a = Nt(o, e), c = Nt(o, n), l = a > i || c > i, [u, f] = Vt({
    datas: r,
    distX: o[0],
    distY: o[1]
  });
  return {
    offset: [u, f],
    isOutside: l
  };
}
function _n(e, n) {
  return e.isBound ? e.offset : n.isSnap ? xs(n).offset : 0;
}
function fl(e, [n, t], [s, r], [o, i], [a, c]) {
  let l = -a, u = -c;
  if (e && n && t) {
    l = 0, u = 0;
    const f = [];
    if (s && r ? f.push([0, c], [a, 0]) : s ? f.push([a, 0]) : r ? f.push([0, c]) : o && i ? f.push([0, c], [a, 0]) : o ? f.push([a, 0]) : i && f.push([0, c]), f.length) {
      f.sort((d, p) => It(V([n, t], d)) - It(V([n, t], p)));
      const h = f[0];
      if (h[0] && I(n) > ht)
        l = -h[0], u = t * I(n + l) / I(n) - t;
      else if (h[1] && I(t) > ht) {
        const d = t;
        u = -h[1], l = n * I(t + u) / I(d) - n;
      }
      if (e && r && s)
        if (I(l) > ht && I(l) < I(a)) {
          const d = I(a) / I(l);
          l *= d, u *= d;
        } else if (I(u) > ht && I(u) < I(c)) {
          const d = I(c) / I(u);
          l *= d, u *= d;
        } else
          l = Oe(-a, l), u = Oe(-c, u);
    }
  } else
    l = n || s ? -a : 0, u = t || r ? -c : 0;
  return [l, u];
}
function hl(e, n, t, s, r, o) {
  if (!ke(e, "draggable"))
    return [
      {
        isSnap: false,
        isBound: false,
        offset: 0
      },
      {
        isSnap: false,
        isBound: false,
        offset: 0
      }
    ];
  const i = tr(o.absolutePoses, [n, t]), { left: a, right: c, top: l, bottom: u } = Ot(i), f = {
    horizontal: i.map((M) => M[1]),
    vertical: i.map((M) => M[0])
  }, h = js(e.props.snapDirections), d = Us(h, {
    left: a,
    right: c,
    top: l,
    bottom: u,
    center: (a + c) / 2,
    middle: (l + u) / 2
  }), {
    vertical: p,
    horizontal: g
  } = Nn(e, r, d, f), {
    vertical: m,
    horizontal: S
  } = rl(e, i, o), v = p.isSnap, x = g.isSnap, C = p.isBound || m.isBound, E = g.isBound || S.isBound, D = Oe(
    p.offset,
    m.offset
  ), T = Oe(
    g.offset,
    S.offset
  ), [w, z] = fl(
    s,
    [n, t],
    [C, E],
    [v, x],
    [D, T]
  );
  return [
    {
      isBound: C,
      isSnap: v,
      offset: w
    },
    {
      isBound: E,
      isSnap: x,
      offset: z
    }
  ];
}
function Nn(e, n, t, s = t) {
  const { horizontal: r, vertical: o } = qs(
    Ln(e),
    s.vertical,
    s.horizontal
  ), { horizontal: i, vertical: a } = n ? {
    horizontal: { isSnap: false, index: -1 },
    vertical: { isSnap: false, index: -1 }
  } : Wn(
    e,
    t.vertical,
    t.horizontal,
    void 0,
    void 0,
    void 0,
    void 0
  ), c = _n(
    r[0],
    i
  ), l = _n(o[0], a), u = I(c), f = I(l);
  return {
    horizontal: {
      isBound: r[0].isBound,
      isSnap: i.isSnap,
      snapIndex: i.index,
      offset: c,
      dist: u,
      bounds: r,
      snap: i
    },
    vertical: {
      isBound: o[0].isBound,
      isSnap: a.isSnap,
      snapIndex: a.index,
      offset: l,
      dist: f,
      bounds: o,
      snap: a
    }
  };
}
function zr(e, n, t, s, r, o, i = [1, 1]) {
  const { horizontal: a, vertical: c } = qs(n, t, s), { horizontal: l, vertical: u } = ii(
    e,
    t,
    s,
    [],
    [],
    r,
    o,
    i
  ), f = _n(
    a[0],
    l
  ), h = _n(c[0], u), d = I(f), p = I(h);
  return {
    horizontal: {
      isBound: a[0].isBound,
      isSnap: l.isSnap,
      snapIndex: l.index,
      offset: f,
      dist: d,
      bounds: a,
      snap: l
    },
    vertical: {
      isBound: c[0].isBound,
      isSnap: u.isSnap,
      snapIndex: u.index,
      offset: h,
      dist: p,
      bounds: c,
      snap: u
    }
  };
}
function dl(e, n, t, s) {
  const r = ft(e, n) / Math.PI * 180, {
    vertical: {
      isBound: o,
      isSnap: i,
      dist: a
    },
    horizontal: {
      isBound: c,
      isSnap: l,
      dist: u
    }
  } = t, f = r % 180, h = f < 3 || f > 177, d = f > 87 && f < 93;
  return u < a && (o || i && !d && (!s || !h)) ? "vertical" : c || l && !h && (!s || !d) ? "horizontal" : "";
}
function pl(e, n, t, s, r, o) {
  return t.map(([i, a]) => {
    const c = gt(n, i), l = gt(n, a), u = s ? gl(
      e,
      c,
      l,
      r
    ) : Nn(e, r, {
      vertical: [l[0]],
      horizontal: [l[1]]
    }), {
      horizontal: {
        // dist: otherHorizontalDist,
        offset: f,
        isBound: h,
        isSnap: d
      },
      vertical: {
        // dist: otherVerticalDist,
        offset: p,
        isBound: g,
        isSnap: m
      }
    } = u, S = V(a, i);
    if (!p && !f)
      return {
        isBound: g || h,
        isSnap: m || d,
        sign: S,
        offset: [0, 0]
      };
    const v = dl(
      c,
      l,
      u,
      s
    );
    if (!v)
      return {
        sign: S,
        isBound: false,
        isSnap: false,
        offset: [0, 0]
      };
    const x = v === "vertical";
    let C = [0, 0];
    return !s && I(a[0]) === 1 && I(a[1]) === 1 && i[0] !== a[0] && i[1] !== a[1] ? C = Vt({
      datas: o,
      distX: -p,
      distY: -f
    }) : C = vs(
      c,
      l,
      -(x ? p : f),
      x,
      o
    ).offset, C = C.map(
      (E, D) => E * (S[D] ? 2 / S[D] : 0)
    ), {
      sign: S,
      isBound: x ? g : h,
      isSnap: x ? m : d,
      offset: C
    };
  });
}
function Pr(e, n) {
  return e.isBound ? e.offset : n.isSnap ? n.offset : 0;
}
function gl(e, n, t, s) {
  const { horizontal: r, vertical: o } = Vc(e, n, t), { horizontal: i, vertical: a } = s ? {
    horizontal: { isSnap: false },
    vertical: { isSnap: false }
  } : tl(e, n, t), c = Pr(
    r,
    i
  ), l = Pr(
    o,
    a
  ), u = I(c), f = I(l);
  return {
    horizontal: {
      isBound: r.isBound,
      isSnap: i.isSnap,
      offset: c,
      dist: u
    },
    vertical: {
      isBound: o.isBound,
      isSnap: a.isSnap,
      offset: l,
      dist: f
    }
  };
}
function ml(e, n, t, s, r) {
  const o = [-t[0], -t[1]], { width: i, height: a } = e.state, c = e.props.bounds;
  let l = 1 / 0, u = 1 / 0;
  if (c) {
    const f = [
      [t[0], -t[1]],
      [-t[0], t[1]]
    ], {
      left: h = -1 / 0,
      top: d = -1 / 0,
      right: p = 1 / 0,
      bottom: g = 1 / 0
    } = c;
    f.forEach((m) => {
      const S = m[0] !== o[0], v = m[1] !== o[1], x = gt(n, m), C = ft(s, x) * 360 / Math.PI;
      if (v) {
        const E = x.slice();
        (I(C - 360) < 2 || I(C - 180) < 2) && (E[1] = s[1]);
        const {
          offset: [, D],
          isOutside: T
        } = vs(
          s,
          E,
          (s[1] < x[1] ? g : d) - x[1],
          false,
          r
        );
        isNaN(D) || (u = a + (T ? 1 : -1) * I(D));
      }
      if (S) {
        const E = x.slice();
        (I(C - 90) < 2 || I(C - 270) < 2) && (E[0] = s[0]);
        const {
          offset: [D],
          isOutside: T
        } = vs(
          s,
          E,
          (s[0] < x[0] ? p : h) - x[0],
          true,
          r
        );
        isNaN(D) || (l = i + (T ? 1 : -1) * I(D));
      }
    });
  }
  return {
    maxWidth: l,
    maxHeight: u
  };
}
var vt = {
  name: "draggable",
  props: [
    "draggable",
    "throttleDrag",
    "throttleDragRotate",
    "hideThrottleDragRotateLine",
    "startDragRotate",
    "edgeDraggable"
  ],
  events: [
    "dragStart",
    "drag",
    "dragEnd",
    "dragGroupStart",
    "dragGroup",
    "dragGroupEnd"
  ],
  requestStyle() {
    return ["left", "top", "right", "bottom"];
  },
  requestChildStyle() {
    return ["left", "top", "right", "bottom"];
  },
  render(e, n) {
    const { hideThrottleDragRotateLine: t, throttleDragRotate: s, zoom: r } = e.props, { dragInfo: o, beforeOrigin: i } = e.getState();
    if (t || !s || !o)
      return [];
    const a = o.dist;
    if (!a[0] && !a[1])
      return [];
    const c = It(a), l = ft(a, [0, 0]);
    return [
      (0, import_jsx_runtime.jsx)(
        "div",
        {
          className: H("line", "horizontal", "dragline", "dashed"),
          style: {
            width: `${c}px`,
            transform: `translate(${i[0]}px, ${i[1]}px) rotate(${l}rad) scaleY(${r})`
          }
        },
        "dragRotateGuideline"
      )
    ];
  },
  dragStart(e, n) {
    const { datas: t, parentEvent: s, parentGesto: r } = n, o = e.state, { gestos: i, style: a } = o;
    if (i.draggable)
      return false;
    i.draggable = r || e.targetGesto, t.datas = {}, t.left = parseFloat(a.left || "") || 0, t.top = parseFloat(a.top || "") || 0, t.bottom = parseFloat(a.bottom || "") || 0, t.right = parseFloat(a.right || "") || 0, t.startValue = [0, 0], ge(e, n), Fn(e, n, "translate"), Al(e, t), t.prevDist = [0, 0], t.prevBeforeDist = [0, 0], t.isDrag = false, t.deltaOffset = [0, 0];
    const c = K(e, n, {
      set: (u) => {
        t.startValue = u;
      },
      ...Yn(e, n)
    });
    return (s || F(e, "onDragStart", c)) !== false ? (t.isDrag = true, e.state.dragInfo = {
      startRect: e.getRect(),
      dist: [0, 0]
    }) : (i.draggable = null, t.isPinch = false), t.isDrag ? c : false;
  },
  drag(e, n) {
    if (!n)
      return;
    kn(e, n, "translate");
    const {
      datas: t,
      parentEvent: s,
      parentFlag: r,
      isPinch: o,
      deltaOffset: i,
      useSnap: a,
      isRequest: c,
      isGroup: l,
      parentThrottleDrag: u
    } = n;
    let { distX: f, distY: h } = n;
    const { isDrag: d, prevDist: p, prevBeforeDist: g, startValue: m } = t;
    if (!d)
      return;
    i && (f += i[0], h += i[1]);
    const S = e.props, v = S.parentMoveable, x = l ? 0 : S.throttleDrag || u || 0, C = s ? 0 : S.throttleDragRotate || 0;
    let E = 0, D = false, T = false, w = false, z = false;
    if (!s && C > 0 && (f || h)) {
      const W = S.startDragRotate || 0, Z = U(
        W + ft([0, 0], [f, h]) * 180 / Math.PI,
        C
      ) - W, $ = h * Math.abs(Math.cos((Z - 90) / 180 * Math.PI)), L = f * Math.abs(Math.cos(Z / 180 * Math.PI)), j = It([L, $]);
      E = Z * Math.PI / 180, f = j * Math.cos(E), h = j * Math.sin(E);
    }
    if (!o && !s && !r) {
      const [W, Z] = hl(
        e,
        f,
        h,
        C,
        !a && c || i,
        t
      );
      D = W.isSnap, T = W.isBound, w = Z.isSnap, z = Z.isBound;
      const $ = W.offset, L = Z.offset;
      f += $, h += L;
    }
    const M = tt(
      Ho({ datas: t, distX: f, distY: h }),
      m
    ), R = tt(
      Rc({ datas: t, distX: f, distY: h }),
      m
    );
    dr(R, bt), dr(M, bt), C || (!D && !T && (R[0] = U(R[0], x), M[0] = U(M[0], x)), !w && !z && (R[1] = U(R[1], x), M[1] = U(M[1], x)));
    const P = V(M, m), y = V(R, m), k = V(y, p), _ = V(P, g);
    t.prevDist = y, t.prevBeforeDist = P, t.passDelta = k, t.passDist = y;
    const O = t.left + P[0], B = t.top + P[1], A = t.right - P[0], N = t.bottom - P[1], G = Xn(
      t,
      `translate(${R[0]}px, ${R[1]}px)`,
      `translate(${y[0]}px, ${y[1]}px)`
    );
    if (Hs(n, G), e.state.dragInfo.dist = s ? [0, 0] : y, !s && !v && k.every((W) => !W) && _.some((W) => !W))
      return;
    const { width: Y, height: q } = e.state, X = K(e, n, {
      transform: G,
      dist: y,
      delta: k,
      translate: R,
      beforeDist: P,
      beforeDelta: _,
      beforeTranslate: M,
      left: O,
      top: B,
      right: A,
      bottom: N,
      width: Y,
      height: q,
      isPinch: o,
      ...Ct(
        {
          transform: G
        },
        n
      )
    });
    return !s && F(e, "onDrag", X), X;
  },
  dragAfter(e, n) {
    const t = n.datas, { deltaOffset: s } = t;
    return s[0] || s[1] ? (t.deltaOffset = [0, 0], this.drag(e, { ...n, deltaOffset: s })) : false;
  },
  dragEnd(e, n) {
    const { parentEvent: t, datas: s } = n;
    if (e.state.dragInfo = null, !s.isDrag)
      return;
    s.isDrag = false;
    const r = zt(e, n, {});
    return !t && F(e, "onDragEnd", r), r;
  },
  dragGroupStart(e, n) {
    var f;
    const { datas: t, clientX: s, clientY: r } = n, o = this.dragStart(e, n);
    if (!o)
      return false;
    const { childEvents: i, eventParams: a } = ts(
      e,
      this,
      "dragStart",
      [s || 0, r || 0],
      n,
      false,
      "draggable"
    ), c = {
      ...o,
      targets: e.props.targets,
      events: a
    }, l = F(e, "onDragGroupStart", c);
    t.isDrag = l !== false;
    const u = ((f = i[0]) == null ? void 0 : f.datas.startValue) ?? [0, 0];
    return t.throttleOffset = [u[0] % 1, u[1] % 1], t.isDrag ? o : false;
  },
  dragGroup(e, n) {
    const { datas: t } = n;
    if (!t.isDrag)
      return;
    const s = this.drag(e, {
      ...n,
      parentThrottleDrag: e.props.throttleDrag
    }), { passDelta: r } = n.datas, { eventParams: o } = ts(
      e,
      this,
      "drag",
      r,
      n,
      false,
      "draggable"
    );
    if (!s)
      return;
    const i = {
      targets: e.props.targets,
      events: o,
      ...s
    };
    return F(e, "onDragGroup", i), i;
  },
  dragGroupEnd(e, n) {
    const { isDrag: t, datas: s } = n;
    if (!s.isDrag)
      return;
    this.dragEnd(e, n);
    const { eventParams: r } = ts(
      e,
      this,
      "dragEnd",
      [0, 0],
      n,
      false,
      "draggable"
    );
    return F(
      e,
      "onDragGroupEnd",
      zt(e, n, {
        targets: e.props.targets,
        events: r
      })
    ), t;
  },
  /**
       * @method Moveable.Draggable#request
       * @param {object} [e] - the draggable's request parameter
       * @param {number} [e.x] - x position
       * @param {number} [e.y] - y position
       * @param {number} [e.deltaX] - X number to move
       * @param {number} [e.deltaY] - Y number to move
       * @return {Moveable.Requester} Moveable Requester
       * @example
  
       * // Instantly Request (requestStart - request - requestEnd)
       * // Use Relative Value
       * moveable.request("draggable", { deltaX: 10, deltaY: 10 }, true);
       * // Use Absolute Value
       * moveable.request("draggable", { x: 200, y: 100 }, true);
       *
       * // requestStart
       * const requester = moveable.request("draggable");
       *
       * // request
       * // Use Relative Value
       * requester.request({ deltaX: 10, deltaY: 10 });
       * requester.request({ deltaX: 10, deltaY: 10 });
       * requester.request({ deltaX: 10, deltaY: 10 });
       * // Use Absolute Value
       * moveable.request("draggable", { x: 200, y: 100 });
       * moveable.request("draggable", { x: 220, y: 100 });
       * moveable.request("draggable", { x: 240, y: 100 });
       *
       * // requestEnd
       * requester.requestEnd();
       */
  request(e) {
    const n = {}, t = e.getRect();
    let s = 0, r = 0, o = false;
    return {
      isControl: false,
      requestStart(i) {
        return o = i.useSnap, { datas: n, useSnap: o };
      },
      request(i) {
        return "x" in i ? s = i.x - t.left : "deltaX" in i && (s += i.deltaX), "y" in i ? r = i.y - t.top : "deltaY" in i && (r += i.deltaY), { datas: n, distX: s, distY: r, useSnap: o };
      },
      requestEnd() {
        return { datas: n, isDrag: true, useSnap: o };
      }
    };
  },
  unset(e) {
    e.state.gestos.draggable = null, e.state.dragInfo = null;
  }
};
function fi(e, n) {
  return {
    fixedPosition: gt(e, n),
    fixedDirection: n,
    fixedOffset: [0, 0]
  };
}
function Sl(e, n) {
  const { allMatrix: t, is3d: s, width: r, height: o } = e, i = s ? 4 : 3, a = [
    r / 2 * (1 + n[0]),
    o / 2 * (1 + n[1])
  ];
  return {
    fixedPosition: at(t, a, i),
    fixedDirection: n,
    fixedOffset: [0, 0]
  };
}
function hi(e, n) {
  const { allMatrix: t, is3d: s, width: r, height: o } = e, i = s ? 4 : 3, a = Ac(n, r, o), c = at(
    t,
    n,
    i
  ), l = [
    r ? 0 : n[0],
    o ? 0 : n[1]
  ];
  return {
    fixedPosition: c,
    fixedDirection: a,
    fixedOffset: l
  };
}
var _r = sr("resizable");
var Es = {
  name: "resizable",
  ableGroup: "size",
  canPinch: true,
  props: [
    "resizable",
    "throttleResize",
    "renderDirections",
    "displayAroundControls",
    "keepRatio",
    "resizeFormat",
    "keepRatioFinally",
    "edge",
    "checkResizableError"
  ],
  events: [
    "resizeStart",
    "beforeResize",
    "resize",
    "resizeEnd",
    "resizeGroupStart",
    "beforeResizeGroup",
    "resizeGroup",
    "resizeGroupEnd"
  ],
  render: Qo("resizable"),
  dragControlCondition: _r,
  viewClassName: nr("resizable"),
  dragControlStart(e, n) {
    const {
      inputEvent: t,
      isPinch: s,
      isGroup: r,
      parentDirection: o,
      parentGesto: i,
      datas: a,
      parentFixedDirection: c,
      parentEvent: l
    } = n, u = Mi(
      o,
      s,
      t,
      a
    ), f = e.state, { target: h, width: d, height: p, gestos: g } = f;
    if (!u || !h || g.resizable)
      return false;
    g.resizable = i || e.controlGesto, !s && ge(e, n), a.datas = {}, a.direction = u, a.startOffsetWidth = d, a.startOffsetHeight = p, a.prevWidth = 0, a.prevHeight = 0, a.minSize = [0, 0], a.startWidth = f.inlineCSSWidth || f.cssWidth, a.startHeight = f.inlineCSSHeight || f.cssHeight, a.maxSize = [1 / 0, 1 / 0], r || (a.minSize = [f.minOffsetWidth, f.minOffsetHeight], a.maxSize = [f.maxOffsetWidth, f.maxOffsetHeight]);
    const m = e.props.transformOrigin || "% %";
    a.transformOrigin = Yt(m) ? m.split(" ") : m, a.startOffsetMatrix = f.offsetMatrix, a.startTransformOrigin = f.transformOrigin, a.isWidth = (n == null ? void 0 : n.parentIsWidth) ?? (!u[0] && !u[1] || u[0] || !u[1]);
    function S(w) {
      a.ratio = w && isFinite(w) ? w : 0;
    }
    a.startPositions = Bt(e.state);
    function v(w) {
      const z = fi(
        a.startPositions,
        w
      );
      a.fixedDirection = z.fixedDirection, a.fixedPosition = z.fixedPosition, a.fixedOffset = z.fixedOffset;
    }
    function x(w) {
      const z = hi(e.state, w);
      a.fixedDirection = z.fixedDirection, a.fixedPosition = z.fixedPosition, a.fixedOffset = z.fixedOffset;
    }
    function C(w) {
      a.minSize = [
        Q(`${w[0]}`, 0) || 0,
        Q(`${w[1]}`, 0) || 0
      ];
    }
    function E(w) {
      const z = [w[0] || 1 / 0, w[1] || 1 / 0];
      (!je(z[0]) || isFinite(z[0])) && (z[0] = Q(`${z[0]}`, 0) || 1 / 0), (!je(z[1]) || isFinite(z[1])) && (z[1] = Q(`${z[1]}`, 0) || 1 / 0), a.maxSize = z;
    }
    S(d / p), v(c || [-u[0], -u[1]]), a.setFixedDirection = v, a.setFixedPosition = x, a.setMin = C, a.setMax = E;
    const D = K(e, n, {
      direction: u,
      startRatio: a.ratio,
      set: ([w, z]) => {
        a.startWidth = w, a.startHeight = z;
      },
      setMin: C,
      setMax: E,
      setRatio: S,
      setFixedDirection: v,
      setFixedPosition: x,
      setOrigin: (w) => {
        a.transformOrigin = w;
      },
      dragStart: vt.dragStart(
        e,
        new Pe().dragStart([0, 0], n)
      )
    }), T = l || F(e, "onResizeStart", D);
    return a.startFixedDirection = a.fixedDirection, a.startFixedPosition = a.fixedPosition, T !== false && (a.isResize = true, e.state.snapRenderInfo = {
      request: n.isRequest,
      direction: u
    }), a.isResize ? D : false;
  },
  dragControl(e, n) {
    const {
      datas: t,
      parentFlag: s,
      isPinch: r,
      parentKeepRatio: o,
      dragClient: i,
      parentDist: a,
      useSnap: c,
      isRequest: l,
      isGroup: u,
      parentEvent: f,
      resolveMatrix: h
    } = n, {
      isResize: d,
      transformOrigin: p,
      startWidth: g,
      startHeight: m,
      prevWidth: S,
      prevHeight: v,
      minSize: x,
      maxSize: C,
      ratio: E,
      startOffsetWidth: D,
      startOffsetHeight: T,
      isWidth: w
    } = t;
    if (!d)
      return;
    if (h) {
      const { is3d: nt } = e.state, { startOffsetMatrix: Ft, startTransformOrigin: Lt } = t, ut = nt ? 4 : 3;
      let St = ye(yn(n));
      const xe = Math.sqrt(St.length);
      ut !== xe && (St = Xt(St, xe, ut));
      const fr = nn(
        Ft,
        St,
        Lt,
        ut
      ), oa = me(
        fr,
        D,
        T,
        ut
      );
      t.startPositions = oa, t.nextTargetMatrix = St, t.nextAllMatrix = fr;
    }
    const z = de(e.props, "resizable"), {
      resizeFormat: M,
      throttleResize: R = s ? 0 : 1,
      parentMoveable: P,
      keepRatioFinally: y
    } = z, k = t.direction;
    let _ = k, O = 0, B = 0;
    !k[0] && !k[1] && (_ = [1, 1]);
    const A = E && (o ?? z.keepRatio) || false;
    function N() {
      const nt = t.fixedDirection, Ft = _i(_, A, t, n);
      O = Ft.distWidth, B = Ft.distHeight;
      let Lt = _[0] - nt[0] || A ? Math.max(D + O, bt) : D, ut = _[1] - nt[1] || A ? Math.max(T + B, bt) : T;
      return A && D && T && (w ? ut = Lt / E : Lt = ut * E), [Lt, ut];
    }
    let [G, Y] = N();
    f || (t.setFixedDirection(t.fixedDirection), F(
      e,
      "onBeforeResize",
      K(
        e,
        n,
        {
          startFixedDirection: t.startFixedDirection,
          startFixedPosition: t.startFixedPosition,
          setFixedDirection(nt) {
            return t.setFixedDirection(nt), [G, Y] = N(), [G, Y];
          },
          setFixedPosition(nt) {
            return t.setFixedPosition(nt), [G, Y] = N(), [G, Y];
          },
          boundingWidth: G,
          boundingHeight: Y,
          setSize(nt) {
            [G, Y] = nt;
          }
        },
        true
      )
    ));
    let q = i;
    i || (!s && r ? q = Xc(e, [0, 0]) : q = t.fixedPosition);
    let X = [0, 0];
    r || (X = Il(
      e,
      G,
      Y,
      k,
      q,
      !c && l,
      t
    )), a && (!a[0] && (X[0] = 0), !a[1] && (X[1] = 0));
    function W() {
      M && ([G, Y] = M([
        G,
        Y
      ])), G = U(G, R), Y = U(Y, R);
    }
    if (A) {
      _[0] && _[1] && X[0] && X[1] && (I(X[0]) > I(X[1]) ? X[1] = 0 : X[0] = 0);
      const nt = !X[0] && !X[1];
      nt && W(), _[0] && !_[1] || X[0] && !X[1] || nt && w ? (G += X[0], Y = G / E) : (!_[0] && _[1] || !X[0] && X[1] || nt && !w) && (Y += X[1], G = Y * E);
    } else
      G += X[0], Y += X[1], G = Math.max(0, G), Y = Math.max(0, Y);
    [G, Y] = _s(
      [G, Y],
      x,
      C,
      A ? E : false
    ), W(), A && (u || y) && (w ? Y = G / E : G = Y * E), O = G - D, B = Y - T;
    const Z = [O - S, B - v];
    t.prevWidth = O, t.prevHeight = B;
    const $ = kc(
      e,
      G,
      Y,
      q,
      p,
      t
    );
    if (!P && Z.every((nt) => !nt) && $.every((nt) => !nt))
      return;
    const L = vt.drag(
      e,
      en(
        n,
        e.state,
        $,
        !!r,
        false,
        "draggable"
      )
    ), j = L.transform, ot = g + O, pt = m + B, lt = K(e, n, {
      width: ot,
      height: pt,
      offsetWidth: Math.round(G),
      offsetHeight: Math.round(Y),
      startRatio: E,
      boundingWidth: G,
      boundingHeight: Y,
      direction: k,
      dist: [O, B],
      delta: Z,
      isPinch: !!r,
      drag: L,
      ...Ri(
        {
          style: {
            width: `${ot}px`,
            height: `${pt}px`
          },
          transform: j
        },
        L,
        n
      )
    });
    return !f && F(e, "onResize", lt), lt;
  },
  dragControlAfter(e, n) {
    const t = n.datas, {
      isResize: s,
      startOffsetWidth: r,
      startOffsetHeight: o,
      prevWidth: i,
      prevHeight: a
    } = t;
    if (!s || e.props.checkResizableError === false)
      return;
    const { width: c, height: l } = e.state, u = c - (r + i), f = l - (o + a), h = I(u) > 3, d = I(f) > 3;
    if (h && (t.startWidth += u, t.startOffsetWidth += u, t.prevWidth += u), d && (t.startHeight += f, t.startOffsetHeight += f, t.prevHeight += f), h || d)
      return this.dragControl(e, n);
  },
  dragControlEnd(e, n) {
    const { datas: t, parentEvent: s } = n;
    if (!t.isResize)
      return;
    t.isResize = false;
    const r = zt(e, n, {});
    return !s && F(e, "onResizeEnd", r), r;
  },
  dragGroupControlCondition: _r,
  dragGroupControlStart(e, n) {
    const { datas: t } = n, s = this.dragControlStart(e, { ...n, isGroup: true });
    if (!s)
      return false;
    const r = $t(e, "resizable", n), {
      startOffsetWidth: o,
      startOffsetHeight: i
    } = t;
    function a() {
      const d = t.minSize;
      r.forEach((p) => {
        const {
          minSize: g,
          startOffsetWidth: m,
          startOffsetHeight: S
        } = p.datas, v = o * (m ? g[0] / m : 0), x = i * (S ? g[1] / S : 0);
        d[0] = Math.max(d[0], v), d[1] = Math.max(d[1], x);
      });
    }
    function c() {
      const d = t.maxSize;
      r.forEach((p) => {
        const {
          maxSize: g,
          startOffsetWidth: m,
          startOffsetHeight: S
        } = p.datas, v = o * (m ? g[0] / m : 0), x = i * (S ? g[1] / S : 0);
        d[0] = Math.min(d[0], v), d[1] = Math.min(d[1], x);
      });
    }
    const l = jt(
      e,
      this,
      "dragControlStart",
      n,
      (d, p) => zn(e, d, t, p)
    );
    a(), c();
    const u = (d) => {
      s.setFixedDirection(d), l.forEach((p, g) => {
        p.setFixedDirection(d), zn(e, p.moveable, t, r[g]);
      });
    };
    t.setFixedDirection = u;
    const f = {
      ...s,
      targets: e.props.targets,
      events: l.map((d) => ({
        ...d,
        setMin: (p) => {
          d.setMin(p), a();
        },
        setMax: (p) => {
          d.setMax(p), c();
        }
      })),
      setFixedDirection: u,
      setMin: (d) => {
        s.setMin(d), a();
      },
      setMax: (d) => {
        s.setMax(d), c();
      }
    }, h = F(e, "onResizeGroupStart", f);
    return t.isResize = h !== false, t.isResize ? s : false;
  },
  dragGroupControl(e, n) {
    const { datas: t } = n;
    if (!t.isResize)
      return;
    const s = de(e.props, "resizable");
    Vn(e, "onBeforeResize", (d) => {
      F(
        e,
        "onBeforeResizeGroup",
        K(
          e,
          n,
          {
            ...d,
            targets: s.targets
          },
          true
        )
      );
    });
    const r = this.dragControl(e, { ...n, isGroup: true });
    if (!r)
      return;
    const { boundingWidth: o, boundingHeight: i, dist: a } = r, c = s.keepRatio, l = [
      o / (o - a[0]),
      i / (i - a[1])
    ], u = t.fixedPosition, f = jt(
      e,
      this,
      "dragControl",
      n,
      (d, p) => {
        const [g, m] = mt(
          Qe(e.rotation / 180 * Math.PI, 3),
          [
            p.datas.originalX * l[0],
            p.datas.originalY * l[1],
            1
          ],
          3
        );
        return {
          ...p,
          parentDist: null,
          parentScale: l,
          dragClient: tt(u, [g, m]),
          parentKeepRatio: c
        };
      }
    ), h = {
      targets: s.targets,
      events: f,
      ...r
    };
    return F(e, "onResizeGroup", h), h;
  },
  dragGroupControlEnd(e, n) {
    const { isDrag: t, datas: s } = n;
    if (!s.isResize)
      return;
    this.dragControlEnd(e, n);
    const r = jt(e, this, "dragControlEnd", n), o = zt(
      e,
      n,
      {
        targets: e.props.targets,
        events: r
      }
    );
    return F(e, "onResizeGroupEnd", o), t;
  },
  /**
       * @method Moveable.Resizable#request
       * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter
       * @return {Moveable.Requester} Moveable Requester
       * @example
  
       * // Instantly Request (requestStart - request - requestEnd)
       * // Use Relative Value
       * moveable.request("resizable", { deltaWidth: 10, deltaHeight: 10 }, true);
       *
       * // Use Absolute Value
       * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 }, true);
       *
       * // requestStart
       * const requester = moveable.request("resizable");
       *
       * // request
       * // Use Relative Value
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       *
       * // Use Absolute Value
       * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 });
       * moveable.request("resizable", { offsetWidth: 110, offsetHeight: 100 });
       * moveable.request("resizable", { offsetWidth: 120, offsetHeight: 100 });
       *
       * // requestEnd
       * requester.requestEnd();
       */
  request(e) {
    const n = {};
    let t = 0, s = 0, r = false;
    const o = e.getRect();
    return {
      isControl: true,
      requestStart(i) {
        return r = i.useSnap, {
          datas: n,
          parentDirection: i.direction || [1, 1],
          parentIsWidth: (i == null ? void 0 : i.horizontal) ?? true,
          useSnap: r
        };
      },
      request(i) {
        return "offsetWidth" in i ? t = i.offsetWidth - o.offsetWidth : "deltaWidth" in i && (t += i.deltaWidth), "offsetHeight" in i ? s = i.offsetHeight - o.offsetHeight : "deltaHeight" in i && (s += i.deltaHeight), {
          datas: n,
          parentDist: [t, s],
          parentKeepRatio: i.keepRatio,
          useSnap: r
        };
      },
      requestEnd() {
        return { datas: n, isDrag: true, useSnap: r };
      }
    };
  },
  unset(e) {
    e.state.gestos.resizable = null;
  }
};
function es(e, n, t, s, r) {
  const o = e.props.groupable, i = e.state, a = i.is3d ? 4 : 3, c = n.origin, l = at(
    e.state.rootMatrix,
    // TO-DO #710
    V([c[0], c[1]], o ? [0, 0] : [i.left, i.top]),
    a
  ), u = tt([r.left, r.top], l);
  n.startAbsoluteOrigin = u, n.prevDeg = ft(u, [t, s]) / Math.PI * 180, n.defaultDeg = n.prevDeg, n.prevSnapDeg = 0, n.loop = 0, n.startDist = Nt(u, [t, s]);
}
function En(e, n, t) {
  const { defaultDeg: s, prevDeg: r } = t;
  let o = r % 360, i = Math.floor(r / 360);
  o < 0 && (o += 360), o > e && o > 270 && e < 90 ? ++i : o < e && o < 90 && e > 270 && --i;
  const a = n * (i * 360 + e - s);
  return t.prevDeg = s + a, a;
}
function ns(e, n, t, s) {
  return En(
    ft(s.startAbsoluteOrigin, [e, n]) / Math.PI * 180,
    t,
    s
  );
}
function ss(e, n, t, s, r, o) {
  const { throttleRotate: i = 0 } = e.props, a = t.prevSnapDeg;
  let c = 0, l = false;
  if (o) {
    const f = Ol(
      e,
      n,
      s,
      r + s
    );
    l = f.isSnap, c = r + f.dist;
  }
  l || (c = U(r + s, i));
  const u = c - r;
  return t.prevSnapDeg = u, [u - a, u, c];
}
function di(e, [n, t, s, r], o) {
  if (e === "none")
    return [];
  if (ct(e))
    return e.map(
      (f) => di(f, [n, t, s, r], o)[0]
    );
  const [i, a] = (e || "top").split("-");
  let c = [n, t];
  i === "left" ? c = [s, n] : i === "right" ? c = [t, r] : i === "bottom" && (c = [r, s]);
  let l = [
    (c[0][0] + c[1][0]) / 2,
    (c[0][1] + c[1][1]) / 2
  ];
  const u = bi(c, o);
  if (a) {
    const f = a === "top" || a === "left", h = i === "bottom" || i === "left";
    l = c[f && !h || !f && h ? 0 : 1];
  }
  return [[l, u]];
}
function Cs(e, n) {
  if (n.isRequest)
    return n.requestAble === "rotatable";
  const t = n.inputEvent.target;
  if (dt(t, H("rotation-control")) || e.props.rotateAroundControls && dt(t, H("around-control")) || dt(t, H("control")) && dt(t, H("rotatable")))
    return true;
  const s = e.props.rotationTarget;
  return s ? rr(s, true).some((r) => r ? t === r || t.contains(r) : false) : false;
}
var xl = `.rotation {
position: absolute;
height: 40px;
width: 1px;
transform-origin: 50% 100%;
height: calc(40px * var(--zoom));
top: auto;
left: 0;
bottom: 100%;
will-change: transform;
}
.rotation .rotation-line {
display: block;
width: 100%;
height: 100%;
transform-origin: 50% 50%;
}
.rotation .rotation-control {
border-color: #4af;
border-color: var(--moveable-color);
background:#fff;
cursor: alias;
}
:global .view-rotation-dragging, .rotatable.direction.control {
cursor: alias;
}
.rotatable.direction.control.move {
cursor: move;
}
`;
var vl = {
  name: "rotatable",
  canPinch: true,
  props: [
    "rotatable",
    "rotationPosition",
    "throttleRotate",
    "renderDirections",
    "rotationTarget",
    "rotateAroundControls",
    "edge",
    "resolveAblesWithRotatable",
    "displayAroundControls"
  ],
  events: [
    "rotateStart",
    "beforeRotate",
    "rotate",
    "rotateEnd",
    "rotateGroupStart",
    "beforeRotateGroup",
    "rotateGroup",
    "rotateGroupEnd"
  ],
  css: [xl],
  viewClassName(e) {
    return e.isDragging("rotatable") ? H("view-rotation-dragging") : "";
  },
  render(e, n) {
    const {
      rotatable: t,
      rotationPosition: s,
      zoom: r,
      renderDirections: o,
      rotateAroundControls: i,
      resolveAblesWithRotatable: a
    } = de(e.props, "rotatable"), { renderPoses: c, direction: l } = e.getState();
    if (!t)
      return null;
    const u = di(
      s,
      c,
      l
    ), f = [];
    if (u.forEach(([h, d], p) => {
      f.push(
        (0, import_jsx_runtime.jsxs)(
          "div",
          {
            className: H("rotation"),
            style: {
              // tslint:disable-next-line: max-line-length
              transform: `translate(-50%) translate(${h[0]}px, ${h[1]}px) rotate(${d}rad)`
            },
            children: [
              (0, import_jsx_runtime.jsx)(
                "div",
                {
                  className: H("line rotation-line"),
                  style: {
                    transform: `scaleX(${r})`
                  }
                }
              ),
              (0, import_jsx_runtime.jsx)(
                "div",
                {
                  className: H("control rotation-control"),
                  style: {
                    transform: `translate(0.5px) scale(${r})`
                  }
                }
              )
            ]
          },
          `rotation${p}`
        )
      );
    }), o) {
      const h = Be(a || {}), d = {};
      h.forEach((g) => {
        a[g].forEach((m) => {
          d[m] = g;
        });
      });
      let p = [];
      ct(o) && (p = o.map((g) => {
        const m = d[g];
        return {
          data: m ? { resolve: m } : {},
          classNames: m ? ["move"] : [],
          dir: g
        };
      })), f.push(
        ...Zo(
          e,
          "rotatable",
          p
        )
      );
    }
    return i && f.push(...ei(e)), f;
  },
  dragControlCondition: Cs,
  dragControlStart(e, n) {
    var _;
    const {
      datas: t,
      clientX: s,
      clientY: r,
      parentRotate: o,
      parentFlag: i,
      isPinch: a,
      isRequest: c
    } = n, l = e.state, {
      target: u,
      left: f,
      top: h,
      direction: d,
      beforeDirection: p,
      targetTransform: g,
      moveableClientRect: m,
      offsetMatrix: S,
      targetMatrix: v,
      allMatrix: x,
      width: C,
      height: E
    } = l;
    if (!c && !u)
      return false;
    const D = e.getRect();
    t.rect = D, t.transform = g, t.left = f, t.top = h;
    let T = (O) => {
      const B = hi(e.state, O);
      t.fixedDirection = B.fixedDirection, t.fixedOffset = B.fixedOffset, t.fixedPosition = B.fixedPosition, P && P.setFixedPosition(O);
    }, w = (O) => {
      const B = Sl(
        e.state,
        O
      );
      t.fixedDirection = B.fixedDirection, t.fixedOffset = B.fixedOffset, t.fixedPosition = B.fixedPosition, P && P.setFixedDirection(O);
    }, z = s, M = r;
    if (c || a || i) {
      const O = o || 0;
      t.beforeInfo = {
        origin: D.beforeOrigin,
        prevDeg: O,
        defaultDeg: O,
        prevSnapDeg: 0,
        startDist: 0
      }, t.afterInfo = {
        ...t.beforeInfo,
        origin: D.origin
      }, t.absoluteInfo = {
        ...t.beforeInfo,
        origin: D.origin,
        startValue: O
      };
    } else {
      const O = (_ = n.inputEvent) == null ? void 0 : _.target;
      if (O) {
        const A = O.getAttribute("data-direction") || "", N = bc[A];
        if (N) {
          t.isControl = true, t.isAroundControl = dt(
            O,
            H("around-control")
          ), t.controlDirection = N;
          const G = O.getAttribute("data-resolve");
          G && (t.resolveAble = G);
          const Y = jl(
            l.rootMatrix,
            l.renderPoses,
            m
          );
          [z, M] = gt(
            Y,
            N
          );
        }
      }
      t.beforeInfo = { origin: D.beforeOrigin }, t.afterInfo = { origin: D.origin }, t.absoluteInfo = {
        origin: D.origin,
        startValue: D.rotation
      };
      const B = T;
      T = (A) => {
        const N = l.is3d ? 4 : 3, [G, Y] = tt(
          bo(v, N),
          A
        ), q = mt(
          S,
          fe([G, Y], N)
        ), X = mt(
          x,
          fe([A[0], A[1]], N)
        );
        B(A);
        const W = l.posDelta;
        t.beforeInfo.origin = V(q, W), t.afterInfo.origin = V(X, W), t.absoluteInfo.origin = V(X, W), es(
          e,
          t.beforeInfo,
          z,
          M,
          m
        ), es(
          e,
          t.afterInfo,
          z,
          M,
          m
        ), es(
          e,
          t.absoluteInfo,
          z,
          M,
          m
        );
      }, w = (A) => {
        const N = gt(
          [
            [0, 0],
            [C, 0],
            [0, E],
            [C, E]
          ],
          A
        );
        T(N);
      };
    }
    t.startClientX = z, t.startClientY = M, t.direction = d, t.beforeDirection = p, t.startValue = 0, t.datas = {}, Fn(e, n, "rotate");
    let R = false, P = false;
    t.isControl && t.resolveAble && t.resolveAble === "resizable" && (P = Es.dragControlStart(e, {
      ...new Pe("resizable").dragStart([0, 0], n),
      parentPosition: t.controlPosition,
      parentFixedPosition: t.fixedPosition
    })), P || (R = vt.dragStart(
      e,
      new Pe().dragStart([0, 0], n)
    )), T(Ul(e));
    const y = K(e, n, {
      set: (O) => {
        t.startValue = O * Math.PI / 180;
      },
      setFixedDirection: w,
      setFixedPosition: T,
      ...Yn(e, n),
      dragStart: R,
      resizeStart: P
    }), k = F(e, "onRotateStart", y);
    return t.isRotate = k !== false, l.snapRenderInfo = {
      request: n.isRequest
    }, t.isRotate ? y : false;
  },
  dragControl(e, n) {
    const {
      datas: t,
      clientDistX: s,
      clientDistY: r,
      parentRotate: o,
      parentFlag: i,
      isPinch: a,
      groupDelta: c,
      resolveMatrix: l
    } = n, {
      beforeDirection: u,
      beforeInfo: f,
      afterInfo: h,
      absoluteInfo: d,
      isRotate: p,
      startValue: g,
      rect: m,
      startClientX: S,
      startClientY: v
    } = t;
    if (!p)
      return;
    kn(e, n, "rotate");
    const x = Tc(n), C = u * x, { parentMoveable: E } = e.props;
    let D = 0, T, w, z = 0, M, R, P = 0, y, k;
    const _ = 180 / Math.PI * g, O = d.startValue;
    let B = false;
    const A = S + s, N = v + r;
    if (!i && "parentDist" in n) {
      const j = n.parentDist;
      T = j, M = j, y = j;
    } else a || i ? (T = En(o, u, f), M = En(o, C, h), y = En(o, C, d)) : (T = ns(
      A,
      N,
      u,
      f
    ), M = ns(
      A,
      N,
      C,
      h
    ), y = ns(
      A,
      N,
      C,
      d
    ), B = true);
    if (w = _ + T, R = _ + M, k = O + y, F(
      e,
      "onBeforeRotate",
      K(
        e,
        n,
        {
          beforeRotation: w,
          rotation: R,
          absoluteRotation: k,
          setRotation(j) {
            M = j - _, T = M, y = M;
          }
        },
        true
      )
    ), [D, T, w] = ss(
      e,
      m,
      f,
      T,
      _,
      B
    ), [z, M, R] = ss(
      e,
      m,
      h,
      M,
      _,
      B
    ), [P, y, k] = ss(
      e,
      m,
      d,
      y,
      O,
      B
    ), !P && !z && !D && !E && !l)
      return;
    const G = Xn(
      t,
      `rotate(${R}deg)`,
      `rotate(${M}deg)`
    );
    l && (t.fixedPosition = Vs(
      e,
      t.targetAllTransform,
      t.fixedDirection,
      t.fixedOffset,
      t
    ));
    const Y = $c(e, M, t), q = V(
      tt(c || [0, 0], Y),
      t.prevInverseDist || [0, 0]
    );
    t.prevInverseDist = Y, t.requestValue = null;
    const X = qo(
      e,
      G,
      q,
      a,
      n
    );
    let W = X;
    const Z = Nt([A, N], d.startAbsoluteOrigin) - d.startDist;
    let $;
    if (t.resolveAble === "resizable") {
      const j = Es.dragControl(e, {
        ...en(
          n,
          e.state,
          [n.deltaX, n.deltaY],
          !!a,
          false,
          "resizable"
        ),
        resolveMatrix: true,
        parentDistance: Z
      });
      j && ($ = j, W = Ri(W, j, n));
    }
    const L = K(e, n, {
      delta: z,
      dist: M,
      rotate: R,
      rotation: R,
      beforeDist: T,
      beforeDelta: D,
      beforeRotate: w,
      beforeRotation: w,
      absoluteDist: y,
      absoluteDelta: P,
      absoluteRotate: k,
      absoluteRotation: k,
      isPinch: !!a,
      resize: $,
      ...X,
      ...W
    });
    return F(e, "onRotate", L), L;
  },
  dragControlEnd(e, n) {
    const { datas: t } = n;
    if (!t.isRotate)
      return;
    t.isRotate = false;
    const s = zt(e, n, {});
    return F(e, "onRotateEnd", s), s;
  },
  dragGroupControlCondition: Cs,
  dragGroupControlStart(e, n) {
    const { datas: t } = n, {
      left: s,
      top: r,
      beforeOrigin: o
    } = e.state, i = this.dragControlStart(e, n);
    if (!i)
      return false;
    i.set(t.beforeDirection * e.rotation);
    const a = jt(
      e,
      this,
      "dragControlStart",
      n,
      (u, f) => {
        const { left: h, top: d, beforeOrigin: p } = u.state, g = tt(
          V([h, d], [s, r]),
          V(p, o)
        );
        return f.datas.startGroupClient = g, f.datas.groupClient = g, { ...f, parentRotate: 0 };
      }
    ), c = {
      ...i,
      targets: e.props.targets,
      events: a
    }, l = F(e, "onRotateGroupStart", c);
    return t.isRotate = l !== false, t.isRotate ? i : false;
  },
  dragGroupControl(e, n) {
    const { datas: t } = n;
    if (!t.isRotate)
      return;
    Vn(e, "onBeforeRotate", (l) => {
      F(
        e,
        "onBeforeRotateGroup",
        K(
          e,
          n,
          {
            ...l,
            targets: e.props.targets
          },
          true
        )
      );
    });
    const s = this.dragControl(e, n);
    if (!s)
      return;
    const r = t.beforeDirection, o = s.beforeDist, i = o / 180 * Math.PI, a = jt(
      e,
      this,
      "dragControl",
      n,
      (l, u) => {
        const f = u.datas.startGroupClient, [h, d] = u.datas.groupClient, [p, g] = Je(
          f,
          i * r
        ), m = [p - h, g - d];
        return u.datas.groupClient = [p, g], { ...u, parentRotate: o, groupDelta: m };
      }
    );
    e.rotation = r * s.beforeRotation;
    const c = {
      targets: e.props.targets,
      events: a,
      set(l) {
        e.rotation = l;
      },
      setGroupRotation(l) {
        e.rotation = l;
      },
      ...s
    };
    return F(e, "onRotateGroup", c), c;
  },
  dragGroupControlEnd(e, n) {
    const { isDrag: t, datas: s } = n;
    if (!s.isRotate)
      return;
    this.dragControlEnd(e, n);
    const r = jt(e, this, "dragControlEnd", n), o = zt(e, n, {
      targets: e.props.targets,
      events: r
    });
    return F(e, "onRotateGroupEnd", o), t;
  },
  /**
       * @method Moveable.Rotatable#request
       * @param {object} [e] - the Resizable's request parameter
       * @param {number} [e.deltaRotate=0] -  delta number of rotation
       * @param {number} [e.rotate=0] - absolute number of moveable's rotation
       * @return {Moveable.Requester} Moveable Requester
       * @example
  
       * // Instantly Request (requestStart - request - requestEnd)
       * moveable.request("rotatable", { deltaRotate: 10 }, true);
       *
       * * moveable.request("rotatable", { rotate: 10 }, true);
       *
       * // requestStart
       * const requester = moveable.request("rotatable");
       *
       * // request
       * requester.request({ deltaRotate: 10 });
       * requester.request({ deltaRotate: 10 });
       * requester.request({ deltaRotate: 10 });
       *
       * requester.request({ rotate: 10 });
       * requester.request({ rotate: 20 });
       * requester.request({ rotate: 30 });
       *
       * // requestEnd
       * requester.requestEnd();
       */
  request(e) {
    const n = {};
    let t = 0;
    const s = e.getRotation();
    return {
      isControl: true,
      requestStart() {
        return { datas: n };
      },
      request(r) {
        return "deltaRotate" in r ? t += r.deltaRotate : "rotate" in r && (t = r.rotate - s), { datas: n, parentDist: t };
      },
      requestEnd() {
        return { datas: n, isDrag: true };
      }
    };
  }
};
function El(e, n) {
  const { direction: t, classNames: s, size: r, pos: o, zoom: i, key: a } = e, c = t === "horizontal", l = c ? "Y" : "X";
  return n.createElement("div", {
    key: a,
    className: s.join(" "),
    style: {
      [c ? "width" : "height"]: `${r}`,
      transform: `translate(${o[0]}, ${o[1]}) translate${l}(-50%) scale${l}(${i})`
    }
  });
}
function Js(e, n) {
  return El(
    {
      ...e,
      classNames: [
        H("line", "guideline", e.direction),
        ...e.classNames
      ].filter((t) => t),
      size: e.size || `${e.sizeValue}px`,
      pos: e.pos || e.posValue.map((t) => `${U(t, 0.1)}px`)
    },
    n
  );
}
function Or(e, n, t, s, r, o, i, a) {
  const { zoom: c } = e.props;
  return t.map(({ type: l, pos: u }, f) => {
    const h = [0, 0];
    return h[i] = s, h[i ? 0 : 1] = -r + u, Js(
      {
        key: `${n}TargetGuideline${f}`,
        classNames: [H("target", "bold", l)],
        posValue: h,
        sizeValue: o,
        zoom: c,
        direction: n
      },
      a
    );
  });
}
function Ir(e, n, t, s, r, o) {
  const { zoom: i, isDisplayInnerSnapDigit: a } = e.props, c = n === "horizontal" ? te : ee, l = r[c.start], u = r[c.end];
  return t.filter(({ hide: f, elementRect: h }) => {
    if (f)
      return false;
    if (a && h) {
      const d = h.rect;
      if (d[c.start] <= l && u <= d[c.end])
        return false;
    }
    return true;
  }).map((f, h) => {
    const { pos: d, size: p, element: g, className: m } = f, S = [-s[0] + d[0], -s[1] + d[1]];
    return Js(
      {
        key: `${n}-default-guideline-${h}`,
        classNames: g ? [H("bold"), m] : [H("normal"), m],
        direction: n,
        posValue: S,
        sizeValue: p,
        zoom: i
      },
      o
    );
  });
}
function Ye(e, n, t, s, r, o, i, a) {
  const {
    snapDigit: c = 0,
    isDisplaySnapDigit: l = true,
    snapDistFormat: u = (m, S) => m,
    zoom: f
  } = e.props, h = n === "horizontal" ? "X" : "Y", d = n === "vertical" ? "height" : "width", p = Math.abs(r), g = l ? parseFloat(p.toFixed(c)) : 0;
  return (0, import_jsx_runtime.jsxs)(
    "div",
    {
      className: H("guideline-group", n),
      style: {
        left: `${o[0]}px`,
        top: `${o[1]}px`,
        [d]: `${p}px`
      },
      children: [
        Js(
          {
            direction: n,
            classNames: [H(t), i],
            size: "100%",
            posValue: [0, 0],
            sizeValue: p,
            zoom: f
          },
          a
        ),
        (0, import_jsx_runtime.jsx)(
          "div",
          {
            className: H("size-value", "gap"),
            style: {
              transform: `translate${h}(-50%) scale(${f})`
            },
            children: g > 0 ? u(g, n) : ""
          }
        )
      ]
    },
    `${n}-${t}-guideline-${s}`
  );
}
function Cl(e, n, t, s) {
  const r = e === "vertical" ? 0 : 1, o = e === "vertical" ? 1 : 0, i = r ? te : ee, a = t[i.start], c = t[i.end];
  return yi(n, (l) => l.pos[r]).map((l) => {
    const u = [], f = [], h = [];
    return l.forEach((d) => {
      const p = d.element, g = d.elementRect.rect;
      if (g[i.end] < a)
        u.push(d);
      else if (c < g[i.start])
        f.push(d);
      else if (g[i.start] <= a && c <= g[i.end] && s) {
        const m = d.pos, S = {
          element: p,
          rect: { ...g, [i.end]: g[i.start] }
        }, v = {
          element: p,
          rect: { ...g, [i.start]: g[i.end] }
        }, x = [0, 0], C = [0, 0];
        x[r] = m[r], x[o] = m[o], C[r] = m[r], C[o] = m[o] + d.size, u.push({
          type: e,
          pos: x,
          size: 0,
          elementRect: S,
          direction: "",
          elementDirection: "end"
        }), f.push({
          type: e,
          pos: C,
          size: 0,
          elementRect: v,
          direction: "",
          elementDirection: "start"
        });
      }
    }), u.sort((d, p) => p.pos[o] - d.pos[o]), f.sort((d, p) => d.pos[o] - p.pos[o]), {
      total: l,
      start: u,
      end: f,
      inner: h
    };
  });
}
function Dl(e, n, t, s, r) {
  const { isDisplayInnerSnapDigit: o } = e.props, i = [];
  return ["vertical", "horizontal"].forEach((a) => {
    const c = n.filter(
      (m) => m.type === a
    ), l = a === "vertical" ? 1 : 0, u = l ? 0 : 1, f = Cl(
      a,
      c,
      s,
      o
    ), h = l ? ee : te, d = l ? te : ee, p = s[h.start], g = s[h.end];
    f.forEach(({ total: m, start: S, end: v, inner: x }) => {
      const C = t[u] + m[0].pos[u] - s[d.start];
      let E = s;
      S.forEach((D) => {
        const T = D.elementRect.rect, w = E[h.start] - T[h.end];
        if (w > 0) {
          const z = [0, 0];
          z[l] = t[l] + E[h.start] - p - w, z[u] = C, i.push(
            Ye(
              e,
              a,
              "dashed",
              i.length,
              w,
              z,
              D.className,
              r
            )
          );
        }
        E = T;
      }), E = s, v.forEach((D) => {
        const T = D.elementRect.rect, w = T[h.start] - E[h.end];
        if (w > 0) {
          const z = [0, 0];
          z[l] = t[l] + E[h.end] - p, z[u] = C, i.push(
            Ye(
              e,
              a,
              "dashed",
              i.length,
              w,
              z,
              D.className,
              r
            )
          );
        }
        E = T;
      }), x.forEach((D) => {
        const T = D.elementRect.rect, w = p - T[h.start], z = T[h.end] - g, M = [0, 0], R = [0, 0];
        M[l] = t[l] - w, M[u] = C, R[l] = t[l] + g - p, R[u] = C, i.push(
          Ye(
            e,
            a,
            "dashed",
            i.length,
            w,
            M,
            D.className,
            r
          )
        ), i.push(
          Ye(
            e,
            a,
            "dashed",
            i.length,
            z,
            R,
            D.className,
            r
          )
        );
      });
    });
  }), i;
}
function bl(e, n, t, s, r) {
  const o = [];
  return ["horizontal", "vertical"].forEach((i) => {
    const a = n.filter((m) => m.type === i).slice(0, 1), c = i === "vertical" ? 0 : 1, l = c ? 0 : 1, u = c ? ee : te, f = c ? te : ee, h = s[u.start], d = s[u.end], p = s[f.start], g = s[f.end];
    a.forEach(({ gap: m, gapRects: S }) => {
      const v = Math.max(
        p,
        ...S.map(({ rect: E }) => E[f.start])
      ), x = Math.min(
        g,
        ...S.map(({ rect: E }) => E[f.end])
      ), C = (v + x) / 2;
      v === x || C === (p + g) / 2 || S.forEach(({ rect: E, className: D }) => {
        const T = [t[0], t[1]];
        if (E[u.end] < h)
          T[c] += E[u.end] - h;
        else if (d < E[u.start])
          T[c] += E[u.start] - h - m;
        else
          return;
        T[l] += C - p, o.push(
          Ye(
            e,
            c ? "vertical" : "horizontal",
            "gap",
            o.length,
            m,
            T,
            D,
            r
          )
        );
      });
    });
  }), o;
}
function Ds(e) {
  var M;
  const n = e.state, { containerClientRect: t, hasFixed: s } = n, {
    overflow: r,
    scrollHeight: o,
    scrollWidth: i,
    clientHeight: a,
    clientWidth: c,
    clientLeft: l,
    clientTop: u
  } = t, {
    snapGap: f = true,
    verticalGuidelines: h,
    horizontalGuidelines: d,
    snapThreshold: p = 5,
    maxSnapElementGuidelineDistance: g = 1 / 0,
    isDisplayGridGuidelines: m
  } = e.props, { top: S, left: v, bottom: x, right: C } = Ot(
    Bt(e.state)
  ), E = {
    top: S,
    left: v,
    bottom: x,
    right: C,
    center: (v + C) / 2,
    middle: (S + x) / 2
  };
  let T = [...Rl(e)];
  const w = (((M = n.snapThresholdInfo) == null ? void 0 : M.multiples) ?? [1, 1]).map((R) => R * p);
  f && T.push(
    ...wl(e, E, w)
  );
  const z = {
    ...n.snapOffset || {
      left: 0,
      top: 0,
      bottom: 0,
      right: 0
    }
  };
  if (T.push(
    ...Tl(
      e,
      r ? i : c,
      r ? o : a,
      l,
      u,
      z,
      m
    )
  ), s) {
    const { left: R, top: P } = t;
    z.left += R, z.top += P, z.right += R, z.bottom += P;
  }
  return T.push(
    ...gi(
      d || false,
      h || false,
      r ? i : c,
      r ? o : a,
      l,
      u,
      z
    )
  ), T = T.filter(({ element: R, elementRect: P, type: y }) => {
    if (!R || !P)
      return true;
    const k = P.rect;
    return pi(
      E,
      k,
      y,
      g
    );
  }), T;
}
function wl(e, n, t) {
  const {
    maxSnapElementGuidelineDistance: s = 1 / 0,
    maxSnapElementGapDistance: r = 1 / 0
  } = e.props, o = e.state.elementRects, i = [];
  return [
    ["vertical", te, ee],
    ["horizontal", ee, te]
  ].forEach(([a, c, l]) => {
    const u = n[c.start], f = n[c.end], h = n[c.center], d = n[l.start], p = n[l.end], g = {
      left: t[0],
      top: t[1]
    };
    function m(x) {
      const C = x.rect, E = g[c.start];
      return C[c.end] < u + E ? u - C[c.end] : f - E < C[c.start] ? C[c.start] - f : -1;
    }
    const S = o.filter((x) => {
      const C = x.rect;
      return C[l.start] > p || C[l.end] < d ? false : m(x) > 0;
    }).sort((x, C) => m(x) - m(C)), v = [];
    S.forEach((x) => {
      S.forEach((C) => {
        if (x === C)
          return;
        const { rect: E } = x, { rect: D } = C, T = E[l.start], w = E[l.end], z = D[l.start], M = D[l.end];
        T > M || z > w || v.push([x, C]);
      });
    }), v.forEach(([x, C]) => {
      const { rect: E } = x, { rect: D } = C, T = E[c.start], w = E[c.end], z = D[c.start], M = D[c.end], R = g[c.start];
      let P = 0, y = 0, k = false, _ = false, O = false;
      if (w <= u && f <= z) {
        if (_ = true, P = (z - w - (f - u)) / 2, y = w + P + (f - u) / 2, I(y - h) > R)
          return;
      } else if (w < z && M < u + R) {
        if (k = true, P = z - w, y = M + P, I(y - u) > R)
          return;
      } else if (w < z && f - R < T) {
        if (O = true, P = z - w, y = T - P, I(y - f) > R)
          return;
      } else
        return;
      P && pi(
        n,
        D,
        a,
        s
      ) && (P > r || i.push({
        type: a,
        pos: a === "vertical" ? [y, 0] : [0, y],
        element: C.element,
        size: 0,
        className: C.className,
        isStart: k,
        isCenter: _,
        isEnd: O,
        gap: P,
        hide: true,
        gapRects: [x, C],
        direction: "",
        elementDirection: ""
      }));
    });
  }), i;
}
function Ml(e, n, t, s) {
  var h, d;
  const r = e.props, o = e.state, { snapGridAll: i } = r, { snapGridWidth: a = 0, snapGridHeight: c = 0 } = r, { snapRenderInfo: l } = o, u = l && (((h = l.direction) == null ? void 0 : h[0]) || ((d = l.direction) == null ? void 0 : d[1])), f = e.moveables;
  if (i && f && u && (a || c)) {
    if (o.snapThresholdInfo)
      return;
    o.snapThresholdInfo = {
      multiples: [1, 1],
      offset: [0, 0]
    };
    const p = e.getRect(), g = p.children, m = l.direction;
    if (g) {
      const S = m.map((x, C) => {
        const { snapSize: E, posName: D, sizeName: T, clientOffset: w } = C === 0 ? {
          snapSize: a,
          posName: "left",
          sizeName: "width",
          clientOffset: s.left - n
        } : {
          snapSize: c,
          posName: "top",
          sizeName: "height",
          clientOffset: s.top - t
        };
        if (!E)
          return {
            dir: x,
            multiple: 1,
            snapSize: E,
            snapOffset: 0
          };
        const z = p[T], M = p[D], R = Da(
          g.map((A) => [
            A[D] - M,
            A[T],
            z - A[T] - A[D] + M
          ])
        ).filter((A) => A).sort((A, N) => A - N), P = R[0], y = R.map(
          (A) => U(A / P, 0.1) * E
        );
        let k = 1;
        const _ = U(z / P, 0.1);
        for (k = 1; k <= 10 && !y.every((A) => A * k % 1 === 0); ++k)
          ;
        const O = (-x + 1) / 2, B = bn(
          M - w,
          M - w + z,
          O,
          1 - O
        );
        return {
          multiple: _ * k,
          dir: x,
          snapSize: E,
          snapOffset: Math.round(B / E)
        };
      }), v = S.map((x) => x.multiple || 1);
      o.snapThresholdInfo.multiples = v, o.snapThresholdInfo.offset = S.map((x) => x.snapOffset), S.forEach((x, C) => {
        x.snapSize;
      });
    }
  } else
    o.snapThresholdInfo = null;
}
function Tl(e, n, t, s = 0, r = 0, o, i) {
  const a = e.props, c = e.state;
  let { snapGridWidth: l = 0, snapGridHeight: u = 0 } = a;
  const f = [], { left: h, top: d } = o;
  let p = [0, 0];
  Ml(e, s, r, o);
  const g = c.snapThresholdInfo, m = l, S = u;
  if (g && (l *= g.multiples[0] || 1, u *= g.multiples[1] || 1, p = g.offset), u) {
    const v = (x) => {
      f.push({
        type: "horizontal",
        pos: [
          h,
          U(
            p[1] * S + x - r + d,
            0.1
          )
        ],
        className: H("grid-guideline"),
        size: n,
        hide: !i,
        direction: "",
        grid: true
      });
    };
    for (let x = 0; x <= t * 2; x += u)
      v(x);
    for (let x = -u; x >= -t; x -= u)
      v(x);
  }
  if (l) {
    const v = (x) => {
      f.push({
        type: "vertical",
        pos: [
          U(
            p[0] * m + x - s + h,
            0.1
          ),
          d
        ],
        className: H("grid-guideline"),
        size: t,
        hide: !i,
        direction: "",
        grid: true
      });
    };
    for (let x = 0; x <= n * 2; x += l)
      v(x);
    for (let x = -l; x >= -n; x -= l)
      v(x);
  }
  return f;
}
function pi(e, n, t, s) {
  return t === "horizontal" ? I(e.right - n.left) <= s || I(e.left - n.right) <= s || e.left <= n.right && n.left <= e.right : t === "vertical" ? I(e.bottom - n.top) <= s || I(e.top - n.bottom) <= s || e.top <= n.bottom && n.top <= e.bottom : true;
}
function Rl(e) {
  const n = e.state, { elementGuidelines: t = [] } = e.props;
  if (!t.length)
    return n.elementRects = [], [];
  const s = (n.elementRects || []).filter(
    (u) => !u.refresh
  ), r = t.map((u) => Dt(u) && "element" in u ? {
    ...u,
    element: Ht(u.element, true)
  } : {
    element: Ht(u, true)
  }).filter((u) => u.element), { maintained: o, added: i } = Ce(
    s.map((u) => u.element),
    r.map((u) => u.element)
  ), a = [];
  o.forEach(([u, f]) => {
    a[f] = s[u];
  }), yl(
    e,
    i.map((u) => r[u])
  ).map((u, f) => {
    a[i[f]] = u;
  }), n.elementRects = a;
  const c = js(
    e.props.elementSnapDirections
  ), l = [];
  return a.forEach((u) => {
    const {
      element: f,
      top: h = c.top,
      left: d = c.left,
      right: p = c.right,
      bottom: g = c.bottom,
      center: m = c.center,
      middle: S = c.middle,
      className: v,
      rect: x
    } = u, { horizontal: C, vertical: E, horizontalNames: D, verticalNames: T } = Us(
      {
        top: h,
        right: p,
        left: d,
        bottom: g,
        center: m,
        middle: S
      },
      x
    ), w = x.top, z = x.left, M = x.right - z, R = x.bottom - w, P = [M, R];
    E.forEach((y, k) => {
      l.push({
        type: "vertical",
        element: f,
        pos: [U(y, 0.1), w],
        size: R,
        sizes: P,
        className: v,
        elementRect: u,
        elementDirection: wr[T[k]] || T[k],
        direction: ""
      });
    }), C.forEach((y, k) => {
      l.push({
        type: "horizontal",
        element: f,
        pos: [z, U(y, 0.1)],
        size: M,
        sizes: P,
        className: v,
        elementRect: u,
        elementDirection: wr[D[k]] || D[k],
        direction: ""
      });
    });
  }), l;
}
function Br(e, n) {
  return e ? e.map((t) => {
    const s = Dt(t) ? t : { pos: t }, r = s.pos;
    return je(r) ? s : {
      ...s,
      pos: Q(r, n)
    };
  }) : [];
}
function gi(e, n, t, s, r = 0, o = 0, i = { left: 0, top: 0, right: 0, bottom: 0 }) {
  const a = [], {
    left: c,
    top: l,
    bottom: u,
    right: f
  } = i, h = t + f - c, d = s + u - l;
  return Br(e, d).forEach((p) => {
    a.push({
      type: "horizontal",
      pos: [
        c,
        U(p.pos - o + l, 0.1)
      ],
      size: h,
      className: p.className,
      direction: ""
    });
  }), Br(n, h).forEach((p) => {
    a.push({
      type: "vertical",
      pos: [
        U(p.pos - r + c, 0.1),
        l
      ],
      size: d,
      className: p.className,
      direction: ""
    });
  }), a;
}
function yl(e, n) {
  if (!n.length)
    return [];
  const t = e.props.groupable, s = e.state, {
    containerClientRect: r,
    // targetClientRect: {
    //     top: clientTop,
    //     left: clientLeft,
    // },
    rootMatrix: o,
    is3d: i,
    offsetDelta: a
  } = s, c = i ? 4 : 3, [l, u] = Jc(
    o,
    r,
    c
  ), f = t ? 0 : a[0], h = t ? 0 : a[1];
  return n.map((d) => {
    const p = d.element.getBoundingClientRect(), g = p.left - l - f, m = p.top - u - h, S = m + p.height, v = g + p.width, [x, C] = Ie(
      o,
      [g, m],
      c
    ), [E, D] = Ie(
      o,
      [v, S],
      c
    );
    return {
      ...d,
      rect: {
        left: x,
        right: E,
        top: C,
        bottom: D,
        center: (x + E) / 2,
        middle: (C + D) / 2
      }
    };
  });
}
function dn(e) {
  const n = e.state, t = n.container, s = e.props.snapContainer || t;
  if (n.snapContainer === s && n.guidelines && n.guidelines.length)
    return false;
  const r = n.containerClientRect, o = {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  };
  if (t !== s) {
    const i = Ht(s, true);
    if (i) {
      const a = Ve(i), c = Yr(n, [
        a.left - r.left,
        a.top - r.top
      ]), l = Yr(n, [
        a.right - r.right,
        a.bottom - r.bottom
      ]);
      o.left = U(c[0], 1e-5), o.top = U(c[1], 1e-5), o.right = U(l[0], 1e-5), o.bottom = U(l[1], 1e-5);
    }
  }
  return n.snapContainer = s, n.snapOffset = o, n.guidelines = Ds(e), n.enableSnap = true, true;
}
function mi(e, n, t, s, r, o) {
  const i = me(e, n, t, o ? 4 : 3), a = gt(i, s);
  return tr(i, V(r, a));
}
function Ar(e) {
  return e ? e / I(e) : 0;
}
function zl(e, n, t, s, r, o) {
  const { fixedDirection: i } = o, a = nl(
    t,
    i,
    s
  ), c = Ks(
    e,
    n,
    t,
    s
  ), l = [
    ...pl(
      e,
      n,
      a,
      s,
      r,
      o
    ),
    ...ui(e, c, o)
  ], u = Pn(l, 0), f = Pn(l, 1);
  return {
    width: {
      isBound: u.isBound,
      offset: u.offset[0]
    },
    height: {
      isBound: f.isBound,
      offset: f.offset[1]
    }
  };
}
function Pl(e, n, t, s, r, o, i, a, c) {
  const l = gt(n, i), {
    horizontal: { offset: u },
    vertical: { offset: f }
  } = Nn(e, a, {
    vertical: [l[0]],
    horizontal: [l[1]]
  });
  if (U(f, gs) || U(u, gs)) {
    const [h, d] = Vt({
      datas: c,
      distX: -f,
      distY: -u
    }), p = Math.min(
      r || 1 / 0,
      t + i[0] * h
    ), g = Math.min(
      o || 1 / 0,
      s + i[1] * d
    );
    return [p - t, g - s];
  }
  return [0, 0];
}
function Si(e, n, t, s, r, o, i, a) {
  const c = Bt(e.state), l = e.props.keepRatio;
  let u = 0, f = 0;
  for (let h = 0; h < 2; ++h) {
    const d = n(u, f), { width: p, height: g } = zl(
      e,
      d,
      r,
      l,
      i,
      a
    ), m = p.isBound, S = g.isBound;
    let v = p.offset, x = g.offset;
    if (h === 1 && (m || (v = 0), S || (x = 0)), h === 0 && i && !m && !S)
      return [0, 0];
    if (l) {
      const C = I(v) * (t ? 1 / t : 1), E = I(x) * (s ? 1 / s : 1);
      (m && S ? C < E : S || !m && C < E) ? v = t * x / s : x = s * v / t;
    }
    u += v, f += x;
  }
  if (!l && r[0] && r[1]) {
    const { maxWidth: h, maxHeight: d } = ml(
      e,
      c,
      r,
      o,
      a
    ), [p, g] = Pl(
      e,
      n(u, f).map(
        (m) => m.map((S) => U(S, gs))
      ),
      t + u,
      s + f,
      h,
      d,
      r,
      i,
      a
    );
    u += p, f += g;
  }
  return [u, f];
}
function Ne(e) {
  return e < 0 && (e = e % 360 + 360), e %= 360, e;
}
function _l(e, n) {
  n = Ne(n);
  const t = Math.floor(e / 360), s = t * 360 + 360 - n, r = t * 360 + n;
  return I(e - s) < I(e - r) ? s : r;
}
function rs(e, n) {
  e = Ne(e), n = Ne(n);
  const t = Ne(e - n);
  return Math.min(t, 360 - t);
}
function Ol(e, n, t, s) {
  const r = e.props, o = r[ni] ?? 5, i = r[si];
  if (ke(e, "rotatable")) {
    const { pos1: a, pos2: c, pos3: l, pos4: u, origin: f } = n, h = t * Math.PI / 180, d = [a, c, l, u].map(
      (S) => V(S, f)
    ), p = d.map((S) => Je(S, h)), g = [
      ...jc(e, d, p, f, t),
      ...cl(e, d, p, f, t)
    ];
    g.sort((S, v) => I(S - t) - I(v - t));
    const m = g.length > 0;
    if (m)
      return {
        isSnap: m,
        dist: m ? g[0] : t
      };
  }
  if (i != null && i.length && o) {
    const c = i.slice().sort((l, u) => rs(l, s) - rs(u, s))[0];
    if (rs(c, s) <= o)
      return {
        isSnap: true,
        dist: t + _l(s, c) - s
      };
  }
  return {
    isSnap: false,
    dist: t
  };
}
function Il(e, n, t, s, r, o, i) {
  if (!ke(e, "resizable"))
    return [0, 0];
  const { fixedDirection: a, nextAllMatrix: c } = i, { allMatrix: l, is3d: u } = e.state;
  return Si(
    e,
    (f, h) => mi(
      c || l,
      n + f,
      t + h,
      a,
      r,
      u
    ),
    n,
    t,
    s,
    r,
    o,
    i
  );
}
function Bl(e, n, t, s, r) {
  if (!ke(e, "scalable"))
    return [0, 0];
  const {
    startOffsetWidth: o,
    startOffsetHeight: i,
    fixedPosition: a,
    fixedDirection: c,
    is3d: l
  } = r, u = Si(
    e,
    (f, h) => mi(
      Ic(
        r,
        tt(n, [
          f / o,
          h / i
        ])
      ),
      o,
      i,
      c,
      a,
      l
    ),
    o,
    i,
    t,
    a,
    s,
    r
  );
  return [u[0] / o, u[1] / i];
}
function Al(e, n) {
  n.absolutePoses = Bt(e.state);
}
function Gr(e) {
  const n = [];
  return e.forEach((t) => {
    t.guidelineInfos.forEach(({ guideline: s }) => {
      yt(n, (r) => r.guideline === s) || (s.direction = "", n.push({ guideline: s, posInfo: t }));
    });
  }), n.map(({ guideline: t, posInfo: s }) => ({
    ...t,
    direction: s.direction
  }));
}
function $r(e, n, t, s, r, o) {
  const { vertical: i, horizontal: a } = qs(
    Ln(e, o),
    n,
    t
  ), c = be();
  i.forEach((h) => {
    h.isBound && (h.direction === "start" && (c.left = true), h.direction === "end" && (c.right = true), s.push({
      type: "bounds",
      pos: h.pos
    }));
  }), a.forEach((h) => {
    h.isBound && (h.direction === "start" && (c.top = true), h.direction === "end" && (c.bottom = true), r.push({
      type: "bounds",
      pos: h.pos
    }));
  });
  const {
    boundMap: l,
    vertical: u,
    horizontal: f
  } = ll(e);
  return u.forEach((h) => {
    Ut(
      s,
      ({ type: d, pos: p }) => d === "bounds" && p === h
    ) >= 0 || s.push({
      type: "bounds",
      pos: h
    });
  }), f.forEach((h) => {
    Ut(
      r,
      ({ type: d, pos: p }) => d === "bounds" && p === h
    ) >= 0 || r.push({
      type: "bounds",
      pos: h
    });
  }), {
    boundMap: c,
    innerBoundMap: l
  };
}
var Gl = sr("", ["resizable", "scalable"]);
var $l = {
  name: "snappable",
  dragRelation: "strong",
  props: [
    "snappable",
    "snapContainer",
    "snapDirections",
    "elementSnapDirections",
    "snapGap",
    "snapGridWidth",
    "snapGridHeight",
    "isDisplaySnapDigit",
    "isDisplayInnerSnapDigit",
    "isDisplayGridGuidelines",
    "snapDigit",
    "snapThreshold",
    "snapRenderThreshold",
    "snapGridAll",
    ni,
    si,
    ri,
    oi,
    "horizontalGuidelines",
    "verticalGuidelines",
    "elementGuidelines",
    "bounds",
    "innerBounds",
    "snapDistFormat",
    "maxSnapElementGuidelineDistance",
    "maxSnapElementGapDistance"
  ],
  events: ["snap", "bound"],
  css: [
    `:host {
--bounds-color: #d66;
}
.guideline {
pointer-events: none;
z-index: 2;
}
.guideline.bounds {
background: #d66;
background: var(--bounds-color);
}
.guideline-group {
position: absolute;
top: 0;
left: 0;
}
.guideline-group .size-value {
position: absolute;
color: #f55;
font-size: 12px;
font-size: calc(12px * var(--zoom));
font-weight: bold;
}
.guideline-group.horizontal .size-value {
transform-origin: 50% 100%;
transform: translateX(-50%);
left: 50%;
bottom: 5px;
bottom: calc(2px + 3px * var(--zoom));
}
.guideline-group.vertical .size-value {
transform-origin: 0% 50%;
top: 50%;
transform: translateY(-50%);
left: 5px;
left: calc(2px + 3px * var(--zoom));
}
.guideline.gap {
background: #f55;
}
.size-value.gap {
color: #f55;
}
`
  ],
  render(e, n) {
    const t = e.state, {
      top: s,
      left: r,
      pos1: o,
      pos2: i,
      pos3: a,
      pos4: c,
      snapRenderInfo: l
    } = t, { snapRenderThreshold: u = 1 } = e.props;
    if (!l || !l.render || !ke(e, ""))
      return Me(
        e,
        "boundMap",
        be(),
        (G) => JSON.stringify(G)
      ), Me(
        e,
        "innerBoundMap",
        be(),
        (G) => JSON.stringify(G)
      ), [];
    t.guidelines = Ds(e);
    const f = Math.min(o[0], i[0], a[0], c[0]), h = Math.min(o[1], i[1], a[1], c[1]), d = l.externalPoses || [], p = Bt(e.state), g = [], m = [], S = [], v = [], x = [], { width: C, height: E, top: D, left: T, bottom: w, right: z } = Ot(p), M = {
      left: T,
      right: z,
      top: D,
      bottom: w,
      center: (T + z) / 2,
      middle: (D + w) / 2
    }, R = d.length > 0, P = R ? Ot(d) : {};
    if (!l.request) {
      if (l.direction && x.push(
        el(
          e,
          p,
          l.direction,
          u,
          u
        )
      ), l.snap) {
        const G = Ot(p);
        l.center && (G.middle = (G.top + G.bottom) / 2, G.center = (G.left + G.right) / 2), x.push(
          Mr(e, G, u, u)
        );
      }
      R && (l.center && (P.middle = (P.top + P.bottom) / 2, P.center = (P.left + P.right) / 2), x.push(
        Mr(
          e,
          P,
          u,
          u
        )
      )), x.forEach((G) => {
        const {
          vertical: { posInfos: Y },
          horizontal: { posInfos: q }
        } = G;
        g.push(
          ...Y.filter(({ guidelineInfos: X }) => X.some(({ guideline: W }) => !W.hide)).map(
            (X) => ({
              type: "snap",
              pos: X.pos
            })
          )
        ), m.push(
          ...q.filter(({ guidelineInfos: X }) => X.some(({ guideline: W }) => !W.hide)).map(
            (X) => ({
              type: "snap",
              pos: X.pos
            })
          )
        ), S.push(...Gr(Y)), v.push(...Gr(q));
      });
    }
    const { boundMap: y, innerBoundMap: k } = $r(
      e,
      [T, z],
      [D, w],
      g,
      m
    );
    R && $r(
      e,
      [P.left, P.right],
      [P.top, P.bottom],
      g,
      m,
      l.externalBounds
    );
    const _ = [...S, ...v], O = _.filter(
      (G) => G.element && !G.gapRects
    ), B = _.filter((G) => G.gapRects).sort((G, Y) => G.gap - Y.gap);
    F(
      e,
      "onSnap",
      {
        guidelines: _.filter(({ element: G }) => !G),
        elements: O,
        gaps: B
      },
      true
    );
    const A = Me(
      e,
      "boundMap",
      y,
      (G) => JSON.stringify(G),
      be()
    ), N = Me(
      e,
      "innerBoundMap",
      k,
      (G) => JSON.stringify(G),
      be()
    );
    return (y === A || k === N) && F(
      e,
      "onBound",
      {
        bounds: y,
        innerBounds: k
      },
      true
    ), [
      ...Dl(
        e,
        O,
        [f, h],
        M,
        n
      ),
      ...bl(
        e,
        B,
        [f, h],
        M,
        n
      ),
      ...Ir(
        e,
        "horizontal",
        v,
        [r, s],
        M,
        n
      ),
      ...Ir(
        e,
        "vertical",
        S,
        [r, s],
        M,
        n
      ),
      ...Or(
        e,
        "horizontal",
        m,
        f,
        s,
        C,
        0,
        n
      ),
      ...Or(
        e,
        "vertical",
        g,
        h,
        r,
        E,
        1,
        n
      )
    ];
  },
  dragStart(e, n) {
    e.state.snapRenderInfo = {
      request: n.isRequest,
      snap: true,
      center: true
    }, dn(e);
  },
  drag(e) {
    const n = e.state;
    dn(e) || (n.guidelines = Ds(e)), n.snapRenderInfo && (n.snapRenderInfo.render = true);
  },
  pinchStart(e) {
    this.unset(e);
  },
  dragEnd(e) {
    this.unset(e);
  },
  dragControlCondition(e, n) {
    if (Gl(e, n) || Cs(e, n))
      return true;
    if (!n.isRequest && n.inputEvent)
      return dt(n.inputEvent.target, H("snap-control"));
  },
  dragControlStart(e) {
    e.state.snapRenderInfo = null, dn(e);
  },
  dragControl(e) {
    this.drag(e);
  },
  dragControlEnd(e) {
    this.unset(e);
  },
  dragGroupStart(e, n) {
    this.dragStart(e, n);
  },
  dragGroup(e) {
    this.drag(e);
  },
  dragGroupEnd(e) {
    this.unset(e);
  },
  dragGroupControlStart(e) {
    e.state.snapRenderInfo = null, dn(e);
  },
  dragGroupControl(e) {
    this.drag(e);
  },
  dragGroupControlEnd(e) {
    this.unset(e);
  },
  unset(e) {
    const n = e.state;
    n.enableSnap = false, n.guidelines = [], n.snapRenderInfo = null, n.elementRects = [];
  }
};
function kl(e, n) {
  return [e[0] * n[0], e[1] * n[1]];
}
function H(...e) {
  return Mc(Ws, ...e);
}
function xi(e) {
  e();
}
function Xl(e) {
  return !e || e === "none" ? [1, 0, 0, 1, 0, 0] : Dt(e) ? e : ye(e);
}
function He(e, n, t) {
  return Rn(
    n,
    he(t, n),
    e,
    he(
      t.map((s) => -s),
      n
    )
  );
}
function Yl(e, n, t) {
  return n === "%" ? Qs(e.ownerSVGElement)[t ? "width" : "height"] / 100 : 1;
}
function Fl(e) {
  return Ll(er(e, ":before")).map((t, s) => {
    const { value: r, unit: o } = ce(t);
    return r * Yl(e, o, s === 0);
  });
}
function On(e) {
  return e ? e.split(" ") : ["0", "0"];
}
function Ll(e) {
  return On(e.transformOrigin);
}
function vi(e) {
  const t = Tt(e)("transform");
  if (t && t !== "none")
    return t;
  if ("transform" in e) {
    const r = e.transform.baseVal;
    if (!r)
      return "";
    const o = r.length;
    if (!o)
      return "";
    const i = [];
    for (let a = 0; a < o; ++a) {
      const c = r[a].matrix;
      i.push(
        `matrix(${["a", "b", "c", "d", "e", "f"].map((l) => c[l]).join(", ")})`
      );
    }
    return i.join(" ");
  }
  return "";
}
function Ke(e, n, t, s, r) {
  var g, m;
  const o = Bs(e) || ne(e);
  let i = false, a, c;
  if (!e || t)
    a = e;
  else {
    const S = (g = e == null ? void 0 : e.assignedSlot) == null ? void 0 : g.parentElement, v = e.parentElement;
    S ? (i = true, c = v, a = S) : a = v;
  }
  let l = false, u = e === n || a === n, f = "relative", h = 1;
  const d = parseFloat(r == null ? void 0 : r("zoom")) || 1, p = r == null ? void 0 : r("position");
  for (; a && a !== o; ) {
    n === a && (u = true);
    const S = Tt(a), v = a.tagName.toLowerCase(), x = vi(a), C = S("willChange"), E = parseFloat(S("zoom")) || 1;
    if (f = S("position"), s && E !== 1) {
      h = E;
      break;
    }
    if (
      // offsetParent is the parentElement if the target's zoom is not 1 and not absolute.
      !t && s && d !== 1 && p && p !== "absolute" || v === "svg" || v === "foreignobject" || f !== "static" || x && x !== "none" || C === "transform"
    )
      break;
    const D = (m = e == null ? void 0 : e.assignedSlot) == null ? void 0 : m.parentNode, T = a.parentNode;
    D && (i = true, c = T);
    const w = T;
    if (w && w.nodeType === 11) {
      a = w.host, l = true, f = Tt(a)("position");
      break;
    }
    a = w, f = "relative";
  }
  return {
    offsetZoom: h,
    hasSlot: i,
    parentSlotElement: c,
    isCustomElement: l,
    isStatic: f === "static",
    isEnd: u || !a || a === o,
    offsetParent: a || o
  };
}
function Wl(e, n) {
  const t = e.tagName.toLowerCase();
  let s = e.offsetLeft, r = e.offsetTop;
  const o = Tt(e), i = Ps(s);
  let a = !i, c, l;
  return !a && (t !== "svg" || e.ownerSVGElement) ? (c = $o ? Fl(e) : On(o("transformOrigin")).map(
    (u) => parseFloat(u)
  ), l = c.slice(), a = true, t === "svg" ? (s = 0, r = 0) : [s, r, c[0], c[1]] = Vl(
    e,
    c,
    e === n && n.tagName.toLowerCase() === "g"
  )) : (c = On(o("transformOrigin")).map(
    (u) => parseFloat(u)
  ), l = c.slice()), {
    tagName: t,
    isSVG: i,
    hasOffset: a,
    offset: [s || 0, r || 0],
    origin: c,
    targetOrigin: l
  };
}
function Ei(e, n) {
  const t = Tt(e), s = Tt(ne(e)), r = s("position");
  if (!n && (!r || r === "static"))
    return [0, 0];
  let o = parseInt(s("marginLeft"), 10), i = parseInt(s("marginTop"), 10);
  return t("position") === "absolute" && ((t("top") !== "auto" || t("bottom") !== "auto") && (i = 0), (t("left") !== "auto" || t("right") !== "auto") && (o = 0)), [o, i];
}
function bs(e) {
  e.forEach((n) => {
    const t = n.matrix;
    t && (n.matrix = Xt(t, 3, 4));
  });
}
function Nl(e) {
  let n = e.parentElement, t = false;
  const s = ne(e);
  for (; n; ) {
    const r = er(n).transform;
    if (r && r !== "none") {
      t = true;
      break;
    }
    if (n === s)
      break;
    n = n.parentElement;
  }
  return {
    fixedContainer: n || s,
    hasTransform: t
  };
}
function Hn(e, n = e.length > 9) {
  return `${n ? "matrix3d" : "matrix"}(${wo(
    e,
    !n
  ).join(",")})`;
}
function Qs(e) {
  const n = e.clientWidth, t = e.clientHeight;
  if (!e)
    return { x: 0, y: 0, width: 0, height: 0, clientWidth: n, clientHeight: t };
  const s = e.viewBox, r = s && s.baseVal || {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  return {
    x: r.x,
    y: r.y,
    width: r.width || n,
    height: r.height || t,
    clientWidth: n,
    clientHeight: t
  };
}
function Hl(e, n) {
  const {
    width: t,
    height: s,
    clientWidth: r,
    clientHeight: o
  } = Qs(e), i = r / t, a = o / s, c = e.preserveAspectRatio.baseVal, l = c.align, u = c.meetOrSlice, f = [0, 0], h = [i, a], d = [0, 0];
  if (l !== 1) {
    const g = (l - 2) % 3, m = Math.floor((l - 2) / 3);
    f[0] = t * g / 2, f[1] = s * m / 2;
    const S = u === 2 ? Math.max(a, i) : Math.min(i, a);
    h[0] = S, h[1] = S, d[0] = (r - t) / 2 * g, d[1] = (o - s) / 2 * m;
  }
  const p = Gs(h, n);
  return [p[n * (n - 1)], p[n * (n - 1) + 1]] = d, He(p, n, f);
}
function Vl(e, n, t) {
  const s = e.tagName.toLowerCase();
  if (!e.getBBox || !t && s === "g")
    return [0, 0, 0, 0];
  const o = Tt(e)("transform-box") === "fill-box", i = e.getBBox(), a = Qs(e.ownerSVGElement);
  let c = i.x, l = i.y;
  s === "foreignobject" && !c && !l && (c = parseFloat(e.getAttribute("x")) || 0, l = parseFloat(e.getAttribute("y")) || 0);
  const u = c - a.x, f = l - a.y, h = o ? n[0] : n[0] - u, d = o ? n[1] : n[1] - f;
  return [u, f, h, d];
}
function at(e, n, t) {
  return mt(e, fe(n, t), t);
}
function me(e, n, t, s) {
  return [
    [0, 0],
    [n, 0],
    [0, t],
    [n, t]
  ].map((r) => at(e, r, s));
}
function Ot(e) {
  const n = e.map((l) => l[0]), t = e.map((l) => l[1]), s = Math.min(...n), r = Math.min(...t), o = Math.max(...n), i = Math.max(...t), a = o - s, c = i - r;
  return {
    left: s,
    top: r,
    right: o,
    bottom: i,
    width: a,
    height: c
  };
}
function kr(e, n, t, s) {
  const r = me(e, n, t, s);
  return Ot(r);
}
function ql(e, n, t, s, r) {
  const o = e.target, i = e.origin, a = n.matrix, { offsetWidth: c, offsetHeight: l } = Di(o), u = t.getBoundingClientRect();
  let f = [0, 0];
  t === ne(t) && (f = Ei(o, true));
  const h = o.getBoundingClientRect(), d = h.left - u.left + t.scrollLeft - (t.clientLeft || 0) + f[0], p = h.top - u.top + t.scrollTop - (t.clientTop || 0) + f[1], g = h.width, m = h.height, S = Rn(s, r, a), {
    left: v,
    top: x,
    width: C,
    height: E
  } = kr(S, c, l, s), D = at(S, i, s), T = V(D, [v, x]), w = [
    d + T[0] * g / C,
    p + T[1] * m / E
  ], z = [0, 0];
  let M = 0;
  for (; ++M < 10; ) {
    const R = kt(r, s);
    [z[0], z[1]] = V(
      at(R, w, s),
      at(R, D, s)
    );
    const P = Rn(
      s,
      r,
      he(z, s),
      a
    ), { left: y, top: k } = kr(
      P,
      c,
      l,
      s
    ), _ = y - d, O = k - p;
    if (I(_) < 2 && I(O) < 2)
      break;
    w[0] -= _, w[1] -= O;
  }
  return z.map((R) => Math.round(R));
}
function jl(e, n, t) {
  const r = e.length === 16 ? 4 : 3, o = n.map((c) => at(e, c, r)), { left: i, top: a } = t;
  return o.map((c) => [c[0] + i, c[1] + a]);
}
function It(e) {
  return Math.sqrt(e[0] * e[0] + e[1] * e[1]);
}
function Ci(e, n) {
  return It([n[0] - e[0], n[1] - e[1]]);
}
function Fe(e, n, t = 1, s = ft(e, n)) {
  const r = Ci(e, n);
  return {
    transform: `translateY(-50%) translate(${e[0]}px, ${e[1]}px) rotate(${s}rad) scaleY(${t})`,
    width: `${r}px`
  };
}
function In(e, n, ...t) {
  const s = t.length, r = t.reduce((i, a) => i + a[0], 0) / s, o = t.reduce((i, a) => i + a[1], 0) / s;
  return {
    transform: `translateZ(0px) translate(${r}px, ${o}px) rotate(${e}rad) scale(${n})`
  };
}
function de(e, n) {
  const t = e[n];
  return Dt(t) ? {
    ...e,
    ...t
  } : e;
}
function Di(e) {
  const n = e && !Ps(e.offsetWidth);
  let t = 0, s = 0, r = 0, o = 0, i = 0, a = 0, c = 0, l = 0, u = 0, f = 0, h = 0, d = 0, p = 1 / 0, g = 1 / 0, m = 1 / 0, S = 1 / 0, v = 0, x = 0, C = false;
  if (e)
    if (!n && e.ownerSVGElement) {
      const E = e.getBBox();
      C = true, t = E.width, s = E.height, i = t, a = s, c = t, l = s, r = t, o = s;
    } else {
      const E = Tt(e), D = e.style, T = E("boxSizing") === "border-box", w = parseFloat(E("borderLeftWidth")) || 0, z = parseFloat(E("borderRightWidth")) || 0, M = parseFloat(E("borderTopWidth")) || 0, R = parseFloat(E("borderBottomWidth")) || 0, P = parseFloat(E("paddingLeft")) || 0, y = parseFloat(E("paddingRight")) || 0, k = parseFloat(E("paddingTop")) || 0, _ = parseFloat(E("paddingBottom")) || 0, O = P + y, B = k + _, A = w + z, N = M + R, G = O + A, Y = B + N, q = E("position");
      let X = 0, W = 0;
      if ("clientLeft" in e) {
        let Z = null;
        if (q === "absolute" ? Z = Ke(e, ne(e)).offsetParent : Z = e.parentElement, Z) {
          const $ = Tt(Z);
          X = parseFloat($("width")), W = parseFloat($("height"));
        }
      }
      u = Math.max(
        O,
        Q(E("minWidth"), X) || 0
      ), f = Math.max(
        B,
        Q(E("minHeight"), W) || 0
      ), p = Q(E("maxWidth"), X), g = Q(E("maxHeight"), W), isNaN(p) && (p = 1 / 0), isNaN(g) && (g = 1 / 0), v = Q(D.width, 0) || 0, x = Q(D.height, 0) || 0, i = parseFloat(E("width")) || 0, a = parseFloat(E("height")) || 0, c = I(i - v) < 1 ? At(u, v || i, p) : i, l = I(a - x) < 1 ? At(f, x || a, g) : a, t = c, s = l, r = c, o = l, T ? (m = p, S = g, h = u, d = f, c = t - G, l = s - Y) : (m = p + G, S = g + Y, h = u + G, d = f + Y, t = c + G, s = l + Y), r = c + O, o = l + B;
    }
  return {
    svg: C,
    offsetWidth: t,
    offsetHeight: s,
    clientWidth: r,
    clientHeight: o,
    contentWidth: c,
    contentHeight: l,
    inlineCSSWidth: v,
    inlineCSSHeight: x,
    cssWidth: i,
    cssHeight: a,
    minWidth: u,
    minHeight: f,
    maxWidth: p,
    maxHeight: g,
    minOffsetWidth: h,
    minOffsetHeight: d,
    maxOffsetWidth: m,
    maxOffsetHeight: S
  };
}
function bi(e, n) {
  return ft(
    n > 0 ? e[0] : e[1],
    n > 0 ? e[1] : e[0]
  );
}
function pn() {
  return {
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    right: 0,
    bottom: 0,
    clientLeft: 0,
    clientTop: 0,
    clientWidth: 0,
    clientHeight: 0,
    scrollWidth: 0,
    scrollHeight: 0
  };
}
function wi(e, n) {
  const t = e === ne(e) || e === Bs(e), s = {
    clientLeft: e.clientLeft,
    clientTop: e.clientTop,
    clientWidth: e.clientWidth,
    clientHeight: e.clientHeight,
    scrollWidth: e.scrollWidth,
    scrollHeight: e.scrollHeight,
    overflow: false
  };
  return t && (s.clientHeight = Math.max(n.height, s.clientHeight), s.scrollHeight = Math.max(n.height, s.scrollHeight)), s.overflow = Tt(e)("overflow") !== "visible", {
    ...n,
    ...s
  };
}
function os(e, n, t, s) {
  const { left: r, right: o, top: i, bottom: a } = e, c = n.top, l = n.left, u = {
    left: l + r,
    top: c + i,
    right: l + o,
    bottom: c + a,
    width: o - r,
    height: a - i
  };
  return t && s ? wi(t, u) : u;
}
function Ve(e, n) {
  let t = 0, s = 0, r = 0, o = 0;
  if (e) {
    const a = e.getBoundingClientRect();
    t = a.left, s = a.top, r = a.width, o = a.height;
  }
  const i = {
    left: t,
    top: s,
    width: r,
    height: o,
    right: t + r,
    bottom: s + o
  };
  return e && n ? wi(e, i) : i;
}
function Ul(e) {
  const { groupable: n, svgOrigin: t } = e.props, { offsetWidth: s, offsetHeight: r, svg: o, transformOrigin: i } = e.getState();
  return !n && o && t ? or(t, s, r) : i;
}
function Mi(e, n, t, s) {
  let r;
  if (e)
    r = e;
  else if (n)
    r = [0, 0];
  else {
    const o = t.target;
    r = Ti(o, s);
  }
  return r;
}
function Ti(e, n) {
  if (!e)
    return;
  const t = e.getAttribute("data-rotation") || "", s = e.getAttribute("data-direction");
  if (n.deg = t, !s)
    return;
  const r = [0, 0];
  return s.indexOf("w") > -1 && (r[0] = -1), s.indexOf("e") > -1 && (r[0] = 1), s.indexOf("n") > -1 && (r[1] = -1), s.indexOf("s") > -1 && (r[1] = 1), r;
}
function tr(e, n) {
  return [
    tt(n, e[0]),
    tt(n, e[1]),
    tt(n, e[2]),
    tt(n, e[3])
  ];
}
function Bt({
  left: e,
  top: n,
  pos1: t,
  pos2: s,
  pos3: r,
  pos4: o
}) {
  return tr([t, s, r, o], [e, n]);
}
function ws(e, n) {
  e[n ? "controlAbles" : "targetAbles"].forEach((t) => {
    t.unset && t.unset(e);
  });
}
function we(e, n) {
  const t = n ? "controlGesto" : "targetGesto", s = e[t];
  (s == null ? void 0 : s.isIdle()) === false && ws(e, n), s == null || s.unset(), e[t] = null;
}
function Ct(e, n) {
  if (n) {
    const t = $e(n);
    t.nextStyle = {
      ...t.nextStyle,
      ...e
    };
  }
  return {
    style: e,
    cssText: Be(e).map((t) => `${xa(t, "-")}: ${e[t]};`).join("")
  };
}
function Ri(e, n, t) {
  const s = n.afterTransform || n.transform;
  return {
    ...Ct(
      {
        ...e.style,
        ...n.style,
        transform: s
      },
      t
    ),
    afterTransform: s,
    transform: e.transform
  };
}
function K(e, n, t, s) {
  const r = n.datas;
  r.datas || (r.datas = {});
  const o = {
    ...t,
    target: e.state.target,
    clientX: n.clientX,
    clientY: n.clientY,
    inputEvent: n.inputEvent,
    currentTarget: e,
    moveable: e,
    datas: r.datas,
    isRequest: n.isRequest,
    isRequestChild: n.isRequestChild,
    isFirstDrag: !!n.isFirstDrag,
    isTrusted: n.isTrusted !== false,
    stopAble() {
      r.isEventStart = false;
    },
    stopDrag() {
      var i;
      (i = n.stop) == null || i.call(n);
    }
  };
  return r.isStartEvent ? s || (r.lastEvent = o) : r.isStartEvent = true, o;
}
function zt(e, n, t) {
  const s = n.datas, r = "isDrag" in t ? t.isDrag : n.isDrag;
  return s.datas || (s.datas = {}), {
    isDrag: r,
    ...t,
    moveable: e,
    target: e.state.target,
    clientX: n.clientX,
    clientY: n.clientY,
    inputEvent: n.inputEvent,
    currentTarget: e,
    lastEvent: s.lastEvent,
    isDouble: n.isDouble,
    datas: s.datas,
    isFirstDrag: !!n.isFirstDrag
  };
}
function Vn(e, n, t) {
  e._emitter.on(n, t);
}
function F(e, n, t, s, r) {
  return e.triggerEvent(n, t, s, r);
}
function er(e, n) {
  return Mt(e).getComputedStyle(e, n);
}
function gn(e, n, t) {
  const s = {}, r = {};
  return e.filter((o) => {
    const i = o.name;
    if (s[i] || !n.some((a) => o[a]))
      return false;
    if (!t && o.ableGroup) {
      if (r[o.ableGroup])
        return false;
      r[o.ableGroup] = true;
    }
    return s[i] = true, true;
  });
}
function Ms(e, n) {
  return e === n || e == null && n == null;
}
function Xr(...e) {
  const n = e.length - 1;
  for (let t = 0; t < n; ++t) {
    const s = e[t];
    if (!Ps(s))
      return s;
  }
  return e[n];
}
function yi(e, n) {
  const t = [], s = [];
  return e.forEach((r, o) => {
    const i = n(r, o, e), a = s.indexOf(i), c = t[a] || [];
    a === -1 && (s.push(i), t.push(c)), c.push(r);
  }), t;
}
function Zl(e, n) {
  const t = [], s = {};
  return e.forEach((r, o) => {
    const i = n(r, o, e);
    let a = s[i];
    a || (a = [], s[i] = a, t.push(a)), a.push(r);
  }), t;
}
function zi(e) {
  return e.reduce((n, t) => n.concat(t), []);
}
function Oe(...e) {
  return e.sort((n, t) => I(t) - I(n)), e[0];
}
function Ie(e, n, t) {
  return mt(kt(e, t), fe(n, t), t);
}
function Kl(e, n) {
  const { is3d: t, rootMatrix: s } = e, r = t ? 4 : 3;
  return [n.distX, n.distY] = Ie(
    s,
    [n.distX, n.distY],
    r
  ), n;
}
function Pt(e, n, t, s) {
  if (!t[0] && !t[1])
    return n;
  const r = at(e, [Ar(t[0] || 1), 0], s), o = at(e, [0, Ar(t[1] || 1)], s), i = at(
    e,
    [t[0] / It(r), t[1] / It(o)],
    s
  );
  return tt(n, i);
}
function Gt(e, n, t) {
  return t ? `${e / n * 100}%` : `${e}px`;
}
function Bn(e) {
  return I(e) <= bt ? 0 : e;
}
function nr(e) {
  return (n) => {
    if (!n.isDragging(e))
      return "";
    const s = Yc(n, e).deg;
    return s ? H(`view-control-rotation${s}`) : "";
  };
}
function sr(e, n = [e]) {
  return (t, s) => {
    if (s.isRequest)
      return n.some((o) => s.requestAble === o) ? s.parentDirection : false;
    const r = s.inputEvent.target;
    return dt(r, H("direction")) && (!e || dt(r, H(e)));
  };
}
function Jl(e, n, t) {
  const s = ze(e, {
    "x%": (C) => C / 100 * n.offsetWidth,
    "y%": (C) => C / 100 * n.offsetHeight
  }), r = e.slice(
    0,
    t < 0 ? void 0 : t
  ), o = e.slice(
    0,
    t < 0 ? void 0 : t + 1
  ), i = e[t] || "", a = t < 0 ? [] : e.slice(t), c = t < 0 ? [] : e.slice(t + 1), l = s.slice(0, t < 0 ? void 0 : t), u = s.slice(
    0,
    t < 0 ? void 0 : t + 1
  ), f = s[t] ?? ze([""])[0], h = t < 0 ? [] : s.slice(t), d = t < 0 ? [] : s.slice(t + 1), p = f ? [f] : [], g = Ee(l), m = Ee(u), S = Ee(h), v = Ee(d), x = et(
    g,
    S,
    4
  );
  return {
    transforms: e,
    beforeFunctionMatrix: g,
    beforeFunctionMatrix2: m,
    targetFunctionMatrix: Ee(p),
    afterFunctionMatrix: S,
    afterFunctionMatrix2: v,
    allFunctionMatrix: x,
    beforeFunctions: l,
    beforeFunctions2: u,
    targetFunction: p[0],
    afterFunctions: h,
    afterFunctions2: d,
    beforeFunctionTexts: r,
    beforeFunctionTexts2: o,
    targetFunctionText: i,
    afterFunctionTexts: a,
    afterFunctionTexts2: c
  };
}
function Ql(e) {
  return !e || !Dt(e) || le(e) ? false : ct(e) || "length" in e;
}
function Ht(e, n) {
  return e ? le(e) ? e : Yt(e) ? n ? document.querySelector(e) : e : Gn(e) ? e() : go(e) ? e : "current" in e ? e.current : e : null;
}
function rr(e, n) {
  return e ? (Ql(e) ? [].slice.call(e) : [e]).reduce((s, r) => Yt(r) && n ? [
    ...s,
    ...[].slice.call(document.querySelectorAll(r))
  ] : (ct(r) ? s.push(rr(r, n)) : s.push(Ht(r, n)), s), []) : [];
}
function tu(e, n, t) {
  let s = ft(e, n) / Math.PI * 180;
  return s = t >= 0 ? s : 180 - s, s = s >= 0 ? s : 360 + s, s;
}
function Yr(e, n) {
  const { rootMatrix: t, is3d: s } = e;
  let o = kt(t, s ? 4 : 3);
  return s || (o = Xt(o, 3, 4)), o[12] = 0, o[13] = 0, o[14] = 0, vn(o, n);
}
function Pi(e, n, t, s, r) {
  const [o, i] = e;
  let a = 0, c = 0;
  if (r && o && i) {
    const l = ft([0, 0], n), u = ft([0, 0], s), f = It(n), h = Math.cos(l - u) * f;
    if (!s[0])
      c = h, a = c * t;
    else if (!s[1])
      a = h, c = a / t;
    else {
      const d = s[0] * o, p = s[1] * i;
      let g = Math.atan2(
        d + n[0],
        p + n[1]
      ), m = Math.atan2(d, p);
      g < 0 && (g += Math.PI * 2), m < 0 && (m += Math.PI * 2);
      let S = 0;
      I(g - m) < Math.PI / 2 || I(g - m) > Math.PI / 2 * 3 || (m += Math.PI), S = g - m, S > Math.PI * 2 ? S -= Math.PI * 2 : S > Math.PI ? S = 2 * Math.PI - S : S < -Math.PI && (S = -2 * Math.PI - S);
      const v = It([d + n[0], p + n[1]]) * Math.cos(S);
      a = v * Math.sin(m) - d, c = v * Math.cos(m) - p, s[0] < 0 && (a *= -1), s[1] < 0 && (c *= -1);
    }
  } else
    a = s[0] * n[0], c = s[1] * n[1];
  return [a, c];
}
function _i(e, n, t, s) {
  const { ratio: r, startOffsetWidth: o, startOffsetHeight: i } = t;
  let a = 0, c = 0;
  const { distX: l, distY: u, pinchScale: f, parentDistance: h, parentDist: d, parentScale: p } = s, g = t.fixedDirection, m = [0, 1].map((v) => I(e[v] - g[v])), S = [0, 1].map((v) => {
    let x = m[v];
    return x !== 0 && (x = 2 / x), x;
  });
  if (d)
    a = d[0], c = d[1], n && (a ? c || (c = a / r) : a = c * r);
  else if (je(f))
    a = (f - 1) * o, c = (f - 1) * i;
  else if (p)
    a = (p[0] - 1) * o, c = (p[1] - 1) * i;
  else if (h) {
    const v = o * m[0], x = i * m[1], C = It([v, x]);
    a = h / C * v * S[0], c = h / C * x * S[1];
  } else {
    let v = Vt({ datas: t, distX: l, distY: u });
    v = S.map((x, C) => v[C] * x), [a, c] = Pi(
      [o, i],
      v,
      r,
      e,
      n
    );
  }
  return {
    // direction,
    // sizeDirection,
    distWidth: a,
    distHeight: c
  };
}
function Ts(e, n) {
  if (n) {
    if (e === "left")
      return { x: "0%", y: "50%" };
    if (e === "top")
      return { x: "50%", y: "50%" };
    if (e === "center")
      return { x: "50%", y: "50%" };
    if (e === "right")
      return { x: "100%", y: "50%" };
    if (e === "bottom")
      return { x: "50%", y: "100%" };
    const [t, s] = e.split(" "), r = Ts(t || ""), o = Ts(s || ""), i = {
      ...r,
      ...o
    }, a = {
      x: "50%",
      y: "50%"
    };
    return i.x && (a.x = i.x), i.y && (a.y = i.y), i.value && (i.x && !i.y && (a.y = i.value), !i.x && i.y && (a.x = i.value)), a;
  }
  return e === "left" ? { x: "0%" } : e === "right" ? { x: "100%" } : e === "top" ? { y: "0%" } : e === "bottom" ? { y: "100%" } : e ? e === "center" ? { value: "50%" } : { value: e } : {};
}
function or(e, n, t) {
  const { x: s, y: r } = Ts(e, true);
  return [Q(s, n) || 0, Q(r, t) || 0];
}
function eu(e, n, t) {
  const s = e.map((o) => V(o, n)), r = s.map((o) => Je(o, t));
  return {
    prev: s,
    next: r,
    result: r.map((o) => tt(o, n))
  };
}
function Oi(e, n) {
  return e.length === n.length && e.every((t, s) => {
    const r = n[s], o = ct(t), i = ct(r);
    return o && i ? Oi(t, r) : !o && !i ? t === r : false;
  });
}
function Me(e, n, t, s, r) {
  const o = e._store;
  let i = o[n];
  if (!(n in o))
    if (r != null)
      o[n] = r, i = r;
    else
      return o[n] = t, t;
  return i === t || s(i) === s(t) ? i : (o[n] = t, t);
}
function Et(e) {
  return e >= 0 ? 1 : -1;
}
function I(e) {
  return Math.abs(e);
}
function is(e, n) {
  return ba(e).map((t) => n(t));
}
function Ii(e) {
  return je(e) ? {
    top: e,
    left: e,
    right: e,
    bottom: e
  } : {
    left: e.left || 0,
    top: e.top || 0,
    right: e.right || 0,
    bottom: e.bottom || 0
  };
}
var nu = tn("pinchable", {
  props: ["pinchable"],
  events: [
    "pinchStart",
    "pinch",
    "pinchEnd",
    "pinchGroupStart",
    "pinchGroup",
    "pinchGroupEnd"
  ],
  dragStart() {
    return true;
  },
  pinchStart(e, n) {
    const { datas: t, targets: s, angle: r, originalDatas: o } = n, { pinchable: i, ables: a } = e.props;
    if (!i)
      return false;
    const c = `onPinch${s ? "Group" : ""}Start`, l = `drag${s ? "Group" : ""}ControlStart`, u = (i === true ? e.controlAbles : a.filter((p) => i.indexOf(p.name) > -1)).filter((p) => p.canPinch && p[l]), f = K(e, n, {});
    s && (f.targets = s);
    const h = F(e, c, f);
    t.isPinch = h !== false, t.ables = u;
    const d = t.isPinch;
    return d ? (u.forEach((p) => {
      if (o[p.name] = o[p.name] || {}, !p[l])
        return;
      const g = {
        ...n,
        datas: o[p.name],
        parentRotate: r,
        isPinch: true
      };
      p[l](e, g);
    }), e.state.snapRenderInfo = {
      request: n.isRequest,
      direction: [0, 0]
    }, d) : false;
  },
  pinch(e, n) {
    const {
      datas: t,
      scale: s,
      distance: r,
      originalDatas: o,
      inputEvent: i,
      targets: a,
      angle: c
    } = n;
    if (!t.isPinch)
      return;
    const l = r * (1 - 1 / s), u = K(e, n, {});
    a && (u.targets = a), F(e, `onPinch${a ? "Group" : ""}`, u);
    const h = t.ables, d = `drag${a ? "Group" : ""}Control`;
    return h.forEach((p) => {
      p[d] && p[d](e, {
        ...n,
        datas: o[p.name],
        inputEvent: i,
        resolveMatrix: true,
        pinchScale: s,
        parentDistance: l,
        parentRotate: c,
        isPinch: true
      });
    }), u;
  },
  pinchEnd(e, n) {
    const { datas: t, isPinch: s, inputEvent: r, targets: o, originalDatas: i } = n;
    if (!t.isPinch)
      return;
    const a = `onPinch${o ? "Group" : ""}End`, c = zt(e, n, {
      isDrag: s
    });
    o && (c.targets = o), F(e, a, c);
    const l = t.ables, u = `drag${o ? "Group" : ""}ControlEnd`;
    return l.forEach((f) => {
      f[u] && f[u](e, {
        ...n,
        isDrag: s,
        datas: i[f.name],
        inputEvent: r,
        isPinch: true
      });
    }), s;
  },
  pinchGroupStart(e, n) {
    return this.pinchStart(e, {
      ...n,
      targets: e.props.targets
    });
  },
  pinchGroup(e, n) {
    return this.pinch(e, { ...n, targets: e.props.targets });
  },
  pinchGroupEnd(e, n) {
    return this.pinchEnd(e, { ...n, targets: e.props.targets });
  }
});
var Fr = sr("scalable");
var su = {
  name: "scalable",
  ableGroup: "size",
  canPinch: true,
  props: [
    "scalable",
    "throttleScale",
    "renderDirections",
    "keepRatio",
    "edge",
    "displayAroundControls"
  ],
  events: [
    "scaleStart",
    "beforeScale",
    "scale",
    "scaleEnd",
    "scaleGroupStart",
    "beforeScaleGroup",
    "scaleGroup",
    "scaleGroupEnd"
  ],
  render: Qo("scalable"),
  dragControlCondition: Fr,
  viewClassName: nr("scalable"),
  dragControlStart(e, n) {
    const { datas: t, isPinch: s, inputEvent: r, parentDirection: o } = n, i = Mi(
      o,
      s,
      r,
      t
    ), { width: a, height: c, targetTransform: l, target: u, pos1: f, pos2: h, pos4: d } = e.state;
    if (!i || !u)
      return false;
    s || ge(e, n), t.datas = {}, t.transform = l, t.prevDist = [1, 1], t.direction = i, t.startOffsetWidth = a, t.startOffsetHeight = c, t.startValue = [1, 1];
    const p = !i[0] && !i[1] || i[0] || !i[1];
    Fn(e, n, "scale"), t.isWidth = p;
    function g(E) {
      t.ratio = E && isFinite(E) ? E : 0;
    }
    t.startPositions = Bt(e.state);
    function m(E) {
      const D = fi(
        t.startPositions,
        E
      );
      t.fixedDirection = D.fixedDirection, t.fixedPosition = D.fixedPosition, t.fixedOffset = D.fixedOffset;
    }
    t.setFixedDirection = m, g(Nt(f, h) / Nt(h, d)), m([-i[0], -i[1]]);
    const S = (E) => {
      t.minScaleSize = E;
    }, v = (E) => {
      t.maxScaleSize = E;
    };
    S([-1 / 0, -1 / 0]), v([1 / 0, 1 / 0]);
    const x = K(e, n, {
      direction: i,
      set: (E) => {
        t.startValue = E;
      },
      setRatio: g,
      setFixedDirection: m,
      setMinScaleSize: S,
      setMaxScaleSize: v,
      ...Yn(e, n),
      dragStart: vt.dragStart(
        e,
        new Pe().dragStart([0, 0], n)
      )
    }), C = F(e, "onScaleStart", x);
    return t.startFixedDirection = t.fixedDirection, C !== false && (t.isScale = true, e.state.snapRenderInfo = {
      request: n.isRequest,
      direction: i
    }), t.isScale ? x : false;
  },
  dragControl(e, n) {
    kn(e, n, "scale");
    const {
      datas: t,
      parentKeepRatio: s,
      parentFlag: r,
      isPinch: o,
      dragClient: i,
      isRequest: a,
      useSnap: c,
      resolveMatrix: l
    } = n, {
      prevDist: u,
      direction: f,
      startOffsetWidth: h,
      startOffsetHeight: d,
      isScale: p,
      startValue: g,
      isWidth: m,
      ratio: S
    } = t;
    if (!p)
      return false;
    const v = e.props, { throttleScale: x, parentMoveable: C } = v;
    let E = f;
    !f[0] && !f[1] && (E = [1, 1]);
    const D = S && (s ?? v.keepRatio) || false, T = e.state, w = [g[0], g[1]];
    function z() {
      const { distWidth: $, distHeight: L } = _i(
        E,
        D,
        t,
        n
      ), j = h ? (h + $) / h : 1, ot = d ? (d + L) / d : 1;
      g[0] || (w[0] = $ / h), g[1] || (w[1] = L / d);
      let pt = (E[0] || D ? j : 1) * w[0], lt = (E[1] || D ? ot : 1) * w[1];
      return pt === 0 && (pt = Et(u[0]) * un), lt === 0 && (lt = Et(u[1]) * un), [pt, lt];
    }
    let M = z();
    if (!o && e.props.groupable) {
      const L = (T.snapRenderInfo || {}).direction;
      ct(L) && (L[0] || L[1]) && (T.snapRenderInfo = { direction: f, request: n.isRequest });
    }
    F(
      e,
      "onBeforeScale",
      K(
        e,
        n,
        {
          scale: M,
          setFixedDirection($) {
            return t.setFixedDirection($), M = z(), M;
          },
          startFixedDirection: t.startFixedDirection,
          setScale($) {
            M = $;
          }
        },
        true
      )
    );
    let R = [M[0] / w[0], M[1] / w[1]], P = i, y = [0, 0];
    const k = Et(R[0] * R[1]), _ = !i && !r && o;
    if (_ || l ? P = Vs(
      e,
      t.targetAllTransform,
      [0, 0],
      [0, 0],
      t
    ) : i || (P = t.fixedPosition), o || (y = Bl(
      e,
      R,
      f,
      !c && a,
      t
    )), D) {
      E[0] && E[1] && y[0] && y[1] && (Math.abs(y[0] * h) > Math.abs(y[1] * d) ? y[1] = 0 : y[0] = 0);
      const $ = !y[0] && !y[1];
      if ($ && (m ? R[0] = U(R[0] * w[0], x) / w[0] : R[1] = U(R[1] * w[1], x) / w[1]), E[0] && !E[1] || y[0] && !y[1] || $ && m) {
        R[0] += y[0];
        const L = h * R[0] * w[0] / S;
        R[1] = Et(k * R[0]) * I(L / d / w[1]);
      } else if (!E[0] && E[1] || !y[0] && y[1] || $ && !m) {
        R[1] += y[1];
        const L = d * R[1] * w[1] * S;
        R[0] = Et(k * R[1]) * I(L / h / w[0]);
      }
    } else
      R[0] += y[0], R[1] += y[1], y[0] || (R[0] = U(R[0] * w[0], x) / w[0]), y[1] || (R[1] = U(R[1] * w[1], x) / w[1]);
    R[0] === 0 && (R[0] = Et(u[0]) * un), R[1] === 0 && (R[1] = Et(u[1]) * un), M = kl(R, [w[0], w[1]]);
    const O = [h, d];
    let B = [h * M[0], d * M[1]];
    B = _s(
      B,
      t.minScaleSize,
      t.maxScaleSize,
      D ? S : false
    ), M = is(2, ($) => O[$] ? B[$] / O[$] : B[$]), R = is(2, ($) => M[$] / w[$]);
    const A = is(
      2,
      ($) => u[$] ? R[$] / u[$] : R[$]
    ), N = `scale(${R.join(", ")})`, G = `scale(${M.join(", ")})`, Y = Xn(t, G, N), q = !g[0] || !g[1], X = Bc(
      e,
      q ? G : N,
      t.fixedDirection,
      P,
      t.fixedOffset,
      t,
      q
    ), W = _ ? X : V(X, t.prevInverseDist || [0, 0]);
    if (t.prevDist = R, t.prevInverseDist = X, M[0] === u[0] && M[1] === u[1] && W.every(($) => !$) && !C && !_)
      return false;
    const Z = K(e, n, {
      offsetWidth: h,
      offsetHeight: d,
      direction: f,
      scale: M,
      dist: R,
      delta: A,
      isPinch: !!o,
      ...qo(e, Y, W, o, n)
    });
    return F(e, "onScale", Z), Z;
  },
  dragControlEnd(e, n) {
    const { datas: t } = n;
    if (!t.isScale)
      return false;
    t.isScale = false;
    const s = zt(e, n, {});
    return F(e, "onScaleEnd", s), s;
  },
  dragGroupControlCondition: Fr,
  dragGroupControlStart(e, n) {
    const { datas: t } = n, s = this.dragControlStart(e, n);
    if (!s)
      return false;
    const r = $t(e, "resizable", n);
    t.moveableScale = e.scale;
    const o = jt(
      e,
      this,
      "dragControlStart",
      n,
      (l, u) => zn(e, l, t, u)
    ), i = (l) => {
      s.setFixedDirection(l), o.forEach((u, f) => {
        u.setFixedDirection(l), zn(e, u.moveable, t, r[f]);
      });
    };
    t.setFixedDirection = i;
    const a = {
      ...s,
      targets: e.props.targets,
      events: o,
      setFixedDirection: i
    }, c = F(e, "onScaleGroupStart", a);
    return t.isScale = c !== false, t.isScale ? a : false;
  },
  dragGroupControl(e, n) {
    const { datas: t } = n;
    if (!t.isScale)
      return;
    Vn(e, "onBeforeScale", (u) => {
      F(
        e,
        "onBeforeScaleGroup",
        K(
          e,
          n,
          {
            ...u,
            targets: e.props.targets
          },
          true
        )
      );
    });
    const s = this.dragControl(e, n);
    if (!s)
      return;
    const { dist: r } = s, o = t.moveableScale;
    e.scale = [r[0] * o[0], r[1] * o[1]];
    const i = e.props.keepRatio, a = t.fixedPosition, c = jt(
      e,
      this,
      "dragControl",
      n,
      (u, f) => {
        const [h, d] = mt(
          Qe(e.rotation / 180 * Math.PI, 3),
          [f.datas.originalX * r[0], f.datas.originalY * r[1], 1],
          3
        );
        return {
          ...f,
          parentDist: null,
          parentScale: r,
          parentKeepRatio: i,
          // recalculate child fixed position for parent group's dragging.
          dragClient: tt(a, [h, d])
        };
      }
    ), l = {
      targets: e.props.targets,
      events: c,
      ...s
    };
    return F(e, "onScaleGroup", l), l;
  },
  dragGroupControlEnd(e, n) {
    const { isDrag: t, datas: s } = n;
    if (!s.isScale)
      return;
    this.dragControlEnd(e, n);
    const r = jt(e, this, "dragControlEnd", n), o = zt(e, n, {
      targets: e.props.targets,
      events: r
    });
    return F(e, "onScaleGroupEnd", o), t;
  },
  /**
       * @method Moveable.Scalable#request
       * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter
       * @return {Moveable.Requester} Moveable Requester
       * @example
  
       * // Instantly Request (requestStart - request - requestEnd)
       * moveable.request("scalable", { deltaWidth: 10, deltaHeight: 10 }, true);
       *
       * // requestStart
       * const requester = moveable.request("scalable");
       *
       * // request
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       *
       * // requestEnd
       * requester.requestEnd();
       */
  request() {
    const e = {};
    let n = 0, t = 0, s = false;
    return {
      isControl: true,
      requestStart(r) {
        return s = r.useSnap, {
          datas: e,
          parentDirection: r.direction || [1, 1],
          useSnap: s
        };
      },
      request(r) {
        return n += r.deltaWidth, t += r.deltaHeight, {
          datas: e,
          parentDist: [n, t],
          parentKeepRatio: r.keepRatio,
          useSnap: s
        };
      },
      requestEnd() {
        return { datas: e, isDrag: true, useSnap: s };
      }
    };
  }
};
function Zt(e, n) {
  return e.map((t, s) => bn(t, n[s], 1, 2));
}
function Lr(e, n, t) {
  const s = ft(e, n), o = ft(e, t) - s;
  return o >= 0 ? o : o + 2 * Math.PI;
}
function ru(e, n) {
  const t = Lr(e[0], e[1], e[2]), s = Lr(n[0], n[1], n[2]), r = Math.PI;
  return !(t >= r && s <= r || t <= r && s >= r);
}
var ou = {
  name: "warpable",
  ableGroup: "size",
  props: [
    "warpable",
    "renderDirections",
    "edge",
    "displayAroundControls"
  ],
  events: ["warpStart", "warp", "warpEnd"],
  viewClassName: nr("warpable"),
  render(e, n) {
    const { resizable: t, scalable: s, warpable: r, zoom: o } = e.props;
    if (t || s || !r)
      return [];
    const { pos1: i, pos2: a, pos3: c, pos4: l } = e.state, u = Zt(i, a), f = Zt(a, i), h = Zt(i, c), d = Zt(c, i), p = Zt(c, l), g = Zt(l, c), m = Zt(a, l), S = Zt(l, a);
    return [
      (0, import_jsx_runtime.jsx)(
        "div",
        {
          className: H("line"),
          style: Fe(u, p, o)
        },
        "middeLine1"
      ),
      (0, import_jsx_runtime.jsx)(
        "div",
        {
          className: H("line"),
          style: Fe(f, g, o)
        },
        "middeLine2"
      ),
      (0, import_jsx_runtime.jsx)(
        "div",
        {
          className: H("line"),
          style: Fe(h, m, o)
        },
        "middeLine3"
      ),
      (0, import_jsx_runtime.jsx)(
        "div",
        {
          className: H("line"),
          style: Fe(d, S, o)
        },
        "middeLine4"
      ),
      ...ti(e, "warpable", n)
    ];
  },
  dragControlCondition(e, n) {
    if (n.isRequest)
      return false;
    const t = n.inputEvent.target;
    return dt(t, H("direction")) && dt(t, H("warpable"));
  },
  dragControlStart(e, n) {
    const { datas: t, inputEvent: s } = n, { target: r } = e.props, { target: o } = s, i = Ti(o, t);
    if (!i || !r)
      return false;
    const a = e.state, {
      transformOrigin: c,
      is3d: l,
      targetTransform: u,
      targetMatrix: f,
      width: h,
      height: d,
      left: p,
      top: g
    } = a;
    t.datas = {}, t.targetTransform = u, t.warpTargetMatrix = l ? f : Xt(f, 3, 4), t.targetInverseMatrix = Do(
      kt(t.warpTargetMatrix, 4),
      3,
      4
    ), t.direction = i, t.left = p, t.top = g, t.poses = [
      [0, 0],
      [h, 0],
      [0, d],
      [h, d]
    ].map((v) => V(v, c)), t.nextPoses = t.poses.map(
      ([v, x]) => mt(t.warpTargetMatrix, [v, x, 0, 1], 4)
    ), t.startValue = rt(4), t.prevMatrix = rt(4), t.absolutePoses = Bt(a), t.posIndexes = Vo(i), ge(e, n), Fn(e, n, "matrix3d"), a.snapRenderInfo = {
      request: n.isRequest,
      direction: i
    };
    const m = K(e, n, {
      set: (v) => {
        t.startValue = v;
      },
      ...Yn(e, n)
    });
    return F(e, "onWarpStart", m) !== false && (t.isWarp = true), t.isWarp;
  },
  dragControl(e, n) {
    const { datas: t, isRequest: s } = n;
    let { distX: r, distY: o } = n;
    const {
      targetInverseMatrix: i,
      prevMatrix: a,
      isWarp: c,
      startValue: l,
      poses: u,
      posIndexes: f,
      absolutePoses: h
    } = t;
    if (!c)
      return false;
    if (kn(e, n, "matrix3d"), ke(e, "warpable")) {
      const E = f.map(
        (w) => h[w]
      );
      E.length > 1 && E.push([
        (E[0][0] + E[1][0]) / 2,
        (E[0][1] + E[1][1]) / 2
      ]);
      const { horizontal: D, vertical: T } = Nn(e, s, {
        horizontal: E.map((w) => w[1] + o),
        vertical: E.map((w) => w[0] + r)
      });
      o -= D.offset, r -= T.offset;
    }
    const d = Vt({ datas: t, distX: r, distY: o }, true), p = t.nextPoses.slice();
    if (f.forEach((E) => {
      p[E] = tt(p[E], d);
    }), !Dc.every(
      (E) => ru(
        E.map((D) => u[D]),
        E.map((D) => p[D])
      )
    ))
      return false;
    const g = $s(
      u[0],
      u[2],
      u[1],
      u[3],
      p[0],
      p[2],
      p[1],
      p[3]
    );
    if (!g.length)
      return false;
    const m = et(i, g, 4), S = No(t, m, true), v = et(kt(a, 4), S, 4);
    t.prevMatrix = S;
    const x = et(l, S, 4), C = Xn(
      t,
      `matrix3d(${x.join(", ")})`,
      `matrix3d(${S.join(", ")})`
    );
    return Hs(n, C), F(
      e,
      "onWarp",
      K(e, n, {
        delta: v,
        matrix: x,
        dist: S,
        multiply: et,
        transform: C,
        ...Ct(
          {
            transform: C
          },
          n
        )
      })
    ), true;
  },
  dragControlEnd(e, n) {
    const { datas: t, isDrag: s } = n;
    return t.isWarp ? (t.isWarp = false, F(
      e,
      "onWarpEnd",
      zt(e, n, {})
    ), s) : false;
  }
};
var iu = H("area-pieces");
var mn = H("area-piece");
var Bi = H("avoid");
var au = H("view-dragging");
function as(e) {
  const n = e.areaElement;
  if (!n)
    return;
  const { width: t, height: s } = e.state;
  po(n, Bi), n.style.cssText += `left: 0px; top: 0px; width: ${t}px; height: ${s}px`;
}
function Wr(e) {
  return (0, import_jsx_runtime.jsxs)("div", { className: iu, children: [
    (0, import_jsx_runtime.jsx)("div", { className: mn }),
    (0, import_jsx_runtime.jsx)("div", { className: mn }),
    (0, import_jsx_runtime.jsx)("div", { className: mn }),
    (0, import_jsx_runtime.jsx)("div", { className: mn })
  ] }, "area_pieces");
}
var Ai = {
  name: "dragArea",
  props: ["dragArea", "passDragArea"],
  events: ["click", "clickGroup"],
  render(e, n) {
    const { target: t, dragArea: s, groupable: r, passDragArea: o } = e.props, { width: i, height: a, renderPoses: c } = e.getState(), l = o ? H("area", "pass") : H("area");
    if (r)
      return [
        (0, import_jsx_runtime.jsx)(
          "div",
          {
            ref: _t(e, "areaElement"),
            className: l
          },
          "area"
        ),
        Wr()
      ];
    if (!t || !s)
      return [];
    const u = $s(
      [0, 0],
      [i, 0],
      [0, a],
      [i, a],
      c[0],
      c[1],
      c[2],
      c[3]
    ), f = u.length ? Hn(u, true) : "none";
    return [
      (0, import_jsx_runtime.jsx)(
        "div",
        {
          ref: _t(e, "areaElement"),
          className: l,
          style: {
            top: "0px",
            left: "0px",
            width: `${i}px`,
            height: `${a}px`,
            transformOrigin: "0 0",
            transform: f
          }
        },
        "area"
      ),
      Wr()
    ];
  },
  dragStart(e, { datas: n, clientX: t, clientY: s, inputEvent: r }) {
    if (!r)
      return false;
    n.isDragArea = false;
    const o = e.areaElement, i = e.state, { moveableClientRect: a, renderPoses: c, rootMatrix: l, is3d: u } = i, { left: f, top: h } = a, {
      left: d,
      top: p,
      width: g,
      height: m
    } = Ot(c), S = u ? 4 : 3;
    let [v, x] = Ie(
      l,
      [t - f, s - h],
      S
    );
    v -= d, x -= p;
    const C = [
      { left: d, top: p, width: g, height: x - 10 },
      { left: d, top: p, width: v - 10, height: m },
      {
        left: d,
        top: p + x + 10,
        width: g,
        height: m - x - 10
      },
      {
        left: d + v + 10,
        top: p,
        width: g - v - 10,
        height: m
      }
    ], E = [].slice.call(
      o.nextElementSibling.children
    );
    C.forEach((D, T) => {
      E[T].style.cssText = `left: ${D.left}px;top: ${D.top}px; width: ${D.width}px; height: ${D.height}px;`;
    }), qt(o, Bi), i.disableNativeEvent = true;
  },
  drag(e, { datas: n, inputEvent: t }) {
    if (this.enableNativeEvent(e), !t)
      return false;
    n.isDragArea || (n.isDragArea = true, as(e));
  },
  dragEnd(e, n) {
    this.enableNativeEvent(e);
    const { inputEvent: t, datas: s } = n;
    if (!t)
      return false;
    s.isDragArea || as(e);
  },
  dragGroupStart(e, n) {
    return this.dragStart(e, n);
  },
  dragGroup(e, n) {
    return this.drag(e, n);
  },
  dragGroupEnd(e, n) {
    return this.dragEnd(e, n);
  },
  unset(e) {
    as(e), e.state.disableNativeEvent = false;
  },
  enableNativeEvent(e) {
    const n = e.state;
    n.disableNativeEvent && fo(() => {
      n.disableNativeEvent = false;
    });
  }
};
var cu = tn("origin", {
  props: ["origin", "svgOrigin"],
  render(e, n) {
    const { zoom: t, svgOrigin: s, groupable: r } = e.props, {
      beforeOrigin: o,
      rotation: i,
      svg: a,
      allMatrix: c,
      is3d: l,
      left: u,
      top: f,
      offsetWidth: h,
      offsetHeight: d
    } = e.getState();
    let p;
    if (!r && a && s) {
      const [g, m] = or(
        s,
        h,
        d
      ), v = at(c, [g, m], l ? 4 : 3);
      p = In(
        i,
        t,
        V(v, [u, f])
      );
    } else
      p = In(i, t, o);
    return [
      (0, import_jsx_runtime.jsx)(
        "div",
        {
          className: H("control", "origin"),
          style: p
        },
        "beforeOrigin"
      )
    ];
  }
});
function lu(e) {
  const n = e.scrollContainer;
  return [n.scrollLeft, n.scrollTop];
}
var uu = {
  name: "scrollable",
  canPinch: true,
  props: [
    "scrollable",
    "scrollContainer",
    "scrollThreshold",
    "scrollThrottleTime",
    "getScrollPosition",
    "scrollOptions"
  ],
  events: ["scroll", "scrollGroup"],
  dragRelation: "strong",
  dragStart(e, n) {
    const t = e.props, {
      scrollContainer: s = e.getContainer(),
      scrollOptions: r
    } = t, o = new Eo(), i = Ht(
      s,
      true
    );
    n.datas.dragScroll = o, e.state.dragScroll = o;
    const a = n.isControl ? "controlGesto" : "targetGesto", c = n.targets;
    o.on("scroll", ({ container: l, direction: u }) => {
      const f = K(e, n, {
        scrollContainer: l,
        direction: u
      }), h = c ? "onScrollGroup" : "onScroll";
      c && (f.targets = c), F(e, h, f);
    }).on("move", ({ offsetX: l, offsetY: u, inputEvent: f }) => {
      e[a].scrollBy(
        l,
        u,
        f.inputEvent,
        false
      );
    }).on("scrollDrag", ({ next: l }) => {
      l(e[a].getCurrentEvent());
    }), o.dragStart(n, {
      container: i,
      ...r
    });
  },
  checkScroll(e, n) {
    const t = n.datas.dragScroll;
    if (!t)
      return;
    const {
      scrollContainer: s = e.getContainer(),
      scrollThreshold: r = 0,
      scrollThrottleTime: o = 0,
      getScrollPosition: i = lu,
      scrollOptions: a
    } = e.props;
    return t.drag(n, {
      container: s,
      threshold: r,
      throttleTime: o,
      getScrollPosition: (c) => i({
        scrollContainer: c.container,
        direction: c.direction
      }),
      ...a
    }), true;
  },
  drag(e, n) {
    return this.checkScroll(e, n);
  },
  dragEnd(e, n) {
    n.datas.dragScroll.dragEnd(), n.datas.dragScroll = null;
  },
  dragControlStart(e, n) {
    return this.dragStart(e, { ...n, isControl: true });
  },
  dragControl(e, n) {
    return this.drag(e, n);
  },
  dragControlEnd(e, n) {
    return this.dragEnd(e, n);
  },
  dragGroupStart(e, n) {
    return this.dragStart(e, { ...n, targets: e.props.targets });
  },
  dragGroup(e, n) {
    return this.drag(e, { ...n, targets: e.props.targets });
  },
  dragGroupEnd(e, n) {
    return this.dragEnd(e, { ...n, targets: e.props.targets });
  },
  dragGroupControlStart(e, n) {
    return this.dragStart(e, {
      ...n,
      targets: e.props.targets,
      isControl: true
    });
  },
  dragGroupControl(e, n) {
    return this.drag(e, { ...n, targets: e.props.targets });
  },
  dragGroupControEnd(e, n) {
    return this.dragEnd(e, { ...n, targets: e.props.targets });
  },
  unset(e) {
    var t;
    const n = e.state;
    (t = n.dragScroll) == null || t.dragEnd(), n.dragScroll = null;
  }
};
var Gi = {
  name: "",
  props: [
    "target",
    "dragTargetSelf",
    "dragTarget",
    "dragContainer",
    "container",
    "warpSelf",
    "rootContainer",
    "useResizeObserver",
    "useMutationObserver",
    "zoom",
    "dragFocusedInput",
    "transformOrigin",
    "ables",
    "className",
    "pinchThreshold",
    "pinchOutside",
    "triggerAblesSimultaneously",
    "checkInput",
    "cspNonce",
    "translateZ",
    "hideDefaultLines",
    "props",
    "flushSync",
    "stopPropagation",
    "preventClickEventOnDrag",
    "preventClickDefault",
    "viewContainer",
    "persistData",
    "useAccuratePosition",
    "firstRenderState",
    "linePadding",
    "controlPadding",
    "preventDefault",
    "preventRightClick",
    "preventWheelClick",
    "requestStyles"
  ],
  events: ["changeTargets"]
};
var fu = tn("padding", {
  props: ["padding"],
  render(e, n) {
    const t = e.props;
    if (t.dragArea)
      return [];
    const { left: s, top: r, right: o, bottom: i } = Ii(t.padding || {}), { renderPoses: a, pos1: c, pos2: l, pos3: u, pos4: f } = e.getState(), h = [c, l, u, f], d = [];
    return s > 0 && d.push([0, 2]), r > 0 && d.push([0, 1]), o > 0 && d.push([1, 3]), i > 0 && d.push([2, 3]), d.map(([p, g], m) => {
      const S = h[p], v = h[g], x = a[p], C = a[g], E = $s(
        [0, 0],
        [100, 0],
        [0, 100],
        [100, 100],
        S,
        v,
        x,
        C
      );
      if (E.length)
        return (0, import_jsx_runtime.jsx)(
          "div",
          {
            className: H("padding"),
            style: {
              transform: Hn(E, true)
            }
          },
          `padding${m}`
        );
    });
  }
});
var Nr = ["nw", "ne", "se", "sw"];
function Sn(e, n) {
  const t = e[0] + e[1], s = t > n ? n / t : 1;
  return e[0] *= s, e[1] = n - e[1] * s, e;
}
var hu = [1, 2, 5, 6];
var du = [0, 3, 4, 7];
var oe = [1, -1, -1, 1];
var ie = [1, 1, -1, -1];
function ir(e, n, t, s, r = 0, o = 0, i = t, a = s) {
  const c = [];
  let l = false;
  const u = e.filter((h) => !h.virtual), f = u.map((h) => {
    const { horizontal: d, vertical: p, pos: g } = h;
    if (p && !l && (l = true, c.push("/")), l) {
      const m = Math.max(
        0,
        p === 1 ? g[1] - o : a - g[1]
      );
      return c.push(Gt(m, s, n)), m;
    } else {
      const m = Math.max(
        0,
        d === 1 ? g[0] - r : i - g[0]
      );
      return c.push(Gt(m, t, n)), m;
    }
  });
  return {
    radiusPoses: u,
    styles: c,
    raws: f
  };
}
function $i(e) {
  const n = [0, 0], t = [0, 0], s = e.length;
  for (let r = 0; r < s; ++r) {
    const o = e[r];
    o.sub && (o.horizontal && (n[1] === 0 && (n[0] = r), n[1] = r - n[0] + 1, t[0] = r + 1), o.vertical && (t[1] === 0 && (t[0] = r), t[1] = r - t[0] + 1));
  }
  return {
    horizontalRange: n,
    verticalRange: t
  };
}
function ki(e, n, t, s, r, o = [0, 0], i = false) {
  const a = e.indexOf("/"), c = (a > -1 ? e.slice(0, a) : e).length, l = e.slice(0, c), u = e.slice(c + 1), f = l.length, h = u.length, d = h > 0, [
    p = "0px",
    g = p,
    m = p,
    S = g
  ] = l, [
    v = p,
    x = d ? v : g,
    C = d ? v : m,
    E = d ? x : S
  ] = u, D = [p, g, m, S].map(
    (P) => Q(P, n)
  ), T = [v, x, C, E].map(
    (P) => Q(P, t)
  ), w = D.slice(), z = T.slice();
  [w[0], w[1]] = Sn(
    [w[0], w[1]],
    n
  ), [w[3], w[2]] = Sn(
    [w[3], w[2]],
    n
  ), [z[0], z[3]] = Sn(
    [z[0], z[3]],
    t
  ), [z[1], z[2]] = Sn(
    [z[1], z[2]],
    t
  );
  const M = i ? w : w.slice(0, Math.max(o[0], f)), R = i ? z : z.slice(0, Math.max(o[1], h));
  return [
    ...M.map((P, y) => {
      const k = Nr[y];
      return {
        virtual: y >= f,
        horizontal: oe[y],
        vertical: 0,
        pos: [
          s + P,
          r + (ie[y] === -1 ? t : 0)
        ],
        sub: true,
        raw: D[y],
        direction: k
      };
    }),
    ...R.map((P, y) => {
      const k = Nr[y];
      return {
        virtual: y >= h,
        horizontal: 0,
        vertical: ie[y],
        pos: [
          s + (oe[y] === -1 ? n : 0),
          r + P
        ],
        sub: true,
        raw: T[y],
        direction: k
      };
    })
  ];
}
function pu(e, n, t, s, r = n.length) {
  const { horizontalRange: o, verticalRange: i } = $i(
    e.slice(s)
  ), a = t - s;
  let c = 0;
  if (a === 0)
    c = r;
  else if (a > 0 && a < o[1])
    c = o[1] - a;
  else if (a >= i[0])
    c = i[0] + i[1] - a;
  else
    return;
  e.splice(t, c), n.splice(t, c);
}
function gu(e, n, t, s, r, o, i, a, c, l = 0, u = 0) {
  const { horizontalRange: f, verticalRange: h } = $i(
    e.slice(t)
  );
  if (s > -1) {
    const d = oe[s] === 1 ? o - l : a - o;
    for (let p = f[1]; p <= s; ++p) {
      const g = ie[p] === 1 ? u : c;
      let m = 0;
      if (s === p ? m = o : p === 0 ? m = l + d : oe[p] === -1 && (m = a - (n[t][0] - l)), e.splice(t + p, 0, {
        horizontal: oe[p],
        vertical: 0,
        pos: [m, g]
      }), n.splice(t + p, 0, [m, g]), p === 0)
        break;
    }
  } else if (r > -1) {
    const d = ie[r] === 1 ? i - u : c - i;
    if (f[1] === 0 && h[1] === 0) {
      const g = [l + d, u];
      e.push({
        horizontal: oe[0],
        vertical: 0,
        pos: g
      }), n.push(g);
    }
    const p = h[0];
    for (let g = h[1]; g <= r; ++g) {
      const m = oe[g] === 1 ? l : a;
      let S = 0;
      if (r === g ? S = i : g === 0 ? S = u + d : ie[g] === 1 ? S = n[t + p][1] : ie[g] === -1 && (S = c - (n[t + p][1] - u)), e.push({
        horizontal: 0,
        vertical: ie[g],
        pos: [m, S]
      }), n.push([m, S]), g === 0)
        break;
    }
  }
}
function mu(e, n = e.map((t) => t.raw)) {
  const t = e.map((r, o) => r.horizontal ? n[o] : null).filter((r) => r != null), s = e.map((r, o) => r.vertical ? n[o] : null).filter((r) => r != null);
  return {
    horizontals: t,
    verticals: s
  };
}
var Su = [
  [0, -1, "n"],
  [1, 0, "e"]
];
var xu = [
  [-1, -1, "nw"],
  [0, -1, "n"],
  [1, -1, "ne"],
  [1, 0, "e"],
  [1, 1, "se"],
  [0, 1, "s"],
  [-1, 1, "sw"],
  [-1, 0, "w"]
];
function ar(e, n, t) {
  const { clipRelative: s } = e.props, { width: r, height: o } = e.state, { type: i, poses: a } = n, c = i === "rect", l = i === "circle";
  if (i === "polygon")
    return t.map(
      (u) => `${Gt(u[0], r, s)} ${Gt(
        u[1],
        o,
        s
      )}`
    );
  if (c || i === "inset") {
    const u = t[1][1], f = t[3][0], h = t[7][0], d = t[5][1];
    if (c)
      return [u, f, d, h].map((g) => `${g}px`);
    const p = [u, r - f, o - d, h].map(
      (g, m) => Gt(g, m % 2 ? r : o, s)
    );
    if (t.length > 8) {
      const [g, m] = V(t[4], t[0]);
      p.push(
        "round",
        ...ir(
          a.slice(8).map((S, v) => ({
            ...S,
            pos: t[v]
          })),
          s,
          g,
          m,
          h,
          u,
          f,
          d
        ).styles
      );
    }
    return p;
  } else if (l || i === "ellipse") {
    const u = t[0], f = Gt(
      I(t[1][1] - u[1]),
      l ? Math.sqrt((r * r + o * o) / 2) : o,
      s
    ), h = l ? [f] : [Gt(I(t[2][0] - u[0]), r, s), f];
    return h.push(
      "at",
      Gt(u[0], r, s),
      Gt(u[1], o, s)
    ), h;
  }
}
function An(e, n, t, s) {
  const r = [s, (s + n) / 2, n], o = [e, (e + t) / 2, t];
  return xu.map(([i, a, c]) => {
    const l = r[i + 1], u = o[a + 1];
    return {
      vertical: I(a),
      horizontal: I(i),
      direction: c,
      pos: [l, u]
    };
  });
}
function Xi(e) {
  const n = [1 / 0, -1 / 0], t = [1 / 0, -1 / 0];
  return e.forEach(({ pos: s }) => {
    n[0] = Math.min(n[0], s[0]), n[1] = Math.max(n[1], s[0]), t[0] = Math.min(t[0], s[1]), t[1] = Math.max(t[1], s[1]);
  }), [I(n[1] - n[0]), I(t[1] - t[0])];
}
function Hr(e, n, t, s, r) {
  if (!e)
    return;
  let o = r;
  if (!o) {
    const u = Tt(e), f = u("clipPath");
    o = f !== "none" ? f : u("clip");
  }
  if ((!o || o === "none" || o === "auto") && (o = s, !o))
    return;
  const { prefix: i = o, value: a = "" } = uo(o), c = i === "circle";
  let l = " ";
  if (i === "polygon") {
    const u = ae(a || "0% 0%, 100% 0%, 100% 100%, 0% 100%");
    l = ",";
    const f = u.map((d) => {
      const [p, g] = d.split(" ");
      return {
        vertical: 1,
        horizontal: 1,
        pos: [Q(p, n), Q(g, t)]
      };
    }), h = ue(f.map((d) => d.pos));
    return {
      type: i,
      clipText: o,
      poses: f,
      splitter: l,
      left: h.minX,
      right: h.maxX,
      top: h.minY,
      bottom: h.maxY
    };
  } else if (c || i === "ellipse") {
    let u = "", f = "", h = 0, d = 0;
    const p = Qt(a);
    if (c) {
      let S = "";
      [S = "50%", , u = "50%", f = "50%"] = p, h = Q(
        S,
        Math.sqrt((n * n + t * t) / 2)
      ), d = h;
    } else {
      let S = "", v = "";
      [S = "50%", v = "50%", , u = "50%", f = "50%"] = p, h = Q(S, n), d = Q(v, t);
    }
    const g = [
      Q(u, n),
      Q(f, t)
    ], m = [
      {
        vertical: 1,
        horizontal: 1,
        pos: g,
        direction: "nesw"
      },
      ...Su.slice(0, c ? 1 : 2).map((S) => ({
        vertical: I(S[1]),
        horizontal: S[0],
        direction: S[2],
        sub: true,
        pos: [g[0] + S[0] * h, g[1] + S[1] * d]
      }))
    ];
    return {
      type: i,
      clipText: o,
      radiusX: h,
      radiusY: d,
      left: g[0] - h,
      top: g[1] - d,
      right: g[0] + h,
      bottom: g[1] + d,
      poses: m,
      splitter: l
    };
  } else if (i === "inset") {
    const u = Qt(a || "0 0 0 0"), f = u.indexOf("round"), h = (f > -1 ? u.slice(0, f) : u).length, d = u.slice(h + 1), [
      p,
      g = p,
      m = p,
      S = g
    ] = u.slice(0, h), [v, x] = [p, m].map(
      (M) => Q(M, t)
    ), [C, E] = [S, g].map(
      (M) => Q(M, n)
    ), D = n - E, T = t - x, w = ki(
      d,
      D - C,
      T - v,
      C,
      v
    ), z = [
      ...An(v, D, T, C),
      ...w
    ];
    return {
      type: "inset",
      clipText: o,
      poses: z,
      top: v,
      left: C,
      right: D,
      bottom: T,
      radius: d,
      splitter: l
    };
  } else if (i === "rect") {
    const u = ae(a || `0px, ${n}px, ${t}px, 0px`);
    l = ",";
    const [f, h, d, p] = u.map((m) => {
      const { value: S } = ce(m);
      return S;
    }), g = An(f, h, d, p);
    return {
      type: "rect",
      clipText: o,
      poses: g,
      top: f,
      right: h,
      bottom: d,
      left: p,
      values: u,
      splitter: l
    };
  }
}
function vu(e, n, t, s, r) {
  const { direction: o, sub: i } = e[n], a = e.map(() => [0, 0]), c = o ? o.split("") : [];
  if (s && n < 8) {
    const l = c.filter(
      (m) => m === "w" || m === "e"
    ), u = c.filter(
      (m) => m === "n" || m === "s"
    ), f = l[0], h = u[0];
    a[n] = t;
    const [d, p] = Xi(e), g = d && p ? d / p : 0;
    if (g && r) {
      const m = (n + 4) % 8, S = e[m].pos, v = [0, 0];
      o.indexOf("w") > -1 ? v[0] = -1 : o.indexOf("e") > -1 && (v[0] = 1), o.indexOf("n") > -1 ? v[1] = -1 : o.indexOf("s") > -1 && (v[1] = 1);
      const x = Pi(
        [d, p],
        t,
        g,
        v,
        true
      ), C = d + x[0], E = p + x[1];
      let D = S[1], T = S[1], w = S[0], z = S[0];
      v[0] === -1 ? w = z - C : v[0] === 1 ? z = w + C : (w = w - C / 2, z = z + C / 2), v[1] === -1 ? D = T - E : (v[1] === 1 || (D = T - E / 2), T = D + E);
      const M = An(D, z, T, w);
      e.forEach((R, P) => {
        a[P][0] = M[P].pos[0] - R.pos[0], a[P][1] = M[P].pos[1] - R.pos[1];
      });
    } else
      e.forEach((m, S) => {
        const { direction: v } = m;
        v && (v.indexOf(f) > -1 && (a[S][0] = t[0]), v.indexOf(h) > -1 && (a[S][1] = t[1]));
      }), f && (a[1][0] = t[0] / 2, a[5][0] = t[0] / 2), h && (a[3][1] = t[1] / 2, a[7][1] = t[1] / 2);
  } else o && !i ? c.forEach((l) => {
    const u = l === "n" || l === "s";
    e.forEach((f, h) => {
      const {
        direction: d,
        horizontal: p,
        vertical: g
      } = f;
      !d || d.indexOf(l) === -1 || (a[h] = [
        u || !p ? 0 : t[0],
        !u || !g ? 0 : t[1]
      ]);
    });
  }) : a[n] = t;
  return a;
}
function Eu(e, n) {
  const [t, s] = Wo(e, n), { clipPath: r, clipIndex: o } = n.datas, {
    type: i,
    poses: a,
    splitter: c
  } = r, l = a.map((h) => h.pos);
  if (i === "polygon")
    l.splice(o, 0, [t, s]);
  else if (i === "inset") {
    const h = hu.indexOf(o), d = du.indexOf(o), p = a.length;
    if (gu(
      a,
      l,
      8,
      h,
      d,
      t,
      s,
      l[4][0],
      l[4][1],
      l[0][0],
      l[0][1]
    ), p === a.length)
      return;
  } else
    return;
  const u = ar(e, r, l), f = `${i}(${u.join(c)})`;
  F(
    e,
    "onClip",
    K(e, n, {
      clipEventType: "added",
      clipType: i,
      poses: l,
      clipStyles: u,
      clipStyle: f,
      distX: 0,
      distY: 0,
      ...Ct(
        {
          clipPath: f
        },
        n
      )
    })
  );
}
function Cu(e, n) {
  const { clipPath: t, clipIndex: s } = n.datas, {
    type: r,
    poses: o,
    splitter: i
  } = t, a = o.map((f) => f.pos), c = a.length;
  if (r === "polygon")
    o.splice(s, 1), a.splice(s, 1);
  else if (r === "inset") {
    if (s < 8 || (pu(o, a, s, 8, c), c === o.length))
      return;
  } else
    return;
  const l = ar(e, t, a), u = `${r}(${l.join(i)})`;
  F(
    e,
    "onClip",
    K(e, n, {
      clipEventType: "removed",
      clipType: r,
      poses: a,
      clipStyles: l,
      clipStyle: u,
      distX: 0,
      distY: 0,
      ...Ct(
        {
          clipPath: u
        },
        n
      )
    })
  );
}
var Du = {
  name: "clippable",
  props: [
    "clippable",
    "defaultClipPath",
    "customClipPath",
    "keepRatio",
    "clipRelative",
    "clipArea",
    "dragWithClip",
    "clipTargetBounds",
    "clipVerticalGuidelines",
    "clipHorizontalGuidelines",
    "clipSnapThreshold"
  ],
  events: ["clipStart", "clip", "clipEnd"],
  css: [
    `.control.clip-control {
background: #6d6;
cursor: pointer;
}
.control.clip-control.clip-radius {
background: #d66;
}
.line.clip-line {
background: #6e6;
cursor: move;
z-index: 1;
}
.clip-area {
position: absolute;
top: 0;
left: 0;
}
.clip-ellipse {
position: absolute;
cursor: move;
border: 1px solid #6d6;
border: var(--zoompx) solid #6d6;
border-radius: 50%;
transform-origin: 0px 0px;
}`,
    `:host {
--bounds-color: #d66;
}`,
    `.guideline {
pointer-events: none;
z-index: 2;
}`,
    `.line.guideline.bounds {
background: #d66;
background: var(--bounds-color);
}`
  ],
  render(e, n) {
    const { customClipPath: t, defaultClipPath: s, clipArea: r, zoom: o, groupable: i } = e.props, {
      target: a,
      width: c,
      height: l,
      allMatrix: u,
      is3d: f,
      left: h,
      top: d,
      pos1: p,
      pos2: g,
      pos3: m,
      pos4: S,
      clipPathState: v,
      snapBoundInfos: x,
      rotation: C
    } = e.getState();
    if (!a || i)
      return [];
    const E = Hr(
      a,
      c,
      l,
      s || "inset",
      v || t
    );
    if (!E)
      return [];
    const D = f ? 4 : 3, T = E.type, z = E.poses.map((_) => {
      const O = at(u, _.pos, D);
      return [O[0] - h, O[1] - d];
    });
    let M = [], R = [];
    const P = T === "rect", y = T === "inset", k = T === "polygon";
    if (P || y || k) {
      const _ = y ? z.slice(0, 8) : z;
      R = _.map((O, B) => {
        const A = B === 0 ? _[_.length - 1] : _[B - 1], N = ft(A, O), G = Ci(A, O);
        return (0, import_jsx_runtime.jsx)(
          "div",
          {
            className: H("line", "clip-line", "snap-control"),
            "data-clip-index": B,
            style: {
              width: `${G}px`,
              transform: `translate(${A[0]}px, ${A[1]}px) rotate(${N}rad) scaleY(${o})`
            }
          },
          `clipLine${B}`
        );
      });
    }
    if (M = z.map((_, O) => (0, import_jsx_runtime.jsx)(
      "div",
      {
        className: H("control", "clip-control", "snap-control"),
        "data-clip-index": O,
        style: {
          transform: `translate(${_[0]}px, ${_[1]}px) rotate(${C}rad) scale(${o})`
        }
      },
      `clipControl${O}`
    )), y && M.push(
      ...z.slice(8).map((_, O) => (0, import_jsx_runtime.jsx)(
        "div",
        {
          className: H(
            "control",
            "clip-control",
            "clip-radius",
            "snap-control"
          ),
          "data-clip-index": 8 + O,
          style: {
            transform: `translate(${_[0]}px, ${_[1]}px) rotate(${C}rad) scale(${o})`
          }
        },
        `clipRadiusControl${O}`
      ))
    ), T === "circle" || T === "ellipse") {
      const { left: _, top: O, radiusX: B, radiusY: A } = E, [N, G] = V(
        at(u, [_, O], D),
        at(u, [0, 0], D)
      );
      let Y = "none";
      if (!r) {
        const q = Math.max(10, B / 5, A / 5), X = [];
        for (let W = 0; W <= q; ++W) {
          const Z = Math.PI * 2 / q * W;
          X.push([
            B + (B - o) * Math.cos(Z),
            A + (A - o) * Math.sin(Z)
          ]);
        }
        X.push([B, -2]), X.push([-2, -2]), X.push([-2, A * 2 + 2]), X.push([B * 2 + 2, A * 2 + 2]), X.push([B * 2 + 2, -2]), X.push([B, -2]), Y = `polygon(${X.map((W) => `${W[0]}px ${W[1]}px`).join(", ")})`;
      }
      M.push(
        (0, import_jsx_runtime.jsx)(
          "div",
          {
            className: H("clip-ellipse", "snap-control"),
            style: {
              width: `${B * 2}px`,
              height: `${A * 2}px`,
              clipPath: Y,
              transform: `translate(${-h + N}px, ${-d + G}px) ${Hn(u)}`
            }
          },
          "clipEllipse"
        )
      );
    }
    if (r) {
      const {
        width: _,
        height: O,
        left: B,
        top: A
      } = Ot([p, g, m, S, ...z]);
      if (k || P || y) {
        const N = y ? z.slice(0, 8) : z;
        M.push(
          (0, import_jsx_runtime.jsx)(
            "div",
            {
              className: H("clip-area", "snap-control"),
              style: {
                width: `${_}px`,
                height: `${O}px`,
                transform: `translate(${B}px, ${A}px)`,
                clipPath: `polygon(${N.map((G) => `${G[0] - B}px ${G[1] - A}px`).join(", ")})`
              }
            },
            "clipArea"
          )
        );
      }
    }
    return x && ["vertical", "horizontal"].forEach((_) => {
      const O = x[_], B = _ === "horizontal";
      O.isSnap && R.push(
        ...O.snap.posInfos.map(({ pos: A }, N) => {
          const G = V(
            at(
              u,
              B ? [0, A] : [A, 0],
              D
            ),
            [h, d]
          ), Y = V(
            at(
              u,
              B ? [c, A] : [A, l],
              D
            ),
            [h, d]
          );
          return Ze(
            n,
            "",
            G,
            Y,
            o,
            `clip${_}snap${N}`,
            "guideline"
          );
        })
      ), O.isBound && R.push(
        ...O.bounds.map(({ pos: A }, N) => {
          const G = V(
            at(
              u,
              B ? [0, A] : [A, 0],
              D
            ),
            [h, d]
          ), Y = V(
            at(
              u,
              B ? [c, A] : [A, l],
              D
            ),
            [h, d]
          );
          return Ze(
            n,
            "",
            G,
            Y,
            o,
            `clip${_}bounds${N}`,
            "guideline",
            "bounds",
            "bold"
          );
        })
      );
    }), [...M, ...R];
  },
  dragControlCondition(e, n) {
    return n.inputEvent && (n.inputEvent.target.getAttribute("class") || "").indexOf("clip") > -1;
  },
  dragStart(e, n) {
    const t = e.props, { dragWithClip: s = true } = t;
    return s ? false : this.dragControlStart(e, n);
  },
  drag(e, n) {
    return this.dragControl(e, { ...n, isDragTarget: true });
  },
  dragEnd(e, n) {
    return this.dragControlEnd(e, n);
  },
  dragControlStart(e, n) {
    const t = e.state, { defaultClipPath: s, customClipPath: r } = e.props, { target: o, width: i, height: a } = t, c = n.inputEvent ? n.inputEvent.target : null, l = c && c.getAttribute("class") || "", u = n.datas, f = Hr(
      o,
      i,
      a,
      s || "inset",
      r
    );
    if (!f)
      return false;
    const { clipText: h, type: d, poses: p } = f;
    return F(
      e,
      "onClipStart",
      K(e, n, {
        clipType: d,
        clipStyle: h,
        poses: p.map((m) => m.pos)
      })
    ) === false ? (u.isClipStart = false, false) : (u.isControl = l && l.indexOf("clip-control") > -1, u.isLine = l.indexOf("clip-line") > -1, u.isArea = l.indexOf("clip-area") > -1 || l.indexOf("clip-ellipse") > -1, u.clipIndex = c ? parseInt(c.getAttribute("data-clip-index"), 10) : -1, u.clipPath = f, u.isClipStart = true, t.clipPathState = h, ge(e, n), true);
  },
  dragControl(e, n) {
    const { datas: t, originalDatas: s, isDragTarget: r } = n;
    if (!t.isClipStart)
      return false;
    const { isControl: o, isLine: i, isArea: a, clipIndex: c, clipPath: l } = t;
    if (!l)
      return false;
    const u = de(e.props, "clippable"), { keepRatio: f } = u;
    let h = 0, d = 0;
    const p = s.draggable, g = Vt(n);
    r && p ? [h, d] = p.prevBeforeDist : [h, d] = g;
    const m = [h, d], S = e.state, { width: v, height: x } = S, C = !a && !o && !i, { type: E, poses: D, splitter: T } = l, w = D.map(($) => $.pos);
    C && (h = -h, d = -d);
    const z = !o || D[c].direction === "nesw", M = E === "inset" || E === "rect";
    let R = D.map(() => [0, 0]);
    if (o && !z) {
      const { horizontal: $, vertical: L } = D[c], j = [h * I($), d * I(L)];
      R = vu(D, c, j, M, f);
    } else z && (R = w.map(() => [h, d]));
    const P = w.map(($, L) => tt($, R[L])), y = [...P];
    S.snapBoundInfos = null;
    const k = l.type === "circle", _ = l.type === "ellipse";
    if (k || _) {
      const $ = Ot(P), L = I($.bottom - $.top), j = I(_ ? $.right - $.left : L), ot = P[0][1] + L, pt = P[0][0] - j, lt = P[0][0] + j;
      k && (y.push([lt, $.bottom]), R.push([1, 0])), y.push([$.left, ot]), R.push([0, 1]), y.push([pt, $.bottom]), R.push([1, 0]);
    }
    const O = gi(
      (u.clipHorizontalGuidelines || []).map(
        ($) => Q(`${$}`, x)
      ),
      (u.clipVerticalGuidelines || []).map(
        ($) => Q(`${$}`, v)
      ),
      v,
      x
    );
    let B = [], A = [];
    if (k || _)
      B = [y[4][0], y[2][0]], A = [y[1][1], y[3][1]];
    else if (M) {
      const $ = [
        y[0],
        y[2],
        y[4],
        y[6]
      ], L = [R[0], R[2], R[4], R[6]];
      B = $.filter((j, ot) => L[ot][0]).map((j) => j[0]), A = $.filter((j, ot) => L[ot][1]).map((j) => j[1]);
    } else
      B = y.filter(($, L) => R[L][0]).map(($) => $[0]), A = y.filter(($, L) => R[L][1]).map(($) => $[1]);
    const N = [0, 0], { horizontal: G, vertical: Y } = zr(
      O,
      u.clipTargetBounds && {
        left: 0,
        top: 0,
        right: v,
        bottom: x
      },
      B,
      A,
      5,
      5
    );
    let q = G.offset, X = Y.offset;
    if (G.isBound && (N[1] += q), Y.isBound && (N[0] += X), (_ || k) && R[0][0] === 0 && R[0][1] === 0) {
      const $ = Ot(P);
      let L = $.bottom - $.top, j = _ ? $.right - $.left : L;
      const ot = Y.isBound ? I(X) : Y.snapIndex === 0 ? -X : X, pt = G.isBound ? I(q) : G.snapIndex === 0 ? -q : q;
      j -= ot, L -= pt, k && (L = ai(Y, G) > 0 ? L : j, j = L);
      const lt = y[0];
      y[1][1] = lt[1] - L, y[2][0] = lt[0] + j, y[3][1] = lt[1] + L, y[4][0] = lt[0] - j;
    } else if (M && f && o) {
      const [$, L] = Xi(D), j = $ && L ? $ / L : 0, pt = D[c].direction || "";
      let lt = y[1][1], nt = y[5][1], Ft = y[7][0], Lt = y[3][0];
      I(q) <= I(X) ? q = Et(q) * I(X) / j : X = Et(X) * I(q) * j, pt.indexOf("w") > -1 ? Ft -= X : pt.indexOf("e") > -1 ? Lt -= X : (Ft += X / 2, Lt -= X / 2), pt.indexOf("n") > -1 ? lt -= q : pt.indexOf("s") > -1 ? nt -= q : (lt += q / 2, nt -= q / 2);
      const ut = An(lt, Lt, nt, Ft);
      y.forEach((St, xe) => {
        [St[0], St[1]] = ut[xe].pos;
      });
    } else
      y.forEach(($, L) => {
        const j = R[L];
        j[0] && ($[0] -= X), j[1] && ($[1] -= q);
      });
    const W = ar(e, l, P), Z = `${E}(${W.join(T)})`;
    if (S.clipPathState = Z, k || _)
      B = [y[4][0], y[2][0]], A = [y[1][1], y[3][1]];
    else if (M) {
      const $ = [
        y[0],
        y[2],
        y[4],
        y[6]
      ];
      B = $.map((L) => L[0]), A = $.map((L) => L[1]);
    } else
      B = y.map(($) => $[0]), A = y.map(($) => $[1]);
    if (S.snapBoundInfos = zr(
      O,
      u.clipTargetBounds && {
        left: 0,
        top: 0,
        right: v,
        bottom: x
      },
      B,
      A,
      1,
      1
    ), p) {
      const { is3d: $, allMatrix: L } = S, j = $ ? 4 : 3;
      let ot = N;
      r && (ot = [
        m[0] + N[0] - g[0],
        m[1] + N[1] - g[1]
      ]), p.deltaOffset = et(
        L,
        [ot[0], ot[1], 0, 0],
        j
      );
    }
    return F(
      e,
      "onClip",
      K(e, n, {
        clipEventType: "changed",
        clipType: E,
        poses: P,
        clipStyle: Z,
        clipStyles: W,
        distX: h,
        distY: d,
        ...Ct(
          {
            [E === "rect" ? "clip" : "clipPath"]: Z
          },
          n
        )
      })
    ), true;
  },
  dragControlEnd(e, n) {
    this.unset(e);
    const { isDrag: t, datas: s, isDouble: r } = n, { isLine: o, isClipStart: i, isControl: a } = s;
    return i ? (F(
      e,
      "onClipEnd",
      zt(e, n, {})
    ), r && (a ? Cu(e, n) : o && Eu(e, n)), r || t) : false;
  },
  unset(e) {
    e.state.clipPathState = "", e.state.snapBoundInfos = null;
  }
};
var bu = {
  name: "originDraggable",
  props: ["originDraggable", "originRelative"],
  events: ["dragOriginStart", "dragOrigin", "dragOriginEnd"],
  css: [
    `:host[data-able-origindraggable] .control.origin {
pointer-events: auto;
}`
  ],
  dragControlCondition(e, n) {
    return n.isRequest ? n.requestAble === "originDraggable" : dt(n.inputEvent.target, H("origin"));
  },
  dragControlStart(e, n) {
    const { datas: t } = n;
    ge(e, n);
    const s = K(e, n, {
      dragStart: vt.dragStart(
        e,
        new Pe().dragStart([0, 0], n)
      )
    }), r = F(e, "onDragOriginStart", s);
    return t.startOrigin = e.state.transformOrigin, t.startTargetOrigin = e.state.targetOrigin, t.prevOrigin = [0, 0], t.isDragOrigin = true, r === false ? (t.isDragOrigin = false, false) : s;
  },
  dragControl(e, n) {
    const { datas: t, isPinch: s, isRequest: r } = n;
    if (!t.isDragOrigin)
      return false;
    const [o, i] = Vt(n), a = e.state, { width: c, height: l, offsetMatrix: u, targetMatrix: f, is3d: h } = a, { originRelative: d = true } = e.props, p = h ? 4 : 3;
    let g = [o, i];
    if (r) {
      const M = n.distOrigin;
      (M[0] || M[1]) && (g = M);
    }
    const m = tt(t.startOrigin, g), S = tt(t.startTargetOrigin, g), v = V(g, t.prevOrigin), x = nn(u, f, m, p), C = e.getRect(), E = Ot(me(x, c, l, p)), D = [C.left - E.left, C.top - E.top];
    t.prevOrigin = g;
    const T = [
      Gt(S[0], c, d),
      Gt(S[1], l, d)
    ].join(" "), w = vt.drag(
      e,
      en(n, e.state, D, !!s)
    ), z = K(e, n, {
      width: c,
      height: l,
      origin: m,
      dist: g,
      delta: v,
      transformOrigin: T,
      drag: w,
      ...Ct(
        {
          transformOrigin: T,
          transform: w.transform
        },
        n
      ),
      afterTransform: w.transform
    });
    return F(e, "onDragOrigin", z), z;
  },
  dragControlEnd(e, n) {
    const { datas: t } = n;
    return t.isDragOrigin ? (F(
      e,
      "onDragOriginEnd",
      zt(e, n, {})
    ), true) : false;
  },
  dragGroupControlCondition(e, n) {
    return this.dragControlCondition(e, n);
  },
  dragGroupControlStart(e, n) {
    return !!this.dragControlStart(e, n);
  },
  dragGroupControl(e, n) {
    const t = this.dragControl(e, n);
    return t ? (e.transformOrigin = t.transformOrigin, true) : false;
  },
  /**
      * @method Moveable.OriginDraggable#request
      * @param {object} e - the OriginDraggable's request parameter
      * @param {number} [e.x] - x position
      * @param {number} [e.y] - y position
      * @param {number} [e.deltaX] - x number to move
      * @param {number} [e.deltaY] - y number to move
      * @param {array} [e.deltaOrigin] - left, top number to move transform-origin
      * @param {array} [e.origin] - transform-origin position
      * @param {number} [e.isInstant] - Whether to execute the request instantly
      * @return {Moveable.Requester} Moveable Requester
      * @example
  
      * // Instantly Request (requestStart - request - requestEnd)
      * // Use Relative Value
      * moveable.request("originDraggable", { deltaX: 10, deltaY: 10 }, true);
      * // Use Absolute Value
      * moveable.request("originDraggable", { x: 200, y: 100 }, true);
      * // Use Transform Value
      * moveable.request("originDraggable", { deltaOrigin: [10, 0] }, true);
      * moveable.request("originDraggable", { origin: [100, 0] }, true);
      * // requestStart
      * const requester = moveable.request("originDraggable");
      *
      * // request
      * // Use Relative Value
      * requester.request({ deltaX: 10, deltaY: 10 });
      * requester.request({ deltaX: 10, deltaY: 10 });
      * requester.request({ deltaX: 10, deltaY: 10 });
      * // Use Absolute Value
      * moveable.request("originDraggable", { x: 200, y: 100 });
      * moveable.request("originDraggable", { x: 220, y: 100 });
      * moveable.request("originDraggable", { x: 240, y: 100 });
      *
      * // requestEnd
      * requester.requestEnd();
      */
  request(e) {
    const n = {}, t = e.getRect();
    let s = 0, r = 0;
    const o = t.transformOrigin, i = [0, 0];
    return {
      isControl: true,
      requestStart() {
        return { datas: n };
      },
      request(a) {
        return "deltaOrigin" in a ? (i[0] += a.deltaOrigin[0], i[1] += a.deltaOrigin[1]) : "origin" in a ? (i[0] = a.origin[0] - o[0], i[1] = a.origin[1] - o[1]) : ("x" in a ? s = a.x - t.left : "deltaX" in a && (s += a.deltaX), "y" in a ? r = a.y - t.top : "deltaY" in a && (r += a.deltaY)), { datas: n, distX: s, distY: r, distOrigin: i };
      },
      requestEnd() {
        return { datas: n, isDrag: true };
      }
    };
  }
};
function wu(e, n, t, s) {
  const r = e.filter(
    ({ virtual: c, horizontal: l }) => l && !c
  ).length, o = e.filter(
    ({ virtual: c, vertical: l }) => l && !c
  ).length;
  let i = -1;
  if (n === 0 && (r === 0 ? i = 0 : r === 1 && (i = 1)), n === 2 && (r <= 2 ? i = 2 : r <= 3 && (i = 3)), n === 3 && (o === 0 ? i = 4 : o < 4 && (i = 7)), n === 1 && (o <= 1 ? i = 5 : o <= 2 && (i = 6)), i === -1 || !e[i].virtual)
    return;
  const a = e[i];
  Mu(e, i), i < 4 ? a.pos[0] = t : a.pos[1] = s;
}
function Mu(e, n) {
  n < 4 ? e.slice(0, n + 1).forEach((t) => {
    t.virtual = false;
  }) : (e[0].virtual && (e[0].virtual = false), e.slice(4, n + 1).forEach((t) => {
    t.virtual = false;
  }));
}
function Tu(e, n) {
  n < 4 ? e.slice(n, 4).forEach((t) => {
    t.virtual = true;
  }) : e.slice(n).forEach((t) => {
    t.virtual = true;
  });
}
function Vr(e, n, t, s = [0, 0], r) {
  let o = [];
  return !e || e === "0px" ? o = [] : o = Qt(e), ki(o, n, t, 0, 0, s, r);
}
function qr(e, n, t, s, r) {
  const o = e.state, { width: i, height: a } = o, { raws: c, styles: l, radiusPoses: u } = ir(
    r,
    e.props.roundRelative,
    i,
    a
  ), { horizontals: f, verticals: h } = mu(u, c), d = l.join(" ");
  o.borderRadiusState = d;
  const p = K(e, n, {
    horizontals: f,
    verticals: h,
    borderRadius: d,
    width: i,
    height: a,
    delta: s,
    dist: t,
    ...Ct(
      {
        borderRadius: d
      },
      n
    )
  });
  return F(e, "onRound", p), p;
}
function jr(e) {
  var s;
  const { style: n } = e.getState();
  let t = n.borderRadius || "";
  if (!t && e.props.groupable) {
    const r = e.moveables[0], o = e.getTargets()[0];
    o && ((r == null ? void 0 : r.props.target) === o ? (t = ((s = e.moveables[0]) == null ? void 0 : s.state.style.borderRadius) ?? "", n.borderRadius = t) : (t = er(o).borderRadius, n.borderRadius = t));
  }
  return t;
}
var Ru = {
  name: "roundable",
  props: [
    "roundable",
    "roundRelative",
    "minRoundControls",
    "maxRoundControls",
    "roundClickable",
    "roundPadding",
    "isDisplayShadowRoundControls"
  ],
  events: [
    "roundStart",
    "round",
    "roundEnd",
    "roundGroupStart",
    "roundGroup",
    "roundGroupEnd"
  ],
  css: [
    `.control.border-radius {
background: #d66;
cursor: pointer;
z-index: 3;
}`,
    `.control.border-radius.vertical {
background: #d6d;
z-index: 2;
}`,
    `.control.border-radius.virtual {
opacity: 0.5;
z-index: 1;
}`,
    `:host.round-line-clickable .line.direction {
cursor: pointer;
}`
  ],
  className(e) {
    const n = e.props.roundClickable;
    return n === true || n === "line" ? H("round-line-clickable") : "";
  },
  requestStyle() {
    return ["borderRadius"];
  },
  requestChildStyle() {
    return ["borderRadius"];
  },
  render(e, n) {
    const {
      target: t,
      width: s,
      height: r,
      allMatrix: o,
      is3d: i,
      left: a,
      top: c,
      borderRadiusState: l
    } = e.getState(), {
      minRoundControls: u = [0, 0],
      maxRoundControls: f = [4, 4],
      zoom: h,
      roundPadding: d = 0,
      isDisplayShadowRoundControls: p,
      groupable: g
    } = e.props;
    if (!t)
      return null;
    const m = l || jr(e), S = i ? 4 : 3, v = Vr(
      m,
      s,
      r,
      u,
      true
    );
    if (!v)
      return null;
    let x = 0, C = 0;
    const E = g ? [0, 0] : [a, c];
    return v.map((D, T) => {
      const w = D.horizontal, z = D.vertical, M = D.direction || "", R = [...D.pos];
      C += Math.abs(w), x += Math.abs(z), w && M.indexOf("n") > -1 && (R[1] -= d), z && M.indexOf("w") > -1 && (R[0] -= d), w && M.indexOf("s") > -1 && (R[1] += d), z && M.indexOf("e") > -1 && (R[0] += d);
      const P = V(at(o, R, S), E), y = p && p !== "horizontal", k = D.vertical ? x <= f[1] && (y || !D.virtual) : C <= f[0] && (p || !D.virtual);
      return (0, import_jsx_runtime.jsx)(
        "div",
        {
          className: H(
            "control",
            "border-radius",
            D.vertical ? "vertical" : "",
            D.virtual ? "virtual" : ""
          ),
          "data-radius-index": T,
          style: {
            display: k ? "block" : "none",
            transform: `translate(${P[0]}px, ${P[1]}px) scale(${h})`
          }
        },
        `borderRadiusControl${T}`
      );
    });
  },
  dragControlCondition(e, n) {
    if (!n.inputEvent || n.isRequest)
      return false;
    const t = n.inputEvent.target.getAttribute("class") || "";
    return t.indexOf("border-radius") > -1 || t.indexOf("moveable-line") > -1 && t.indexOf("moveable-direction") > -1;
  },
  dragGroupControlCondition(e, n) {
    return this.dragControlCondition(e, n);
  },
  dragControlStart(e, n) {
    const { inputEvent: t, datas: s } = n, r = t.target, o = r.getAttribute("class") || "", i = o.indexOf("border-radius") > -1, a = o.indexOf("moveable-line") > -1 && o.indexOf("moveable-direction") > -1, c = i ? parseInt(r.getAttribute("data-radius-index"), 10) : -1;
    let l = -1;
    if (a) {
      const x = r.getAttribute("data-line-key") || "";
      x && (l = parseInt(x.replace(/render-line-/g, ""), 10), isNaN(l) && (l = -1));
    }
    if (!i && !a)
      return false;
    const u = K(e, n, {});
    if (F(e, "onRoundStart", u) === false)
      return false;
    s.lineIndex = l, s.controlIndex = c, s.isControl = i, s.isLine = a, ge(e, n);
    const { roundRelative: h, minRoundControls: d = [0, 0] } = e.props, p = e.state, { width: g, height: m } = p;
    s.isRound = true, s.prevDist = [0, 0];
    const S = jr(e), v = Vr(
      S || "",
      g,
      m,
      d,
      true
    ) || [];
    return s.controlPoses = v, p.borderRadiusState = ir(
      v,
      h,
      g,
      m
    ).styles.join(" "), u;
  },
  dragControl(e, n) {
    const { datas: t } = n, s = t.controlPoses;
    if (!t.isRound || !t.isControl || !s.length)
      return false;
    const r = t.controlIndex, [o, i] = Vt(n), a = [o, i], c = V(a, t.prevDist), { maxRoundControls: l = [4, 4] } = e.props, { width: u, height: f } = e.state, h = s[r], d = h.vertical, p = h.horizontal, g = s.map((S) => {
      const { horizontal: v, vertical: x } = S, C = [
        v * p * a[0],
        x * d * a[1]
      ];
      if (v) {
        if (l[0] === 1)
          return C;
        if (l[0] < 4 && v !== p)
          return C;
      } else {
        if (l[1] === 0)
          return C[1] = x * p * a[0] / u * f, C;
        if (d) {
          if (l[1] === 1)
            return C;
          if (l[1] < 4 && x !== d)
            return C;
        }
      }
      return [0, 0];
    });
    g[r] = a;
    const m = s.map((S, v) => ({
      ...S,
      pos: tt(S.pos, g[v])
    }));
    return r < 4 ? m.slice(0, r + 1).forEach((S) => {
      S.virtual = false;
    }) : m.slice(4, r + 1).forEach((S) => {
      S.virtual = false;
    }), t.prevDist = [o, i], qr(e, n, a, c, m);
  },
  dragControlEnd(e, n) {
    const t = e.state;
    t.borderRadiusState = "";
    const { datas: s, isDouble: r } = n;
    if (!s.isRound)
      return false;
    const { isControl: o, controlIndex: i, isLine: a, lineIndex: c } = s, l = s.controlPoses, u = l.filter(({ virtual: d }) => d).length, { roundClickable: f = true } = e.props;
    if (r && f) {
      if (o && (f === true || f === "control"))
        Tu(l, i);
      else if (a && (f === true || f === "line")) {
        const [d, p] = Wo(e, n);
        wu(l, c, d, p);
      }
      u !== l.filter(({ virtual: d }) => d).length && qr(e, n, [0, 0], [0, 0], l);
    }
    const h = zt(e, n, {});
    return F(e, "onRoundEnd", h), t.borderRadiusState = "", h;
  },
  dragGroupControlStart(e, n) {
    const t = this.dragControlStart(e, n);
    if (!t)
      return false;
    const s = e.moveables, r = e.props.targets, o = $t(e, "roundable", n), i = {
      targets: e.props.targets,
      events: o.map((a, c) => ({
        ...a,
        target: r[c],
        moveable: s[c],
        currentTarget: s[c]
      })),
      ...t
    };
    return F(e, "onRoundGroupStart", i), t;
  },
  dragGroupControl(e, n) {
    const t = this.dragControl(e, n);
    if (!t)
      return false;
    const s = e.moveables, r = e.props.targets, o = $t(e, "roundable", n), i = {
      targets: e.props.targets,
      events: o.map((a, c) => ({
        ...a,
        target: r[c],
        moveable: s[c],
        currentTarget: s[c],
        ...Ct(
          {
            borderRadius: t.borderRadius
          },
          a
        )
      })),
      ...t
    };
    return F(e, "onRoundGroup", i), i;
  },
  dragGroupControlEnd(e, n) {
    const t = e.moveables, s = e.props.targets, r = $t(e, "roundable", n);
    Vn(e, "onRound", (a) => {
      const c = {
        targets: e.props.targets,
        events: r.map((l, u) => ({
          ...l,
          target: s[u],
          moveable: t[u],
          currentTarget: t[u],
          ...Ct(
            {
              borderRadius: a.borderRadius
            },
            l
          )
        })),
        ...a
      };
      F(e, "onRoundGroup", c);
    });
    const o = this.dragControlEnd(e, n);
    if (!o)
      return false;
    const i = {
      targets: e.props.targets,
      events: r.map((a, c) => {
        var l;
        return {
          ...a,
          target: s[c],
          moveable: t[c],
          currentTarget: t[c],
          lastEvent: (l = a.datas) == null ? void 0 : l.lastEvent
        };
      }),
      ...o
    };
    return F(e, "onRoundGroupEnd", i), i;
  },
  unset(e) {
    e.state.borderRadiusState = "";
  }
};
function yu(e, n) {
  const s = rt(n ? 4 : 3), r = `matrix${n ? "3d" : ""}(${s.join(",")})`;
  return e === r || e === "matrix(1,0,0,1,0,0)";
}
var Yi = {
  isPinch: true,
  name: "beforeRenderable",
  props: [],
  events: [
    "beforeRenderStart",
    "beforeRender",
    "beforeRenderEnd",
    "beforeRenderGroupStart",
    "beforeRenderGroup",
    "beforeRenderGroupEnd"
  ],
  dragRelation: "weak",
  setTransform(e, n) {
    const { is3d: t, targetMatrix: s, inlineTransform: r } = e.state, o = t ? `matrix3d(${s.join(",")})` : `matrix(${wo(s, true)})`, i = !r || r === "none" ? o : r;
    n.datas.startTransforms = yu(i, t) ? [] : Qt(i);
  },
  resetStyle(e) {
    const n = e.datas;
    n.nextStyle = {}, n.nextTransforms = e.datas.startTransforms, n.nextTransformAppendedIndexes = [];
  },
  fillDragStartParams(e, n) {
    return K(e, n, {
      setTransform: (t) => {
        n.datas.startTransforms = ct(t) ? t : Qt(t);
      },
      isPinch: !!n.isPinch
    });
  },
  fillDragParams(e, n) {
    return K(e, n, {
      isPinch: !!n.isPinch
    });
  },
  dragStart(e, n) {
    this.setTransform(e, n), this.resetStyle(n), F(
      e,
      "onBeforeRenderStart",
      this.fillDragStartParams(e, n)
    );
  },
  drag(e, n) {
    n.datas.startTransforms || this.setTransform(e, n), this.resetStyle(n), F(
      e,
      "onBeforeRender",
      K(e, n, {
        isPinch: !!n.isPinch
      })
    );
  },
  dragEnd(e, n) {
    n.datas.startTransforms || (this.setTransform(e, n), this.resetStyle(n)), F(
      e,
      "onBeforeRenderEnd",
      K(e, n, {
        isPinch: !!n.isPinch,
        isDrag: n.isDrag
      })
    );
  },
  dragGroupStart(e, n) {
    this.dragStart(e, n);
    const t = $t(e, "beforeRenderable", n), s = e.moveables, r = t.map((o, i) => {
      const a = s[i];
      return this.setTransform(a, o), this.resetStyle(o), this.fillDragStartParams(a, o);
    });
    F(
      e,
      "onBeforeRenderGroupStart",
      K(e, n, {
        isPinch: !!n.isPinch,
        targets: e.props.targets,
        setTransform() {
        },
        events: r
      })
    );
  },
  dragGroup(e, n) {
    this.drag(e, n);
    const t = $t(e, "beforeRenderable", n), s = e.moveables, r = t.map((o, i) => {
      const a = s[i];
      return this.resetStyle(o), this.fillDragParams(a, o);
    });
    F(
      e,
      "onBeforeRenderGroup",
      K(e, n, {
        isPinch: !!n.isPinch,
        targets: e.props.targets,
        events: r
      })
    );
  },
  dragGroupEnd(e, n) {
    this.dragEnd(e, n), F(
      e,
      "onBeforeRenderGroupEnd",
      K(e, n, {
        isPinch: !!n.isPinch,
        isDrag: n.isDrag,
        targets: e.props.targets
      })
    );
  },
  dragControlStart(e, n) {
    return this.dragStart(e, n);
  },
  dragControl(e, n) {
    return this.drag(e, n);
  },
  dragControlEnd(e, n) {
    return this.dragEnd(e, n);
  },
  dragGroupControlStart(e, n) {
    return this.dragGroupStart(e, n);
  },
  dragGroupControl(e, n) {
    return this.dragGroup(e, n);
  },
  dragGroupControlEnd(e, n) {
    return this.dragGroupEnd(e, n);
  }
};
var Fi = {
  name: "renderable",
  props: [],
  events: [
    "renderStart",
    "render",
    "renderEnd",
    "renderGroupStart",
    "renderGroup",
    "renderGroupEnd"
  ],
  dragRelation: "weak",
  dragStart(e, n) {
    F(
      e,
      "onRenderStart",
      K(e, n, {
        isPinch: !!n.isPinch
      })
    );
  },
  drag(e, n) {
    F(e, "onRender", this.fillDragParams(e, n));
  },
  dragAfter(e, n) {
    return this.drag(e, n);
  },
  dragEnd(e, n) {
    F(e, "onRenderEnd", this.fillDragEndParams(e, n));
  },
  dragGroupStart(e, n) {
    F(
      e,
      "onRenderGroupStart",
      K(e, n, {
        isPinch: !!n.isPinch,
        targets: e.props.targets
      })
    );
  },
  dragGroup(e, n) {
    const t = $t(e, "beforeRenderable", n), s = e.moveables, r = t.map((o, i) => {
      const a = s[i];
      return this.fillDragParams(a, o);
    });
    F(
      e,
      "onRenderGroup",
      K(e, n, {
        isPinch: !!n.isPinch,
        targets: e.props.targets,
        transform: fn(n),
        transformObject: {},
        ...Ct(hn(n)),
        events: r
      })
    );
  },
  dragGroupEnd(e, n) {
    const t = $t(e, "beforeRenderable", n), s = e.moveables, r = t.map((o, i) => {
      const a = s[i];
      return this.fillDragEndParams(a, o);
    });
    F(
      e,
      "onRenderGroupEnd",
      K(e, n, {
        isPinch: !!n.isPinch,
        isDrag: n.isDrag,
        targets: e.props.targets,
        events: r,
        transformObject: {},
        transform: fn(n),
        ...Ct(hn(n))
      })
    );
  },
  dragControlStart(e, n) {
    return this.dragStart(e, n);
  },
  dragControl(e, n) {
    return this.drag(e, n);
  },
  dragControlAfter(e, n) {
    return this.dragAfter(e, n);
  },
  dragControlEnd(e, n) {
    return this.dragEnd(e, n);
  },
  dragGroupControlStart(e, n) {
    return this.dragGroupStart(e, n);
  },
  dragGroupControl(e, n) {
    return this.dragGroup(e, n);
  },
  dragGroupControlEnd(e, n) {
    return this.dragGroupEnd(e, n);
  },
  fillDragParams(e, n) {
    const t = {};
    return ze(yn(n) || []).forEach((s) => {
      t[s.name] = s.functionValue;
    }), K(e, n, {
      isPinch: !!n.isPinch,
      transformObject: t,
      transform: fn(n),
      ...Ct(hn(n))
    });
  },
  fillDragEndParams(e, n) {
    const t = {};
    return ze(yn(n) || []).forEach((s) => {
      t[s.name] = s.functionValue;
    }), K(e, n, {
      isPinch: !!n.isPinch,
      isDrag: n.isDrag,
      transformObject: t,
      transform: fn(n),
      ...Ct(hn(n))
    });
  }
};
function qe(e, n, t, s, r, o, i) {
  o.clientDistX = o.distX, o.clientDistY = o.distY;
  const a = r === "Start", c = r === "End", l = r === "After", u = e.state.target, f = o.isRequest, h = s.indexOf("Control") > -1;
  if (!u || a && h && !f && e.areaElement === o.inputEvent.target)
    return false;
  const d = [...n];
  if (f) {
    const M = o.requestAble;
    d.some((R) => R.name === M) || d.push(
      ...e.props.ables.filter((R) => R.name === M)
    );
  }
  if (!d.length || d.every((M) => M.dragRelation))
    return false;
  const p = o.inputEvent;
  let g;
  c && p && (g = document.elementFromPoint(o.clientX, o.clientY) || p.target);
  let m = false;
  const S = () => {
    var M;
    m = true, (M = o.stop) == null || M.call(o);
  }, v = a && (!e.targetGesto || !e.controlGesto || !e.targetGesto.isFlag() || !e.controlGesto.isFlag());
  v && e.updateRect(r, true, false);
  const x = o.datas, C = h ? "controlGesto" : "targetGesto", E = e[C], D = (M, R, P) => {
    if (!(R in M) || E !== e[C])
      return false;
    const y = M.name, k = x[y] || (x[y] = {});
    if (a && (k.isEventStart = !P || !M[P] || M[P](e, o)), !k.isEventStart)
      return false;
    const _ = M[R](e, {
      ...o,
      stop: S,
      datas: k,
      originalDatas: x,
      inputTarget: g
    });
    return e._emitter.off(), a && _ === false && (k.isEventStart = false), _;
  };
  v && d.forEach((M) => {
    M.unset && M.unset(e);
  }), D(Yi, `drag${s}${r}`);
  let T = 0, w = 0;
  t.forEach((M) => {
    if (m)
      return false;
    const R = `${M}${s}${r}`, P = `${M}${s}Condition`;
    r === "" && !f && Kl(e.state, o);
    let y = d.filter((O) => O[R]);
    y = y.filter((O, B) => O.name && y.indexOf(O) === B);
    const _ = y.filter(
      (O) => D(O, R, P)
    ).length;
    m && ++T, _ && ++w, !m && a && y.length && !_ && (T += y.filter((O) => {
      const B = O.name;
      return x[B].isEventStart ? O.dragRelation !== "strong" : false;
    }).length ? 1 : 0);
  }), (!l || w) && D(Fi, `drag${s}${r}`);
  const z = E !== e[C] || T === t.length;
  return (c || m || z) && (e.state.gestos = {}, e.moveables && e.moveables.forEach(
    (M) => {
      M.state.gestos = {};
    }
  ), d.forEach((M) => {
    M.unset && M.unset(e);
  })), a && !z && !f && w && e.props.preventDefault && (o == null || o.preventDefault()), e.isUnmounted || z ? false : ((!a && w && !i || c) && (e.props.flushSync || xi)(() => {
    e.updateRect(c ? r : "", true, false), e.forceUpdate();
  }), !a && !c && !l && w && !i && qe(
    e,
    n,
    t,
    s,
    r + "After",
    o
  ), true);
}
function cr(e, n) {
  return (t, s = t.inputEvent.target) => {
    var a;
    const r = s, o = e.areaElement, i = e._dragTarget;
    return !i || !n && ((a = e.controlGesto) != null && a.isFlag()) ? false : r === i || i.contains(r) || r === o || !e.isMoveableElement(r) && !e.controlBox.contains(r) || dt(r, "moveable-area") || dt(r, "moveable-padding") || dt(r, "moveable-edgeDraggable");
  };
}
function Li(e, n, t) {
  const s = e.controlBox, r = [], o = e.props, i = o.dragArea, a = e.state.target, c = o.dragTarget;
  r.push(s), (!i || c) && r.push(n), !i && c && a && n !== a && o.dragTargetSelf && r.push(a);
  const l = cr(e);
  return Ni(e, r, "targetAbles", t, {
    dragStart: l,
    pinchStart: l
  });
}
function Wi(e, n) {
  const t = e.controlBox, s = [];
  s.push(t);
  const r = cr(e, true), o = (i, a = i.inputEvent.target) => a === t ? true : !r(i, a);
  return Ni(e, s, "controlAbles", n, {
    dragStart: o,
    pinchStart: o
  });
}
function Ni(e, n, t, s, r = {}) {
  const o = t === "targetAbles", {
    pinchOutside: i,
    pinchThreshold: a,
    preventClickEventOnDrag: c,
    preventClickDefault: l,
    checkInput: u,
    dragFocusedInput: f,
    preventDefault: h = true,
    preventRightClick: d = true,
    preventWheelClick: p = true,
    dragContainer: g
  } = e.props, m = Ht(g, true), S = {
    preventDefault: h,
    preventRightClick: d,
    preventWheelClick: p,
    container: m || Mt(e.getControlBoxElement()),
    pinchThreshold: a,
    pinchOutside: i,
    preventClickEventOnDrag: o ? c : false,
    preventClickEventOnDragStart: o ? l : false,
    preventClickEventByCondition: o ? null : (C) => e.controlBox.contains(C.target),
    checkInput: o ? u : false,
    dragFocusedInput: f
  }, v = new $n(n, S), x = s === "Control";
  return ["drag", "pinch"].forEach((C) => {
    ["Start", "", "End"].forEach((E) => {
      v.on(`${C}${E}`, (D) => {
        var P;
        const T = D.eventType, w = C === "drag" && D.isPinch;
        if (r[T] && !r[T](D)) {
          D.stop();
          return;
        }
        if (w)
          return;
        const z = C === "drag" ? [C] : ["drag", C], M = [...e[t]];
        qe(
          e,
          M,
          z,
          s,
          E,
          D
        ) ? (e.props.stopPropagation || E === "Start" && x) && ((P = D == null ? void 0 : D.inputEvent) == null || P.stopPropagation()) : D.stop();
      });
    });
  }), v;
}
var zu = class {
  constructor(n, t, s) {
    b(this, "ables", []);
    b(this, "_onEvent", (n2) => {
      const t2 = this.eventName, s2 = this.moveable;
      s2.state.disableNativeEvent || this.ables.forEach((r) => {
        r[t2](s2, {
          inputEvent: n2
        });
      });
    });
    this.target = n, this.moveable = t, this.eventName = s, n.addEventListener(s.toLowerCase(), this._onEvent);
  }
  setAbles(n) {
    this.ables = n;
  }
  destroy() {
    this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent), this.target = null, this.moveable = null;
  }
};
function Hi(e, n) {
  const t = Xs(n), s = t.className;
  return (0, import_react.forwardRef)((r, o) => {
    const { className: i = "", cspNonce: a, ...c } = r, l = (0, import_react.useRef)(null);
    return (0, import_react.useImperativeHandle)(o, () => l.current, []), (0, import_react.useEffect)(() => {
      const u = t.inject(l.current, {
        nonce: r.cspNonce
      });
      return () => {
        u.destroy();
      };
    }, []), (0, import_react.createElement)(e, {
      ref: l,
      "data-styled-id": s,
      className: `${i} ${s}`,
      ...c
    });
  });
}
function Pu(e, n, t = n, s) {
  var O;
  const {
    matrixes: r,
    is3d: o,
    targetMatrix: i,
    transformOrigin: a,
    targetOrigin: c,
    offsetContainer: l,
    hasFixed: u,
    zoom: f
  } = Uo(e, n), {
    matrixes: h,
    is3d: d,
    offsetContainer: p,
    zoom: g
  } = Nc(l, t), m = s, S = 4, v = e.tagName.toLowerCase() !== "svg" && "ownerSVGElement" in e;
  let x = i, C = rt(S), E = rt(S), D = rt(S), T = rt(S);
  const w = r.length, z = h.map((B) => ({
    ...B,
    matrix: B.matrix ? [...B.matrix] : void 0
  })).reverse();
  r.reverse(), !o && m && (x = Xt(x, 3, 4), bs(r)), !d && m && bs(z), z.forEach((B) => {
    E = et(E, B.matrix, S);
  });
  const M = t || ne(e), R = ((O = z[0]) == null ? void 0 : O.target) || Ke(M, M, true).offsetParent, P = z.slice(1).reduce((B, A) => et(B, A.matrix, S), rt(S));
  r.forEach((B, A) => {
    if (w - 2 === A && (D = C.slice()), w - 1 === A && (T = C.slice()), !B.matrix) {
      const N = r[A + 1], G = ql(
        B,
        N,
        R,
        S,
        et(P, C, S)
      );
      B.matrix = he(G, S);
    }
    C = et(C, B.matrix, S);
  });
  const y = !v && o;
  x || (x = rt(y ? 4 : 3));
  const k = Hn(
    v && x.length === 16 ? Xt(x, 4, 3) : x,
    y
  ), _ = E;
  return E = Do(E, S, S), {
    hasZoom: f !== 1 || g !== 1,
    hasFixed: u,
    matrixes: r,
    rootMatrix: E,
    originalRootMatrix: _,
    beforeMatrix: D,
    offsetMatrix: T,
    allMatrix: C,
    targetMatrix: x,
    targetTransform: k,
    inlineTransform: e.style.transform,
    transformOrigin: a,
    targetOrigin: c,
    is3d: m,
    offsetContainer: l,
    offsetRootContainer: p
  };
}
function _u(e, n, t = n, s) {
  let r = 0, o = 0, i = 0, a = {};
  const c = Di(e);
  if (e && (r = c.offsetWidth, o = c.offsetHeight), e) {
    const u = Pu(
      e,
      n,
      t,
      s
      // prevMatrix, prevRootMatrix, prevN,
    ), f = Te(
      u.allMatrix,
      u.transformOrigin,
      r,
      o
    );
    a = {
      ...u,
      ...f
    };
    const h = Te(
      u.allMatrix,
      [50, 50],
      100,
      100
    );
    i = bi(
      [h.pos1, h.pos2],
      h.direction
    );
  }
  const l = 4;
  return {
    hasZoom: false,
    width: r,
    height: o,
    rotation: i,
    ...c,
    originalRootMatrix: rt(l),
    rootMatrix: rt(l),
    beforeMatrix: rt(l),
    offsetMatrix: rt(l),
    allMatrix: rt(l),
    targetMatrix: rt(l),
    targetTransform: "",
    inlineTransform: "",
    transformOrigin: [0, 0],
    targetOrigin: [0, 0],
    is3d: true,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    origin: [0, 0],
    pos1: [0, 0],
    pos2: [0, 0],
    pos3: [0, 0],
    pos4: [0, 0],
    direction: 1,
    hasFixed: false,
    offsetContainer: null,
    offsetRootContainer: null,
    matrixes: [],
    ...a
  };
}
function Rs(e, n, t, s, r, o = []) {
  let i = 1, a = [0, 0], c = pn(), l = pn(), u = pn(), f = pn(), h = [0, 0];
  const d = {}, p = _u(n, t, r, true);
  if (n) {
    const g = Tt(n);
    o.forEach((x) => {
      d[x] = g(x);
    });
    const m = p.is3d ? 4 : 3, S = Te(
      p.offsetMatrix,
      tt(p.transformOrigin, bo(p.targetMatrix, m)),
      p.width,
      p.height
    );
    i = S.direction, a = tt(S.origin, [
      S.left - p.left,
      S.top - p.top
    ]), f = Ve(p.offsetRootContainer);
    const v = Ke(s, s, true).offsetParent || p.offsetRootContainer;
    if (p.hasZoom) {
      const x = Te(
        et(p.originalRootMatrix, p.allMatrix),
        p.transformOrigin,
        p.width,
        p.height
      ), C = Te(
        p.originalRootMatrix,
        On(
          Tt(v)("transformOrigin")
        ).map((E) => parseFloat(E)),
        v.offsetWidth,
        v.offsetHeight
      );
      if (c = os(
        x,
        f
      ), u = os(
        C,
        f,
        v,
        true
      ), e) {
        const E = x.left, D = x.top;
        l = os(
          {
            left: E,
            top: D,
            bottom: D,
            right: D
          },
          f
        );
      }
    } else {
      c = Ve(n), u = Wc(v), e && (l = Ve(e));
      const {
        left: x,
        top: C,
        clientLeft: E,
        clientTop: D
      } = u, T = [
        c.left - x,
        c.top - C
      ];
      h = V(
        Ie(p.rootMatrix, T, 4),
        [E + p.left, D + p.top]
      );
    }
  }
  return {
    targetClientRect: c,
    containerClientRect: u,
    moveableClientRect: l,
    rootContainerClientRect: f,
    beforeDirection: i,
    beforeOrigin: a,
    originalBeforeOrigin: a,
    target: n,
    style: d,
    offsetDelta: h,
    ...p
  };
}
function Ur(e) {
  let { pos1: n, pos2: t, pos3: s, pos4: r } = e;
  if (!n || !t || !s || !r)
    return null;
  const o = ue([n, t, s, r]), i = [o.minX, o.minY], a = V(e.origin, i);
  return n = V(n, i), t = V(t, i), s = V(s, i), r = V(r, i), {
    ...e,
    left: e.left,
    top: e.top,
    posDelta: i,
    pos1: n,
    pos2: t,
    pos3: s,
    pos4: r,
    origin: a,
    beforeOrigin: a,
    // originalBeforeOrigin: origin,
    isPersisted: true
  };
}
var pe = class extends ys.PureComponent {
  constructor() {
    super(...arguments);
    b(this, "state", {
      container: null,
      gestos: {},
      renderLines: [
        [
          [0, 0],
          [0, 0]
        ],
        [
          [0, 0],
          [0, 0]
        ],
        [
          [0, 0],
          [0, 0]
        ],
        [
          [0, 0],
          [0, 0]
        ]
      ],
      renderPoses: [
        [0, 0],
        [0, 0],
        [0, 0],
        [0, 0]
      ],
      disableNativeEvent: false,
      posDelta: [0, 0],
      ...Rs(null)
    });
    b(this, "renderState", {});
    b(this, "enabledAbles", []);
    b(this, "targetAbles", []);
    b(this, "controlAbles", []);
    b(this, "controlBox");
    b(this, "areaElement");
    b(this, "targetGesto");
    b(this, "controlGesto");
    b(this, "rotation", 0);
    b(this, "scale", [1, 1]);
    b(this, "isMoveableMounted", false);
    b(this, "isUnmounted", false);
    b(this, "events", {
      mouseEnter: null,
      mouseLeave: null
    });
    b(this, "_emitter", new Ae());
    b(this, "_prevOriginalDragTarget", null);
    b(this, "_originalDragTarget", null);
    b(this, "_prevDragTarget", null);
    b(this, "_dragTarget", null);
    b(this, "_prevPropTarget", null);
    b(this, "_propTarget", null);
    b(this, "_prevDragArea", false);
    b(this, "_isPropTargetChanged", false);
    b(this, "_hasFirstTarget", false);
    b(this, "_reiszeObserver", null);
    b(this, "_observerId", 0);
    b(this, "_mutationObserver", null);
    b(this, "_rootContainer", null);
    b(this, "_viewContainer", null);
    b(this, "_viewClassNames", []);
    b(this, "_store", {});
    b(this, "checkUpdateRect", () => {
      if (this.isDragging())
        return;
      const t = this.props.parentMoveable;
      if (t) {
        t.checkUpdateRect();
        return;
      }
      Ea(this._observerId), this._observerId = fo(() => {
        this.isDragging() || this.updateRect();
      });
    });
    b(this, "_onPreventClick", (t) => {
      t.stopPropagation(), t.preventDefault();
    });
  }
  render() {
    const t = this.props, s = this.getState(), {
      parentPosition: r,
      className: o,
      target: i,
      zoom: a,
      cspNonce: c,
      translateZ: l,
      cssStyled: u,
      groupable: f,
      linePadding: h,
      controlPadding: d
    } = t;
    this._checkUpdateRootContainer(), this.checkUpdate(), this.updateRenderPoses();
    const [p, g] = r || [0, 0], {
      left: m,
      top: S,
      target: v,
      direction: x,
      hasFixed: C,
      offsetDelta: E
    } = s, D = t.targets, T = this.isDragging(), w = {};
    this.getEnabledAbles().forEach((k) => {
      w[`data-able-${k.name.toLowerCase()}`] = true;
    });
    const z = this._getAbleClassName(), M = D && D.length && (v || f) || i || !this._hasFirstTarget && this.state.isPersisted, R = this.controlBox || this.props.firstRenderState || this.props.persistData, P = [m - p, S - g];
    !f && t.useAccuratePosition && (P[0] += E[0], P[1] += E[1]);
    const y = {
      position: C ? "fixed" : "absolute",
      display: M ? "block" : "none",
      visibility: R ? "visible" : "hidden",
      transform: `translate3d(${P[0]}px, ${P[1]}px, ${l})`,
      "--zoom": a,
      "--zoompx": `${a}px`
    };
    return h && (y["--moveable-line-padding"] = h), d && (y["--moveable-control-padding"] = d), (0, import_jsx_runtime.jsxs)(
      u,
      {
        cspNonce: c,
        ref: _t(this, "controlBox"),
        className: `${H(
          "control-box",
          x === -1 ? "reverse" : "",
          T ? "dragging" : ""
        )} ${z} ${o}`,
        ...w,
        onClick: this._onPreventClick,
        style: y,
        children: [
          this.renderAbles(),
          this._renderLines()
        ]
      }
    );
  }
  componentDidMount() {
    this.isMoveableMounted = true, this.isUnmounted = false;
    const t = this.props, { parentMoveable: s, container: r } = t;
    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateTargets(), this._updateNativeEvents(), this._updateEvents(), this.updateCheckInput(), this._updateObserver(this.props), !r && !s && !this.state.isPersisted && (this.updateRect("", false, false), this.forceUpdate());
  }
  componentDidUpdate(t) {
    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateNativeEvents(), this._updateTargets(), this._updateEvents(), this.updateCheckInput(), this._updateObserver(t);
  }
  componentWillUnmount() {
    var r, o;
    this.isMoveableMounted = false, this.isUnmounted = true, this._emitter.off(), (r = this._reiszeObserver) == null || r.disconnect(), (o = this._mutationObserver) == null || o.disconnect(), this._viewContainer && this._changeAbleViewClassNames([]), we(this, false), we(this, true);
    const s = this.events;
    for (const i in s) {
      const a = s[i];
      a && a.destroy();
    }
  }
  getTargets() {
    const t = this.props.target;
    return t ? [t] : [];
  }
  /**
   * Get the able used in MoveableManager.
   * @method Moveable#getAble
   * @param - able name
   */
  getAble(t) {
    const s = this.props.ables || [];
    return yt(s, (r) => r.name === t);
  }
  getContainer() {
    const { parentMoveable: t, wrapperMoveable: s, container: r } = this.props;
    return r || s && s.getContainer() || t && t.getContainer() || this.controlBox.parentElement;
  }
  /**
   * Returns the element of the control box.
   * @method Moveable#getControlBoxElement
   */
  getControlBoxElement() {
    return this.controlBox;
  }
  /**
   * Target element to be dragged in moveable
   * @method Moveable#getDragElement
   */
  getDragElement() {
    return this._dragTarget;
  }
  /**
   * Check if the target is an element included in the moveable.
   * @method Moveable#isMoveableElement
   * @param - the target
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * window.addEventListener("click", e => {
   *     if (!moveable.isMoveableElement(e.target)) {
   *         moveable.target = e.target;
   *     }
   * });
   */
  isMoveableElement(t) {
    var s;
    return t && (((s = t.getAttribute) == null ? void 0 : s.call(t, "class")) || "").indexOf(Ws) > -1;
  }
  /**
   * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)
   * @method Moveable#dragStart
   * @param - external `MouseEvent`or `TouchEvent`
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (!moveable.isMoveableElement(e.target)) {
   *          moveable.dragStart(e);
   *     }
   * });
   */
  dragStart(t, s = t.target) {
    const r = this.targetGesto, o = this.controlGesto;
    return r && cr(this)({ inputEvent: t }, s) ? r.isFlag() || r.triggerDragStart(t) : o && this.isMoveableElement(s) && (o.isFlag() || o.triggerDragStart(t)), this;
  }
  /**
   * Hit test an element or rect on a moveable target.
   * (100% = 100)
   * @method Moveable#hitTest
   * @param - element or rect to test
   * @return - Get hit test rate (rate > 0 is hitted)
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (moveable.hitTest(e.target) > 0) {
   *          console.log("hiited");
   *     }
   * });
   */
  hitTest(t) {
    const { target: s, pos1: r, pos2: o, pos3: i, pos4: a, targetClientRect: c } = this.state;
    if (!s)
      return 0;
    let l;
    if (le(t)) {
      const S = t.getBoundingClientRect();
      l = {
        left: S.left,
        top: S.top,
        width: S.width,
        height: S.height
      };
    } else
      l = { width: 0, height: 0, ...t };
    const {
      left: u,
      top: f,
      width: h,
      height: d
    } = l, p = fs([r, o, a, i], c), g = Xa(p, [
      [u, f],
      [u + h, f],
      [u + h, f + d],
      [u, f + d]
    ]), m = We(p);
    return !g || !m ? 0 : Math.min(100, g / m * 100);
  }
  /**
   * Whether the coordinates are inside Moveable
   * @method Moveable#isInside
   * @param - x coordinate
   * @param - y coordinate
   * @return - True if the coordinate is in moveable or false
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (moveable.isInside(e.clientX, e.clientY)) {
   *          console.log("inside");
   *     }
   * });
   */
  isInside(t, s) {
    const { target: r, pos1: o, pos2: i, pos3: a, pos4: c, targetClientRect: l } = this.state;
    return r ? Tn(
      [t, s],
      fs([o, i, c, a], l)
    ) : false;
  }
  /**
   * If the width, height, left, and top of all elements change, update the shape of the moveable.
   * @method Moveable#updateRect
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * window.addEventListener("resize", e => {
   *     moveable.updateRect();
   * });
   */
  updateRect(t, s, r = true) {
    const o = this.props, i = !o.parentPosition && !o.wrapperMoveable;
    i && _e(true);
    const a = o.parentMoveable, l = this.state.target || o.target, u = this.getContainer(), f = a ? a._rootContainer : this._rootContainer, h = Rs(
      this.controlBox,
      l,
      u,
      u,
      f || u,
      this._getRequestStyles()
    );
    if (!l && this._hasFirstTarget && o.persistData) {
      const d = Ur(o.persistData);
      for (const p in d)
        h[p] = d[p];
    }
    i && _e(), this.updateState(h, a ? false : r);
  }
  /**
   * Check if the moveable state is being dragged.
   * @method Moveable#isDragging
   * @param - If you want to check if able is dragging, specify ableName.
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * // false
   * console.log(moveable.isDragging());
   *
   * moveable.on("drag", () => {
   *   // true
   *   console.log(moveable.isDragging());
   * });
   */
  isDragging(t) {
    var o, i;
    const s = this.targetGesto, r = this.controlGesto;
    return s != null && s.isFlag() ? t ? !!((o = s.getEventData()[t]) != null && o.isEventStart) : true : r != null && r.isFlag() ? t ? !!((i = r.getEventData()[t]) != null && i.isEventStart) : true : false;
  }
  /**
   * If the width, height, left, and top of the only target change, update the shape of the moveable.
   * Use `.updateRect()` method
   * @method Moveable#updateTarget
   * @deprecated
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * moveable.updateTarget();
   */
  updateTarget(t) {
    this.updateRect(t, true);
  }
  /**
   * You can get the vertex information, position and offset size information of the target based on the container.
   * @method Moveable#getRect
   * @return - The Rect Info
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * const rectInfo = moveable.getRect();
   */
  getRect() {
    const t = this.state, s = Bt(this.state), [r, o, i, a] = s, c = Ot(s), { width: l, height: u } = t, { width: f, height: h, left: d, top: p } = c, g = [t.left, t.top], m = tt(g, t.origin), S = tt(g, t.beforeOrigin), v = t.transformOrigin;
    return {
      width: f,
      height: h,
      left: d,
      top: p,
      pos1: r,
      pos2: o,
      pos3: i,
      pos4: a,
      offsetWidth: l,
      offsetHeight: u,
      beforeOrigin: S,
      origin: m,
      transformOrigin: v,
      rotation: this.getRotation()
    };
  }
  /**
   * Get a manager that manages the moveable's state and props.
   * @method Moveable#getManager
   * @return - The Rect Info
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * const manager = moveable.getManager(); // real moveable class instance
   */
  getManager() {
    return this;
  }
  /**
   * You can stop the dragging currently in progress through a method from outside.
   * @method Moveable#stopDrag
   * @return - The Rect Info
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * moveable.stopDrag();
   */
  stopDrag(t) {
    if (!t || t === "target") {
      const s = this.targetGesto;
      (s == null ? void 0 : s.isIdle()) === false && ws(this, false), s == null || s.stop();
    }
    if (!t || t === "control") {
      const s = this.controlGesto;
      (s == null ? void 0 : s.isIdle()) === false && ws(this, true), s == null || s.stop();
    }
  }
  getRotation() {
    const { pos1: t, pos2: s, direction: r } = this.state;
    return tu(t, s, r);
  }
  /**
   * Request able through a method rather than an event.
   * At the moment of execution, requestStart is executed,
   * and then request and requestEnd can be executed through Requester.
   * @method Moveable#request
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}
   * @param - ableName
   * @param - request to be able params.
   * @param - If isInstant is true, request and requestEnd are executed immediately.
   * @return - Able Requester. If there is no request in able, nothing will work.
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("draggable", { deltaX: 10, deltaY: 10 }, true);
   *
   * // Start move
   * const requester = moveable.request("draggable");
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.requestEnd();
   */
  request(t, s = {}, r) {
    const o = this, i = o.props, a = i.parentMoveable || i.wrapperMoveable || o, c = a.props.ables, l = i.groupable, u = yt(c, (S) => S.name === t);
    if (this.isDragging() || !u || !u.request)
      return {
        request() {
          return this;
        },
        requestEnd() {
          return this;
        }
      };
    const f = u.request(o), h = r || s.isInstant, d = f.isControl ? "controlAbles" : "targetAbles", p = `${l ? "Group" : ""}${f.isControl ? "Control" : ""}`, g = [...a[d]], m = {
      request(S) {
        return qe(
          o,
          g,
          ["drag"],
          p,
          "",
          {
            ...f.request(S),
            requestAble: t,
            isRequest: true
          },
          h
        ), m;
      },
      requestEnd() {
        return qe(
          o,
          g,
          ["drag"],
          p,
          "End",
          {
            ...f.requestEnd(),
            requestAble: t,
            isRequest: true
          },
          h
        ), m;
      }
    };
    return qe(
      o,
      g,
      ["drag"],
      p,
      "Start",
      {
        ...f.requestStart(s),
        requestAble: t,
        isRequest: true
      },
      h
    ), h ? m.request(s).requestEnd() : m;
  }
  /**
   * moveable is the top level that manages targets
   * `Single`: MoveableManager instance
   * `Group`: MoveableGroup instance
   * `IndividualGroup`: MoveableIndividaulGroup instance
   * Returns leaf target MoveableManagers.
   */
  getMoveables() {
    return [this];
  }
  /**
   * Remove the Moveable object and the events.
   * @method Moveable#destroy
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * moveable.destroy();
   */
  destroy() {
    this.componentWillUnmount();
  }
  updateRenderPoses() {
    const t = this.getState(), s = this.props, r = s.padding, {
      originalBeforeOrigin: o,
      transformOrigin: i,
      allMatrix: a,
      is3d: c,
      pos1: l,
      pos2: u,
      pos3: f,
      pos4: h,
      left: d,
      top: p,
      isPersisted: g
    } = t, m = s.zoom || 1;
    if (!r && m <= 1) {
      t.renderPoses = [l, u, f, h], t.renderLines = [
        [l, u],
        [u, h],
        [h, f],
        [f, l]
      ];
      return;
    }
    const { left: S, top: v, bottom: x, right: C } = Ii(r || {}), E = c ? 4 : 3;
    let D = [];
    g ? D = i : this.controlBox && s.groupable ? D = o : D = tt(o, [d, p]);
    const T = Rn(
      E,
      he(
        D.map((P) => -P),
        E
      ),
      a,
      he(i, E)
    ), w = Pt(T, l, [-S, -v], E), z = Pt(T, u, [C, -v], E), M = Pt(T, f, [-S, x], E), R = Pt(T, h, [C, x], E);
    t.renderPoses = [w, z, M, R], t.renderLines = [
      [w, z],
      [z, R],
      [R, M],
      [M, w]
    ];
    {
      const P = m / 2;
      t.renderLines = [
        [
          Pt(T, l, [-S - P, -v], E),
          Pt(T, u, [C + P, -v], E)
        ],
        [
          Pt(T, u, [C, -v - P], E),
          Pt(T, h, [C, x + P], E)
        ],
        [
          Pt(T, h, [C + P, x], E),
          Pt(T, f, [-S - P, x], E)
        ],
        [
          Pt(T, f, [-S, x + P], E),
          Pt(T, l, [-S, -v - P], E)
        ]
      ];
    }
  }
  checkUpdate() {
    this._isPropTargetChanged = false;
    const { target: t, container: s, parentMoveable: r } = this.props, { target: o, container: i } = this.state;
    if (!o && !t)
      return;
    this.updateAbles();
    const a = !Ms(o, t);
    if (!(a || !Ms(i, s)))
      return;
    const l = s || this.controlBox;
    l && this.unsetAbles(), this.updateState({ target: t, container: s }), !r && l && this.updateRect("End", false, false), this._isPropTargetChanged = a;
  }
  waitToChangeTarget() {
    return new Promise(() => {
    });
  }
  triggerEvent(t, s) {
    const r = this.props;
    if (this._emitter.trigger(t, s), r.parentMoveable && s.isRequest && !s.isRequestChild)
      return r.parentMoveable.triggerEvent(t, s, true);
    const o = r[t];
    return o && o(s);
  }
  useCSS(t, s) {
    const r = this.props.customStyledMap, o = t + s;
    return r[o] || (r[o] = Hi(t, s)), r[o];
  }
  getState() {
    var i;
    const t = this.props;
    (t.target || (i = t.targets) != null && i.length) && (this._hasFirstTarget = true);
    const s = this.controlBox, r = t.persistData, o = t.firstRenderState;
    if (o && !s)
      return o;
    if (!this._hasFirstTarget && r) {
      const a = Ur(r);
      if (a)
        return this.updateState(a, false), this.state;
    }
    return this.state.isPersisted = false, this.state;
  }
  updateSelectors() {
  }
  unsetAbles() {
    this.targetAbles.forEach((t) => {
      t.unset && t.unset(this);
    });
  }
  updateAbles(t = this.props.ables, s = "") {
    const o = this.props.triggerAblesSimultaneously, i = this.getEnabledAbles(t), a = `drag${s}Start`, c = `pinch${s}Start`, l = `drag${s}ControlStart`, u = gn(
      i,
      [a, c],
      o
    ), f = gn(
      i,
      [l],
      o
    );
    this.enabledAbles = i, this.targetAbles = u, this.controlAbles = f;
  }
  updateState(t, s) {
    if (s) {
      if (this.isUnmounted)
        return;
      this.setState(t);
    } else {
      const r = this.state;
      for (const o in t)
        r[o] = t[o];
    }
  }
  getEnabledAbles(t = this.props.ables) {
    const s = this.props;
    return t.filter(
      (r) => r && (r.always && s[r.name] !== false || s[r.name])
    );
  }
  renderAbles() {
    const s = this.props.triggerAblesSimultaneously, r = {
      createElement: import_react.createElement
    };
    return this.renderState = {}, Zl(
      zi(
        gn(
          this.getEnabledAbles(),
          ["render"],
          s
        ).map(({ render: o }) => o(this, r) || [])
      ).filter((o) => o),
      ({ key: o }) => o
    ).map((o) => o[0]);
  }
  updateCheckInput() {
    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);
  }
  _getRequestStyles() {
    return this.getEnabledAbles().reduce(
      (s, r) => {
        var i;
        const o = ((i = r.requestStyle) == null ? void 0 : i.call(r)) ?? [];
        return [...s, ...o];
      },
      [...this.props.requestStyles || []]
    );
  }
  _updateObserver(t) {
    this._updateResizeObserver(t), this._updateMutationObserver(t);
  }
  _updateEvents() {
    const t = this.targetAbles.length, s = this.controlAbles.length, r = this._dragTarget;
    (!t && this.targetGesto || this._isTargetChanged(true)) && (we(this, false), this.updateState({ gestos: {} })), s || we(this, true), r && t && !this.targetGesto && (this.targetGesto = Li(this, r, "")), !this.controlGesto && s && (this.controlGesto = Wi(this, "Control"));
  }
  _updateTargets() {
    const t = this.props;
    this._prevPropTarget = this._propTarget, this._prevDragTarget = this._dragTarget, this._prevOriginalDragTarget = this._originalDragTarget, this._prevDragArea = t.dragArea, this._propTarget = t.target, this._originalDragTarget = t.dragTarget || t.target, this._dragTarget = Ht(this._originalDragTarget, true);
  }
  _renderLines() {
    const t = this.props, {
      zoom: s,
      hideDefaultLines: r,
      hideChildMoveableDefaultLines: o,
      parentMoveable: i
    } = t;
    if (r || i && o)
      return [];
    const a = this.getState(), c = {};
    return a.renderLines.map((l, u) => Ze(
      c,
      "",
      l[0],
      l[1],
      s,
      `render-line-${u}`
    ));
  }
  _isTargetChanged(t) {
    const s = this.props, r = s.dragTarget || s.target, o = this._prevOriginalDragTarget, i = this._prevDragArea, a = s.dragArea;
    return !a && o !== r || (t || a) && i !== a || this._prevPropTarget != this._propTarget;
  }
  _updateNativeEvents() {
    const s = this.props.dragArea ? this.areaElement : this.state.target, r = this.events, o = Be(r);
    if (this._isTargetChanged())
      for (const a in r) {
        const c = r[a];
        c && c.destroy(), r[a] = null;
      }
    if (!s)
      return;
    const i = this.enabledAbles;
    o.forEach((a) => {
      const c = gn(i, [a]), l = c.length > 0;
      let u = r[a];
      if (!l) {
        u && (u.destroy(), r[a] = null);
        return;
      }
      u || (u = new zu(s, this, a), r[a] = u), u.setAbles(c);
    });
  }
  _checkUpdateRootContainer() {
    const t = this.props.rootContainer;
    !this._rootContainer && t && (this._rootContainer = Ht(t, true));
  }
  _checkUpdateViewContainer() {
    const t = this.props.viewContainer;
    !this._viewContainer && t && (this._viewContainer = Ht(t, true)), this._viewContainer && this._changeAbleViewClassNames([
      ...this._getAbleViewClassNames(),
      this.isDragging() ? au : ""
    ]);
  }
  _changeAbleViewClassNames(t) {
    const s = this._viewContainer, r = yi(t.filter(Boolean), (c) => c).map(
      ([c]) => c
    ), o = this._viewClassNames, { removed: i, added: a } = wn(o, r);
    i.forEach((c) => {
      po(s, o[c]);
    }), a.forEach((c) => {
      qt(s, r[c]);
    }), this._viewClassNames = r;
  }
  _getAbleViewClassNames() {
    return (this.getEnabledAbles().map((t) => {
      var s;
      return ((s = t.viewClassName) == null ? void 0 : s.call(t, this)) || "";
    }).join(" ") + ` ${this._getAbleClassName("-view")}`).split(/\s+/g);
  }
  _getAbleClassName(t = "") {
    const s = this.getEnabledAbles(), r = this.targetGesto, o = this.controlGesto, i = r != null && r.isFlag() ? r.getEventData() : {}, a = o != null && o.isFlag() ? o.getEventData() : {};
    return s.map((c) => {
      var f, h, d;
      const l = c.name;
      let u = ((f = c.className) == null ? void 0 : f.call(c, this)) || "";
      return ((h = i[l]) != null && h.isEventStart || (d = a[l]) != null && d.isEventStart) && (u += ` ${H(`${l}${t}-dragging`)}`), u.trim();
    }).filter(Boolean).join(" ");
  }
  _updateResizeObserver(t) {
    var a;
    const s = this.props, r = s.target, o = Mt(this.getControlBoxElement());
    if (!o.ResizeObserver || !r || !s.useResizeObserver) {
      (a = this._reiszeObserver) == null || a.disconnect();
      return;
    }
    if (t.target === r && this._reiszeObserver)
      return;
    const i = new o.ResizeObserver(this.checkUpdateRect);
    i.observe(r, {
      box: "border-box"
    }), this._reiszeObserver = i;
  }
  _updateMutationObserver(t) {
    var a;
    const s = this.props, r = s.target, o = Mt(this.getControlBoxElement());
    if (!o.MutationObserver || !r || !s.useMutationObserver) {
      (a = this._mutationObserver) == null || a.disconnect();
      return;
    }
    if (t.target === r && this._mutationObserver)
      return;
    const i = new o.MutationObserver((c) => {
      for (const l of c)
        l.type === "attributes" && l.attributeName === "style" && this.checkUpdateRect();
    });
    i.observe(r, {
      attributes: true
    }), this._mutationObserver = i;
  }
};
b(pe, "defaultProps", {
  dragTargetSelf: false,
  target: null,
  dragTarget: null,
  container: null,
  rootContainer: null,
  origin: true,
  parentMoveable: null,
  wrapperMoveable: null,
  isWrapperMounted: false,
  parentPosition: null,
  warpSelf: false,
  svgOrigin: "",
  dragContainer: null,
  useResizeObserver: false,
  useMutationObserver: false,
  preventDefault: true,
  preventRightClick: true,
  preventWheelClick: true,
  linePadding: 0,
  controlPadding: 0,
  ables: [],
  pinchThreshold: 20,
  dragArea: false,
  passDragArea: false,
  transformOrigin: "",
  className: "",
  zoom: 1,
  triggerAblesSimultaneously: false,
  padding: {},
  pinchOutside: true,
  checkInput: false,
  dragFocusedInput: false,
  groupable: false,
  hideDefaultLines: false,
  cspNonce: "",
  translateZ: 0,
  cssStyled: null,
  customStyledMap: {},
  props: {},
  stopPropagation: false,
  preventClickDefault: false,
  preventClickEventOnDrag: true,
  flushSync: xi,
  firstRenderState: null,
  persistData: null,
  viewContainer: null,
  requestStyles: [],
  useAccuratePosition: false
});
var lr = {
  name: "groupable",
  props: [
    "defaultGroupRotate",
    "useDefaultGroupRotate",
    "defaultGroupOrigin",
    "groupable",
    "groupableProps",
    "targetGroups",
    "hideChildMoveableDefaultLines"
  ],
  events: [],
  render(e, n) {
    var h;
    const t = e.props;
    let s = t.targets || [];
    const { left: r, top: o, isPersisted: i } = e.getState(), a = t.zoom || 1, c = e.renderGroupRects;
    let l = ((h = t.persistData) == null ? void 0 : h.children) || [];
    i ? s = l.map(() => null) : l = [];
    const u = Me(
      e,
      "parentPosition",
      [r, o],
      (d) => d.join(",")
    ), f = Me(
      e,
      "requestStyles",
      e.getRequestChildStyles(),
      (d) => d.join(",")
    );
    return e.moveables = e.moveables.slice(0, s.length), [
      ...s.map((d, p) => (0, import_jsx_runtime.jsx)(
        pe,
        {
          ref: Fo(e, "moveables", p),
          target: d,
          origin: false,
          requestStyles: f,
          cssStyled: t.cssStyled,
          customStyledMap: t.customStyledMap,
          useResizeObserver: t.useResizeObserver,
          useMutationObserver: t.useMutationObserver,
          hideChildMoveableDefaultLines: t.hideChildMoveableDefaultLines,
          parentMoveable: e,
          parentPosition: [r, o],
          persistData: l[p],
          zoom: a
        },
        "moveable" + p
      )),
      ...zi(
        c.map(({ pos1: d, pos2: p, pos3: g, pos4: m }, S) => {
          const v = [d, p, g, m];
          return [
            [0, 1],
            [1, 3],
            [3, 2],
            [2, 0]
          ].map(([x, C], E) => Ze(
            n,
            "",
            V(v[x], u),
            V(v[C], u),
            a,
            `group-rect-${S}-${E}`
          ));
        })
      )
    ];
  }
};
var Ou = tn("clickable", {
  props: ["clickable"],
  events: ["click", "clickGroup"],
  always: true,
  dragRelation: "weak",
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  dragStart() {
  },
  dragControlStart() {
  },
  dragGroupStart(e, n) {
    n.datas.inputTarget = n.inputEvent && n.inputEvent.target;
  },
  dragEnd(e, n) {
    const t = e.props.target, s = n.inputEvent, r = n.inputTarget, i = !e.isMoveableElement(r) && e.controlBox.contains(r);
    if (!s || !r || n.isDrag || e.isMoveableElement(r) || i)
      return;
    const a = t.contains(r);
    F(
      e,
      "onClick",
      K(e, n, {
        isDouble: n.isDouble,
        inputTarget: r,
        isTarget: t === r,
        moveableTarget: e.props.target,
        containsTarget: a
      })
    );
  },
  dragGroupEnd(e, n) {
    const t = n.inputEvent, s = n.inputTarget;
    if (!t || !s || n.isDrag || e.isMoveableElement(s) || // External event duplicate target or dragAreaElement
    n.datas.inputTarget === s)
      return;
    const r = e.props.targets;
    let o = r.indexOf(s);
    const i = o > -1;
    let a = false;
    o === -1 && (o = Ut(
      r,
      (c) => c.contains(s)
    ), a = o > -1), F(
      e,
      "onClickGroup",
      K(e, n, {
        isDouble: n.isDouble,
        targets: r,
        inputTarget: s,
        targetIndex: o,
        isTarget: i,
        containsTarget: a,
        moveableTarget: r[o]
      })
    );
  },
  dragControlEnd(e, n) {
    this.dragEnd(e, n);
  },
  dragGroupControlEnd(e, n) {
    this.dragEnd(e, n);
  }
});
function ve(e) {
  let n = e.originalDatas.draggable;
  return n || (e.originalDatas.draggable = {}, n = e.originalDatas.draggable), { ...e, datas: n };
}
var Iu = tn("edgeDraggable", {
  css: [
    `.edge.edgeDraggable.line {
cursor: move;
}`
  ],
  render(e, n) {
    const t = e.props, s = t.edgeDraggable;
    return s ? Jo(
      n,
      "edgeDraggable",
      s,
      e.getState().renderPoses,
      t.zoom
    ) : [];
  },
  dragCondition(e, n) {
    var r;
    const t = e.props, s = (r = n.inputEvent) == null ? void 0 : r.target;
    return !t.edgeDraggable || !s ? false : !t.draggable && dt(s, H("direction")) && dt(s, H("edge")) && dt(s, H("edgeDraggable"));
  },
  dragStart(e, n) {
    return vt.dragStart(e, ve(n));
  },
  drag(e, n) {
    return vt.drag(e, ve(n));
  },
  dragEnd(e, n) {
    return vt.dragEnd(e, ve(n));
  },
  dragGroupCondition(e, n) {
    var r;
    const t = e.props, s = (r = n.inputEvent) == null ? void 0 : r.target;
    return !t.edgeDraggable || !s ? false : !t.draggable && dt(s, H("direction")) && dt(s, H("line"));
  },
  dragGroupStart(e, n) {
    return vt.dragGroupStart(e, ve(n));
  },
  dragGroup(e, n) {
    return vt.dragGroup(e, ve(n));
  },
  dragGroupEnd(e, n) {
    return vt.dragGroupEnd(e, ve(n));
  },
  unset(e) {
    return vt.unset(e);
  }
});
var Vi = {
  name: "individualGroupable",
  props: ["individualGroupable", "individualGroupableProps"],
  events: []
};
var Bu = [
  Yi,
  Gi,
  $l,
  nu,
  vt,
  Iu,
  Es,
  su,
  ou,
  vl,
  uu,
  fu,
  cu,
  bu,
  Du,
  Ru,
  lr,
  Vi,
  Ou,
  Ai,
  Fi
];
function Zr([e, n, t], s) {
  return (e * s[0] + n * s[1] + t) / Math.sqrt(e * e + n * n);
}
function xn([e, n], t) {
  return -e * t[0] - n * t[1];
}
function Kr(e, n) {
  return Math.max(
    ...e.map(([t, s, r, o]) => Math.max(t[n], s[n], r[n], o[n]))
  );
}
function Jr(e, n) {
  return Math.min(
    ...e.map(([t, s, r, o]) => Math.min(t[n], s[n], r[n], o[n]))
  );
}
function Au(e, n) {
  let t = [0, 0], s = [0, 0], r = [0, 0], o = [0, 0], i = 0, a = 0;
  if (!e.length)
    return {
      pos1: t,
      pos2: s,
      pos3: r,
      pos4: o,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: i,
      height: a,
      rotation: n
    };
  const c = U(n, bt);
  if (c % 90) {
    const d = c / 180 * Math.PI, p = Math.tan(d), g = -1 / p, m = [ms, Cr], S = [
      [0, 0],
      [0, 0]
    ], v = [ms, Cr], x = [
      [0, 0],
      [0, 0]
    ];
    e.forEach((P) => {
      P.forEach((y) => {
        const k = Zr([-p, 1, 0], y), _ = Zr([-g, 1, 0], y);
        m[0] > k && (S[0] = y, m[0] = k), m[1] < k && (S[1] = y, m[1] = k), v[0] > _ && (x[0] = y, v[0] = _), v[1] < _ && (x[1] = y, v[1] = _);
      });
    });
    const [C, E] = S, [D, T] = x, w = [-p, 1, xn([-p, 1], C)], z = [-p, 1, xn([-p, 1], E)], M = [-g, 1, xn([-g, 1], D)], R = [-g, 1, xn([-g, 1], T)];
    [t, s, r, o] = [
      [w, M],
      [w, R],
      [z, M],
      [z, R]
    ].map(
      ([P, y]) => As(P, y)[0]
    ), i = v[1] - v[0], a = m[1] - m[0];
  } else {
    const d = Jr(e, 0), p = Jr(e, 1), g = Kr(e, 0), m = Kr(e, 1);
    t = [d, p], s = [g, p], r = [d, m], o = [g, m], i = g - d, a = m - p, c % 180 && ([t, s, r, o] = [r, t, o, s], i = m - p, a = g - d);
  }
  c % 360 > 180 && ([t, s, r, o] = [o, r, s, t]);
  const { minX: l, minY: u, maxX: f, maxY: h } = ue([t, s, r, o]);
  return {
    pos1: t,
    pos2: s,
    pos3: r,
    pos4: o,
    width: i,
    height: a,
    minX: l,
    minY: u,
    maxX: f,
    maxY: h,
    rotation: n
  };
}
function qi(e, n) {
  const t = n.map((s) => {
    if (ct(s)) {
      const r = qi(e, s), o = r.length;
      return o > 1 ? r : o === 1 ? r[0] : null;
    } else {
      const r = yt(
        e,
        ({ manager: o }) => o.props.target === s
      );
      return r ? (r.finded = true, r.manager) : null;
    }
  }).filter(Boolean);
  return t.length === 1 && ct(t[0]) ? t[0] : t;
}
var ji = class extends pe {
  constructor() {
    super(...arguments);
    b(this, "differ", new vo());
    b(this, "moveables", []);
    b(this, "transformOrigin", "50% 50%");
    b(this, "renderGroupRects", []);
    b(this, "_targetGroups", []);
    b(this, "_hasFirstTargets", false);
  }
  componentDidMount() {
    super.componentDidMount();
  }
  checkUpdate() {
    this._isPropTargetChanged = false, this.updateAbles();
  }
  getTargets() {
    return this.props.targets;
  }
  updateRect(t, s, r = true) {
    var W;
    const o = this.state;
    if (!this.controlBox || o.isPersisted)
      return;
    _e(true), this.moveables.forEach((Z) => {
      Z.updateRect(t, false, false);
    });
    const i = this.props, a = this.moveables, c = o.target || i.target, l = a.map((Z) => ({
      finded: false,
      manager: Z
    })), u = this.props.targetGroups || [], f = qi(l, u), h = i.useDefaultGroupRotate;
    f.push(
      ...l.filter(({ finded: Z }) => !Z).map(({ manager: Z }) => Z)
    );
    const d = [], p = !s || t !== "" && i.updateGroup;
    let g = i.defaultGroupRotate || 0;
    if (!this._hasFirstTargets) {
      const Z = (W = i.persistData) == null ? void 0 : W.rotation;
      Z != null && (g = Z);
    }
    function m(Z, $, L) {
      const j = Z.map((ut) => {
        if (ct(ut)) {
          const St = m(ut, $), xe = [St.pos1, St.pos2, St.pos3, St.pos4];
          return d.push(St), { poses: xe, rotation: St.rotation };
        } else
          return {
            poses: Bt(ut.state),
            rotation: ut.getRotation()
          };
      }), ot = j.map(({ rotation: ut }) => ut);
      let pt = 0;
      const lt = ot[0], nt = ot.every((ut) => Math.abs(lt - ut) < 0.1);
      p ? pt = !h && nt ? lt : g : pt = !h && !L && nt ? lt : $;
      const Ft = j.map(({ poses: ut }) => ut);
      return Au(Ft, pt);
    }
    const S = m(
      f,
      this.rotation,
      true
    );
    p && (this.rotation = S.rotation, this.transformOrigin = i.defaultGroupOrigin || "50% 50%", this.scale = [1, 1]), this._targetGroups = u, this.renderGroupRects = d;
    const v = this.transformOrigin, x = this.rotation, C = this.scale, { width: E, height: D, minX: T, minY: w } = S, z = eu(
      [
        [0, 0],
        [E, 0],
        [0, D],
        [E, D]
      ],
      or(v, E, D),
      this.rotation / 180 * Math.PI
    ), { minX: M, minY: R } = ue(z.result), P = ` rotate(${x}deg) scale(${Et(C[0])}, ${Et(C[1])})`, y = `translate(${-M}px, ${-R}px)${P}`;
    this.controlBox.style.transform = `translate3d(${T}px, ${w}px, ${this.props.translateZ || 0})`, c.style.cssText += `left:0px;top:0px;transform-origin:${v};width:${E}px;height:${D}px;transform: ${y}`, o.width = E, o.height = D;
    const k = this.getContainer(), _ = Rs(
      this.controlBox,
      c,
      this.controlBox,
      this.getContainer(),
      this._rootContainer || k,
      []
    ), O = [_.left, _.top], [B, A, N, G] = Bt(_), Y = ue([B, A, N, G]), q = [Y.minX, Y.minY], X = Et(C[0] * C[1]);
    _.pos1 = V(B, q), _.pos2 = V(A, q), _.pos3 = V(N, q), _.pos4 = V(G, q), _.left = T - _.left + q[0], _.top = w - _.top + q[1], _.origin = V(tt(O, _.origin), q), _.beforeOrigin = V(tt(O, _.beforeOrigin), q), _.originalBeforeOrigin = tt(O, _.originalBeforeOrigin), _.transformOrigin = V(tt(O, _.transformOrigin), q), c.style.transform = `translate(${-M - q[0]}px, ${-R - q[1]}px)` + P, _e(), this.updateState(
      {
        ..._,
        posDelta: q,
        direction: X,
        beforeDirection: X
      },
      r
    );
  }
  getRect() {
    return {
      ...super.getRect(),
      children: this.moveables.map((t) => t.getRect())
    };
  }
  triggerEvent(t, s, r) {
    if (r || t.indexOf("Group") > -1)
      return super.triggerEvent(t, s);
    this._emitter.trigger(t, s);
  }
  getRequestChildStyles() {
    return this.getEnabledAbles().reduce((s, r) => {
      var i;
      const o = ((i = r.requestChildStyle) == null ? void 0 : i.call(r)) ?? [];
      return [...s, ...o];
    }, []);
  }
  getMoveables() {
    return [...this.moveables];
  }
  updateAbles() {
    super.updateAbles([...this.props.ables, lr], "Group");
  }
  _updateTargets() {
    super._updateTargets(), this._originalDragTarget = this.props.dragTarget || this.areaElement, this._dragTarget = Ht(this._originalDragTarget, true);
  }
  _updateEvents() {
    const t = this.state, s = this.props, r = this._prevDragTarget, o = s.dragTarget || this.areaElement, i = s.targets, { added: a, changed: c, removed: l } = this.differ.update(i), u = a.length || l.length;
    (u || this._prevOriginalDragTarget !== this._originalDragTarget) && (we(this, false), we(this, true), this.updateState({ gestos: {} })), r !== o && (t.target = null), t.target || (t.target = this.areaElement, this.controlBox.style.display = "block"), t.target && (this.targetGesto || (this.targetGesto = Li(this, this._dragTarget, "Group")), this.controlGesto || (this.controlGesto = Wi(this, "GroupControl")));
    const f = !Ms(t.container, s.container);
    f && (t.container = s.container), (f || u || this.transformOrigin !== (s.defaultGroupOrigin || "50% 50%") || c.length || i.length && !Oi(this._targetGroups, s.targetGroups || [])) && (this.updateRect(), this._hasFirstTargets = true), this._isPropTargetChanged = !!u;
  }
  _updateObserver() {
  }
};
b(ji, "defaultProps", {
  ...pe.defaultProps,
  transformOrigin: ["50%", "50%"],
  groupable: true,
  dragArea: true,
  keepRatio: true,
  targets: [],
  defaultGroupRotate: 0,
  defaultGroupOrigin: "50% 50%"
});
var Gu = class extends pe {
  constructor() {
    super(...arguments);
    b(this, "moveables", []);
  }
  render() {
    const t = this.props, { cspNonce: s, cssStyled: r, persistData: o } = t;
    let i = t.targets || [];
    const a = i.length, c = this.isUnmounted || !a;
    let l = (o == null ? void 0 : o.children) ?? [];
    return c && !a && l.length ? i = l.map(() => null) : c || (l = []), (0, import_jsx_runtime.jsx)(
      r,
      {
        cspNonce: s,
        ref: _t(this, "controlBox"),
        className: H("control-box"),
        children: i.map((u, f) => {
          var d;
          const h = ((d = t.individualGroupableProps) == null ? void 0 : d.call(t, u, f)) ?? {};
          return (0, import_jsx_runtime.jsx)(
            pe,
            {
              ref: Fo(this, "moveables", f),
              ...t,
              ...h,
              target: u,
              wrapperMoveable: this,
              isWrapperMounted: this.isMoveableMounted,
              persistData: l[f]
            },
            "moveable" + f
          );
        })
      }
    );
  }
  componentDidMount() {
  }
  componentDidUpdate() {
  }
  getTargets() {
    return this.props.targets;
  }
  updateRect(t, s, r = true) {
    _e(true), this.moveables.forEach((o) => {
      o.updateRect(t, s, r);
    }), _e();
  }
  getRect() {
    return {
      ...super.getRect(),
      children: this.moveables.map((t) => t.getRect())
    };
  }
  request(t, s = {}, r) {
    const o = this.moveables.map(
      (c) => c.request(t, { ...s, isInstant: false }, false)
    ), i = r || s.isInstant, a = {
      request(c) {
        return o.forEach((l) => l.request(c)), this;
      },
      requestEnd() {
        return o.forEach((c) => c.requestEnd()), this;
      }
    };
    return i ? a.request(s).requestEnd() : a;
  }
  dragStart(t, s = t.target) {
    const r = s, o = yt(this.moveables, (i) => {
      const a = i.getTargets()[0], c = i.getControlBoxElement(), l = i.getDragElement();
      return !a || !l ? false : l === r || l.contains(r) || l !== a && a === r || a.contains(r) || c === r || c.contains(r);
    });
    return o && o.dragStart(t, s), this;
  }
  hitTest() {
    return 0;
  }
  isInside() {
    return false;
  }
  isDragging() {
    return false;
  }
  getDragElement() {
    return null;
  }
  getMoveables() {
    return [...this.moveables];
  }
  updateRenderPoses() {
  }
  checkUpdate() {
  }
  triggerEvent() {
  }
  updateAbles() {
  }
  _updateEvents() {
  }
  _updateObserver() {
  }
};
function Ui(e, n) {
  const t = [];
  return e.forEach((s) => {
    if (s) {
      if (Yt(s)) {
        n[s] && t.push(...n[s]);
        return;
      }
      ct(s) ? t.push(...Ui(s, n)) : t.push(s);
    }
  }), t;
}
function Zi(e, n) {
  const t = [];
  return e.forEach((s) => {
    if (s) {
      if (Yt(s)) {
        n[s] && t.push(...n[s]);
        return;
      }
      ct(s) ? t.push(Zi(s, n)) : t.push(s);
    }
  }), t;
}
function Ki(e, n) {
  return e.length !== n.length || e.some((t, s) => {
    const r = n[s];
    return !t && !r ? false : t != r ? ct(t) && ct(r) ? Ki(t, r) : true : false;
  });
}
function $u(e, n, t) {
  n.forEach((s) => {
    s in e || (e[s] = function(...r) {
      const o = this[t][s](...r);
      return o === this[t] ? this : o;
    });
  });
}
var Cn = class extends ys.PureComponent {
  constructor() {
    super(...arguments);
    b(this, "moveable");
    b(this, "refTargets", []);
    b(this, "selectorMap", {});
    b(this, "_differ", new vo());
    b(this, "_elementTargets", []);
    b(this, "_tmpRefTargets", []);
    b(this, "_tmpSelectorMap", {});
    b(this, "_onChangeTargets", null);
  }
  static makeStyled() {
    const t = {};
    this.getTotalAbles().forEach(({ css: o }) => {
      o && o.forEach((i) => {
        t[i] = true;
      });
    });
    const r = Be(t).join(`
`);
    this.defaultStyled = Hi("div", Lo(Ws, Cc + r));
  }
  static getTotalAbles() {
    return [
      Gi,
      lr,
      Vi,
      Ai,
      ...this.defaultAbles
    ];
  }
  render() {
    const t = this.constructor;
    t.defaultStyled || t.makeStyled();
    const { ables: s, props: r, ...o } = this.props, [i, a] = this._updateRefs(true), c = Ui(i, a);
    let l = c.length > 1;
    const f = [...t.getTotalAbles(), ...s || []], h = {
      ...o,
      ...r || {},
      ables: f,
      cssStyled: t.defaultStyled,
      customStyledMap: t.customStyledMap
    };
    this._elementTargets = c;
    let d = null;
    const p = this.moveable, g = o.persistData;
    if (g != null && g.children && (l = true), o.individualGroupable)
      return (0, import_jsx_runtime.jsx)(
        Gu,
        {
          ref: _t(this, "moveable"),
          ...h,
          target: null,
          targets: c
        },
        "individual-group"
      );
    if (l) {
      const m = Zi(i, a);
      if (p && !p.props.groupable && !p.props.individualGroupable) {
        const S = p.props.target;
        S && c.indexOf(S) > -1 && (d = { ...p.state });
      }
      return (0, import_jsx_runtime.jsx)(
        ji,
        {
          ref: _t(this, "moveable"),
          ...h,
          ...o.groupableProps ?? {},
          target: null,
          targets: c,
          targetGroups: m,
          firstRenderState: d
        },
        "group"
      );
    } else {
      const m = c[0];
      if (p && (p.props.groupable || p.props.individualGroupable)) {
        const S = p.moveables || [], v = yt(
          S,
          (x) => x.props.target === m
        );
        v && (d = { ...v.state });
      }
      return (0, import_jsx_runtime.jsx)(
        pe,
        {
          ref: _t(this, "moveable"),
          ...h,
          target: m,
          firstRenderState: d
        },
        "single"
      );
    }
  }
  componentDidMount() {
    $u(this, wc, "moveable"), this._checkChangeTargets();
  }
  componentDidUpdate() {
    this._checkChangeTargets();
  }
  componentWillUnmount() {
    this.selectorMap = {}, this.refTargets = [];
  }
  /**
   * Get targets set in moveable through target or targets of props.
   * @method Moveable#getTargets
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body, {
   *    target: [targetRef, ".target", document.querySelectorAll(".target")],
   * });
   *
   * console.log(moveable.getTargets());
   */
  getTargets() {
    var t;
    return ((t = this.moveable) == null ? void 0 : t.getTargets()) ?? [];
  }
  /**
   * If the element list corresponding to the selector among the targets is changed, it is updated.
   * @method Moveable#updateSelectors
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body, {
   *    target: ".target",
   * });
   *
   * moveable.updateSelectors();
   */
  updateSelectors() {
    this.selectorMap = {}, this._updateRefs(), this.forceUpdate();
  }
  /**
   * User changes target and waits for target to change.
   * @method Moveable#waitToChangeTarget
   * @story combination-with-other-components--components-selecto
   * @example
   * document.querySelector(".target").addEventListener("mousedown", e => {
   *   moveable.waitToChangeTarget().then(() => {
   *      moveable.dragStart(e, e.currentTarget);
   *   });
   *   moveable.target = e.currentTarget;
   * });
   */
  waitToChangeTarget() {
    let t;
    return this._onChangeTargets = () => {
      this._onChangeTargets = null, t();
    }, new Promise((s) => {
      t = s;
    });
  }
  waitToChangeTargets() {
    return this.waitToChangeTarget();
  }
  getManager() {
    return this.moveable;
  }
  getMoveables() {
    return this.moveable.getMoveables();
  }
  getDragElement() {
    return this.moveable.getDragElement();
  }
  _updateRefs(t) {
    const s = this.refTargets, r = rr(
      this.props.target || this.props.targets
    ), o = typeof document < "u";
    let i = Ki(s, r);
    const a = this.selectorMap, c = {};
    return this.refTargets.forEach(function l(u) {
      Yt(u) ? a[u] ? c[u] = a[u] : o && (i = true, c[u] = [].slice.call(
        document.querySelectorAll(u)
      )) : ct(u) && u.forEach(l);
    }), this._tmpRefTargets = r, this._tmpSelectorMap = c, [r, c, !t && i];
  }
  _checkChangeTargets() {
    var c, l, u;
    this.refTargets = this._tmpRefTargets, this.selectorMap = this._tmpSelectorMap;
    const { added: t, removed: s } = this._differ.update(this._elementTargets);
    (t.length || s.length) && ((l = (c = this.props).onChangeTargets) == null || l.call(c, {
      moveable: this.moveable,
      targets: this._elementTargets
    }), (u = this._onChangeTargets) == null || u.call(this));
    const [o, i, a] = this._updateRefs();
    this.refTargets = o, this.selectorMap = i, a && this.forceUpdate();
  }
};
b(Cn, "defaultAbles", []), b(Cn, "customStyledMap", {}), b(Cn, "defaultStyled", null);
var ku = class extends Cn {
};
b(ku, "defaultAbles", Bu);
var Xu = Ao();
var Yu = Xu.browser.name === "safari";
var Se = "infinite-viewer-";
var Qr = `${Se}wrapper`;
var to = `${Se}scroll-area`;
var Fu = `${Se}scroll-bar`;
var Ji = `${Se}horizontal-scroll-bar`;
var Qi = `${Se}vertical-scroll-bar`;
var eo = `${Se}scroll-thumb`;
var ta = Xs(
  Lo(
    Se,
    `
{
    position: relative;
    overscroll-behavior: none;
}
.wrapper {
    position: absolute;
    width: 100%;
    height: 100%;
    overflow: auto;
    scrollbar-width: none;
    top: 0;
    left: 0;
    will-change: scroll-position;
}
.restrict-wrapper {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
}
.wrapper::-webkit-scrollbar {
    display: none;
}
.scroll-area {
    position:absolute;
    top:0;
    left:0;
    transform-origin: 0 0;
}
.scroll-bar {
    position:absolute;
    width: 10px;
    height: 10px;
    box-sizing: border-box;
    right: 0;
    bottom: 0;
    overflow: hidden;
}
.horizontal-scroll-bar {
    width: calc(100% - 20px);
    right: 10px;
    height: 14px;
}
.vertical-scroll-bar {
    height: calc(100% - 20px);
    bottom: 10px;
    width: 14px;
}
.scroll-thumb {
    position:relative;
    opacity: 0.7;
    background: #333;
    border-radius: 3px;
    left: 0px;
    top: 0px;
    z-index: 10;
    width: 6px;
    height: 6px;
    transition: all ease 0.2s;
    opacity: 0;
}
.scroll-bar:hover .scroll-thumb {
    border-radius: 5px;
    opacity: 1;
}
.horizontal-scroll-bar .scroll-thumb {
    margin: 4px 0px;
    transition-property: opacity, margin, height, border-radius;
}
.vertical-scroll-bar .scroll-thumb {
    margin: 0px 4px;
    transition-property: opacity, margin, width, border-radius;
}
.horizontal-scroll-bar:hover .scroll-thumb {
    height: 10px;
    margin: 2px 0px;
}
.vertical-scroll-bar:hover .scroll-thumb {
    width: 10px;
    margin: 0px 2px;
}
`
  )
);
var xt = {
  margin: 500,
  threshold: 100,
  zoom: 1,
  zoomX: 1,
  zoomY: 1,
  rangeX: [-1 / 0, 1 / 0],
  rangeY: [-1 / 0, 1 / 0],
  rangeOffsetX: [0, 0],
  rangeOffsetY: [0, 0],
  wrapperElement: null,
  scrollAreaElement: null,
  horizontalScrollElement: null,
  verticalScrollElement: null,
  usePinch: false,
  useAutoZoom: false,
  useMouseDrag: false,
  pinchThreshold: 30,
  cspNonce: "",
  maxPinchWheel: 1 / 0,
  wheelScale: 0.01,
  displayHorizontalScroll: true,
  displayVerticalScroll: true,
  useTransform: true,
  useWheelPinch: true,
  zoomRange: [1e-3, 1 / 0],
  wheelPinchKey: "ctrl",
  useWheelScroll: Yu,
  zoomOffsetX: "50%",
  zoomOffsetY: "50%",
  translateZ: 0,
  useGesture: true,
  useResizeObserver: false,
  pinchDirection: "all",
  preventWheelClick: true,
  useBounceScrollBar: false,
  useOverflowScroll: false
};
var no = (e) => 1 - Math.pow(1 - e, 3);
var so = {
  horizontal: {
    pos: "Left",
    coord: "X",
    size: "Width"
  },
  vertical: {
    pos: "Top",
    coord: "Y",
    size: "Height"
  }
};
var ea = ta.className;
var ur = [
  "margin",
  "threshold",
  "zoomOffsetX",
  "zoomOffsetY",
  "zoom",
  "zoomX",
  "zoomY",
  "rangeX",
  "rangeY",
  "rangeOffsetX",
  "rangeOffsetY",
  "usePinch",
  "useMouseDrag",
  "pinchThreshold",
  "maxPinchWheel",
  "wheelScale",
  "displayVerticalScroll",
  "displayHorizontalScroll",
  "translateZ",
  "useAutoZoom",
  "wheelPinchKey",
  "zoomRange",
  "zoomRangeX",
  "zoomRangeY",
  "pinchDirection",
  "useOverflowScroll"
];
var Lu = [
  // ignore target, container,
  ...ur,
  "preventWheelClick",
  "useWheelPinch",
  "useWheelScroll",
  "useGesture",
  "cspNonce",
  "wrapperElement",
  "scrollAreaElement",
  "verticalScrollElement",
  "horizontalScrollElement",
  "useResizeObserver",
  "wheelContainer",
  "useBounceScrollBar"
];
var na = [
  "scroll",
  "abortPinch",
  "dragStart",
  "dragEnd",
  "pinchStart",
  "pinch"
];
var Wu = [
  "getScrollLeft",
  "getScrollTop",
  "getScrollWidth",
  "getScrollHeight",
  "getContainerWidth",
  "getContainerHeight",
  "getViewportWidth",
  "getViewportHeight",
  "getViewportScrollWidth",
  "getViewportScrollHeight",
  "scrollTo",
  "scrollBy",
  "zoomBy",
  "scrollCenter",
  "getContainer",
  "getViewport",
  "getWrapper",
  "setZoom",
  "getRangeX",
  "getRangeY",
  "resize",
  "getZoom",
  "getZoomX",
  "getZoomY",
  "getWheelContainer",
  "setTo",
  "setBy"
];
var Nu = 1e-6;
function Hu(e) {
  const { deltaX: n, deltaY: t, datas: s } = e, r = Date.now(), o = s.speed;
  if (!o) {
    s.speed = [0, 0], s.time = r;
    return;
  }
  const i = r - s.time;
  s.speed = [
    o[0] / 2 + n / i,
    o[1] / 2 + t / i
  ];
}
function sa(e, n) {
  const t = Math.sqrt(e[0] * e[0] + e[1] * e[1]);
  return Math.abs(t / n);
}
function Vu(e, n) {
  const t = sa(e, n);
  return [-e[0] / 2 * t, -e[1] / 2 * t];
}
function Wt(e) {
  return Math.abs(e);
}
function qu(e, n, t, s, r) {
  const o = r || isFinite(t[0]) ? t[0] : Math.min(-1, Math.floor(e / n)) * n - s, i = r || isFinite(t[1]) ? t[1] : Math.max(1, Math.ceil(e / n)) * n + s;
  return [o, i];
}
function ro(e, n) {
  return e ?? n;
}
function oo(e, n, t) {
  const s = t.duration, r = t.easing || ((c) => 1 - Math.pow(1 - c, 3)), o = Date.now();
  let i = o;
  const a = () => {
    const c = Date.now();
    let l = c - o;
    s < l && (l = s);
    const u = r(l / s), f = r((i - o) / s);
    i = c, e(u - f), !(l >= s) && n(a);
  };
  n(a);
}
var io = class extends Ae {
  constructor(t, s, r) {
    super();
    b(this, "isAppend", false);
    b(this, "thumbElement");
    b(this, "barElement");
    b(this, "gesto");
    b(this, "size", 0);
    b(this, "scrollSize", 0);
    b(this, "isHorizontal", false);
    b(this, "_onDragStart", (t2) => {
      const s2 = this.isHorizontal, r2 = t2.inputEvent.target, o2 = t2.datas, i2 = this.thumbElement === r2;
      i2 || setTimeout(() => {
        requestAnimationFrame(() => {
          const a2 = this.thumbElement.getBoundingClientRect(), c2 = a2[s2 ? "left" : "top"], l = a2[s2 ? "width" : "height"], u = c2 + l, f = t2[s2 ? "clientX" : "clientY"];
          if (c2 <= f && f <= u)
            return;
          const h = this.size, d = h * h / this.scrollSize;
          this.scrollBy(c2 < f ? d : -d);
        });
      }, 100), o2.isThumb = i2, t2.inputEvent.stopPropagation(), t2.inputEvent.preventDefault();
    });
    b(this, "_onDrag", (t2) => {
      t2.datas.isThumb && this.scrollBy(this.isHorizontal ? t2.deltaX : t2.deltaY);
    });
    b(this, "_onWheel", (t2) => {
      const s2 = this.isHorizontal ? t2.deltaX : t2.deltaY;
      s2 && t2.preventDefault(), this.trigger("scroll", {
        delta: s2
      });
    });
    this.type = s;
    const o = s === "horizontal", i = Rt(t);
    let a, c = r;
    r ? a = r.querySelector(`.${eo}`) : (c = i.createElement("div"), a = i.createElement("div"), c.insertBefore(a, null), this.isAppend = true), qt(
      c,
      o ? Ji : Qi
    ), qt(c, Fu), qt(a, eo), this.thumbElement = a, this.barElement = c, this.isHorizontal = o, this.gesto = new $n(c, {
      container: Mt(i)
    }).on("dragStart", (l) => this._onDragStart(l)).on("drag", (l) => this._onDrag(l)), it(this.barElement, "wheel", this._onWheel, {
      passive: false
    });
  }
  scrollBy(t, s) {
    const r = t / this.size;
    this.trigger("scroll", {
      delta: s ? t : this.scrollSize * r
    });
  }
  render(t, s, r, o) {
    this.size = r, this.scrollSize = o;
    const i = t && U(o - r, 1e-3) > 0 ? 1 : 0, [a, c] = this.isHorizontal ? ["X", "width"] : ["Y", "height"], l = r / o * 100, u = Math.max(0, s) / o * 100;
    this.thumbElement.style.cssText += `${c}: ${l}%;opacity: ${i};transform: translate${a}(${100 / l * u}%)`;
  }
  destroy() {
    st(this.barElement, "wheel", this._onWheel), this.gesto.off(), this.off();
  }
};
function ju(e, n) {
  const t = e.prototype;
  n.forEach((s) => {
    const r = {
      enumerable: true,
      configurable: true,
      get() {
        return this.options[s];
      }
    }, o = Dn(`set ${s}`);
    t[o] ? r.set = function(i) {
      this[o](i);
    } : r.set = function(i) {
      this.options[s] = i;
    }, Object.defineProperty(t, s, r);
  });
}
var ra = class extends Ae {
  /**
   * @sort 1
   */
  constructor(t, s = {}, r = {}) {
    super();
    b(this, "options");
    b(this, "injectResult");
    b(this, "wrapperElement");
    b(this, "scrollAreaElement");
    b(this, "horizontalScrollbar");
    b(this, "verticalScrollbar");
    b(this, "gesto");
    b(this, "offsetX", 0);
    b(this, "offsetY", 0);
    b(this, "containerWidth", 0);
    b(this, "containerHeight", 0);
    b(this, "viewportWidth", 0);
    b(this, "viewportHeight", 0);
    b(this, "viewportScrollWidth", 0);
    b(this, "viewportScrollHeight", 0);
    b(this, "scrollLeft", 0);
    b(this, "scrollTop", 0);
    b(this, "_scrollTimer", 0);
    b(this, "_zoomTimer", 0);
    b(this, "_viewportElement", null);
    b(this, "_wheelContainerElement", null);
    b(this, "dragFlag", false);
    b(this, "isLoop", false);
    b(this, "_tempScale", [1, 1]);
    b(this, "_tempRect", null);
    b(this, "_tempRectTimer", null);
    b(this, "_onDestroys", []);
    b(this, "_asLeft", 0);
    b(this, "_asTop", 0);
    b(this, "resize", () => {
      const { offsetWidth: t2, offsetHeight: s2 } = this._containerElement, {
        offsetWidth: r2,
        offsetHeight: o,
        scrollWidth: i,
        scrollHeight: a
      } = this._viewportElement;
      this.containerWidth = t2, this.containerHeight = s2, this.viewportWidth = r2, this.viewportHeight = o, this.viewportScrollWidth = Math.max(r2, i), this.viewportScrollHeight = Math.max(o, a), this.render(), this._scrollBy(0, 0);
    });
    b(this, "_onScroll", () => {
      const { scrollLeft: t2, scrollTop: s2 } = this.wrapperElement, { zoom: r2 = xt.zoom } = this, o = t2 - this.scrollLeft, i = s2 - this.scrollTop, a = this.getScrollLeft(), c = this.getScrollTop();
      this.isLoop && (this.isLoop = false), this.scrollLeft = t2, this.scrollTop = s2, this.scrollTo(
        a + o / r2,
        c + i / r2
      );
    });
    b(this, "onWheel", (t2) => {
      const s2 = this.options, r2 = s2.pinchDirection, o = s2.maxPinchWheel || 1 / 0, i = t2[`${this.wheelPinchKey}Key`] || t2.ctrlKey;
      if (s2.useWheelPinch && i) {
        let a = t2.deltaY;
        const c = a >= 0 ? 1 : -1, l = Math.min(o, Math.abs(a));
        a = c * l;
        const u = -a, f = Math.max(
          1 + u * (s2.wheelScale || 0.01),
          Nu
        );
        clearTimeout(this._tempRectTimer), this._tempRectTimer = window.setTimeout(() => {
          this._tempRect = null;
        }, 100), this._triggerPinch({
          distance: l,
          scale: f,
          rotation: 0,
          zoom: this.zoom * f,
          zoomX: this.zoomX * (r2 === "vertical" ? 1 : f),
          zoomY: this.zoomY * (r2 === "horizontal" ? 1 : f),
          inputEvent: t2,
          isWheel: true,
          clientX: t2.clientX,
          clientY: t2.clientY,
          ratioX: 0,
          ratioY: 0
        });
      } else if (s2.useWheelScroll) {
        let a = t2.deltaX, c = t2.deltaY;
        t2.shiftKey && !a && (a = c, c = 0), this.scrollBy(a / this.zoomX, c / this.zoomY);
      } else
        return;
      t2.preventDefault();
    });
    b(this, "onGestureStart", (t2) => {
      this._tempScale = [this.zoomX, this.zoomY], this._setClientRect(), t2.preventDefault();
    });
    b(this, "onGestureChange", (t2) => {
      if (t2.preventDefault(), this.gesto.isFlag() || !this._tempScale) {
        this._tempScale = [1, 1];
        return;
      }
      const s2 = t2.scale, r2 = this._tempScale[0], o = this._tempScale[1], i = this.options.pinchDirection;
      this._triggerPinch({
        distance: 0,
        scale: s2,
        rotation: t2.rotation,
        inputEvent: t2,
        isWheel: true,
        zoom: (r2 + o) * s2 / 2,
        zoomX: r2 * (i === "vertical" ? 1 : s2),
        zoomY: o * (i === "horizontal" ? 1 : s2),
        clientX: t2.clientX,
        clientY: t2.clientY,
        ratioX: 0,
        ratioY: 0
      });
    });
    b(this, "onGestureEnd", () => {
    });
    this._containerElement = t, le(s) ? (this._viewportElement = s, this.options = {
      ...xt,
      ...r
    }) : (this._viewportElement = t.children[0], this.options = {
      ...xt,
      ...s
    }), this.init();
  }
  /**
   * Get Container Element
   */
  getContainer() {
    return this._containerElement;
  }
  /**
   * Get Wheel Container Element
   */
  getWheelContainer() {
    return this._wheelContainerElement;
  }
  /**
   * Get Viewport Element
   */
  getViewport() {
    return this._viewportElement;
  }
  /**
   * Get Wrapper Element
   */
  getWrapper() {
    return this.wrapperElement;
  }
  /**
   * Get Scroll Area Element
   */
  geScrollArea() {
    return this.scrollAreaElement;
  }
  /**
   * Destroy elements, properties, and events.
   */
  destroy() {
    this.off(), this.gesto.unset(), this.verticalScrollbar.destroy(), this.horizontalScrollbar.destroy(), this.injectResult.destroy();
    const t = this._containerElement;
    this._onDestroys.forEach((s) => {
      s();
    }), st(this.wrapperElement, "scroll", this._onScroll), st(this._wheelContainerElement, "wheel", this.onWheel), st(t, "gesturestart", this.onGestureStart), st(t, "gesturechange", this.onGestureChange), st(t, "gesturesend", this.onGestureEnd), this.gesto = null, this.injectResult = null, this._containerElement = null, this._viewportEPropertieslement = null, this.options = null;
  }
  /**
   * Gets the number of pixels that an element's content is scrolled vertically.
   */
  getScrollTop(t = {}) {
    let s = false, r = false;
    Dt(t) ? (s = t.range, r = t.absolute) : s = t;
    const o = this.zoomY, i = this.scrollTop / o + this.offsetY + (s ? Wt(this.getRangeY()[0]) : 0);
    return r ? i * o : i;
  }
  /**
   * Gets the number of pixels that an element's content is scrolled vertically.
   */
  getScrollLeft(t = {}) {
    let s = false, r = false;
    Dt(t) ? (s = t.range, r = t.absolute) : s = t;
    const o = this.zoomX, i = this.scrollLeft / o + this.offsetX + (s ? Wt(this.getRangeX()[0]) : 0);
    return r ? i * o : i;
  }
  /**
   * Gets measurement of the width of an element's content with overflow
   */
  getScrollWidth(t) {
    const s = this._getScrollRangeX(), r = this.zoomX, o = this.containerWidth / r + Wt(s[0]) + s[1];
    return t ? o : o * r;
  }
  /**
   * Gets measurement of the height of an element's content with overflow
   */
  getScrollHeight(t) {
    const s = this._getScrollRangeY(), r = this.zoomY, o = this.containerHeight / r + Wt(s[0]) + s[1];
    return t ? o : o * r;
  }
  /**
   * Scroll the element to the center
   */
  scrollCenter(t = {}) {
    this.resize();
    const s = this.zoomX, r = this.zoomY;
    let o = -(this.containerWidth / s - this.viewportWidth) / 2, i = -(this.containerHeight / r - this.viewportHeight) / 2;
    return t.absolute && (o *= s, i *= r), t.horizontal === false && (o = this.getScrollLeft()), t.vertical === false && (i = this.getScrollTop()), this.scrollTo(o, i, t);
  }
  /**
   * Move to that position or zoom.
   * @since 0.25.0
   */
  setTo(t) {
    const {
      x: s = this.getScrollLeft(),
      y: r = this.getScrollTop(),
      zoom: o = [this.getZoomX(), this.getZoomY()],
      duration: i
    } = t, { zoomX: a, zoomY: c, zoomRange: l } = this;
    let {
      zoomOffsetX: u = xt.zoomOffsetX,
      zoomOffsetY: f = xt.zoomOffsetY
    } = this;
    "zoomOffsetX" in t && (u = t.zoomOffsetX), "zoomOffsetY" in t && (f = t.zoomOffsetY);
    const [h, d] = ct(o) ? o : [o, o], p = this.zoomRangeX || l, g = this.zoomRangeY || l, m = At(h, p[0], p[1]), S = At(d, g[0], g[1]), v = Q(`${u}`, this.viewportWidth) * (1 / a - 1 / m), x = Q(`${f}`, this.viewportHeight) * (1 / c - 1 / S);
    this.scrollTo(s - v, r - x, {
      duration: i
    }), this.setZoom(o, {
      zoomOffsetX: u,
      zoomOffsetY: f,
      duration: i,
      zoomBase: "fixed"
    });
  }
  /**
   * Move by the position or zoom delta value.
   * @since 0.25.0
   */
  setBy(t) {
    const { x: s = 0, y: r = 0, zoom: o = [0, 0] } = t, [i, a] = ct(o) ? o : [o, o];
    this.setTo({
      ...t,
      x: this.getScrollLeft() + s,
      y: this.getScrollTop() + r,
      zoom: [this.zoomX + i, this.zoomY + a]
    });
  }
  /**
   * Scrolls the container by the given amount.
   */
  scrollBy(t, s, r) {
    if (this._pauseScrollAnimation(), !r || !r.duration) {
      let o = this.getScrollLeft(), i = this.getScrollTop();
      return r != null && r.absolute && (o *= this.zoomX, i *= this.zoomY), this._scrollTo(o + t, i + s, r);
    } else
      return this._startScrollAnimation([t, s], r), true;
  }
  /**
   * Scrolls the container to set of coordinates.
   * @param scrollLeft
   * @param scrollTop
   */
  scrollTo(t, s, r) {
    if (this._pauseScrollAnimation(), !r || !r.duration)
      return this._scrollTo(t, s, r);
    {
      let o = this.getScrollLeft(), i = this.getScrollTop();
      return r != null && r.absolute && (o *= this.zoomX, i *= this.zoomY), this.scrollBy(t - o, s - i, r);
    }
  }
  /**
   * Set viewer zoom by the given amount
   */
  zoomBy(t, s) {
    this._pauseZoomAnimation();
    const [r, o] = ct(t) ? t : [t, t];
    !s || !s.duration ? this._setZoom([this.zoomX + r, this.zoomY + o], s) : this._startZoomAnimation([r, o], s);
  }
  /**
   * Set viewer zoom
   */
  setZoom(t, s) {
    if (this._pauseZoomAnimation(), !s || !s.duration)
      this._setZoom(t, s);
    else {
      const [r, o] = ct(t) ? t : [t, t];
      this._startZoomAnimation(
        [r - this.zoomX, o - this.zoomY],
        s
      );
    }
  }
  getViewportWidth() {
    return this.viewportWidth;
  }
  getViewportHeight() {
    return this.viewportWidth;
  }
  getViewportScrollWidth() {
    return this.viewportScrollWidth;
  }
  getViewportScrollHeight() {
    return this.viewportScrollHeight;
  }
  getContainerWidth() {
    return this.containerWidth;
  }
  getContainerHeight() {
    return this.containerHeight;
  }
  /**
   * Get viewer zoom
   */
  getZoom() {
    return (this.zoomX + this.zoomY) / 2;
  }
  /**
   * Get viewer zoomX
   * @since 0.20.0
   */
  getZoomX() {
    return this.zoomX;
  }
  /**
   * Get viewer zoom
   * @since 0.20.0
   */
  getZoomY() {
    return this.zoomY;
  }
  /**
   * get x ranges
   */
  getRangeX(t, s) {
    return this._getRangeCoord("horizontal", t, s);
  }
  /**
   * get y ranges
   */
  getRangeY(t, s) {
    return this._getRangeCoord("vertical", t, s);
  }
  init() {
    const t = this._containerElement, s = this.options, r = Rt(t), o = Mt(t);
    let i = s.wrapperElement || t.querySelector(`.${Qr}`), a = s.scrollAreaElement || t.querySelector(`.${to}`);
    const c = s.horizontalScrollElement || t.querySelector(`.${Ji}`), l = s.verticalScrollElement || t.querySelector(`.${Qi}`);
    i || (i = r.createElement("div"), i.insertBefore(this._viewportElement, null), t.insertBefore(i, null)), this.wrapperElement = i, a || (a = r.createElement("div"), i.insertBefore(a, i.firstChild)), this.scrollAreaElement = a, qt(t, ea), qt(i, Qr), qt(a, to);
    const u = new io(
      t,
      "horizontal",
      c
    ), f = new io(
      t,
      "vertical",
      l
    );
    this.horizontalScrollbar = u, this.verticalScrollbar = f, u.on("scroll", (p) => {
      this.scrollBy(p.delta / this.zoomX, 0);
    }), f.on("scroll", (p) => {
      this.scrollBy(0, p.delta / this.zoomY);
    }), u.isAppend && t.insertBefore(u.barElement, null), f.isAppend && t.insertBefore(f.barElement, null), this.injectResult = ta.inject(t, {
      nonce: this.options.cspNonce
    });
    const h = s.wheelContainer;
    let d = null;
    if (h && (Yt(h) ? d = r.querySelector(h) : le(h) ? d = h : ("value" in h || "current" in h) && (d = h.current || h.value)), d || (d = t), this._wheelContainerElement = d, this.gesto = new $n(t, {
      container: Mt(t),
      events: ["touch", "mouse"],
      preventWheelClick: this.options.preventWheelClick ?? true
    }).on("dragStart", (p) => {
      const { inputEvent: g, stop: m, datas: S } = p;
      if (!this.useMouseDrag && p.isMouseEvent) {
        m();
        return;
      }
      if (this._pauseScrollAnimation(), this.dragFlag = false, this.trigger("dragStart", p) === false) {
        m();
        return;
      }
      g.preventDefault(), S.startEvent = g;
    }).on("drag", (p) => {
      !this.options.usePinch || p.isPinch || this.useMouseDrag && p.isMouseEvent ? (this.trigger("drag", {
        ...p,
        inputEvent: p.inputEvent
      }), Hu(p), this.scrollBy(-p.deltaX / this.zoomX, -p.deltaY / this.zoomY)) : !this.dragFlag && p.movement > s.pinchThreshold && (this.dragFlag = true, this.trigger("abortPinch", {
        inputEvent: p.datas.startEvent || p.inputEvent
      }));
    }).on("dragEnd", (p) => {
      this.trigger("dragEnd", {
        isDrag: p.isDrag,
        isDouble: p.isDouble,
        inputEvent: p.inputEvent
      }), this._startScrollAnimationBySpeed(p.datas.speed);
    }).on("pinchStart", ({ inputEvent: p, datas: g, stop: m }) => {
      p.preventDefault(), this._pauseScrollAnimation(), g.startZoom = [this.zoomX, this.zoomY], this.trigger("pinchStart", {
        inputEvent: p
      }) === false && m(), this._setClientRect();
    }).on("pinch", (p) => {
      const g = p.scale, m = this.options.pinchDirection;
      this._triggerPinch({
        rotation: p.rotation,
        distance: p.distance,
        scale: p.scale,
        inputEvent: p.inputEvent,
        isWheel: false,
        zoom: p.datas.startZoom * g,
        zoomX: this.zoomX * (m === "vertical" ? 1 : g),
        zoomY: this.zoomY * (m === "horizontal" ? 1 : g),
        clientX: p.clientX,
        clientY: p.clientY,
        ratioX: 0,
        ratioY: 0
      });
    }).on("pinchEnd", () => {
      this._tempRect = null;
    }), it(i, "scroll", this._onScroll), s.useResizeObserver) {
      const p = new o.ResizeObserver(() => {
        this.resize();
      });
      p.observe(this._viewportElement), p.observe(this._containerElement), this._onDestroys.push(() => {
        p.disconnect();
      });
    } else
      it(o, "resize", this.resize), this._onDestroys.push(() => {
        st(o, "resize", this.resize);
      });
    (s.useWheelPinch || s.useWheelScroll) && it(d, "wheel", this.onWheel, {
      passive: false
    }), s.useGesture && (it(t, "gesturestart", this.onGestureStart, {
      passive: false
    }), it(t, "gesturechange", this.onGestureChange, {
      passive: false
    })), this.resize();
  }
  render() {
    const {
      offsetX: t,
      offsetY: s,
      zoomX: r = xt.zoomX,
      zoomY: o = xt.zoomY,
      translateZ: i = 0,
      rangeX: a,
      rangeY: c,
      containerWidth: l,
      containerHeight: u
    } = this, { useTransform: f = xt.useTransform } = this.options;
    let h = -t * r, d = -s * o;
    this.scrollAreaElement.style.cssText = `width:calc(100% + ${this.getScrollAreaWidth()}px);height:calc(100% + ${this.getScrollAreaHeight()}px);`;
    const p = this._viewportElement.style;
    f === false ? p.cssText += `position: relative; left: ${h}px; top: ${d}px; ` : p.cssText += `transform-origin: 0 0;transform:translate3d(${h}px, ${d}px, ${i}px) scale(${r}, ${o});`, this.renderScroll();
  }
  renderScroll() {
    const { zoomX: t, zoomY: s, containerWidth: r, containerHeight: o } = this, i = this.horizontalScrollbar, a = this.verticalScrollbar;
    if (this.options.useBounceScrollBar) {
      const c = this.getScrollLeft(true) * t, l = this.getRangeX(true), u = r + Wt(l[0]) + Wt(l[1]), f = this.getScrollTop(true) * s, h = this.getRangeY(true), d = o + Wt(h[0]) + Wt(h[1]);
      i.render(
        this.displayHorizontalScroll,
        c,
        r,
        u
      ), a.render(
        this.displayVerticalScroll,
        f,
        o,
        d
      );
    } else {
      const c = this._getScrollRangeX(), l = this._getScrollRangeY(), u = this.getScrollLeft(), f = this.getScrollTop(), h = this.containerWidth + Wt(c[0]) + c[1], d = this.containerHeight + Wt(l[0]) + l[1];
      i.render(
        this.displayHorizontalScroll,
        u - c[0],
        r,
        h
      ), a.render(
        this.displayVerticalScroll,
        f - l[0],
        o,
        d
      );
    }
  }
  move(t, s) {
    const r = this.wrapperElement;
    r.scrollLeft = t, r.scrollTop = s;
  }
  setDisplayVerticalScroll(t) {
    this.options.displayVerticalScroll = t, this.renderScroll();
  }
  setDisplayHorizontalScroll(t) {
    this.options.displayHorizontalScroll = t, this.renderScroll();
  }
  _startZoomAnimation(t, s) {
    if (!t)
      return;
    const r = s.duration, o = s.easing || no;
    oo(
      (i) => this._setZoom(
        [this.zoomX + t[0] * i, this.zoomY + t[1] * i],
        s
      ),
      (i) => {
        this._zoomTimer = requestAnimationFrame(i);
      },
      {
        easing: o,
        duration: r
      }
    );
  }
  _startScrollAnimation(t, s) {
    if (!t[0] && !t[1])
      return;
    const r = s.duration, o = s.easing || no;
    oo(
      (i) => this._scrollBy(t[0] * i, t[1] * i, s),
      (i) => {
        this._scrollTimer = requestAnimationFrame(i);
      },
      {
        easing: o,
        duration: r
      }
    );
  }
  _startScrollAnimationBySpeed(t) {
    if (!t || !t[0] && !t[1])
      return;
    const s = -6e-4, r = sa(t, s), o = Vu(t, s);
    return this._startScrollAnimation(o, {
      duration: r
    });
  }
  _pauseScrollAnimation() {
    cancelAnimationFrame(this._scrollTimer), this._scrollTimer = 0;
  }
  _pauseZoomAnimation() {
    cancelAnimationFrame(this._zoomTimer), this._zoomTimer = 0;
  }
  getScrollAreaWidth() {
    const [t, s] = this.getRangeX(true);
    return t || s ? this.margin * 2 : 0;
  }
  getScrollAreaHeight() {
    const [t, s] = this.getRangeY(true);
    return t || s ? this.margin * 2 : 0;
  }
  _triggerPinch(t) {
    const { clientX: s, clientY: r, zoomX: o, zoomY: i } = t;
    this.useAutoZoom && this._zoomByClient([o, i], s, r), this._tempRect || this._setClientRect();
    const a = this.zoomRange, c = this.zoomRangeX || a, l = this.zoomRangeY || a, { left: u, top: f, width: h, height: d } = this._tempRect, p = (s - u) / h * 100, g = (r - f) / d * 100;
    this.trigger("pinch", {
      ...t,
      zoom: At((o + i) / 2, a[0], a[1]),
      zoomX: At(o, c[0], c[1]),
      zoomY: At(i, l[0], l[1]),
      ratioX: p,
      ratioY: g
    });
  }
  _setClientRect() {
    const t = this.getContainer().getBoundingClientRect();
    this._tempRect = {
      left: t.left,
      top: t.top,
      width: t.width,
      height: t.height
    };
  }
  _zoomByClient(t, s, r) {
    this._tempRect || this._setClientRect();
    const { left: o, top: i, width: a, height: c } = this._tempRect, l = this.options, u = l.zoomOffsetX, f = l.zoomOffsetY;
    l.zoomOffsetX = `${(s - o) / a * 100}%`, l.zoomOffsetY = `${(r - i) / c * 100}%`, this._setZoom(t, {
      zoomBase: "screen"
    }), l.zoomOffsetX = u, l.zoomOffsetY = f;
  }
  _setZoom(t, s = {}) {
    const r = s.zoomBase, {
      containerWidth: o,
      containerHeight: i,
      zoomX: a,
      zoomY: c,
      zoomRange: l
    } = this;
    let {
      zoomOffsetX: u = xt.zoomOffsetX,
      zoomOffsetY: f = xt.zoomOffsetY
    } = this;
    "zoomOffsetX" in s && (u = s.zoomOffsetX), "zoomOffsetY" in s && (f = s.zoomOffsetY);
    const h = this.getScrollLeft(), d = this.getScrollTop(), [p, g] = ct(t) ? t : [t, t], m = this.zoomRangeX || l, S = this.zoomRangeY || l, v = At(p, m[0], m[1]), x = At(g, S[0], S[1]), C = this.options;
    C.zoomX = v, C.zoomY = x, C.zoom = (v + x) / 2;
    const E = this.getScrollLeft(), D = this.getScrollTop();
    let T = 0, w = 0;
    r === "fixed" ? (T = Q(`${u}`, this.viewportWidth), w = Q(`${f}`, this.viewportHeight)) : r === "viewport" ? (T = (-h + Q(`${u}`, this.viewportWidth)) * a, w = (-d + Q(`${f}`, this.viewportHeight)) * c) : (T = Q(`${u}`, o), w = Q(`${f}`, i));
    const z = h + T / a, M = d + w / c, R = E + T / v, P = D + w / x;
    this._scrollBy(z - R, M - P, {
      zoom: !!(v - a || x - c)
    }), this.render();
  }
  _scrollBy(t, s, r) {
    let o = this.getScrollLeft(), i = this.getScrollTop();
    return r != null && r.absolute && (o *= this.zoomX, i *= this.zoomY), this._scrollTo(o + t, i + s, r);
  }
  _scrollTo(t, s, r) {
    const { scrollLeft: o, scrollTop: i } = this, a = r == null ? void 0 : r.absolute;
    this._scrollToType("horizontal", t, a), this._scrollToType("vertical", s, a);
    const c = this.scrollLeft, l = this.scrollTop;
    this.render();
    const u = this.getScrollLeft(), f = this.getScrollTop();
    return this._emitScrollEvent(
      u,
      f,
      r == null ? void 0 : r.zoom
    ), Math.round(o) !== c || Math.round(i) !== l ? (this.isLoop = true, this.move(c, l), requestAnimationFrame(() => {
      if (!this.isLoop)
        return;
      this.isLoop = false;
      const { scrollLeft: h, scrollTop: d } = this.wrapperElement;
      this.scrollLeft = h, this.scrollTop = d, (c !== Math.round(h) || l !== Math.round(d)) && this._scrollTo(u, f);
    }), false) : true;
  }
  _scrollToType(t, s, r) {
    const o = so[t], {
      margin: i = xt.margin,
      threshold: a = xt.threshold
    } = this, c = this[`scroll${o.pos}`], [l, u] = this[`getRange${o.coord}`](true, true);
    let f = Math.round(c);
    const h = this[`getScrollArea${o.size}`](), d = this[`zoom${o.coord}`];
    r && (s = s / d);
    const p = s * d;
    if (l === u)
      f = l, s = l / d;
    else if (p - a <= l) {
      const g = Math.max(0, p - l);
      f = g, s = (l + g) / d;
    } else if (p + a >= u) {
      const g = Math.max(0, u - p);
      f = h - g, s = (u - g) / d;
    } else f < a ? f += i : f > h - a && (f -= i);
    f = Math.round(f), this[`scroll${o.pos}`] = f, this[`offset${o.coord}`] = s - f / d;
  }
  _getRangeCoord(t, s, r) {
    const { margin: o = xt.margin, threshold: i } = this, a = so[t], c = ro(
      this[`range${a.coord}`],
      xt[`range${a.coord}`]
    ), l = ro(
      this[`rangeOffset${a.coord}`],
      xt[`rangeOffset${a.coord}`]
    ), u = this[`zoom${a.coord}`], f = qu(
      this[`getScroll${a.pos}`](),
      o,
      c,
      i,
      r
    );
    return s ? [
      f[0] * u + l[0],
      this.options.useOverflowScroll ? Math.max(
        this[`viewport${a.size}`] * u - this[`container${a.size}`],
        f[1] * u + l[1]
      ) : f[1] * u + l[1]
    ] : [f[0] + l[0], f[1] + l[1]];
  }
  _emitScrollEvent(t, s, r) {
    const o = this._asLeft, i = this._asTop;
    !r && o === t && i === s || (this._asLeft = t, this._asTop = s, this.trigger("scroll", {
      scrollLeft: t,
      scrollTop: s,
      zoomX: this.zoomX,
      zoomY: this.zoomY
    }));
  }
  _getScrollRangeX() {
    const t = this.getScrollLeft(), s = this.rangeX, r = s[0];
    let o = s[1];
    this.useOverflowScroll && isFinite(o) && (o = Math.max(
      o,
      this.viewportWidth - this.containerWidth / this.zoomX
    ));
    const i = Math.min(
      0,
      isFinite(r) ? Math.min(r, t) : t
    ), a = Math.max(
      0,
      isFinite(o) ? Math.max(o, t) : t
    ), c = this.viewportScrollWidth, l = Math.max(this.containerWidth / this.zoomX, c) - c;
    return [Math.min(0, l + i), a];
  }
  _getScrollRangeY() {
    const t = this.getScrollTop(), s = this.rangeY, r = s[0];
    let o = s[1];
    this.useOverflowScroll && isFinite(o) && (o = Math.max(
      o,
      this.viewportHeight - this.containerHeight / this.zoomY
    ));
    const i = Math.min(
      0,
      isFinite(r) ? Math.min(r, t) : t
    ), a = Math.max(
      0,
      isFinite(o) ? Math.max(o, t) : t
    ), c = this.viewportScrollHeight, l = Math.max(this.containerHeight / this.zoomY, c) - c;
    return [Math.min(0, l + i), a];
  }
};
ju(ra, [...ur]);
var ao = na.map((e) => Dn(`on ${e}`));
function Uu(e, n, t, s = {}) {
  n.forEach((r) => {
    const o = s[r] || r;
    o in e || (e[o] = function(...i) {
      const a = this[t][r](...i);
      return a === this[t] ? this : a;
    });
  });
}
var ef = class extends ys.PureComponent {
  constructor() {
    super(...arguments);
    b(this, "infiniteViewer");
    b(this, "containerElement");
    b(this, "wrapperElement");
    b(this, "scrollAreaElement");
    b(this, "horizontalScrollElement");
    b(this, "verticalScrollElement");
  }
  render() {
    const t = this.props.className;
    return (0, import_jsx_runtime.jsxs)(
      "div",
      {
        className: `${t || ""} ${ea}`,
        ref: _t(this, "containerElement"),
        children: [
          (0, import_jsx_runtime.jsxs)(
            "div",
            {
              className: "infinite-viewer-wrapper",
              ref: _t(this, "wrapperElement"),
              children: [
                (0, import_jsx_runtime.jsx)(
                  "div",
                  {
                    className: "infinite-viewer-scroll-area",
                    ref: _t(this, "scrollAreaElement")
                  }
                ),
                this.props.children
              ]
            }
          ),
          (0, import_jsx_runtime.jsx)(
            "div",
            {
              className: "infinite-viewer-scroll-bar infinite-viewer-horizontal-scroll-bar",
              ref: _t(this, "horizontalScrollElement"),
              children: (0, import_jsx_runtime.jsx)("div", { className: "infinite-viewer-scroll-thumb" })
            }
          ),
          (0, import_jsx_runtime.jsx)(
            "div",
            {
              className: "infinite-viewer-scroll-bar infinite-viewer-vertical-scroll-bar",
              ref: _t(this, "verticalScrollElement"),
              children: (0, import_jsx_runtime.jsx)("div", { className: "infinite-viewer-scroll-thumb" })
            }
          )
        ]
      }
    );
  }
  componentDidMount() {
    const t = this.props, s = {};
    Lu.forEach((r) => {
      r in t && typeof t[r] < "u" && (s[r] = t[r]);
    }), this.infiniteViewer = new ra(
      this.containerElement,
      this.scrollAreaElement.nextElementSibling,
      {
        ...s,
        wrapperElement: this.wrapperElement,
        scrollAreaElement: this.scrollAreaElement,
        horizontalScrollElement: this.horizontalScrollElement,
        verticalScrollElement: this.verticalScrollElement
      }
    ), Uu(this, Wu, "infiniteViewer"), na.forEach((r, o) => {
      this.infiniteViewer.on(r, (i) => {
        const a = this.props;
        (a[ao[o]] && a[ao[o]](i)) === false && i.stop();
      });
    });
  }
  componentDidUpdate(t) {
    const s = this.props, r = this.infiniteViewer;
    ur.forEach((o) => {
      o in s && r[o] !== s[o] && (r[o] = s[o]);
    });
  }
  componentWillUnmount() {
    this.infiniteViewer.destroy();
  }
  getElement() {
    return this.containerElement;
  }
};
export {
  ku as Moveable,
  Qu as Selection,
  ef as Viewer
};
//# sourceMappingURL=@interactify_toolkit.js.map
