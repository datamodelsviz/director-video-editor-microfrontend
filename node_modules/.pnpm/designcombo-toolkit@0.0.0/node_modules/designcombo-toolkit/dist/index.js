import { jsx as Z, jsxs as Pe } from "react/jsx-runtime";
import * as Or from "react";
import { createElement as Mr, forwardRef as ia, useRef as oa, useImperativeHandle as aa, useEffect as la } from "react";
const ca = "function", ua = "object", fa = "string", ha = "number", ai = "undefined", li = typeof window !== ai, da = [
  { open: "(", close: ")" },
  { open: '"', close: '"' },
  { open: "'", close: "'" },
  { open: '\\"', close: '\\"' },
  { open: "\\'", close: "\\'" }
], ft = 1e-7, nn = {
  cm: (e) => e * 96 / 2.54,
  mm: (e) => e * 96 / 254,
  in: (e) => e * 96,
  pt: (e) => e * 96 / 72,
  pc: (e) => e * 96 / 6,
  "%": (e, t) => e * t / 100,
  vw: (e, t = window.innerWidth) => e / 100 * t,
  vh: (e, t = window.innerHeight) => e / 100 * t,
  vmax: (e, t = Math.max(window.innerWidth, window.innerHeight)) => e / 100 * t,
  vmin: (e, t = Math.min(window.innerWidth, window.innerHeight)) => e / 100 * t
};
function fs(e) {
  const t = pa(e), n = lt(t, e[0]), r = lt(t, e[1]);
  return n < r && r - n < Math.PI || n > r && r - n < -Math.PI ? 1 : -1;
}
function pa(e) {
  return [0, 1].map((t) => ar(e.map((n) => n[t])));
}
function lt(e, t) {
  const n = t[0] - e[0], r = t[1] - e[1], s = Math.atan2(r, n);
  return s >= 0 ? s : s + Math.PI * 2;
}
function ar(e) {
  const t = e.length;
  let n = 0;
  for (let r = t - 1; r >= 0; --r)
    n += e[r];
  return t ? n / t : 0;
}
function Ft(e, t) {
  return Math.sqrt(Math.pow((t ? t[0] : 0) - e[0], 2) + Math.pow((t ? t[1] : 0) - e[1], 2));
}
function qt(e, t, n = -1) {
  const r = e.length;
  for (let s = 0; s < r; ++s)
    if (t(e[s], s, e))
      return s;
  return n;
}
function V(e, t) {
  if (!t)
    return e;
  const n = 1 / t;
  return Math.round(e / t) / n;
}
function hs(e, t) {
  return e.forEach((n, r) => {
    e[r] = V(e[r], t);
  }), e;
}
function Ot(e, t, n) {
  const r = qt(e, t);
  return r > -1 ? e[r] : n;
}
function Et(e) {
  return e && typeof e === ua;
}
function jt(e) {
  return typeof e === fa;
}
function at(e) {
  return Array.isArray(e);
}
function xn(e) {
  return e.replace(/[\s-_]+([^\s-_])/g, (t, n) => n.toUpperCase());
}
function ga(e, t = "-") {
  return e.replace(/([a-z])([A-Z])/g, (n, r, s) => `${r}${t}${s.toLowerCase()}`);
}
function In(e) {
  return typeof e === ca;
}
function Tr(e) {
  return typeof e === ai;
}
function He(e) {
  return typeof e === ha;
}
function ma(e, t) {
  const n = e === "" || e == " ";
  return (t === "" || t == " ") && n || e === t;
}
function Bt(e, t, n) {
  return Math.max(t, Math.min(e, n));
}
function ae(e) {
  const t = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(e);
  if (!t)
    return { prefix: "", unit: "", value: NaN };
  const n = t[1], r = t[2], s = t[3];
  return { prefix: n, unit: s, value: parseFloat(r) };
}
function oe(e) {
  return _r(e, ",");
}
function ci(e) {
  const t = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(e);
  return !t || t.length < 4 ? {} : { prefix: t[1], value: t[2], suffix: t[3] };
}
function Rr(e, t, n, r) {
  if (!r)
    return e.map((f, h) => Bt(f, t[h], n[h]));
  let [s, i] = e;
  const o = r === !0 ? s / i : r, [a, l] = ds(e, t, !1, o), [c, u] = ds(e, n, !0, o);
  return s < a || i < l ? (s = a, i = l) : (s > c || i > u) && (s = c, i = u), [s, i];
}
function ds(e, t, n, r = e[0] / e[1]) {
  return [
    [
      V(t[0], ft),
      V(t[0] / r, ft)
    ],
    [
      V(t[1] * r, ft),
      V(t[1], ft)
    ]
  ].filter((s) => s.every((i, o) => {
    const a = t[o], l = V(a, ft);
    return n ? i <= a || i <= l : i >= a || i >= l;
  }))[0] || e;
}
function _e(e) {
  return Object.keys(e);
}
const ba = /* @__PURE__ */ (() => {
  const e = li && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);
  return e ? e.bind(window) : (t) => {
    clearTimeout(t);
  };
})(), ui = /* @__PURE__ */ (() => {
  const e = Ve(), t = li && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);
  return t ? t.bind(window) : (n) => {
    const r = Ve();
    return setTimeout(() => {
      n(r - e);
    }, 1e3 / 60);
  };
})();
function Ve() {
  return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();
}
function fi(e, t, n, r, s) {
  return zr(e, t, n) ? n : va(e, t, n + 1, r, s);
}
function zr(e, t, n) {
  if (!e.ignore)
    return null;
  const r = t.slice(Math.max(n - 3, 0), n + 3).join("");
  return new RegExp(e.ignore).exec(r);
}
function va(e, t, n, r, s) {
  for (let i = n; i < r; ++i) {
    const o = t[i].trim();
    if (o === e.close && !zr(e, t, i))
      return i;
    let a = i;
    const l = Ot(s, ({ open: c }) => c === o);
    if (l && (a = fi(l, t, i, r, s)), a === -1)
      break;
    i = a;
  }
  return -1;
}
function _r(e, t) {
  const { separator: n = ",", isSeparateFirst: r, isSeparateOnlyOpenClose: s, isSeparateOpenClose: i = s, openCloseCharacters: o = da } = jt(t) ? {
    separator: t
  } : t, a = o.map(({ open: g, close: m }) => g === m ? g : `${g}|${m}`).join("|"), l = `(\\s*${n}\\s*|${a}|\\s+)`, c = new RegExp(l, "g"), u = e.split(c).filter((g) => g && g !== "undefined"), f = u.length, h = [];
  let d = [];
  function p() {
    return d.length ? (h.push(d.join("")), d = [], !0) : !1;
  }
  for (let g = 0; g < f; ++g) {
    const m = u[g].trim();
    let b = g;
    const S = Ot(o, ({ open: E }) => E === m), v = Ot(o, ({ close: E }) => E === m);
    if (S) {
      if (b = fi(S, u, g, f, o), b !== -1 && i) {
        if (p() && r || (h.push(u.slice(g, b + 1).join("")), g = b, r))
          break;
        continue;
      }
    } else if (v && !zr(v, u, g)) {
      const E = [...o];
      return E.splice(o.indexOf(v), 1), _r(e, {
        separator: n,
        isSeparateFirst: r,
        isSeparateOnlyOpenClose: s,
        isSeparateOpenClose: i,
        openCloseCharacters: E
      });
    } else if (ma(m, n) && !s) {
      if (p(), r)
        break;
      continue;
    }
    b === -1 && (b = f - 1), d.push(u.slice(g, b + 1).join("")), g = b;
  }
  return d.length && h.push(d.join("")), h;
}
function Jt(e) {
  return _r(e, "");
}
function En(e, t, n, r) {
  return (e * r + t * n) / (n + r);
}
function K(e, t) {
  const { value: n, unit: r } = ae(e);
  if (Et(t)) {
    const s = t[r];
    if (s) {
      if (In(s))
        return s(n);
      if (nn[r])
        return nn[r](n, s);
    }
  } else if (r === "%")
    return n * t / 100;
  return nn[r] ? nn[r](n) : n;
}
function Sa(e) {
  return e.reduce((t, n) => t.concat(n), []);
}
function xa(e) {
  const t = [];
  for (let n = 0; n < e; ++n)
    t.push(n);
  return t;
}
function ht(e, t) {
  return e.classList ? e.classList.contains(t) : !!e.className.match(new RegExp(`(\\s|^)${t}(\\s|$)`));
}
function Ht(e, t) {
  e.classList ? e.classList.add(t) : e.className += ` ${t}`;
}
function hi(e, t) {
  if (e.classList)
    e.classList.remove(t);
  else {
    const n = new RegExp(`(\\s|^)${t}(\\s|$)`);
    e.className = e.className.replace(n, " ");
  }
}
function Dt(e) {
  return (e == null ? void 0 : e.ownerDocument) || document;
}
function Ir(e) {
  return Dt(e).documentElement;
}
function ee(e) {
  return Dt(e).body;
}
function di(e) {
  return e && "postMessage" in e && "blur" in e && "self" in e;
}
function le(e) {
  return Et(e) && e.nodeName && e.nodeType && "parentNode" in e && "ownerDocument" in e;
}
function yt(e) {
  var t;
  return ((t = e == null ? void 0 : e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function it(e, t, n, r) {
  e.addEventListener(t, n, r);
}
function et(e, t, n, r) {
  e.removeEventListener(t, n, r);
}
class Ie {
  constructor() {
    Object.defineProperty(this, "_events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  /**
   * Add a listener to the registered event.
   * @param - Name of the event to be added
   * @param - listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add listener in "a" event
   * emitter.on("a", () => {
   * });
   * // Add listeners
   * emitter.on({
   *  a: () => {},
   *  b: () => {},
   * });
   */
  on(t, n) {
    if (Et(t))
      for (const r in t)
        this.on(r, t[r]);
    else
      this._addEvent(t, n, {});
    return this;
  }
  /**
   * Remove listeners registered in the event target.
   * @param - Name of the event to be removed
   * @param - listener function of the event to be removed
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Remove all listeners.
   * emitter.off();
   *
   * // Remove all listeners in "A" event.
   * emitter.off("a");
   *
   *
   * // Remove "listener" listener in "a" event.
   * emitter.off("a", listener);
   */
  off(t, n) {
    if (!t)
      this._events = {};
    else if (Et(t))
      for (const r in t)
        this.off(r);
    else if (!n)
      this._events[t] = [];
    else {
      const r = this._events[t];
      if (r) {
        const s = qt(r, (i) => i.listener === n);
        s > -1 && r.splice(s, 1);
      }
    }
    return this;
  }
  /**
   * Add a disposable listener and Use promise to the registered event.
   * @param - Name of the event to be added
   * @param - disposable listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add a disposable listener in "a" event
   * emitter.once("a", () => {
   * });
   *
   * // Use Promise
   * emitter.once("a").then(e => {
   * });
   */
  once(t, n) {
    return n && this._addEvent(t, n, { once: !0 }), new Promise((r) => {
      this._addEvent(t, r, { once: !0 });
    });
  }
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */
  emit(t, n = {}) {
    const r = this._events[t];
    if (!t || !r)
      return !0;
    let s = !1;
    return n.eventType = t, n.stop = () => {
      s = !0;
    }, n.currentTarget = this, [...r].forEach((i) => {
      i.listener(n), i.once && this.off(t, i.listener);
    }), !s;
  }
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */
  /**
  * Fires an event to call listeners.
  * @param - Event name
  * @param - Event parameter
  * @return If false, stop the event.
  * @example
  *
  * import EventEmitter from "@scena/event-emitter";
  *
  *
  * const emitter = new EventEmitter();
  *
  * emitter.on("a", e => {
  * });
  *
  * // emit
  * emitter.trigger("a", {
  *   a: 1,
  * });
  */
  trigger(t, n = {}) {
    return this.emit(t, n);
  }
  _addEvent(t, n, r) {
    const s = this._events;
    s[t] = s[t] || [], s[t].push({ listener: n, ...r });
  }
}
function Ea(e, t) {
  const n = t[0] - e[0], r = t[1] - e[1], s = Math.atan2(r, n);
  return s >= 0 ? s : s + Math.PI * 2;
}
function Hn(e) {
  return Ea([e[0].clientX, e[0].clientY], [e[1].clientX, e[1].clientY]) / Math.PI * 180;
}
function wa(e) {
  return e.touches && e.touches.length >= 2;
}
function rn(e) {
  return e ? e.touches ? ya(e.touches) : [pi(e)] : [];
}
function Ca(e) {
  return e && (e.type.indexOf("mouse") > -1 || "button" in e);
}
function ps(e, t, n) {
  const r = n.length, { clientX: s, clientY: i, originalClientX: o, originalClientY: a } = Xe(e, r), { clientX: l, clientY: c } = Xe(t, r), { clientX: u, clientY: f } = Xe(n, r), h = s - l, d = i - c, p = s - u, g = i - f;
  return {
    clientX: o,
    clientY: a,
    deltaX: h,
    deltaY: d,
    distX: p,
    distY: g
  };
}
function Vn(e) {
  return Math.sqrt(Math.pow(e[0].clientX - e[1].clientX, 2) + Math.pow(e[0].clientY - e[1].clientY, 2));
}
function ya(e) {
  const t = Math.min(e.length, 2), n = [];
  for (let r = 0; r < t; ++r)
    n.push(pi(e[r]));
  return n;
}
function pi(e) {
  return {
    clientX: e.clientX,
    clientY: e.clientY
  };
}
function Xe(e, t = e.length) {
  const n = {
    clientX: 0,
    clientY: 0,
    originalClientX: 0,
    originalClientY: 0
  }, r = Math.min(e.length, t);
  for (let s = 0; s < r; ++s) {
    const i = e[s];
    n.originalClientX += "originalClientX" in i ? i.originalClientX : i.clientX, n.originalClientY += "originalClientY" in i ? i.originalClientY : i.clientY, n.clientX += i.clientX, n.clientY += i.clientY;
  }
  return t ? {
    clientX: n.clientX / t,
    clientY: n.clientY / t,
    originalClientX: n.originalClientX / t,
    originalClientY: n.originalClientY / t
  } : n;
}
class qn {
  constructor(t) {
    Object.defineProperty(this, "prevClients", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "startClients", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "movement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "length", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this.startClients = t, this.prevClients = t, this.length = t.length;
  }
  getAngle(t = this.prevClients) {
    return Hn(t);
  }
  getRotation(t = this.prevClients) {
    return Hn(t) - Hn(this.startClients);
  }
  getPosition(t = this.prevClients, n) {
    const r = ps(t || this.prevClients, this.prevClients, this.startClients), { deltaX: s, deltaY: i } = r;
    return this.movement += Math.sqrt(s * s + i * i), this.prevClients = t, r;
  }
  getPositions(t = this.prevClients) {
    const n = this.prevClients, r = this.startClients, s = Math.min(this.length, n.length), i = [];
    for (let o = 0; o < s; ++o)
      i[o] = ps([t[o]], [n[o]], [r[o]]);
    return i;
  }
  getMovement(t) {
    const n = this.movement;
    if (!t)
      return n;
    const r = Xe(t, this.length), s = Xe(this.prevClients, this.length), i = r.clientX - s.clientX, o = r.clientY - s.clientY;
    return Math.sqrt(i * i + o * o) + n;
  }
  getDistance(t = this.prevClients) {
    return Vn(t);
  }
  getScale(t = this.prevClients) {
    return Vn(t) / Vn(this.startClients);
  }
  move(t, n) {
    this.startClients.forEach((r) => {
      r.clientX -= t, r.clientY -= n;
    }), this.prevClients.forEach((r) => {
      r.clientX -= t, r.clientY -= n;
    });
  }
}
const gs = ["textarea", "input"];
class Bn extends Ie {
  /**
   *
   */
  constructor(t, n = {}) {
    super(), Object.defineProperty(this, "options", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "flag", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "pinchFlag", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "isDrag", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "isPinch", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "clientStores", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "targets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "prevTime", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "doubleFlag", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_useMouse", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_useTouch", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_useDrag", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dragFlag", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isTrusted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isMouseEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isSecondaryButton", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_preventMouseEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_prevInputEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_isDragAPI", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isIdle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_preventMouseEventId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_window", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: window
    }), Object.defineProperty(this, "onDragStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l, c = !0) => {
        if (!this.flag && l.cancelable === !1)
          return;
        const u = l.type.indexOf("drag") >= -1;
        if (this.flag && u)
          return;
        this._isDragAPI = !0;
        const { container: f, pinchOutside: h, preventWheelClick: d, preventRightClick: p, preventDefault: g, checkInput: m, dragFocusedInput: b, preventClickEventOnDragStart: S, preventClickEventOnDrag: v, preventClickEventByCondition: E } = this.options, x = this._useTouch, w = !this.flag;
        if (this._isSecondaryButton = l.which === 3 || l.button === 2, d && (l.which === 2 || l.button === 1) || p && (l.which === 3 || l.button === 2))
          return this.stop(), !1;
        if (w) {
          const C = this._window.document.activeElement, P = l.target;
          if (P) {
            const y = P.tagName.toLowerCase(), T = gs.indexOf(y) > -1, O = P.isContentEditable;
            if (T || O) {
              if (m || !b && C === P)
                return !1;
              if (C && (C === P || O && C.isContentEditable && C.contains(P)))
                if (b)
                  P.blur();
                else
                  return !1;
            } else if ((g || l.type === "touchstart") && C) {
              const R = C.tagName.toLowerCase();
              (C.isContentEditable || gs.indexOf(R) > -1) && C.blur();
            }
            (S || v || E) && it(this._window, "click", this._onClick, !0);
          }
          this.clientStores = [new qn(rn(l))], this._isIdle = !1, this.flag = !0, this.isDrag = !1, this._isTrusted = c, this._dragFlag = !0, this._prevInputEvent = l, this.data = {}, this.doubleFlag = Ve() - this.prevTime < 200, this._isMouseEvent = Ca(l), !this._isMouseEvent && this._preventMouseEvent && this._allowMouseEvent(), (this._preventMouseEvent || this.emit("dragStart", {
            data: this.data,
            datas: this.data,
            inputEvent: l,
            isMouseEvent: this._isMouseEvent,
            isSecondaryButton: this._isSecondaryButton,
            isTrusted: c,
            isDouble: this.doubleFlag,
            ...this.getCurrentStore().getPosition(),
            preventDefault() {
              l.preventDefault();
            },
            preventDrag: () => {
              this._dragFlag = !1;
            }
          })) === !1 && this.stop(), this._isMouseEvent && this.flag && g && l.preventDefault();
        }
        if (!this.flag)
          return !1;
        let D = 0;
        if (w ? (this._attchDragEvent(), x && h && (D = setTimeout(() => {
          it(f, "touchstart", this.onDragStart, {
            passive: !1
          });
        }))) : x && h && et(f, "touchstart", this.onDragStart), this.flag && wa(l)) {
          if (clearTimeout(D), w && l.touches.length !== l.changedTouches.length)
            return;
          this.pinchFlag || this.onPinchStart(l);
        }
      }
    }), Object.defineProperty(this, "onDrag", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l, c) => {
        if (!this.flag)
          return;
        const { preventDefault: u } = this.options;
        !this._isMouseEvent && u && l.preventDefault(), this._prevInputEvent = l;
        const f = rn(l), h = this.moveClients(f, l, !1);
        if (this._dragFlag) {
          if ((this.pinchFlag || h.deltaX || h.deltaY) && (this._preventMouseEvent || this.emit("drag", {
            ...h,
            isScroll: !!c,
            inputEvent: l
          })) === !1) {
            this.stop();
            return;
          }
          this.pinchFlag && this.onPinch(l, f);
        }
        this.getCurrentStore().getPosition(f, !0);
      }
    }), Object.defineProperty(this, "onDragEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        if (!this.flag)
          return;
        const { pinchOutside: c, container: u, preventClickEventOnDrag: f, preventClickEventOnDragStart: h, preventClickEventByCondition: d } = this.options, p = this.isDrag;
        (f || h || d) && requestAnimationFrame(() => {
          this._allowClickEvent();
        }), !d && !h && f && !p && this._allowClickEvent(), this._useTouch && c && et(u, "touchstart", this.onDragStart), this.pinchFlag && this.onPinchEnd(l);
        const g = l != null && l.touches ? rn(l) : [];
        g.length === 0 || !this.options.keepDragging ? this.flag = !1 : this._addStore(new qn(g));
        const b = this._getPosition(), S = Ve(), v = !p && this.doubleFlag;
        this._prevInputEvent = null, this.prevTime = p || v ? 0 : S, this.flag || (this._dettachDragEvent(), this._preventMouseEvent || this.emit("dragEnd", {
          data: this.data,
          datas: this.data,
          isDouble: v,
          isDrag: p,
          isClick: !p,
          isMouseEvent: this._isMouseEvent,
          isSecondaryButton: this._isSecondaryButton,
          inputEvent: l,
          isTrusted: this._isTrusted,
          ...b
        }), this.clientStores = [], this._isMouseEvent || (this._preventMouseEvent = !0, clearTimeout(this._preventMouseEventId), this._preventMouseEventId = setTimeout(() => {
          this._preventMouseEvent = !1;
        }, 200)), this._isIdle = !0);
      }
    }), Object.defineProperty(this, "onBlur", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        this.onDragEnd();
      }
    }), Object.defineProperty(this, "_allowClickEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        et(this._window, "click", this._onClick, !0);
      }
    }), Object.defineProperty(this, "_onClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        this._allowClickEvent(), this._allowMouseEvent();
        const c = this.options.preventClickEventByCondition;
        c != null && c(l) || (l.stopPropagation(), l.preventDefault());
      }
    }), Object.defineProperty(this, "_onContextMenu", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        this.options.preventRightClick ? this.onDragEnd(l) : l.preventDefault();
      }
    }), Object.defineProperty(this, "_passCallback", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
      }
    });
    const r = [].concat(t), s = r[0];
    this._window = di(s) ? s : yt(s), this.options = {
      checkInput: !1,
      container: s && !("document" in s) ? yt(s) : s,
      preventRightClick: !0,
      preventWheelClick: !0,
      preventClickEventOnDragStart: !1,
      preventClickEventOnDrag: !1,
      preventClickEventByCondition: null,
      preventDefault: !0,
      checkWindowBlur: !1,
      keepDragging: !1,
      pinchThreshold: 0,
      events: ["touch", "mouse"],
      ...n
    };
    const { container: i, events: o, checkWindowBlur: a } = this.options;
    if (this._useDrag = o.indexOf("drag") > -1, this._useTouch = o.indexOf("touch") > -1, this._useMouse = o.indexOf("mouse") > -1, this.targets = r, this._useDrag && r.forEach((l) => {
      it(l, "dragstart", this.onDragStart);
    }), this._useMouse && (r.forEach((l) => {
      it(l, "mousedown", this.onDragStart), it(l, "mousemove", this._passCallback);
    }), it(i, "contextmenu", this._onContextMenu)), a && it(yt(), "blur", this.onBlur), this._useTouch) {
      const l = {
        passive: !1
      };
      r.forEach((c) => {
        it(c, "touchstart", this.onDragStart, l), it(c, "touchmove", this._passCallback, l);
      });
    }
  }
  /**
   * Stop Gesto's drag events.
   */
  stop() {
    this.isDrag = !1, this.data = {}, this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1, this._isIdle = !0, this._allowClickEvent(), this._dettachDragEvent(), this._isDragAPI = !1;
  }
  /**
   * The total moved distance
   */
  getMovement(t) {
    return this.getCurrentStore().getMovement(t) + this.clientStores.slice(1).reduce((n, r) => n + r.movement, 0);
  }
  /**
   * Whether to drag
   */
  isDragging() {
    return this.isDrag;
  }
  /**
   * Whether the operation of gesto is finished and is in idle state
   */
  isIdle() {
    return this._isIdle;
  }
  /**
   * Whether to start drag
   */
  isFlag() {
    return this.flag;
  }
  /**
   * Whether to start pinch
   */
  isPinchFlag() {
    return this.pinchFlag;
  }
  /**
   * Whether to start double click
   */
  isDoubleFlag() {
    return this.doubleFlag;
  }
  /**
   * Whether to pinch
   */
  isPinching() {
    return this.isPinch;
  }
  /**
   * If a scroll event occurs, it is corrected by the scroll distance.
   */
  scrollBy(t, n, r, s = !0) {
    this.flag && (this.clientStores[0].move(t, n), s && this.onDrag(r, !0));
  }
  /**
   * Create a virtual drag event.
   */
  move([t, n], r) {
    const i = this.getCurrentStore().prevClients;
    return this.moveClients(i.map(({ clientX: o, clientY: a }) => ({
      clientX: o + t,
      clientY: a + n,
      originalClientX: o,
      originalClientY: a
    })), r, !0);
  }
  /**
   * The dragStart event is triggered by an external event.
   */
  triggerDragStart(t) {
    this.onDragStart(t, !1);
  }
  /**
   * Set the event data while dragging.
   */
  setEventData(t) {
    const n = this.data;
    for (const r in t)
      n[r] = t[r];
    return this;
  }
  /**
   * Set the event data while dragging.
   * Use `setEventData`
   * @deprecated
   */
  setEventDatas(t) {
    return this.setEventData(t);
  }
  /**
   * Get the current event state while dragging.
   */
  getCurrentEvent(t = this._prevInputEvent) {
    return {
      data: this.data,
      datas: this.data,
      ...this._getPosition(),
      movement: this.getMovement(),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: !1,
      inputEvent: t
    };
  }
  /**
   * Get & Set the event data while dragging.
   */
  getEventData() {
    return this.data;
  }
  /**
   * Get & Set the event data while dragging.
   * Use getEventData method
   * @depreacated
   */
  getEventDatas() {
    return this.data;
  }
  /**
   * Unset Gesto
   */
  unset() {
    const t = this.targets, n = this.options.container;
    this.off(), et(this._window, "blur", this.onBlur), this._useDrag && t.forEach((r) => {
      et(r, "dragstart", this.onDragStart);
    }), this._useMouse && (t.forEach((r) => {
      et(r, "mousedown", this.onDragStart);
    }), et(n, "contextmenu", this._onContextMenu)), this._useTouch && (t.forEach((r) => {
      et(r, "touchstart", this.onDragStart);
    }), et(n, "touchstart", this.onDragStart)), this._prevInputEvent = null, this._allowClickEvent(), this._dettachDragEvent();
  }
  onPinchStart(t) {
    const { pinchThreshold: n } = this.options;
    if (this.isDrag && this.getMovement() > n)
      return;
    const r = new qn(rn(t));
    this.pinchFlag = !0, this._addStore(r), this.emit("pinchStart", {
      data: this.data,
      datas: this.data,
      angle: r.getAngle(),
      touches: this.getCurrentStore().getPositions(),
      ...r.getPosition(),
      inputEvent: t,
      isTrusted: this._isTrusted,
      preventDefault() {
        t.preventDefault();
      },
      preventDrag: () => {
        this._dragFlag = !1;
      }
    }) === !1 && (this.pinchFlag = !1);
  }
  onPinch(t, n) {
    if (!this.flag || !this.pinchFlag || n.length < 2)
      return;
    const r = this.getCurrentStore();
    this.isPinch = !0, this.emit("pinch", {
      data: this.data,
      datas: this.data,
      movement: this.getMovement(n),
      angle: r.getAngle(n),
      rotation: r.getRotation(n),
      touches: r.getPositions(n),
      scale: r.getScale(n),
      distance: r.getDistance(n),
      ...r.getPosition(n),
      inputEvent: t,
      isTrusted: this._isTrusted
    });
  }
  onPinchEnd(t) {
    if (!this.pinchFlag)
      return;
    const n = this.isPinch;
    this.isPinch = !1, this.pinchFlag = !1;
    const r = this.getCurrentStore();
    this.emit("pinchEnd", {
      data: this.data,
      datas: this.data,
      isPinch: n,
      touches: r.getPositions(),
      ...r.getPosition(),
      inputEvent: t
    });
  }
  getCurrentStore() {
    return this.clientStores[0];
  }
  moveClients(t, n, r) {
    const s = this._getPosition(t, r), i = this.isDrag;
    (s.deltaX || s.deltaY) && (this.isDrag = !0);
    let o = !1;
    return !i && this.isDrag && (o = !0), {
      data: this.data,
      datas: this.data,
      ...s,
      movement: this.getMovement(t),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: !1,
      isMouseEvent: this._isMouseEvent,
      isSecondaryButton: this._isSecondaryButton,
      inputEvent: n,
      isTrusted: this._isTrusted,
      isFirstDrag: o
    };
  }
  _addStore(t) {
    this.clientStores.splice(0, 0, t);
  }
  _getPosition(t, n) {
    const s = this.getCurrentStore().getPosition(t, n), { distX: i, distY: o } = this.clientStores.slice(1).reduce((a, l) => {
      const c = l.getPosition();
      return a.distX += c.distX, a.distY += c.distY, a;
    }, s);
    return {
      ...s,
      distX: i,
      distY: o
    };
  }
  _attchDragEvent() {
    const t = this._window, n = this.options.container, r = {
      passive: !1
    };
    this._isDragAPI && (it(n, "dragover", this.onDrag, r), it(t, "dragend", this.onDragEnd)), this._useMouse && (it(n, "mousemove", this.onDrag), it(t, "mouseup", this.onDragEnd)), this._useTouch && (it(n, "touchmove", this.onDrag, r), it(t, "touchend", this.onDragEnd, r), it(t, "touchcancel", this.onDragEnd, r));
  }
  _dettachDragEvent() {
    const t = this._window, n = this.options.container;
    this._isDragAPI && (et(n, "dragover", this.onDrag), et(t, "dragend", this.onDragEnd)), this._useMouse && (et(n, "mousemove", this.onDrag), et(t, "mouseup", this.onDragEnd)), this._useTouch && (et(n, "touchstart", this.onDragStart), et(n, "touchmove", this.onDrag), et(t, "touchend", this.onDragEnd), et(t, "touchcancel", this.onDragEnd));
  }
  _allowMouseEvent() {
    this._preventMouseEvent = !1, clearTimeout(this._preventMouseEventId);
  }
}
class Pa {
  constructor() {
    Object.defineProperty(this, "keys", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "values", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  get(t) {
    const n = this.keys.indexOf(t);
    return n !== -1 ? this.values[n] : void 0;
  }
  set(t, n) {
    const r = this.keys.indexOf(t);
    r === -1 ? (this.keys.push(t), this.values.push(n)) : this.values[r] = n;
  }
}
class Da {
  constructor() {
    Object.defineProperty(this, "object", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  get(t) {
    return this.object[t];
  }
  set(t, n) {
    this.object[t] = n;
  }
}
const Oa = typeof Map == "function";
class Ma {
  constructor() {
    Object.defineProperty(this, "prev", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "next", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  connect(t, n) {
    this.prev = t, this.next = n, t && (t.next = this), n && (n.prev = this);
  }
  disconnect() {
    const { prev: t, next: n } = this;
    t && (t.next = n), n && (n.prev = t);
  }
  getIndex() {
    let t = -1, n = this;
    for (; n; )
      n = n.prev, ++t;
    return t;
  }
}
function Ta(e, t) {
  const n = [], r = [];
  return e.forEach(([s, i]) => {
    const o = new Ma();
    n[s] = o, r[i] = o;
  }), n.forEach((s, i) => {
    s.connect(n[i - 1]);
  }), e.filter((s, i) => !t[i]).map(([s, i]) => {
    if (s === i)
      return [0, 0];
    const o = n[s], a = r[i - 1], l = o.getIndex();
    o.disconnect(), o.connect(a, a == null ? void 0 : a.next);
    const c = o.getIndex();
    return [l, c];
  });
}
class Ra {
  constructor(t, n, r, s, i, o, a, l) {
    Object.defineProperty(this, "prevList", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "list", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "added", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "removed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "changed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maintained", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "changedBeforeAdded", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fixed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cacheOrdered", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cachePureChanged", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.prevList = t, this.list = n, this.added = r, this.removed = s, this.changed = i, this.maintained = o, this.changedBeforeAdded = a, this.fixed = l;
  }
  get ordered() {
    return this.cacheOrdered || this.calculateOrdered(), this.cacheOrdered;
  }
  get pureChanged() {
    return this.cachePureChanged || this.calculateOrdered(), this.cachePureChanged;
  }
  calculateOrdered() {
    const t = Ta(this.changedBeforeAdded, this.fixed), n = [];
    this.cacheOrdered = t.filter(([r, s], i) => {
      const [o, a] = this.changed[i];
      return r !== s ? (n.push([o, a]), !0) : !1;
    }), this.cachePureChanged = n;
  }
}
function An(e, t, n) {
  const r = Oa ? Map : n ? Da : Pa, s = n || ((S) => S), i = [], o = [], a = [], l = e.map(s), c = t.map(s), u = new r(), f = new r(), h = [], d = [], p = {}, g = [];
  let m = 0, b = 0;
  return l.forEach((S, v) => {
    u.set(S, v);
  }), c.forEach((S, v) => {
    f.set(S, v);
  }), l.forEach((S, v) => {
    const E = f.get(S);
    E === void 0 ? (o.push(v), ++b) : p[E] = b;
  }), c.forEach((S, v) => {
    const E = u.get(S);
    E === void 0 ? (i.push(v), ++m) : (a.push([E, v]), b = p[v] || 0, h.push([
      E - b,
      v - m
    ]), d.push(v === E), E !== v && g.push([E, v]));
  }), o.reverse(), new Ra(e, t, i, o, g, a, h, d);
}
class gi {
  constructor(t = [], n) {
    Object.defineProperty(this, "findKeyCallback", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "list", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.findKeyCallback = n, this.list = [...t];
  }
  update(t) {
    const n = [...t], r = An(this.list, n, this.findKeyCallback);
    return this.list = n, r;
  }
}
Object.defineProperty(gi, "diff", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: An
});
const mi = typeof Map == "function" ? void 0 : /* @__PURE__ */ (() => {
  let e = 0;
  return (t) => t.__DIFF_KEY__ || (t.__DIFF_KEY__ = ++e);
})();
class bi extends gi {
  /**
   * @param - Initializing Children <ko> 초기 설정할 자식 노드들</ko>
   */
  constructor(t = []) {
    super(t, mi);
  }
}
function Se(e, t) {
  return An(e, t, mi);
}
function za(e) {
  let t = e.container;
  return t === document.body ? [
    t.scrollLeft || document.documentElement.scrollLeft,
    t.scrollTop || document.documentElement.scrollTop
  ] : [t.scrollLeft, t.scrollTop];
}
function ms(e, t) {
  return e.addEventListener("scroll", t), () => {
    e.removeEventListener("scroll", t);
  };
}
function sn(e) {
  if (e) {
    if (jt(e))
      return document.querySelector(e);
  } else return null;
  if (In(e))
    return e();
  if (e instanceof Element)
    return e;
  if ("current" in e)
    return e.current;
  if ("value" in e)
    return e.value;
}
class vi extends Ie {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_startRect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_startPos", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_prevTime", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_timer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_prevScrollPos", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [0, 0]
    }), Object.defineProperty(this, "_isWait", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_flag", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_currentOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_lock", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_unregister", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_onScroll", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const t = this._currentOptions;
        this._lock || !t || this.emit("scrollDrag", {
          next: (n) => {
            this.checkScroll({
              container: t.container,
              inputEvent: n
            });
          }
        });
      }
    });
  }
  /**
   */
  dragStart(t, n) {
    const r = sn(n.container);
    if (!r) {
      this._flag = !1;
      return;
    }
    let s = 0, i = 0, o = 0, a = 0;
    if (r === document.body)
      o = window.innerWidth, a = window.innerHeight;
    else {
      const l = r.getBoundingClientRect();
      s = l.top, i = l.left, o = l.width, a = l.height;
    }
    this._flag = !0, this._startPos = [t.clientX, t.clientY], this._startRect = { top: s, left: i, width: o, height: a }, this._prevScrollPos = this._getScrollPosition([0, 0], n), this._currentOptions = n, this._registerScrollEvent(n);
  }
  drag(t, n) {
    if (clearTimeout(this._timer), !this._flag)
      return;
    const { clientX: r, clientY: s } = t, { threshold: i = 0 } = n, { _startRect: o, _startPos: a } = this;
    this._currentOptions = n;
    const l = [0, 0];
    return o.top > s - i ? (a[1] > o.top || s < a[1]) && (l[1] = -1) : o.top + o.height < s + i && (a[1] < o.top + o.height || s > a[1]) && (l[1] = 1), o.left > r - i ? (a[0] > o.left || r < a[0]) && (l[0] = -1) : o.left + o.width < r + i && (a[0] < o.left + o.width || r > a[0]) && (l[0] = 1), !l[0] && !l[1] ? !1 : this._continueDrag({
      ...n,
      direction: l,
      inputEvent: t,
      isDrag: !0
    });
  }
  /**
   */
  checkScroll(t) {
    if (this._isWait)
      return !1;
    const { prevScrollPos: n = this._prevScrollPos, direction: r, throttleTime: s = 0, inputEvent: i, isDrag: o } = t, a = this._getScrollPosition(r || [0, 0], t), l = a[0] - n[0], c = a[1] - n[1], u = r || [
      l ? Math.abs(l) / l : 0,
      c ? Math.abs(c) / c : 0
    ];
    return this._prevScrollPos = a, this._lock = !1, !l && !c ? !1 : (this.emit("move", {
      offsetX: u[0] ? l : 0,
      offsetY: u[1] ? c : 0,
      inputEvent: i
    }), s && o && (clearTimeout(this._timer), this._timer = window.setTimeout(() => {
      this._continueDrag(t);
    }, s)), !0);
  }
  /**
   *
   */
  dragEnd() {
    this._flag = !1, this._lock = !1, clearTimeout(this._timer), this._unregisterScrollEvent();
  }
  _getScrollPosition(t, n) {
    const { container: r, getScrollPosition: s = za } = n;
    return s({
      container: sn(r),
      direction: t
    });
  }
  _continueDrag(t) {
    var h;
    const { container: n, direction: r, throttleTime: s, useScroll: i, isDrag: o, inputEvent: a } = t;
    if (!this._flag || o && this._isWait)
      return;
    const l = Ve(), c = Math.max(s + this._prevTime - l, 0);
    if (c > 0)
      return clearTimeout(this._timer), this._timer = window.setTimeout(() => {
        this._continueDrag(t);
      }, c), !1;
    this._prevTime = l;
    const u = this._getScrollPosition(r, t);
    this._prevScrollPos = u, o && (this._isWait = !0), i || (this._lock = !0);
    const f = {
      container: sn(n),
      direction: r,
      inputEvent: a
    };
    return (h = t.requestScroll) == null || h.call(t, f), this.emit("scroll", f), this._isWait = !1, i || this.checkScroll({
      ...t,
      prevScrollPos: u,
      direction: r,
      inputEvent: a
    });
  }
  _registerScrollEvent(t) {
    this._unregisterScrollEvent();
    const n = t.checkScrollEvent;
    if (!n)
      return;
    const r = n === !0 ? ms : n, s = sn(t.container);
    n === !0 && (s === document.body || s === document.documentElement) ? this._unregister = ms(window, this._onScroll) : this._unregister = r(s, this._onScroll);
  }
  _unregisterScrollEvent() {
    var t;
    (t = this._unregister) == null || t.call(this), this._unregister = null;
  }
}
function Ct(e) {
  return V(e, ft);
}
function _a(e, t) {
  return e.every((n, r) => Ct(n - t[r]) === 0);
}
function Ia(e, t) {
  return !Ct(e[0] - t[0]) && !Ct(e[1] - t[1]);
}
function Ye(e) {
  return e.length < 3 ? 0 : Math.abs(Ba(e.map((t, n) => {
    const r = e[n + 1] || e[0];
    return t[0] * r[1] - r[0] * t[1];
  }))) / 2;
}
function Ba(e) {
  const t = e.length;
  let n = 0;
  for (let r = t - 1; r >= 0; --r)
    n += e[r];
  return n;
}
function lr(e, t) {
  return Aa(e, t).map(({ pos: r }) => r);
}
function cr(e) {
  return [...e.slice(1), e[0]].map((t, n) => [e[n], t]);
}
function wn(e, t) {
  const [n, r] = e, [s, i] = t;
  let o = s - n, a = i - r;
  Math.abs(o) < ft && (o = 0), Math.abs(a) < ft && (a = 0);
  let l = 0, c = 0, u = 0;
  return o ? a ? (l = -a / o, c = 1, u = -l * n - r) : (c = 1, u = -r) : a && (l = -1, u = n), [l, c, u];
}
function Aa(e, t) {
  const n = e.slice(), r = t.slice();
  fs(n) === -1 && n.reverse(), fs(r) === -1 && r.reverse();
  const s = cr(n), i = cr(r), o = s.map((u) => wn(u[0], u[1])), a = i.map((u) => wn(u[0], u[1])), l = [];
  o.forEach((u, f) => {
    const h = s[f], d = [];
    a.forEach((p, g) => {
      const m = Br(u, p), b = Si(m, [h, i[g]]);
      d.push(...b.map((S) => ({
        index1: f,
        index2: g,
        pos: S,
        type: "intersection"
      })));
    }), d.sort((p, g) => Ft(h[0], p.pos) - Ft(h[0], g.pos)), l.push(...d), Cn(h[1], r) && l.push({
      index1: f,
      index2: -1,
      pos: h[1],
      type: "inside"
    });
  }), i.forEach((u, f) => {
    if (!Cn(u[1], n))
      return;
    let h = !1, d = qt(l, ({ index2: p }) => p === f ? (h = !0, !1) : !!h);
    d === -1 && (h = !1, d = qt(l, ({ index1: p, index2: g }) => p === -1 && g + 1 === f ? (h = !0, !1) : !!h)), d === -1 ? l.push({
      index1: -1,
      index2: f,
      pos: u[1],
      type: "inside"
    }) : l.splice(d, 0, {
      index1: -1,
      index2: f,
      pos: u[1],
      type: "inside"
    });
  });
  const c = {};
  return l.filter(({ pos: u }) => {
    const f = `${u[0]}x${u[1]}`;
    return c[f] ? !1 : (c[f] = !0, !0);
  });
}
function Br(e, t) {
  const [n, r, s] = e, [i, o, a] = t, l = n === 0 && i === 0, c = r === 0 && o === 0;
  let u = [];
  if (l && c)
    return [];
  if (l) {
    const f = -s / r, h = -a / o;
    return f !== h ? [] : [
      [-1 / 0, f],
      [1 / 0, f]
    ];
  } else if (c) {
    const f = -s / n, h = -a / i;
    return f !== h ? [] : [
      [f, -1 / 0],
      [f, 1 / 0]
    ];
  } else if (n === 0) {
    const f = -s / r;
    u = [[-(o * f + a) / i, f]];
  } else if (i === 0) {
    const f = -a / o;
    u = [[-(r * f + s) / n, f]];
  } else if (r === 0) {
    const f = -s / n, h = -(i * f + a) / o;
    u = [[f, h]];
  } else if (o === 0) {
    const f = -a / i, h = -(n * f + s) / r;
    u = [[f, h]];
  } else {
    const f = (r * a - o * s) / (o * n - r * i), h = -(n * f + s) / r;
    u = [[f, h]];
  }
  return u.map((f) => [f[0], f[1]]);
}
function Si(e, t) {
  const n = t.map((s) => [0, 1].map((i) => [
    Math.min(s[0][i], s[1][i]),
    Math.max(s[0][i], s[1][i])
  ]));
  let r = [];
  if (e.length === 2) {
    const [s, i] = e[0];
    if (Ct(s - e[1][0])) {
      if (!Ct(i - e[1][1])) {
        const o = Math.max(...n.map((l) => l[0][0])), a = Math.min(...n.map((l) => l[0][1]));
        if (Ct(o - a) > 0)
          return [];
        r = [
          [o, i],
          [a, i]
        ];
      }
    } else {
      const o = Math.max(...n.map((l) => l[1][0])), a = Math.min(...n.map((l) => l[1][1]));
      if (Ct(o - a) > 0)
        return [];
      r = [
        [s, o],
        [s, a]
      ];
    }
  }
  return r.length || (r = e.filter((s) => {
    const [i, o] = s;
    return n.every((a) => 0 <= Ct(i - a[0][0]) && 0 <= Ct(a[0][1] - i) && 0 <= Ct(o - a[1][0]) && 0 <= Ct(a[1][1] - o));
  })), r.map((s) => [
    Ct(s[0]),
    Ct(s[1])
  ]);
}
function Cn(e, t, n) {
  const [r, s] = e, { minX: i, maxX: o } = ce(t), a = [
    [i, s],
    [o, s]
  ], l = wn(a[0], a[1]), c = cr(t), u = [];
  if (c.forEach((d) => {
    const p = wn(d[0], d[1]), g = d[0];
    _a(l, p) ? u.push({
      pos: e,
      line: d,
      type: "line"
    }) : Si(Br(l, p), [a, d]).forEach((b) => {
      d.some((S) => Ia(S, b)) ? u.push({
        pos: b,
        line: d,
        type: "point"
      }) : Ct(g[1] - s) !== 0 && u.push({
        pos: b,
        line: d,
        type: "intersection"
      });
    });
  }), Ot(u, (d) => d[0] === r))
    return !0;
  let f = 0;
  const h = {};
  return u.forEach(({ pos: d, type: p, line: g }) => {
    if (!(d[0] > r))
      if (p === "intersection")
        ++f;
      else {
        if (p === "line")
          return;
        if (p === "point") {
          const m = Ot(g, (v) => v[1] !== s), b = h[d[0]], S = m[1] > s ? 1 : -1;
          b ? b !== S && ++f : h[d[0]] = S;
        }
      }
  }), f % 2 === 1;
}
function ce(e) {
  const t = e.map((r) => r[0]), n = e.map((r) => r[1]);
  return {
    minX: Math.min(...t),
    minY: Math.min(...n),
    maxX: Math.max(...t),
    maxY: Math.max(...n)
  };
}
function ur(e, t) {
  const { width: n, height: r, left: s, top: i } = t, { minX: o, minY: a, maxX: l, maxY: c } = ce(e), u = n / (l - o), f = r / (c - a);
  return e.map((h) => [
    s + (h[0] - o) * u,
    i + (h[1] - a) * f
  ]);
}
function Ga(e, t) {
  const n = lr(e, t);
  return Ye(n);
}
function $a(e, t, n, r, s, i) {
  for (let o = 0; o < s; ++o) {
    const a = n + o * s, l = r + o * s;
    e[a] += e[l] * i, t[a] += t[l] * i;
  }
}
function ka(e, t, n, r, s) {
  for (let i = 0; i < s; ++i) {
    const o = n + i * s, a = r + i * s, l = e[o], c = t[o];
    e[o] = e[a], e[a] = l, t[o] = t[a], t[a] = c;
  }
}
function ja(e, t, n, r, s) {
  for (let i = 0; i < r; ++i) {
    const o = n + i * r;
    e[o] /= s, t[o] /= s;
  }
}
function xi(e, t, n = Math.sqrt(e.length)) {
  const r = e.slice();
  for (let s = 0; s < n; ++s)
    r[s * n + t - 1] = 0, r[(t - 1) * n + s] = 0;
  return r[(t - 1) * (n + 1)] = 1, r;
}
function $t(e, t = Math.sqrt(e.length)) {
  const n = e.slice(), r = nt(t);
  for (let s = 0; s < t; ++s) {
    const i = t * s + s;
    if (!V(n[i], ft)) {
      for (let o = s + 1; o < t; ++o)
        if (n[t * s + o]) {
          ka(n, r, s, o, t);
          break;
        }
    }
    if (!V(n[i], ft))
      return [];
    ja(n, r, s, t, n[i]);
    for (let o = 0; o < t; ++o) {
      const a = o, l = o + s * t, c = n[l];
      !V(c, ft) || s === o || $a(n, r, a, s, t, -c);
    }
  }
  return r;
}
function Xa(e, t = Math.sqrt(e.length)) {
  const n = [];
  for (let r = 0; r < t; ++r)
    for (let s = 0; s < t; ++s)
      n[s * t + r] = e[t * r + s];
  return n;
}
function Ei(e, t = Math.sqrt(e.length)) {
  const n = [], r = e[t * t - 1];
  for (let s = 0; s < t - 1; ++s)
    n[s] = e[t * (t - 1) + s] / r;
  return n[t - 1] = 0, n;
}
function Ya(e, t) {
  const n = nt(t);
  for (let r = 0; r < t - 1; ++r)
    n[t * (t - 1) + r] = e[r] || 0;
  return n;
}
function ue(e, t) {
  const n = e.slice();
  for (let r = e.length; r < t - 1; ++r)
    n[r] = 0;
  return n[t - 1] = 1, n;
}
function kt(e, t = Math.sqrt(e.length), n) {
  if (t === n)
    return e;
  const r = nt(n), s = Math.min(t, n);
  for (let i = 0; i < s - 1; ++i) {
    for (let o = 0; o < s - 1; ++o)
      r[i * n + o] = e[i * t + o];
    r[(i + 1) * n - 1] = e[(i + 1) * t - 1], r[(n - 1) * n + i] = e[(t - 1) * t + i];
  }
  return r[n * n - 1] = e[t * t - 1], r;
}
function yn(e, ...t) {
  let n = nt(e);
  return t.forEach((r) => {
    n = tt(n, r, e);
  }), n;
}
function tt(e, t, n = Math.sqrt(e.length)) {
  const r = [], s = e.length / n, i = t.length / s;
  if (s) {
    if (!i)
      return e;
  } else return t;
  for (let o = 0; o < n; ++o)
    for (let a = 0; a < i; ++a) {
      r[a * n + o] = 0;
      for (let l = 0; l < s; ++l)
        r[a * n + o] += e[l * n + o] * t[a * s + l];
    }
  return r;
}
function Q(e, t) {
  const n = Math.min(e.length, t.length), r = e.slice();
  for (let s = 0; s < n; ++s)
    r[s] = r[s] + t[s];
  return r;
}
function W(e, t) {
  const n = Math.min(e.length, t.length), r = e.slice();
  for (let s = 0; s < n; ++s)
    r[s] = r[s] - t[s];
  return r;
}
function Fa(e, t = e.length === 6) {
  return t ? [e[0], e[1], 0, e[2], e[3], 0, e[4], e[5], 1] : e;
}
function wi(e, t = e.length === 9) {
  return t ? [e[0], e[1], e[3], e[4], e[6], e[7]] : e;
}
function mt(e, t, n = t.length) {
  const r = tt(e, t, n), s = r[n - 1];
  return r.map((i) => i / s);
}
function La(e, t) {
  return tt(e, [
    1,
    0,
    0,
    0,
    0,
    Math.cos(t),
    Math.sin(t),
    0,
    0,
    -Math.sin(t),
    Math.cos(t),
    0,
    0,
    0,
    0,
    1
  ], 4);
}
function Wa(e, t) {
  return tt(e, [
    Math.cos(t),
    0,
    -Math.sin(t),
    0,
    0,
    1,
    0,
    0,
    Math.sin(t),
    0,
    Math.cos(t),
    0,
    0,
    0,
    0,
    1
  ], 4);
}
function Na(e, t) {
  return tt(e, Ke(t, 4));
}
function on(e, [t = 1, n = 1, r = 1]) {
  return tt(e, [t, 0, 0, 0, 0, n, 0, 0, 0, 0, r, 0, 0, 0, 0, 1], 4);
}
function Ze(e, t) {
  return mt(Ke(t, 3), ue(e, 3));
}
function Un(e, [t = 0, n = 0, r = 0]) {
  return tt(e, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, t, n, r, 1], 4);
}
function fr(e, t) {
  return tt(e, t, 4);
}
function Ke(e, t) {
  const n = Math.cos(e), r = Math.sin(e), s = nt(t);
  return s[0] = n, s[1] = r, s[t] = -r, s[t + 1] = n, s;
}
function nt(e) {
  const t = e * e, n = [];
  for (let r = 0; r < t; ++r)
    n[r] = r % (e + 1) ? 0 : 1;
  return n;
}
function Ar(e, t) {
  const n = nt(t), r = Math.min(e.length, t - 1);
  for (let s = 0; s < r; ++s)
    n[(t + 1) * s] = e[s];
  return n;
}
function fe(e, t) {
  const n = nt(t), r = Math.min(e.length, t - 1);
  for (let s = 0; s < r; ++s)
    n[t * (t - 1) + s] = e[s];
  return n;
}
function Gr(e, t, n, r, s, i, o, a) {
  const [l, c] = e, [u, f] = t, [h, d] = n, [p, g] = r, [m, b] = s, [S, v] = i, [E, x] = o, [w, D] = a, C = [
    l,
    0,
    u,
    0,
    h,
    0,
    p,
    0,
    c,
    0,
    f,
    0,
    d,
    0,
    g,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    l,
    0,
    u,
    0,
    h,
    0,
    p,
    0,
    c,
    0,
    f,
    0,
    d,
    0,
    g,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    -m * l,
    -b * l,
    -S * u,
    -v * u,
    -E * h,
    -x * h,
    -w * p,
    -D * p,
    -m * c,
    -b * c,
    -S * f,
    -v * f,
    -E * d,
    -x * d,
    -w * g,
    -D * g
  ], P = $t(C, 8);
  if (!P.length)
    return [];
  const M = tt(P, [m, b, S, v, E, x, w, D], 8);
  return M[8] = 1, kt(Xa(M), 3, 4);
}
function $r() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function De(e, t = 0) {
  return ve(Oe(e, t));
}
function vn(e, t) {
  const n = mt(e, [t[0], t[1] || 0, t[2] || 0, 1], 4), r = n[3] || 1;
  return [n[0] / r, n[1] / r, n[2] / r];
}
function Ha(e, t = document.body) {
  let n = e, r = $r();
  for (; n; ) {
    const s = getComputedStyle(n).transform;
    if (r = fr(De(s), r), n === t)
      break;
    n = n.parentElement;
  }
  return r = $t(r, 4), r[12] = 0, r[13] = 0, r[14] = 0, r;
}
function ve(e) {
  let t = $r();
  return e.forEach((n) => {
    const { matrixFunction: r, functionValue: s } = n;
    r && (t = r(t, s));
  }), t;
}
function Oe(e, t = 0) {
  return (at(e) ? e : Jt(e)).map((r) => {
    const { prefix: s, value: i } = ci(r);
    let o = null, a = s, l = "";
    if (s === "translate" || s === "translateX" || s === "translate3d") {
      const c = Et(t) ? {
        ...t,
        "o%": t["%"]
      } : {
        "%": t,
        "o%": t
      }, [u, f = 0, h = 0] = oe(i).map((d, p) => (p === 0 && "x%" in c ? c["%"] = t["x%"] : p === 1 && "y%" in c ? c["%"] = t["y%"] : c["%"] = t["o%"], K(d, c)));
      o = Un, l = [u, f, h];
    } else if (s === "translateY") {
      const c = Et(t) ? {
        "%": t["y%"],
        ...t
      } : {
        "%": t
      }, u = K(i, c);
      o = Un, l = [0, u, 0];
    } else if (s === "translateZ") {
      const c = parseFloat(i);
      o = Un, l = [0, 0, c];
    } else if (s === "scale" || s === "scale3d") {
      const [c, u = c, f = 1] = oe(i).map((h) => parseFloat(h));
      o = on, l = [c, u, f];
    } else if (s === "scaleX") {
      const c = parseFloat(i);
      o = on, l = [c, 1, 1];
    } else if (s === "scaleY") {
      const c = parseFloat(i);
      o = on, l = [1, c, 1];
    } else if (s === "scaleZ") {
      const c = parseFloat(i);
      o = on, l = [1, 1, c];
    } else if (s === "rotate" || s === "rotateZ" || s === "rotateX" || s === "rotateY") {
      const { unit: c, value: u } = ae(i), f = c === "rad" ? u : u * Math.PI / 180;
      s === "rotate" || s === "rotateZ" ? (a = "rotateZ", o = Na) : s === "rotateX" ? o = La : s === "rotateY" && (o = Wa), l = f;
    } else if (s === "matrix3d")
      o = fr, l = oe(i).map((c) => parseFloat(c));
    else if (s === "matrix") {
      const c = oe(i).map((u) => parseFloat(u));
      o = fr, l = [
        c[0],
        c[1],
        0,
        0,
        c[2],
        c[3],
        0,
        0,
        0,
        0,
        1,
        0,
        c[4],
        c[5],
        0,
        1
      ];
    } else
      a = "";
    return {
      name: s,
      functionName: a,
      value: i,
      matrixFunction: o,
      functionValue: l
    };
  });
}
function Va(e) {
  if ("touches" in e) {
    const t = e.touches[0] || e.changedTouches[0];
    return {
      clientX: t.clientX,
      clientY: t.clientY
    };
  } else
    return {
      clientX: e.clientX,
      clientY: e.clientY
    };
}
function qa(e) {
  if (typeof Map > "u")
    return e.filter((n, r) => e.indexOf(n) === r);
  const t = /* @__PURE__ */ new Map();
  return e.filter((n) => t.has(n) ? !1 : (t.set(n, !0), !0));
}
function Ua(e, t, n) {
  const r = Dt(e);
  return r.elementFromPoint && r.elementFromPoint(t, n) || null;
}
function Za(e) {
  return {
    tag: e.type,
    className: e.props.className,
    style: e.props.style || {},
    children: e.props.children || [],
    attributes: e.props
  };
}
function Ci(e, t, n) {
  const r = Za(e), { tag: s, children: i, attributes: o, className: a, style: l } = r, c = t || Dt(n).createElement(s);
  for (const f in o)
    c.setAttribute(f, o[f]);
  const u = c.children;
  if (i.forEach((f, h) => {
    Ci(f, u[h], c);
  }), a && a.split(/\s+/g).forEach((f) => {
    f && !ht(c, f) && Ht(c, f);
  }), l) {
    const f = c.style;
    for (const h in Object.keys(l))
      f[h] = l[h];
  }
  return !t && n && n.appendChild(c), c;
}
function Zn(e, t, n) {
  e !== t && n(e, t);
}
function bs(e, t, n = e.data.boundArea) {
  let { distX: r = 0, distY: s = 0 } = e;
  const { startX: i, startY: o } = e.data;
  if (t > 0) {
    const g = Math.sqrt((r * r + s * s) / (1 + t * t)), m = t * g;
    r = (r >= 0 ? 1 : -1) * m, s = (s >= 0 ? 1 : -1) * g;
  }
  let a = Math.abs(r), l = Math.abs(s);
  const c = r < 0 ? i - n.left : n.right - i, u = s < 0 ? o - n.top : n.bottom - o;
  [a, l] = Rr([a, l], [0, 0], [c, u], !!t), r = (r >= 0 ? 1 : -1) * a, s = (s >= 0 ? 1 : -1) * l;
  const f = Math.min(0, r), h = Math.min(0, s), d = i + f, p = o + h;
  return {
    left: d,
    top: p,
    right: d + a,
    bottom: p + l,
    width: a,
    height: l
  };
}
function an(e) {
  const t = e.getBoundingClientRect(), { left: n, top: r, width: s, height: i } = t;
  return {
    pos1: [n, r],
    pos2: [n + s, r],
    pos3: [n, r + i],
    pos4: [n + s, r + i]
  };
}
function vs(e, t, n) {
  const { list: r, prevList: s, added: i, removed: o, maintained: a } = Se(e, t);
  return [
    ...i.map((l) => r[l]),
    ...o.map((l) => s[l]),
    ...n ? a.map(([, l]) => r[l]) : []
  ];
}
function Ss(e) {
  let t = 0;
  const n = e.length;
  for (let r = 1; r < n; ++r)
    t = Math.max(Ft(e[r], e[r - 1]), t);
  return t;
}
function Ka(e) {
  let t = 5381, n = e.length;
  for (; n; )
    t = t * 33 ^ e.charCodeAt(--n);
  return t >>> 0;
}
function Ja(e) {
  return Ka(e).toString(36);
}
function Qa(e) {
  if (e && e.getRootNode) {
    const t = e.getRootNode();
    if (t.nodeType === 11)
      return t;
  }
}
function tl(e, t, n) {
  return n.original ? t : t.replace(/([^};{\s}][^};{]*|^\s*){/gm, (r, s) => {
    const i = s.trim();
    return (i ? oe(i) : [""]).map((o) => {
      const a = o.trim();
      return a.indexOf("@") === 0 ? a : a.indexOf(":global") > -1 ? a.replace(/\:global/g, "") : a.indexOf(":host") > -1 ? `${a.replace(/\:host/g, `.${e}`)}` : a ? `.${e} ${a}` : `.${e}`;
    }).join(", ") + " {";
  });
}
function el(e, t, n, r, s) {
  const i = Dt(r), o = i.createElement("style");
  return o.setAttribute("type", "text/css"), o.setAttribute("data-styled-id", e), o.setAttribute("data-styled-count", "1"), n.nonce && o.setAttribute("nonce", n.nonce), o.innerHTML = tl(e, t, n), (s || i.head || i.body).appendChild(o), o;
}
function kr(e) {
  const t = "rCS" + Ja(e);
  return {
    className: t,
    inject(n, r = {}) {
      const s = Qa(n);
      let i = (s || n.ownerDocument || document).querySelector(`style[data-styled-id="${t}"]`);
      if (!i)
        i = el(t, e, r, n, s);
      else {
        const o = parseFloat(i.getAttribute("data-styled-count")) || 0;
        i.setAttribute("data-styled-count", `${o + 1}`);
      }
      return {
        destroy() {
          var a;
          const o = parseFloat(i.getAttribute("data-styled-count")) || 0;
          o <= 1 ? (i.remove ? i.remove() : (a = i.parentNode) == null || a.removeChild(i), i = null) : i.setAttribute("data-styled-count", `${o - 1}`);
        }
      };
    }
  };
}
const yi = kr(`
:host {
    position: fixed;
    display: none;
    border: 1px solid rgba(16, 172, 132,1.0);
    background: rgba(16, 172, 132,0.25);
    pointer-events: none;
    will-change: transform;
    z-index: 100;
}
`), Kn = `selecto-selection ${yi.className}`, nl = [
  "className",
  "boundContainer",
  "selectableTargets",
  "selectByClick",
  "selectFromInside",
  "continueSelect",
  "continueSelectWithoutDeselect",
  "toggleContinueSelect",
  "toggleContinueSelectWithoutDeselect",
  "keyContainer",
  "hitRate",
  "scrollOptions",
  "checkInput",
  "preventDefault",
  "ratio",
  "getElementRect",
  "preventDragFromInside",
  "rootContainer",
  "dragCondition",
  "clickBySelectEnd",
  "checkOverflow",
  "innerScrollOptions"
];
function rl(e) {
  const t = Object.getPrototypeOf(e);
  nl.forEach((n) => {
    const r = {
      enumerable: !0,
      configurable: !0,
      get() {
        return this.options[n];
      }
    }, s = xn(`get ${n}`);
    t[s] ? r.get = function() {
      return this[s]();
    } : r.get = function() {
      return this.options[n];
    };
    const i = xn(`set ${n}`);
    t[i] ? r.set = function(o) {
      this[i](o);
    } : r.set = function(o) {
      this.options[n] = o;
    }, Object.defineProperty(t, n, r);
  });
}
class Uu extends Ie {
  /**
   *
   */
  constructor(t = {}) {
    super(), Object.defineProperty(this, "options", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "target", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dragContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "container", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "gesto", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "injectResult", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "selectedTargets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "dragScroll", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new vi()
    }), Object.defineProperty(this, "_keydownContinueSelect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_keydownContinueSelectWithoutDeselection", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_handleKeyDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        s.key === "Shift" && !this._keydownContinueSelect && (this._keydownContinueSelect = !0, this.emit("keydown", {
          keydownContinueSelect: !0,
          keydownContinueSelectWithoutDeselection: !1
        }));
      }
    }), Object.defineProperty(this, "_handleKeyUp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        s.key === "Shift" && this._keydownContinueSelect && (this._keydownContinueSelect = !1, this.emit("keyup", {
          keydownContinueSelect: !1,
          keydownContinueSelectWithoutDeselection: !1
        }));
      }
    }), Object.defineProperty(this, "_handleBlur", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        this._keydownContinueSelect && (this._keydownContinueSelect = !1, this.emit("keyup", {
          keydownContinueSelect: !1,
          keydownContinueSelectWithoutDeselection: !1
        }));
      }
    }), Object.defineProperty(this, "_onDragStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s, i) => {
        const { data: o, clientX: a, clientY: l, inputEvent: c } = s, { selectFromInside: u, selectByClick: f, rootContainer: h, boundContainer: d, preventDragFromInside: p = !0, clickBySelectEnd: g, dragCondition: m } = this.options;
        if (m && !m(s)) {
          s.stop();
          return;
        }
        o.data = {};
        const b = yt(this.container);
        o.innerWidth = b.innerWidth, o.innerHeight = b.innerHeight, this.findSelectableTargets(o), o.startSelectedTargets = this.selectedTargets, o.scaleMatrix = $r(), o.containerX = 0, o.containerY = 0;
        const S = this.container;
        let v = {
          left: -1 / 0,
          top: -1 / 0,
          right: 1 / 0,
          bottom: 1 / 0
        };
        if (h) {
          const T = this.container.getBoundingClientRect();
          o.containerX = T.left, o.containerY = T.top, o.scaleMatrix = Ha(this.container, h);
        }
        if (d) {
          const T = Et(d) && "element" in d ? {
            left: !0,
            top: !0,
            bottom: !0,
            right: !0,
            ...d
          } : {
            element: d,
            left: !0,
            top: !0,
            bottom: !0,
            right: !0
          }, O = T.element;
          let R;
          if (O) {
            jt(O) ? R = Dt(S).querySelector(O) : O === !0 ? R = this.container : R = O;
            const I = R.getBoundingClientRect();
            T.left && (v.left = I.left), T.top && (v.top = I.top), T.right && (v.right = I.right), T.bottom && (v.bottom = I.bottom);
          }
        }
        o.boundArea = v;
        const E = {
          left: a,
          top: l,
          right: a,
          bottom: l,
          width: 0,
          height: 0
        };
        let x = [];
        const w = f && !g;
        let D = !1;
        if (!u || w) {
          const T = this._findElement(
            i || c.target,
            // elementFromPoint(clientX, clientY),
            o.selectableTargets
          );
          D = !!T, w && (x = T ? [T] : []);
        }
        const C = !u && D;
        if (C && !f)
          return s.stop(), !1;
        const P = c.type, M = P === "mousedown" || P === "touchstart";
        if (!(!s.isClick && M ? this.emit("dragStart", { ...s, data: o.data }) : !0))
          return s.stop(), !1;
        if (this.continueSelect ? (x = vs(this.selectedTargets, x, this.continueSelectWithoutDeselect), o.startPassedTargets = this.selectedTargets) : o.startPassedTargets = [], this._select(x, E, s, !0, C && f && !g && p), o.startX = a, o.startY = l, o.selectFlag = !1, o.preventDragFromInside = !1, c.target) {
          const T = vn(o.scaleMatrix, [
            a - o.containerX,
            l - o.containerY
          ]);
          this.target.style.cssText += `position: ${h ? "absolute" : "fixed"};left:0px;top:0px;transform: translate(${T[0]}px, ${T[1]}px)`;
        }
        if (C && f && !g)
          c.preventDefault(), p && (this._selectEnd(o.startSelectedTargets, o.startPassedTargets, E, s, !0), o.preventDragFromInside = !0);
        else {
          o.selectFlag = !0;
          const { scrollOptions: T, innerScrollOptions: O } = this.options;
          let R = !1;
          if (O) {
            const _ = s.inputEvent.target;
            let A = null, B = _;
            for (; B && B !== Dt(S).body; ) {
              if (getComputedStyle(B).overflow !== "visible") {
                A = B;
                break;
              }
              B = B.parentElement;
            }
            A && (o.innerScrollOptions = {
              container: A,
              checkScrollEvent: !0,
              ...O === !0 ? {} : O
            }, this.dragScroll.dragStart(s, o.innerScrollOptions), R = !0);
          }
          !R && T && T.container && this.dragScroll.dragStart(s, T), C && f && g && (o.selectFlag = !1, s.preventDrag());
        }
        return !0;
      }
    }), Object.defineProperty(this, "_onDrag", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        if (s.data.selectFlag) {
          const i = this.scrollOptions, o = s.data.innerScrollOptions;
          if ((o || (i == null ? void 0 : i.container)) && !s.isScroll && this.dragScroll.drag(s, o || i))
            return;
        }
        this._checkSelected(s);
      }
    }), Object.defineProperty(this, "_onDragEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        const { data: i, inputEvent: o } = s, a = bs(s, this.options.ratio), l = i.selectFlag, c = this.container;
        if (o && this.emit("dragEnd", {
          isDouble: !!s.isDouble,
          isClick: !!s.isClick,
          isDrag: !1,
          isSelect: l,
          ...s,
          data: i.data,
          rect: a
        }), this.target.style.cssText += "display: none;", l)
          i.selectFlag = !1, this.dragScroll.dragEnd();
        else if (this.selectByClick && this.clickBySelectEnd) {
          const u = this._findElement((o == null ? void 0 : o.target) || Ua(c, s.clientX, s.clientY), i.selectableTargets);
          this._select(u ? [u] : [], a, s);
        }
        i.preventDragFromInside || this._selectEnd(i.startSelectedTargets, i.startPassedTargets, a, s);
      }
    }), Object.defineProperty(this, "_onDocumentSelectStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        const i = Dt(this.container);
        if (!this.gesto.isFlag())
          return;
        let o = this.dragContainer;
        o === yt(this.container) && (o = i.documentElement);
        const a = le(o) ? [o] : [].slice.call(o), l = s.target;
        a.some((c) => {
          if (c === l || c.contains(l))
            return s.preventDefault(), !0;
        });
      }
    }), this.target = t.portalContainer;
    let n = t.container;
    this.options = {
      className: "",
      portalContainer: null,
      container: null,
      dragContainer: null,
      selectableTargets: [],
      selectByClick: !0,
      selectFromInside: !0,
      clickBySelectEnd: !1,
      hitRate: 100,
      continueSelect: !1,
      continueSelectWithoutDeselect: !1,
      toggleContinueSelect: null,
      toggleContinueSelectWithoutDeselect: null,
      keyContainer: null,
      scrollOptions: null,
      checkInput: !1,
      preventDefault: !1,
      boundContainer: !1,
      preventDragFromInside: !0,
      dragCondition: null,
      rootContainer: null,
      checkOverflow: !1,
      innerScrollOptions: !1,
      getElementRect: an,
      cspNonce: "",
      ratio: 0,
      ...t
    }, rl(this);
    const r = this.options.portalContainer;
    r && (n = r.parentElement), this.container = n || document.body, this.initElement(), this.initDragScroll(), this.setKeyController();
  }
  /**
   * You can set the currently selected targets.
   * selectByClick, continueSelect, and continueSelectWithoutDeselect are not applied.
   */
  setSelectedTargets(t) {
    const n = this.selectedTargets, { added: r, removed: s, prevList: i, list: o } = Se(n, t);
    return this.selectedTargets = t, {
      added: r.map((a) => o[a]),
      removed: s.map((a) => i[a]),
      beforeSelected: n,
      selected: t
    };
  }
  /**
   * You can set the currently selected targets by points
   * selectByClick, continueSelect, and continueSelectWithoutDeselect are not applied.
   */
  setSelectedTargetsByPoints(t, n) {
    const r = Math.min(t[0], n[0]), s = Math.min(t[1], n[1]), i = Math.max(t[0], n[0]), o = Math.max(t[1], n[1]), a = {
      left: r,
      top: s,
      right: i,
      bottom: o,
      width: i - r,
      height: o - s
    }, l = { ignoreClick: !0 };
    this.findSelectableTargets(l);
    const c = this.hitTest(a, l, !0, null);
    return {
      ...this.setSelectedTargets(c),
      rect: a
    };
  }
  /**
   * Select target by virtual drag from startPoint to endPoint.
   * The target of inputEvent is null.
   */
  selectTargetsByPoints(t, n) {
    const r = new MouseEvent("mousedown", {
      clientX: t[0],
      clientY: t[1],
      cancelable: !0,
      bubbles: !0
    }), s = new MouseEvent("mousemove", {
      clientX: n[0],
      clientY: n[1],
      cancelable: !0,
      bubbles: !0
    }), i = new MouseEvent("mousemove", {
      clientX: n[0],
      clientY: n[1],
      cancelable: !0,
      bubbles: !0
    }), o = this.gesto;
    o.onDragStart(r) !== !1 && (o.onDrag(s), o.onDragEnd(i));
  }
  /**
   * You can get the currently selected targets.
   */
  getSelectedTargets() {
    return this.selectedTargets;
  }
  /**
   * `OnDragStart` is triggered by an external event.
   * @param - external event
   * @example
   * import Selecto from "selecto";
   *
   * const selecto = new Selecto();
   *
   * window.addEventListener("mousedown", e => {
   *   selecto.triggerDragStart(e);
   * });
   */
  triggerDragStart(t) {
    return this.gesto.triggerDragStart(t), this;
  }
  /**
   * Destroy elements, properties, and events.
   */
  destroy() {
    var t;
    this.off(), this.gesto.unset(), this.injectResult.destroy(), this.dragScroll.dragEnd(), et(document, "selectstart", this._onDocumentSelectStart), this.options.portalContainer || (t = this.target.parentElement) == null || t.removeChild(this.target), window.removeEventListener("keydown", this._handleKeyDown), window.removeEventListener("keyup", this._handleKeyUp), window.removeEventListener("blur", this._handleBlur), this.gesto = null, this.injectResult = null, this.target = null, this.container = null, this.options = null;
  }
  getElementPoints(t) {
    const n = this.getElementRect || an, r = n(t), s = [r.pos1, r.pos2, r.pos4, r.pos3];
    if (n !== an) {
      const i = t.getBoundingClientRect();
      return ur(s, i);
    }
    return s;
  }
  /**
   * Get all elements set in `selectableTargets`.
   */
  getSelectableElements() {
    const t = this.container, n = [];
    return this.options.selectableTargets.forEach((r) => {
      if (In(r)) {
        const s = r();
        s && n.push(...[].slice.call(s));
      } else if (le(r))
        n.push(r);
      else if (Et(r)) {
        const s = r.value || r.current;
        s && n.push(s);
      } else {
        const s = [].slice.call(Dt(t).querySelectorAll(r));
        n.push(...s);
      }
    }), n;
  }
  /**
   * If scroll occurs during dragging, you can manually call this method to check the position again.
   */
  checkScroll() {
    if (!this.gesto.isFlag())
      return;
    const t = this.scrollOptions, n = this.gesto.getEventData().innerScrollOptions;
    (n || (t == null ? void 0 : t.container)) && this.dragScroll.checkScroll({
      inputEvent: this.gesto.getCurrentEvent(),
      ...n || t
    });
  }
  /**
   * Find for selectableTargets again during drag event
   * You can update selectable targets during an event.
   */
  findSelectableTargets(t = this.gesto.getEventData()) {
    const n = this.getSelectableElements(), r = n.map((a) => this.getElementPoints(a));
    t.selectableTargets = n, t.selectablePoints = r, t.selectableParentMap = null;
    const s = this.options, i = s.checkOverflow || s.innerScrollOptions, o = Dt(this.container);
    if (i) {
      const a = /* @__PURE__ */ new Map();
      t.selectableInnerScrollParentMap = a, t.selectableInnerScrollPathsList = n.map((l, c) => {
        var d;
        let u = l.parentElement, f = [];
        const h = [];
        for (; u && u !== o.body; ) {
          let p = a.get(u);
          if (!p && getComputedStyle(u).overflow !== "visible") {
            const m = an(u);
            p = {
              parentElement: u,
              indexes: [],
              points: [m.pos1, m.pos2, m.pos4, m.pos3],
              paths: [...h]
            }, f.push(u), f.forEach((b) => {
              a.set(b, p);
            }), f = [];
          }
          p ? (u = p.parentElement, (d = a.get(u)) == null || d.indexes.push(c), h.push(u)) : f.push(u), u = u.parentElement;
        }
        return h;
      });
    }
    return s.checkOverflow || (t.selectableInners = n.map(() => !0)), this._refreshGroups(t), n;
  }
  /**
   * External click or mouse events can be applied to the selecto.
   * @params - Extenal click or mouse event
   * @params - Specify the clicked target directly.
   */
  clickTarget(t, n) {
    const { clientX: r, clientY: s } = Va(t), i = {
      data: {
        selectFlag: !1
      },
      clientX: r,
      clientY: s,
      inputEvent: t,
      isClick: !0,
      isTrusted: !1,
      stop: () => !1
    };
    return this._onDragStart(i, n) && this._onDragEnd(i), this;
  }
  setKeyController() {
    window.addEventListener("keydown", this._handleKeyDown), window.addEventListener("keyup", this._handleKeyUp), window.addEventListener("blur", this._handleBlur);
  }
  setClassName(t) {
    this.options.className = t, this.target.setAttribute("class", `${Kn} ${t || ""}`);
  }
  setKeyEvent() {
    this.setKeyController();
  }
  // with getter, setter property
  setKeyContainer(t) {
    const n = this.options;
    Zn(n.keyContainer, t, () => {
      n.keyContainer = t, this.setKeyController();
    });
  }
  getContinueSelect() {
    return this._keydownContinueSelect;
  }
  getContinueSelectWithoutDeselect() {
    const { continueSelectWithoutDeselect: t, toggleContinueSelectWithoutDeselect: n } = this.options;
    return !n || !this._keydownContinueSelectWithoutDeselection ? t : !t;
  }
  setToggleContinueSelect(t) {
    const n = this.options;
    Zn(n.toggleContinueSelect, t, () => {
      n.toggleContinueSelect = t, this.setKeyEvent();
    });
  }
  setToggleContinueSelectWithoutDeselect(t) {
    const n = this.options;
    Zn(n.toggleContinueSelectWithoutDeselect, t, () => {
      n.toggleContinueSelectWithoutDeselect = t, this.setKeyEvent();
    });
  }
  setPreventDefault(t) {
    this.gesto.options.preventDefault = t;
  }
  setCheckInput(t) {
    this.gesto.options.checkInput = t;
  }
  initElement() {
    const { dragContainer: t, checkInput: n, preventDefault: r, preventClickEventOnDragStart: s, preventClickEventOnDrag: i, preventClickEventByCondition: o, preventRightClick: a = !0, className: l } = this.options, c = this.container;
    console.log({
      jsx: Z("div", { className: `${Kn} ${l || ""}` })
    }), this.target = Ci(Z("div", { className: `${Kn} ${l || ""}` }), this.target, c), console.log(this.target);
    const u = this.target;
    this.dragContainer = typeof t == "string" ? [].slice.call(Dt(c).querySelectorAll(t)) : t || this.target.parentNode, this.gesto = new Bn(this.dragContainer, {
      checkWindowBlur: !0,
      container: yt(c),
      checkInput: n,
      preventDefault: r,
      preventClickEventOnDragStart: s,
      preventClickEventOnDrag: i,
      preventClickEventByCondition: o,
      preventRightClick: a
    }).on("dragStart", this._onDragStart).on("drag", this._onDrag).on("dragEnd", this._onDragEnd), it(document, "selectstart", this._onDocumentSelectStart), this.injectResult = yi.inject(u, {
      nonce: this.options.cspNonce
    });
  }
  hitTest(t, n, r, s) {
    const { hitRate: i, selectByClick: o } = this.options, { left: a, top: l, right: c, bottom: u } = t, f = n.innerGroups, h = n.innerWidth, d = n.innerHeight, p = s == null ? void 0 : s.clientX, g = s == null ? void 0 : s.clientY, m = n.ignoreClick, b = [
      [a, l],
      [c, l],
      [c, u],
      [a, u]
    ], S = (y, T) => {
      const O = ae(typeof i == "function" ? `${i(T)}` : `${i}`), R = m ? !1 : Cn([p, g], y);
      if (!r && o && R)
        return !0;
      const I = lr(b, y);
      if (!I.length)
        return !1;
      let _ = Ye(I), A = 0;
      return _ === 0 && Ye(y) === 0 ? (A = Ss(y), _ = Ss(I)) : A = Ye(y), O.unit === "px" ? _ >= O.value : Bt(Math.round(_ / A * 100), 0, 100) >= Math.min(100, O.value);
    }, v = n.selectableTargets, E = n.selectablePoints, x = n.selectableInners;
    if (!f)
      return v.filter((y, T) => x[T] ? S(E[T], v[T]) : !1);
    const w = [], D = Math.floor(a / h), C = Math.floor(c / h), P = Math.floor(l / d), M = Math.floor(u / d);
    for (let y = D; y <= C; ++y) {
      const T = f[y];
      if (T)
        for (let O = P; O <= M; ++O) {
          const R = T[O];
          R && R.forEach((I) => {
            const _ = E[I], A = x[I], B = v[I];
            A && S(_, B) && w.push(B);
          });
        }
    }
    return qa(w);
  }
  initDragScroll() {
    this.dragScroll.on("scrollDrag", ({ next: t }) => {
      t(this.gesto.getCurrentEvent());
    }).on("scroll", ({ container: t, direction: n }) => {
      this.gesto.getEventData().innerScrollOptions ? this.emit("innerScroll", {
        container: t,
        direction: n
      }) : this.emit("scroll", {
        container: t,
        direction: n
      });
    }).on("move", ({ offsetX: t, offsetY: n, inputEvent: r }) => {
      const s = this.gesto;
      if (!s || !s.isFlag())
        return;
      const i = this.gesto.getEventData(), o = i.boundArea;
      i.startX -= t, i.startY -= n;
      const a = this.gesto.getEventData().innerScrollOptions, l = a == null ? void 0 : a.container;
      let c = !1;
      if (l) {
        const u = i.selectableInnerScrollParentMap, f = u.get(l);
        f && (f.paths.forEach((h) => {
          const d = u.get(h);
          d == null || d.points.forEach((p) => {
            p[0] -= t, p[1] -= n;
          });
        }), f.indexes.forEach((h) => {
          i.selectablePoints[h].forEach((d) => {
            d[0] -= t, d[1] -= n;
          });
        }), c = !0);
      }
      c || i.selectablePoints.forEach((u) => {
        u.forEach((f) => {
          f[0] -= t, f[1] -= n;
        });
      }), this._refreshGroups(i), o.left -= t, o.right -= t, o.top -= n, o.bottom -= n, this.gesto.scrollBy(
        t,
        n,
        r.inputEvent
        // false
      ), this._checkSelected(this.gesto.getCurrentEvent());
    });
  }
  _select(t, n, r, s, i = !1) {
    const o = r.inputEvent, a = r.data, l = this.setSelectedTargets(t), { added: c, removed: u, prevList: f, list: h } = Se(a.startSelectedTargets, t), d = {
      startSelected: f,
      startAdded: c.map((p) => h[p]),
      startRemoved: u.map((p) => f[p])
    };
    s && this.emit("selectStart", {
      ...l,
      ...d,
      rect: n,
      inputEvent: o,
      data: a.data,
      isTrusted: r.isTrusted,
      isDragStartEnd: i
    }), (l.added.length || l.removed.length) && this.emit("select", {
      ...l,
      ...d,
      rect: n,
      inputEvent: o,
      data: a.data,
      isTrusted: r.isTrusted,
      isDragStartEnd: i
    });
  }
  _selectEnd(t, n, r, s, i = !1) {
    const { inputEvent: o, isDouble: a, data: l } = s, c = o && o.type, u = c === "mousedown" || c === "touchstart", { added: f, removed: h, prevList: d, list: p } = Se(t, this.selectedTargets), { added: g, removed: m, prevList: b, list: S } = Se(n, this.selectedTargets);
    this.emit("selectEnd", {
      startSelected: t,
      beforeSelected: n,
      selected: this.selectedTargets,
      added: f.map((v) => p[v]),
      removed: h.map((v) => d[v]),
      afterAdded: g.map((v) => S[v]),
      afterRemoved: m.map((v) => b[v]),
      isDragStart: u && i,
      isDragStartEnd: u && i,
      isClick: !!s.isClick,
      isDouble: !!a,
      rect: r,
      inputEvent: o,
      data: l.data,
      isTrusted: s.isTrusted
    });
  }
  _checkSelected(t, n = bs(t, this.options.ratio)) {
    const { data: r } = t, { top: s, left: i, width: o, height: a } = n, l = r.selectFlag, { containerX: c, containerY: u, scaleMatrix: f } = r, h = vn(f, [
      i - c,
      s - u
    ]), d = vn(f, [o, a]);
    let p = [];
    if (l) {
      this.target.style.cssText += `display: block;left:0px;top:0px;transform: translate(${h[0]}px, ${h[1]}px);width:${d[0]}px;height:${d[1]}px;`;
      const m = this.hitTest(n, r, !0, t);
      p = vs(r.startPassedTargets, m, this.continueSelect && this.continueSelectWithoutDeselect);
    }
    if (this.emit("drag", {
      ...t,
      data: r.data,
      isSelect: l,
      rect: n
    }) === !1) {
      this.target.style.cssText += "display: none;", t.stop();
      return;
    }
    l && this._select(p, n, t);
  }
  _findElement(t, n) {
    let r = t;
    for (; r && !(n.indexOf(r) > -1); )
      r = r.parentElement;
    return r;
  }
  _refreshGroups(t) {
    var i;
    const n = t.innerWidth, r = t.innerHeight, s = t.selectablePoints;
    if (this.options.checkOverflow) {
      const o = (i = this.gesto.getEventData().innerScrollOptions) == null ? void 0 : i.container, a = t.selectableInnerScrollParentMap, l = t.selectableInnerScrollPathsList;
      t.selectableInners = l.map((c, u) => {
        let f = !1;
        return c.every((h) => {
          if (f)
            return !0;
          if (h === o)
            return f = !0, !0;
          const d = a.get(h);
          if (d) {
            const p = s[u], g = d.points;
            if (!lr(p, g).length)
              return !1;
          }
          return !0;
        });
      });
    }
    if (!n || !r)
      t.innerGroups = null;
    else {
      const o = t.selectablePoints, a = {};
      o.forEach((l, c) => {
        let u = 1 / 0, f = -1 / 0, h = 1 / 0, d = -1 / 0;
        l.forEach((p) => {
          const g = Math.floor(p[0] / n), m = Math.floor(p[1] / r);
          u = Math.min(g, u), f = Math.max(g, f), h = Math.min(m, h), d = Math.max(m, d);
        });
        for (let p = u; p <= f; ++p)
          for (let g = h; g <= d; ++g)
            a[p] = a[p] || {}, a[p][g] = a[p][g] || [], a[p][g].push(c);
      }), t.innerGroups = a;
    }
  }
}
function Je(e, t) {
  return {
    events: [],
    props: [],
    name: e,
    ...t
  };
}
function jr(e, t) {
  for (var n = e.length, r = 0; r < n; ++r)
    if (t(e[r], r))
      return !0;
  return !1;
}
function Pi(e, t) {
  for (var n = e.length, r = 0; r < n; ++r)
    if (t(e[r], r))
      return e[r];
  return null;
}
function Di(e) {
  var t = e;
  if (typeof t > "u") {
    if (typeof navigator > "u" || !navigator)
      return "";
    t = navigator.userAgent || "";
  }
  return t.toLowerCase();
}
function Xr(e, t) {
  try {
    return new RegExp(e, "g").exec(t);
  } catch {
    return null;
  }
}
function sl() {
  if (typeof navigator > "u" || !navigator || !navigator.userAgentData)
    return !1;
  var e = navigator.userAgentData, t = e.brands || e.uaList;
  return !!(t && t.length);
}
function il(e, t) {
  var n = Xr("(" + e + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", t);
  return n ? n[3] : "";
}
function hr(e) {
  return e.replace(/_/g, ".");
}
function $e(e, t) {
  var n = null, r = "-1";
  return jr(e, function(s) {
    var i = Xr("(" + s.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", t);
    return !i || s.brand ? !1 : (n = s, r = i[3] || "-1", s.versionAlias ? r = s.versionAlias : s.versionTest && (r = il(s.versionTest.toLowerCase(), t) || r), r = hr(r), !0);
  }), {
    preset: n,
    version: r
  };
}
function ln(e, t) {
  var n = {
    brand: "",
    version: "-1"
  };
  return jr(e, function(r) {
    var s = Oi(t, r);
    return s ? (n.brand = r.id, n.version = r.versionAlias || s.version, n.version !== "-1") : !1;
  }), n;
}
function Oi(e, t) {
  return Pi(e, function(n) {
    var r = n.brand;
    return Xr("" + t.test, r.toLowerCase());
  });
}
var Mi = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}], Ti = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: !0
}], dr = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}], Ri = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  // test webview
  test: "webview",
  id: "webview"
}], zi = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "win32|windows",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "macos|macintel|mac os x",
  id: "mac"
}, {
  test: "android|linux armv81",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];
function _i(e) {
  return !!$e(Ri, e).preset;
}
function ol(e) {
  var t = Di(e), n = !!/mobi/g.exec(t), r = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: _i(t),
    chromium: !1,
    chromiumVersion: "-1",
    webkit: !1,
    webkitVersion: "-1"
  }, s = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  }, i = $e(Mi, t), o = i.preset, a = i.version, l = $e(zi, t), c = l.preset, u = l.version, f = $e(Ti, t);
  if (r.chromium = !!f.preset, r.chromiumVersion = f.version, !r.chromium) {
    var h = $e(dr, t);
    r.webkit = !!h.preset, r.webkitVersion = h.version;
  }
  return c && (s.name = c.id, s.version = u, s.majorVersion = parseInt(u, 10)), o && (r.name = o.id, r.version = a, r.webview && s.name === "ios" && r.name !== "safari" && (r.webview = !1)), r.majorVersion = parseInt(r.version, 10), {
    browser: r,
    os: s,
    isMobile: n,
    isHints: !1
  };
}
function al(e) {
  var t = navigator.userAgentData, n = (t.uaList || t.brands).slice(), r = t.mobile || !1, s = n[0], i = (t.platform || navigator.platform).toLowerCase(), o = {
    name: s.brand,
    version: s.version,
    majorVersion: -1,
    webkit: !1,
    webkitVersion: "-1",
    chromium: !1,
    chromiumVersion: "-1",
    webview: !!ln(Ri, n).brand || _i(Di())
  }, a = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  o.webkit = !o.chromium && jr(dr, function(h) {
    return Oi(n, h);
  });
  var l = ln(Ti, n);
  if (o.chromium = !!l.brand, o.chromiumVersion = l.version || "-1", !o.chromium) {
    var c = ln(dr, n);
    o.webkit = !!c.brand, o.webkitVersion = c.version || "-1";
  }
  var u = Pi(zi, function(h) {
    return new RegExp("" + h.test, "g").exec(i);
  });
  a.name = u ? u.id : "";
  {
    var f = ln(Mi, n);
    o.name = f.brand || o.name, o.version = f.brand && e ? e.uaFullVersion : f.version;
  }
  return o.webkit && (a.name = r ? "ios" : "mac"), a.name === "ios" && o.webview && (o.version = "-1"), a.version = hr(a.version), o.version = hr(o.version), a.majorVersion = parseInt(a.version, 10), o.majorVersion = parseInt(o.version, 10), {
    browser: o,
    os: a,
    isMobile: r,
    isHints: !0
  };
}
function Ii(e) {
  return sl() ? al() : ol(e);
}
const ll = ["n", "w", "s", "e"], Yr = ["n", "w", "s", "e", "nw", "ne", "sw", "se"];
function cl(e, t) {
  return `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="${32 * e}px" height="${32 * e}px" viewBox="0 0 32 32" ><path d="M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z" stroke-linejoin="round" stroke-width="1.2" fill="black" stroke="white" style="transform:rotate(${t}deg);transform-origin: 16px 16px"></path></svg>`;
}
function ul(e) {
  const t = cl(1, e), n = Math.round(e / 45) * 45 % 180;
  let r = "ns-resize";
  return n === 135 ? r = "nwse-resize" : n === 45 ? r = "nesw-resize" : n === 90 && (r = "ew-resize"), `cursor:${r};cursor: url('${t}') 16 16, ${r};`;
}
const Be = Ii(), Bi = Be.browser.webkit, Ai = Bi && (() => {
  const e = typeof window > "u" ? { userAgent: "" } : window.navigator, t = /applewebkit\/([^\s]+)/g.exec(e.userAgent.toLowerCase());
  return t ? parseFloat(t[1]) < 605 : !1;
})(), Gi = Be.browser.name, $i = parseInt(Be.browser.version, 10), fl = Gi === "chrome", hl = Be.browser.chromium, dl = parseInt(Be.browser.chromiumVersion, 10) || 0, pl = fl && $i >= 109 || hl && dl >= 109, gl = Gi === "firefox", ml = parseInt(Be.browser.webkitVersion, 10) >= 612 || $i >= 15, Fr = "moveable-", bl = Yr.map((e) => {
  let t = "", n = "", r = "center", s = "center";
  const i = "calc(var(--moveable-control-padding, 20) * -1px)";
  return e.indexOf("n") > -1 && (t = `top: ${i};`, s = "bottom"), e.indexOf("s") > -1 && (t = "top: 0px;", s = "top"), e.indexOf("w") > -1 && (n = `left: ${i};`, r = "right"), e.indexOf("e") > -1 && (n = "left: 0px;", r = "left"), `.around-control[data-direction*="${e}"] {
        ${n}${t}
        transform-origin: ${r} ${s};
    }`;
}).join(`
`), vl = `
{
position: absolute;
width: 1px;
height: 1px;
left: 0;
top: 0;
z-index: 3000;
--moveable-color: #4af;
--zoom: 1;
--zoompx: 1px;
--moveable-line-padding: 0;
--moveable-control-padding: 0;
will-change: transform;
outline: 1px solid transparent;
}
.control-box {
z-index: 0;
}
.line, .control {
position: absolute;
left: 0;
top: 0;
will-change: transform;
}
.control {
width: 14px;
height: 14px;
border-radius: 50%;
border: 2px solid #fff;
box-sizing: border-box;
background: #4af;
background: var(--moveable-color);
margin-top: -7px;
margin-left: -7px;
border: 2px solid #fff;
z-index: 10;
}
.around-control {
position: absolute;
will-change: transform;
width: calc(var(--moveable-control-padding, 20) * 1px);
height: calc(var(--moveable-control-padding, 20) * 1px);
left: calc(var(--moveable-control-padding, 20) * -0.5px);
top: calc(var(--moveable-control-padding, 20) * -0.5px);
box-sizing: border-box;
background: transparent;
z-index: 8;
cursor: alias;
transform-origin: center center;
}
${bl}
.padding {
position: absolute;
top: 0px;
left: 0px;
width: 100px;
height: 100px;
transform-origin: 0 0;
}
.line {
width: 1px;
height: 1px;
background: #4af;
background: var(--moveable-color);
transform-origin: 0px 50%;
}
.line.edge {
z-index: 1;
background: transparent;
}
.line.dashed {
box-sizing: border-box;
background: transparent;
}
.line.dashed.horizontal {
border-top: 1px dashed #4af;
border-top-color: #4af;
border-top-color: var(--moveable-color);
}
.line.dashed.vertical {
border-left: 1px dashed #4af;
border-left-color: #4af;
border-left-color: var(--moveable-color);
}
.line.vertical {
transform: translateX(-50%);
}
.line.horizontal {
transform: translateY(-50%);
}
.line.vertical.bold {
width: 2px;
}
.line.horizontal.bold {
height: 2px;
}

.control.origin {
border-color: #f55;
background: #fff;
width: 12px;
height: 12px;
margin-top: -6px;
margin-left: -6px;
pointer-events: none;
}
${[0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map((e) => `
.direction[data-rotation="${e}"], :global .view-control-rotation${e} {
${ul(e)}
}
`).join(`
`)}

.line.direction:before {
content: "";
position: absolute;
width: 100%;
height: calc(var(--moveable-line-padding, 0) * 1px);
bottom: 0;
left: 0;
}
.group {
z-index: -1;
}
.area {
position: absolute;
}
.area-pieces {
position: absolute;
top: 0;
left: 0;
display: none;
}
.area.avoid, .area.pass {
pointer-events: none;
}
.area.avoid+.area-pieces {
display: block;
}
.area-piece {
position: absolute;
}

${Ai ? `:global svg *:before {
content:"";
transform-origin: inherit;
}` : ""}
`, Sl = [
  [0, 1, 2],
  [1, 0, 3],
  [2, 0, 3],
  [3, 1, 2]
], pr = 1e-4, wt = 1e-7, cn = 1e-9, gr = Math.pow(10, 10), xs = -gr, xl = {
  n: [0, -1],
  e: [1, 0],
  s: [0, 1],
  w: [-1, 0],
  nw: [-1, -1],
  ne: [1, -1],
  sw: [-1, 1],
  se: [1, 1]
}, Lr = {
  n: [0, 1],
  e: [1, 3],
  s: [3, 2],
  w: [2, 0],
  nw: [0],
  ne: [1],
  sw: [2],
  se: [3]
}, ki = {
  n: 0,
  s: 180,
  w: 270,
  e: 90,
  nw: 315,
  ne: 45,
  sw: 225,
  se: 135
}, El = [
  "isMoveableElement",
  "updateRect",
  "updateTarget",
  "destroy",
  "dragStart",
  "isInside",
  "hitTest",
  "setState",
  "getRect",
  "request",
  "isDragging",
  "getManager",
  "forceUpdate",
  "waitToChangeTarget",
  "updateSelectors",
  "getTargets",
  "stopDrag",
  "getControlBoxElement",
  "getMoveables",
  "getDragElement"
];
function wl(e, ...t) {
  return t.map((n) => n.split(" ").map((r) => r ? `${e}${r}` : "").join(" ")).join(" ");
}
function Rt(e, t) {
  return (n) => {
    n && (e[t] = n);
  };
}
function ji(e, t, n) {
  return (r) => {
    r && (e[t][n] = r);
  };
}
function Xi(e, t) {
  return t.replace(/([^}{]*){/gm, (n, r) => `${r.replace(/\.([^{,\s\d.]+)/g, `.${e}$1`)}{`);
}
function Qe(e, t, n, r, s, i = "draggable") {
  var c;
  const o = ((c = t.gestos[i]) == null ? void 0 : c.move(n, e.inputEvent)) ?? {}, a = o.originalDatas || o.datas, l = a[i] || (a[i] = {});
  return {
    ...o,
    isPinch: !!r,
    parentEvent: !0,
    datas: l,
    originalDatas: e.originalDatas
  };
}
class Me {
  constructor(t = "draggable") {
    Object.defineProperty(this, "ableName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "prevX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "prevY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "startX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "startY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "isDrag", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "isFlag", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "datas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        draggable: {}
      }
    }), this.datas = {
      [t]: {}
    };
  }
  dragStart(t, n) {
    this.isDrag = !1, this.isFlag = !1;
    const r = n.originalDatas;
    return this.datas = r, r[this.ableName] || (r[this.ableName] = {}), {
      ...this.move(t, n.inputEvent),
      type: "dragstart"
    };
  }
  drag(t, n) {
    return this.move([t[0] - this.prevX, t[1] - this.prevY], n);
  }
  move(t, n) {
    let r, s, i = !1;
    if (!this.isFlag)
      this.prevX = t[0], this.prevY = t[1], this.startX = t[0], this.startY = t[1], r = t[0], s = t[1], this.isFlag = !0;
    else {
      const o = this.isDrag;
      r = this.prevX + t[0], s = this.prevY + t[1], (t[0] || t[1]) && (this.isDrag = !0), !o && this.isDrag && (i = !0);
    }
    return this.prevX = r, this.prevY = s, {
      type: "drag",
      clientX: r,
      clientY: s,
      inputEvent: n,
      isFirstDrag: i,
      isDrag: this.isDrag,
      distX: r - this.startX,
      distY: s - this.startY,
      deltaX: t[0],
      deltaY: t[1],
      datas: this.datas[this.ableName],
      originalDatas: this.datas,
      parentEvent: !0,
      parentGesto: this
    };
  }
}
function ye(e, t, n, r) {
  const i = e.length === 16 ? 4 : 3, o = ge(e, n, r, i);
  let [[a, l], [c, u], [f, h], [d, p]] = o, [g, m] = ot(e, t, i);
  const b = Math.min(a, c, f, d), S = Math.min(l, u, h, p), v = Math.max(a, c, f, d), E = Math.max(l, u, h, p);
  a = a - b || 0, c = c - b || 0, f = f - b || 0, d = d - b || 0, l = l - S || 0, u = u - S || 0, h = h - S || 0, p = p - S || 0, g = g - b || 0, m = m - S || 0;
  const x = e[0], w = e[i + 1], D = St(x * w);
  return {
    left: b,
    top: S,
    right: v,
    bottom: E,
    origin: [g, m],
    pos1: [a, l],
    pos2: [c, u],
    pos3: [f, h],
    pos4: [d, p],
    direction: D
  };
}
function Yi(e, t) {
  const { clientX: n, clientY: r, datas: s } = t, { moveableClientRect: i, rootMatrix: o, is3d: a, pos1: l } = e.state, { left: c, top: u } = i, f = a ? 4 : 3, [h, d] = W(ze(o, [n - c, r - u], f), l), [p, g] = Wt({ datas: s, distX: h, distY: d });
  return [p, g];
}
function pe(e, { datas: t }) {
  const { allMatrix: n, beforeMatrix: r, is3d: s, left: i, top: o, origin: a, offsetMatrix: l, targetMatrix: c, transformOrigin: u } = e.state, f = s ? 4 : 3;
  t.is3d = s, t.matrix = n, t.targetMatrix = c, t.beforeMatrix = r, t.offsetMatrix = l, t.transformOrigin = u, t.inverseMatrix = $t(n, f), t.inverseBeforeMatrix = $t(r, f), t.absoluteOrigin = ue(Q([i, o], a), f), t.startDragBeforeDist = mt(t.inverseBeforeMatrix, t.absoluteOrigin, f), t.startDragDist = mt(t.inverseMatrix, t.absoluteOrigin, f);
}
function Cl(e) {
  return ye(e.datas.beforeTransform, [50, 50], 100, 100).direction;
}
function Gn(e, t, n) {
  const { datas: r, originalDatas: { beforeRenderable: s } } = t, i = r.transformIndex, o = s.nextTransforms, a = o.length, l = s.nextTransformAppendedIndexes;
  let c = -1;
  i === -1 ? (n === "translate" ? c = 0 : n === "rotate" && (c = qt(o, (d) => d.match(/scale\(/g))), c === -1 && (c = o.length), r.transformIndex = c) : Ot(l, (d) => d.index === i && d.functionName === n) ? c = i : c = i + l.filter((d) => d.index < i).length;
  const u = Uc(o, e.state, c), f = u.targetFunction, h = n === "rotate" ? "rotateZ" : n;
  r.beforeFunctionTexts = u.beforeFunctionTexts, r.afterFunctionTexts = u.afterFunctionTexts, r.beforeTransform = u.beforeFunctionMatrix, r.beforeTransform2 = u.beforeFunctionMatrix2, r.targetTansform = u.targetFunctionMatrix, r.afterTransform = u.afterFunctionMatrix, r.afterTransform2 = u.afterFunctionMatrix2, r.targetAllTransform = u.allFunctionMatrix, f.functionName === h ? (r.afterFunctionTexts.splice(0, 1), r.isAppendTransform = !1) : a > c && (r.isAppendTransform = !0, s.nextTransformAppendedIndexes = [
    ...l,
    {
      functionName: n,
      index: c,
      isAppend: !0
    }
  ]);
}
function $n(e, t, n) {
  return `${e.beforeFunctionTexts.join(" ")} ${e.isAppendTransform ? n : t} ${e.afterFunctionTexts.join(" ")}`;
}
function yl({ datas: e, distX: t, distY: n }) {
  const [r, s] = Li({ datas: e, distX: t, distY: n }), i = Fi(e, Ya([r, s], 4));
  return mt(i, ue([0, 0, 0], 4), 4);
}
function Fi(e, t, n) {
  const { beforeTransform: r, afterTransform: s, beforeTransform2: i, afterTransform2: o, targetAllTransform: a } = e, l = n ? tt(a, t, 4) : tt(t, a, 4), c = tt($t(n ? i : r, 4), l, 4);
  return tt(c, $t(n ? o : s, 4), 4);
}
function Li({ datas: e, distX: t, distY: n }) {
  const { inverseBeforeMatrix: r, is3d: s, startDragBeforeDist: i, absoluteOrigin: o } = e, a = s ? 4 : 3;
  return W(mt(r, Q(o, [t, n]), a), i);
}
function Wt({ datas: e, distX: t, distY: n }, r) {
  const { inverseBeforeMatrix: s, inverseMatrix: i, is3d: o, startDragBeforeDist: a, startDragDist: l, absoluteOrigin: c } = e, u = o ? 4 : 3;
  return W(mt(r ? s : i, Q(c, [t, n]), u), r ? a : l);
}
function Pl({ datas: e, distX: t, distY: n }, r) {
  const { beforeMatrix: s, matrix: i, is3d: o, startDragBeforeDist: a, startDragDist: l, absoluteOrigin: c } = e, u = o ? 4 : 3;
  return W(mt(i, Q(l, [t, n]), u), c);
}
function Dl(e, t, n, r = t, s = n, i = [0, 0]) {
  return e ? e.map((o, a) => {
    const { value: l, unit: c } = ae(o), u = a ? s : r, f = a ? n : t;
    if (o === "%" || isNaN(l)) {
      const h = u ? i[a] / u : 0;
      return f * h;
    } else if (c !== "%")
      return l;
    return f * l / 100;
  }) : i;
}
function Wi(e) {
  const t = [];
  return e[1] >= 0 && (e[0] >= 0 && t.push(3), e[0] <= 0 && t.push(2)), e[1] <= 0 && (e[0] >= 0 && t.push(1), e[0] <= 0 && t.push(0)), t;
}
function Ol(e, t) {
  return Wi(t).map((n) => e[n]);
}
function Jn(e, t) {
  const n = (t + 1) / 2;
  return [
    En(e[0][0], e[1][0], n, 1 - n),
    En(e[0][1], e[1][1], n, 1 - n)
  ];
}
function pt(e, t) {
  const n = Jn([e[0], e[1]], t[0]), r = Jn([e[2], e[3]], t[0]);
  return Jn([n, r], t[1]);
}
function Ml(e, t, n, r, s, i) {
  const o = ge(t, n, r, s), a = pt(o, i), l = e[0] - a[0], c = e[1] - a[1];
  return [l, c];
}
function tn(e, t, n, r) {
  return tt(e, Le(t, r, n), r);
}
function Tl(e, t, n, r) {
  const { transformOrigin: s, offsetMatrix: i, is3d: o } = e, a = o ? 4 : 3;
  let l;
  if (jt(n)) {
    const { beforeTransform: c, afterTransform: u } = t;
    r ? l = kt(De(n), 4, a) : l = kt(tt(tt(c, De([n]), 4), u, 4), 4, a);
  } else
    l = n;
  return tn(i, l, s, a);
}
function Rl(e, t) {
  const { transformOrigin: n, offsetMatrix: r, is3d: s, targetMatrix: i, targetAllTransform: o } = e, a = s ? 4 : 3;
  return tn(r, tt(o || i, Ar(t, a), a), n, a);
}
function kn(e, t) {
  const n = Ae(t);
  return {
    setTransform: (r, s = -1) => {
      n.startTransforms = at(r) ? r : Jt(r), mr(e, t, s);
    },
    setTransformIndex: (r) => {
      mr(e, t, r);
    }
  };
}
function jn(e, t, n) {
  const s = Ae(t).startTransforms;
  mr(e, t, qt(s, (i) => i.indexOf(`${n}(`) === 0));
}
function mr(e, t, n) {
  const r = Ae(t), s = t.datas;
  if (s.transformIndex = n, n === -1)
    return;
  const i = r.startTransforms[n];
  if (!i)
    return;
  const o = e.state, a = Oe([i], {
    "x%": (l) => l / 100 * o.offsetWidth,
    "y%": (l) => l / 100 * o.offsetHeight
  });
  s.startValue = a[0].functionValue;
}
function Wr(e, t) {
  const n = Ae(e);
  n.nextTransforms = Jt(t);
}
function Ae(e) {
  return e.originalDatas.beforeRenderable;
}
function Pn(e) {
  const { originalDatas: { beforeRenderable: t } } = e;
  return t.nextTransforms;
}
function un(e) {
  return (Pn(e) || []).join(" ");
}
function fn(e) {
  return Ae(e).nextStyle;
}
function Ni(e, t, n, r, s) {
  Wr(s, t);
  const i = vt.drag(e, Qe(s, e.state, n, r)), o = i ? i.transform : t;
  return {
    transform: t,
    drag: i,
    ...xt({
      transform: o
    }, s),
    afterTransform: o
  };
}
function Nr(e, t, n, r, s, i) {
  const o = Tl(e.state, s, t, i);
  return Il(e, n, r, o);
}
function Hi(e, t, n, r, s, i, o) {
  const a = Nr(e, t, n, s, i, o), l = e.state, { left: c, top: u } = l, f = e.props.groupable, h = f ? c : 0, d = f ? u : 0, p = W(r, a);
  return W(p, [h, d]);
}
function zl(e, t, n, r, s, i, o) {
  return Hi(e, t, n, r, s, i, o);
}
function _l(e, t, n) {
  return [
    t ? -1 + e[0] / (t / 2) : 0,
    n ? -1 + e[1] / (n / 2) : 0
  ];
}
function Il(e, t, n, r = e.state.allMatrix) {
  const { width: s, height: i, is3d: o } = e.state, a = o ? 4 : 3, l = [
    s / 2 * (1 + t[0]) + n[0],
    i / 2 * (1 + t[1]) + n[1]
  ];
  return ot(r, l, a);
}
function Bl(e, t, n) {
  const r = n.fixedDirection, s = n.fixedPosition, i = n.fixedOffset;
  return Hi(e, `rotate(${t}deg)`, r, s, i, n);
}
function Al(e, t, n, r, s, i) {
  const { groupable: o } = e.props, a = e.state, { transformOrigin: l, offsetMatrix: c, is3d: u, width: f, height: h, left: d, top: p } = a, g = i.fixedDirection, m = i.nextTargetMatrix || a.targetMatrix, b = u ? 4 : 3, S = Dl(s, t, n, f, h, l), v = o ? d : 0, E = o ? p : 0, x = tn(c, m, S, b), w = Ml(r, x, t, n, b, g);
  return W(w, [v, E]);
}
function Gl(e, t) {
  return pt(It(e.state), t);
}
function $l(e, t) {
  const n = e.targetGesto, r = e.controlGesto;
  let s;
  return n != null && n.isFlag() && (s = n.getEventData()[t]), !s && (r != null && r.isFlag()) && (s = r.getEventData()[t]), s || {};
}
function kl(e) {
  if (e && e.getRootNode) {
    const t = e.getRootNode();
    if (t.nodeType === 11)
      return t;
  }
}
function jl(e) {
  const t = e("scale"), n = e("rotate"), r = e("translate"), s = [];
  return r && r !== "0px" && r !== "none" && s.push(`translate(${r.split(/\s+/).join(",")})`), n && n !== "1" && n !== "none" && s.push(`rotate(${n})`), t && t !== "1" && t !== "none" && s.push(`scale(${t.split(/\s+/).join(",")})`), s;
}
function Vi(e, t, n) {
  let r = e;
  const s = [], i = Ir(e) || ee(e);
  let o = !n && e === t || e === i, a = o, l = !1, c = 3, u, f, h, d = !1, p = Ue(t, t, !0).offsetParent, g = 1;
  for (; r && !a; ) {
    a = o;
    const m = Pt(r), b = m("position"), S = vo(r), v = b === "fixed", E = jl(m);
    let x = Fa(Gc(S)), w, D = !1, C = !1, P = 0, M = 0, y = 0, T = 0, O = {
      hasTransform: !1,
      fixedContainer: null
    };
    v && (d = !0, O = Yc(r), p = O.fixedContainer);
    const R = x.length;
    !l && (R === 16 || E.length) && (l = !0, c = 4, wr(s), h && (h = kt(h, 3, 4))), l && R === 9 && (x = kt(x, 3, 4));
    const { tagName: I, hasOffset: _, isSVG: A, origin: B, targetOrigin: N, offset: G } = Xc(r, e);
    let [k, q] = G;
    I === "svg" && !r.ownerSVGElement && h && (s.push({
      type: "target",
      target: r,
      matrix: Fc(r, c)
    }), s.push({
      type: "offset",
      target: r,
      matrix: nt(c)
    }));
    const j = parseFloat(m("zoom")) || 1;
    if (v)
      w = O.fixedContainer, D = !0;
    else {
      const X = Ue(r, t, !1, !0, m), J = X.offsetZoom;
      if (w = X.offsetParent, D = X.isEnd, C = X.isStatic, g *= J, (X.isCustomElement || J !== 1) && C)
        k -= w.offsetLeft, q -= w.offsetTop;
      else if ((gl || pl) && X.parentSlotElement) {
        let F = w, H = 0, rt = 0;
        for (; F && kl(F); )
          H += F.offsetLeft, rt += F.offsetTop, F = F.offsetParent;
        k -= H, q -= rt;
      }
    }
    if (Bi && !ml && _ && !A && C && (b === "relative" || b === "static") && (k -= w.offsetLeft, q -= w.offsetTop, o = o || D), v)
      _ && O.hasTransform && (y = w.clientLeft, T = w.clientTop);
    else if (_ && p !== w && (P = w.clientLeft, M = w.clientTop), _ && w === i) {
      const X = So(r, !1);
      k += X[0], q += X[1];
    }
    if (s.push({
      type: "target",
      target: r,
      matrix: Le(x, c, B)
    }), E.length && (s.push({
      type: "offset",
      target: r,
      matrix: nt(c)
    }), s.push({
      type: "target",
      target: r,
      matrix: Le(De(E), c, B)
    })), _) {
      const X = r === e, J = X ? 0 : r.scrollLeft, $ = X ? 0 : r.scrollTop;
      s.push({
        type: "offset",
        target: r,
        matrix: fe([
          k - J + P - y,
          q - $ + M - T
        ], c)
      });
    } else
      s.push({
        type: "offset",
        target: r,
        origin: B
      });
    if (j !== 1 && s.push({
      type: "zoom",
      target: r,
      matrix: Le(Ar([j, j], c), c, [0, 0])
    }), h || (h = x), u || (u = B), f || (f = N), a || v)
      break;
    r = w, o = D, (!n || r === i) && (a = o);
  }
  return h || (h = nt(c)), u || (u = [0, 0]), f || (f = [0, 0]), {
    zoom: g,
    offsetContainer: p,
    matrixes: s,
    targetMatrix: h,
    transformOrigin: u,
    targetOrigin: f,
    is3d: l,
    hasFixed: d
  };
}
let ne = null, re = null, xe = null;
function Te(e) {
  e ? (window.Map && (ne = /* @__PURE__ */ new Map(), re = /* @__PURE__ */ new Map()), xe = []) : (ne = null, xe = null, re = null);
}
function Xl(e) {
  const t = re == null ? void 0 : re.get(e);
  if (t)
    return t;
  const n = We(e, !0);
  return re && re.set(e, n), n;
}
function Yl(e, t) {
  if (xe) {
    const r = Ot(xe, (s) => s[0][0] == e && s[0][1] == t);
    if (r)
      return r[1];
  }
  const n = Vi(e, t, !0);
  return xe && xe.push([[e, t], n]), n;
}
function Pt(e) {
  let t = ne == null ? void 0 : ne.get(e);
  if (!t) {
    const s = yt(e).getComputedStyle(e);
    if (!ne)
      return (i) => s[i];
    t = {
      style: s,
      cached: {}
    }, ne.set(e, t);
  }
  const n = t.cached, r = t.style;
  return (s) => (s in n || (n[s] = r[s]), n[s]);
}
function Gt(e, t, n) {
  const r = n.originalDatas;
  r.groupable = r.groupable || {};
  const s = r.groupable;
  s.childDatas = s.childDatas || [];
  const i = s.childDatas;
  return e.moveables.map((o, a) => (i[a] = i[a] || {}, i[a][t] = i[a][t] || {}, {
    ...n,
    isRequestChild: !0,
    datas: i[a][t],
    originalDatas: i[a]
  }));
}
function Qn(e, t, n, r, s, i, o) {
  const a = !!n.match(/Start$/g), l = !!n.match(/End$/g), c = s.isPinch, u = s.datas, f = Gt(e, t.name, s), h = e.moveables, d = [], p = f.map((g, m) => {
    const b = h[m], S = b.state, v = S.gestos;
    let E = g;
    if (a)
      E = new Me(o).dragStart(r, g), d.push(E);
    else {
      if (v[o] || (v[o] = u.childGestos[m]), !v[o])
        return;
      E = Qe(g, S, r, c, i, o), d.push(E);
    }
    const x = t[n](b, {
      ...E,
      parentFlag: !0
    });
    return l && (v[o] = null), x;
  });
  return a && (u.childGestos = h.map((g) => g.state.gestos[o])), {
    eventParams: p,
    childEvents: d
  };
}
function Vt(e, t, n, r, s = (o, a) => a, i) {
  const o = !!n.match(/End$/g), a = Gt(e, t.name, r), l = e.moveables;
  return a.map((u, f) => {
    const h = l[f];
    let d = u;
    d = s(h, u);
    const p = t[n](h, {
      ...d,
      parentFlag: !0
    });
    return o && (h.state.gestos = {}), p;
  });
}
function Dn(e, t, n, r) {
  const s = n.fixedDirection, i = n.fixedPosition, o = r.datas.startPositions || It(t.state), a = pt(o, s), [l, c] = mt(Ke(-e.rotation / 180 * Math.PI, 3), [a[0] - i[0], a[1] - i[1], 1], 3);
  return r.datas.originalX = l, r.datas.originalY = c, r;
}
function qi(e, t, n, r) {
  const { renderPoses: s, rotation: i, direction: o } = e.getState(), { zoom: a } = he(e.props, t), l = Fe(i / Math.PI * 180), c = {}, u = e.renderState;
  u.renderDirectionMap || (u.renderDirectionMap = {});
  const f = u.renderDirectionMap;
  n.forEach(({ dir: d }) => {
    c[d] = !0;
  });
  const h = St(o);
  return n.map(({ data: d, classNames: p, dir: g }) => {
    const m = Lr[g];
    if (!m || !c[g])
      return null;
    f[g] = !0;
    const b = (V(l, 15) + h * ki[g] + 720) % 180, S = {};
    return _e(d).forEach((v) => {
      S[`data-${v}`] = d[v];
    }), Mr("div", { className: L("control", "direction", g, t, ...p), "data-rotation": b, "data-direction": g, ...S, key: `direction-${g}`, style: Rn(i, a, ...m.map((v) => s[v])) });
  });
}
function Ui(e, t, n, r) {
  const { renderDirections: s = t, displayAroundControls: i } = he(e.props, n);
  if (!s)
    return [];
  const o = s === !0 ? Yr : s;
  return [
    ...i ? Qi(e, r, n, o) : [],
    ...qi(e, n, o.map((a) => ({
      data: {},
      classNames: [],
      dir: a
    })))
  ];
}
function qe(e, t, n, r, s, i, ...o) {
  const a = lt(n, r), l = t ? V(a / Math.PI * 180, 15) % 180 : -1;
  return Z("div", { className: L("line", "direction", t ? "edge" : "", t, ...o), "data-rotation": l, "data-line-key": i, "data-direction": t, style: je(n, r, s, a) }, `line-${i}`);
}
function Zi(e, t, n, r, s) {
  return (n === !0 ? ll : n).map((o, a) => {
    const [l, c] = Lr[o];
    if (c != null)
      return qe(e, o, r[l], r[c], s, `${t}Edge${a}`, t);
  }).filter(Boolean);
}
function Ki(e) {
  return (t, n) => {
    const r = he(t.props, e).edge;
    return r && (r === !0 || r.length) ? [
      ...Zi(n, e, r, t.getState().renderPoses, t.props.zoom),
      ...Fl(t, e, n)
    ] : Ji(t, e, n);
  };
}
function Ji(e, t, n) {
  return Ui(e, Yr, t, n);
}
function Fl(e, t, n) {
  return Ui(e, ["nw", "ne", "sw", "se"], t, n);
}
function Qi(e, t, n, r) {
  const s = e.renderState;
  s.renderDirectionMap || (s.renderDirectionMap = {});
  const { renderPoses: i, rotation: o, direction: a } = e.getState(), l = s.renderDirectionMap, { zoom: c } = e.props, u = St(a), f = o / Math.PI * 180;
  return (r || _e(l)).map((h) => {
    const d = Lr[h];
    if (!d)
      return null;
    const p = (V(f, 15) + u * ki[h] + 720) % 180, g = ["around-control"];
    return n && g.push("direction", n), Z("div", { className: L(...g), "data-rotation": p, "data-direction": h, style: Rn(o, c, ...d.map((m) => i[m])) }, `direction-around-${h}`);
  });
}
function Hr(e, t, n) {
  const { position: r = "client", left: s = -1 / 0, top: i = -1 / 0, right: o = 1 / 0, bottom: a = 1 / 0 } = e || {}, l = {
    position: r,
    left: s,
    top: i,
    right: o,
    bottom: a
  };
  return {
    vertical: Es(l, t, !0),
    horizontal: Es(l, n, !1)
  };
}
function Xn(e, t) {
  const { containerClientRect: { clientHeight: n, clientWidth: r, clientLeft: s, clientTop: i }, snapOffset: { left: o, top: a, right: l, bottom: c } } = e.state, u = t || e.props.bounds || {}, h = (u.position || "client") === "css", { left: d = -1 / 0, top: p = -1 / 0 } = u;
  let { right: g = h ? -1 / 0 : 1 / 0, bottom: m = h ? -1 / 0 : 1 / 0 } = u;
  return h && (g = r + l - o - g, m = n + c - a - m), {
    left: d + o - s,
    right: g + o - s,
    top: p + a - i,
    bottom: m + a - i
  };
}
function Ll(e, t, n) {
  const { left: r, top: s, right: i, bottom: o } = Xn(e), [a, l] = n;
  let [c, u] = W(n, t);
  z(c) < wt && (c = 0), z(u) < wt && (u = 0);
  const f = u > 0, h = c > 0, d = {
    isBound: !1,
    offset: 0,
    pos: 0
  }, p = {
    isBound: !1,
    offset: 0,
    pos: 0
  };
  if (c === 0 && u === 0)
    return {
      vertical: d,
      horizontal: p
    };
  if (c === 0)
    f ? o < l && (p.pos = o, p.offset = l - o) : s > l && (p.pos = s, p.offset = l - s);
  else if (u === 0)
    h ? i < a && (d.pos = i, d.offset = a - i) : r > a && (d.pos = r, d.offset = a - r);
  else {
    const g = u / c, m = n[1] - g * a;
    let b = 0, S = 0, v = !1;
    h && i <= a ? (b = g * i + m, S = i, v = !0) : !h && a <= r && (b = g * r + m, S = r, v = !0), v && (b < s || b > o) && (v = !1), v || (f && o <= l ? (b = o, S = (b - m) / g, v = !0) : !f && l <= s && (b = s, S = (b - m) / g, v = !0)), v && (d.isBound = !0, d.pos = S, d.offset = a - S, p.isBound = !0, p.pos = b, p.offset = l - b);
  }
  return {
    vertical: d,
    horizontal: p
  };
}
function Es(e, t, n) {
  const r = e[n ? "left" : "top"], s = e[n ? "right" : "bottom"], i = Math.min(...t), o = Math.max(...t), a = [];
  return r + 1 > i && a.push({
    direction: "start",
    isBound: !0,
    offset: i - r,
    pos: r
  }), s - 1 < o && a.push({
    direction: "end",
    isBound: !0,
    offset: o - s,
    pos: s
  }), a.length || a.push({
    isBound: !1,
    offset: 0,
    pos: 0
  }), a.sort((l, c) => z(c.offset) - z(l.offset));
}
function ws(e, t, n) {
  return (n ? e.map((s) => Ze(s, n)) : e).some((s) => s[0] < t.left && z(s[0] - t.left) > 0.1 || s[0] > t.right && z(s[0] - t.right) > 0.1 || s[1] < t.top && z(s[1] - t.top) > 0.1 || s[1] > t.bottom && z(s[1] - t.bottom) > 0.1);
}
function Wl(e, t, n) {
  const r = _t(e), s = Math.sqrt(r * r - t * t) || 0;
  return [s, -s].sort((i, o) => z(i - e[n ? 0 : 1]) - z(o - e[n ? 0 : 1])).map((i) => lt([0, 0], n ? [i, t] : [t, i]));
}
function Nl(e, t, n, r, s) {
  if (!e.props.bounds)
    return [];
  const i = s * Math.PI / 180, { left: o, top: a, right: l, bottom: c } = Xn(e), u = o - r[0], f = l - r[0], h = a - r[1], d = c - r[1], p = {
    left: u,
    top: h,
    right: f,
    bottom: d
  };
  if (!ws(n, p, 0))
    return [];
  const g = [];
  return [
    [u, 0],
    [f, 0],
    [h, 1],
    [d, 1]
  ].forEach(([m, b]) => {
    n.forEach((S) => {
      const v = lt([0, 0], S);
      g.push(...Wl(S, m, b).map((E) => i + E - v).filter((E) => !ws(t, p, E)).map((E) => V(E * 180 / Math.PI, wt)));
    });
  }), g;
}
const Hl = ["left", "right", "center"], Vl = ["top", "bottom", "middle"], Cs = {
  left: "start",
  right: "end",
  center: "center",
  top: "start",
  bottom: "end",
  middle: "center"
}, Qt = {
  start: "left",
  end: "right",
  center: "center"
}, te = {
  start: "top",
  end: "bottom",
  center: "middle"
};
function Ee() {
  return {
    left: !1,
    top: !1,
    right: !1,
    bottom: !1
  };
}
function Ge(e, t) {
  const { props: { snappable: n, bounds: r, innerBounds: s, verticalGuidelines: i, horizontalGuidelines: o, snapGridWidth: a, snapGridHeight: l }, state: { guidelines: c, enableSnap: u } } = e;
  return !n || !u || t && n !== !0 && n.indexOf(t) < 0 ? !1 : !!(a || l || r || s || c && c.length || i && i.length || o && o.length);
}
function Vr(e) {
  return e === !1 ? {} : e === !0 || !e ? { left: !0, right: !0, top: !0, bottom: !0 } : e;
}
function ql(e, t) {
  const n = Vr(e), r = {};
  for (const s in n)
    s in t && n[s] && (r[s] = t[s]);
  return r;
}
function qr(e, t) {
  const n = ql(e, t), r = Vl.filter((i) => i in n), s = Hl.filter((i) => i in n);
  return {
    horizontalNames: r,
    verticalNames: s,
    horizontal: r.map((i) => n[i]),
    vertical: s.map((i) => n[i])
  };
}
function Ul(e, t, n) {
  const r = ot(e, [t.clientLeft, t.clientTop], n);
  return [t.left + r[0], t.top + r[1]];
}
function Zl([e, t]) {
  let n = t[0] - e[0], r = t[1] - e[1];
  Math.abs(n) < ft && (n = 0), Math.abs(r) < ft && (r = 0);
  let s = 0, i = 0, o = 0;
  return n ? r ? (s = -r / n, i = 1, o = s * e[0] - e[1]) : (i = 1, o = -e[1]) : (s = -1, o = e[0]), [s, i, o].map((a) => V(a, ft));
}
const to = "snapRotationThreshold", eo = "snapRotationDegrees", no = "snapHorizontalThreshold", ro = "snapVerticalThreshold";
function Yn(e, t, n, r = [], s = [], i, o) {
  var f;
  const a = e.props, l = ((f = e.state.snapThresholdInfo) == null ? void 0 : f.multiples) || [1, 1], c = ks(o, a[no], 5), u = ks(i, a[ro], 5);
  return so(e.state.guidelines, t, n, r, s, c, u, l);
}
function so(e, t, n, r, s, i, o, a) {
  return {
    vertical: Ps(e, "vertical", t, o * a[0], r),
    horizontal: Ps(e, "horizontal", n, i * a[1], s)
  };
}
function Kl(e, t, n) {
  const [r, s] = n, [i, o] = t;
  let [a, l] = W(n, t);
  const c = l > 0, u = a > 0;
  a = zn(a), l = zn(l);
  const f = {
    isSnap: !1,
    offset: 0,
    pos: 0
  }, h = {
    isSnap: !1,
    offset: 0,
    pos: 0
  };
  if (a === 0 && l === 0)
    return {
      vertical: f,
      horizontal: h
    };
  const { vertical: d, horizontal: p } = Yn(e, a ? [r] : [], l ? [s] : [], [], [], void 0, void 0);
  d.posInfos.filter(({ pos: x }) => u ? x >= i : x <= i), p.posInfos.filter(({ pos: x }) => c ? x >= o : x <= o), d.isSnap = d.posInfos.length > 0, p.isSnap = p.posInfos.length > 0;
  const { isSnap: g, guideline: m } = br(d), { isSnap: b, guideline: S } = br(p), v = b ? S.pos[1] : 0, E = g ? m.pos[0] : 0;
  if (a === 0)
    b && (h.isSnap = !0, h.pos = S.pos[1], h.offset = s - h.pos);
  else if (l === 0)
    g && (f.isSnap = !0, f.pos = E, f.offset = r - E);
  else {
    const x = l / a, w = n[1] - x * r;
    let D = 0, C = 0, P = !1;
    g ? (C = E, D = x * C + w, P = !0) : b && (D = v, C = (D - w) / x, P = !0), P && (f.isSnap = !0, f.pos = C, f.offset = r - C, h.isSnap = !0, h.pos = D, h.offset = s - D);
  }
  return {
    vertical: f,
    horizontal: h
  };
}
function Zt(e) {
  let t = "";
  return e === -1 || e === "top" || e === "left" ? t = "start" : e === 0 || e === "center" || e === "middle" ? t = "center" : (e === 1 || e === "right" || e === "bottom") && (t = "end"), t;
}
function ys(e, t, n, r) {
  const s = qr(e.props.snapDirections, t), i = Yn(e, s.vertical, s.horizontal, s.verticalNames.map((l) => Zt(l)), s.horizontalNames.map((l) => Zt(l)), n, r), o = Zt(s.horizontalNames[i.horizontal.index]), a = Zt(s.verticalNames[i.vertical.index]);
  return {
    vertical: {
      ...i.vertical,
      direction: a
    },
    horizontal: {
      ...i.horizontal,
      direction: o
    }
  };
}
function br(e) {
  const t = e.isSnap;
  if (!t)
    return {
      isSnap: !1,
      offset: 0,
      dist: -1,
      pos: 0,
      guideline: null
    };
  const n = e.posInfos[0], r = n.guidelineInfos[0], s = r.offset, i = r.dist, o = r.guideline;
  return {
    isSnap: t,
    offset: s,
    dist: i,
    pos: n.pos,
    guideline: o
  };
}
function Ps(e, t, n, r, s = []) {
  var c;
  if (!e || !e.length)
    return {
      isSnap: !1,
      index: -1,
      direction: "",
      posInfos: []
    };
  const o = t === "vertical" ? 0 : 1, a = n.map((u, f) => {
    const h = s[f] || "", d = e.map((p) => {
      const { pos: g } = p, m = u - g[o];
      return {
        offset: m,
        dist: z(m),
        guideline: p,
        direction: h
      };
    }).filter(({ guideline: p, dist: g }) => {
      const { type: m } = p;
      return !(m !== t || g > r);
    }).sort((p, g) => p.dist - g.dist);
    return {
      pos: u,
      index: f,
      guidelineInfos: d,
      direction: h
    };
  }).filter((u) => u.guidelineInfos.length > 0).sort((u, f) => u.guidelineInfos[0].dist - f.guidelineInfos[0].dist), l = a.length > 0;
  return {
    isSnap: l,
    index: l ? a[0].index : -1,
    direction: ((c = a[0]) == null ? void 0 : c.direction) ?? "",
    posInfos: a
  };
}
function Jl(e, t, n, r, s) {
  let i = [];
  n[0] && n[1] ? i = [
    n,
    [-n[0], n[1]],
    [n[0], -n[1]]
  ] : !n[0] && !n[1] ? [
    [-1, -1],
    [1, -1],
    [1, 1],
    [-1, 1]
  ].forEach((h, d, p) => {
    const g = p[d + 1] || p[0];
    i.push(h), i.push([(h[0] + g[0]) / 2, (h[1] + g[1]) / 2]);
  }) : e.props.keepRatio ? i.push([-1, -1], [-1, 1], [1, -1], [1, 1], n) : (i.push(...Ol([
    [-1, -1],
    [1, -1],
    [-1, -1],
    [1, 1]
  ], n)), i.length > 1 && i.push([
    (i[0][0] + i[1][0]) / 2,
    (i[0][1] + i[1][1]) / 2
  ]));
  const o = i.map((h) => pt(t, h)), a = o.map((h) => h[0]), l = o.map((h) => h[1]), c = Yn(e, a, l, i.map((h) => Zt(h[0])), i.map((h) => Zt(h[1])), r, s), u = Zt(i.map((h) => h[0])[c.vertical.index]), f = Zt(i.map((h) => h[1])[c.horizontal.index]);
  return {
    vertical: {
      ...c.vertical,
      direction: u
    },
    horizontal: {
      ...c.horizontal,
      direction: f
    }
  };
}
function io(e, t) {
  const n = z(e.offset), r = z(t.offset);
  return e.isBound && t.isBound ? r - n : e.isBound ? -1 : t.isBound ? 1 : e.isSnap && t.isSnap ? r - n : e.isSnap ? -1 : t.isSnap || n < wt ? 1 : r < wt ? -1 : n - r;
}
function On(e, t) {
  return e.slice().sort((n, r) => {
    const s = n.sign[t], i = r.sign[t], o = n.offset[t], a = r.offset[t];
    if (s) {
      if (!i)
        return -1;
    } else return 1;
    return io({ isBound: n.isBound, isSnap: n.isSnap, offset: o }, { isBound: r.isBound, isSnap: r.isSnap, offset: a });
  })[0];
}
function Ql(e, t, n) {
  const r = [];
  if (n)
    z(t[0]) !== 1 || z(t[1]) !== 1 ? r.push([t, [-1, -1]], [t, [-1, 1]], [t, [1, -1]], [t, [1, 1]]) : r.push([t, [e[0], -e[1]]], [t, [-e[0], e[1]]]), r.push([t, e]);
  else if (e[0] && e[1] || !e[0] && !e[1]) {
    const s = e[0] ? e : [1, 1];
    [1, -1].forEach((i) => {
      [1, -1].forEach((o) => {
        const a = [
          i * s[0],
          o * s[1]
        ];
        t[0] === a[0] && t[1] === a[1] || r.push([t, a]);
      });
    });
  } else e[0] ? (z(t[0]) === 1 ? [1] : [1, -1]).forEach((i) => {
    r.push([
      [t[0], -1],
      [i * e[0], -1]
    ], [
      [t[0], 0],
      [i * e[0], 0]
    ], [
      [t[0], 1],
      [i * e[0], 1]
    ]);
  }) : e[1] && (z(t[1]) === 1 ? [1] : [1, -1]).forEach((i) => {
    r.push([
      [-1, t[1]],
      [-1, i * e[1]]
    ], [
      [0, t[1]],
      [0, i * e[1]]
    ], [
      [1, t[1]],
      [1, i * e[1]]
    ]);
  });
  return r;
}
function oo(e, t) {
  const n = ar([t[0][0], t[1][0]]), r = ar([t[0][1], t[1][1]]);
  return {
    vertical: n <= e[0],
    horizontal: r <= e[1]
  };
}
function Ur(e, [t, n]) {
  let r = n[0] - t[0], s = n[1] - t[1];
  z(r) < wt && (r = 0), z(s) < wt && (s = 0);
  let i, o;
  return r ? s ? (i = s / r * (e[0] - t[0]) + t[1], o = e[1]) : (i = t[1], o = e[1]) : (i = t[0], o = e[0]), i - o;
}
function ao(e, t, n, r = wt) {
  return e.every((s) => {
    const i = Ur(s, t);
    return i <= 0 === n || z(i) <= r;
  });
}
function Ds(e, t, n, r, s = 0) {
  return r && t - s <= e || !r && e <= n + s ? {
    isBound: !0,
    offset: r ? t - e : n - e
  } : {
    isBound: !1,
    offset: 0
  };
}
function tc(e, { line: t, centerSign: n, verticalSign: r, horizontalSign: s, lineConstants: i }) {
  const o = e.props.innerBounds;
  if (!o)
    return {
      isAllBound: !1,
      isBound: !1,
      isVerticalBound: !1,
      isHorizontalBound: !1,
      offset: [0, 0]
    };
  const { left: a, top: l, width: c, height: u } = o, f = [
    [a, l],
    [a, l + u]
  ], h = [
    [a, l],
    [a + c, l]
  ], d = [
    [a + c, l],
    [a + c, l + u]
  ], p = [
    [a, l + u],
    [a + c, l + u]
  ];
  if (ao([
    [a, l],
    [a + c, l],
    [a, l + u],
    [a + c, l + u]
  ], t, n))
    return {
      isAllBound: !1,
      isBound: !1,
      isVerticalBound: !1,
      isHorizontalBound: !1,
      offset: [0, 0]
    };
  const g = Kt(t, i, h, r), m = Kt(t, i, p, r), b = Kt(t, i, f, s), S = Kt(t, i, d, s), v = g.isBound && m.isBound, E = g.isBound || m.isBound, x = b.isBound && S.isBound, w = b.isBound || S.isBound, D = Re(g.offset, m.offset), C = Re(b.offset, S.offset);
  let P = [0, 0], M = !1, y = !1;
  return z(C) < z(D) ? (P = [D, 0], M = E, y = v) : (P = [0, C], M = w, y = x), {
    isAllBound: y,
    isVerticalBound: E,
    isHorizontalBound: w,
    isBound: M,
    offset: P
  };
}
function Kt(e, [t, n], r, s, i, o) {
  const a = e[0], l = r[0], c = r[1], u = zn(c[1] - l[1]), f = zn(c[0] - l[0]), h = n, d = t, p = -t / n;
  if (f) {
    if (!u) {
      if (o && !h)
        return {
          isBound: !1,
          offset: 0
        };
      if (d) {
        const g = (l[1] - a[1]) / p + a[0];
        return Ds(g, l[0], c[0], s, i);
      } else {
        const g = l[1] - a[1], m = z(g) <= (i || 0);
        return {
          isBound: m,
          offset: m ? g : 0
        };
      }
    }
  } else {
    if (o && !d)
      return {
        isBound: !1,
        offset: 0
      };
    if (h) {
      const g = p * (l[0] - a[0]) + a[1];
      return Ds(g, l[1], c[1], s, i);
    } else {
      const g = l[0] - a[0], m = z(g) <= (i || 0);
      return {
        isBound: m,
        offset: m ? g : 0
      };
    }
  }
  return {
    isBound: !1,
    offset: 0
  };
}
function lo(e, t, n) {
  return t.map((r) => {
    const { isBound: s, offset: i, isVerticalBound: o, isHorizontalBound: a } = tc(e, r), l = r.multiple, c = Wt({
      datas: n,
      distX: i[0],
      distY: i[1]
    }).map((u, f) => u * (l[f] ? 2 / l[f] : 0));
    return {
      sign: l,
      isBound: s,
      isVerticalBound: o,
      isHorizontalBound: a,
      isSnap: !1,
      offset: c
    };
  });
}
function ec(e, t, n) {
  const r = Zr(e, t, [0, 0], !1).map((f) => ({
    ...f,
    multiple: f.multiple.map((h) => z(h) * 2)
  })), s = lo(e, r, n), i = On(s, 0), o = On(s, 1);
  let a = 0, l = 0;
  const c = i.isVerticalBound || o.isVerticalBound, u = i.isHorizontalBound || o.isHorizontalBound;
  return (c || u) && ([a, l] = Pl({
    datas: n,
    distX: -i.offset[0],
    distY: -o.offset[1]
  })), {
    vertical: {
      isBound: c,
      offset: a
    },
    horizontal: {
      isBound: u,
      offset: l
    }
  };
}
function nc(e, t) {
  const n = [], r = e[0], s = e[1];
  return r && s ? n.push([[0, s * 2], e, [-r, s]], [[r * 2, 0], e, [r, -s]]) : r ? (n.push([
    [r * 2, 0],
    [r, 1],
    [r, -1]
  ]), t && n.push([
    [0, -1],
    [r, -1],
    [-r, -1]
  ], [
    [0, 1],
    [r, 1],
    [-r, 1]
  ])) : s ? (n.push([
    [0, s * 2],
    [1, s],
    [-1, s]
  ]), t && n.push([
    [-1, 0],
    [-1, s],
    [-1, -s]
  ], [
    [1, 0],
    [1, s],
    [1, -s]
  ])) : n.push([
    [-1, 0],
    [-1, -1],
    [-1, 1]
  ], [
    [1, 0],
    [1, -1],
    [1, 1]
  ], [
    [0, -1],
    [-1, -1],
    [1, -1]
  ], [
    [0, 1],
    [-1, 1],
    [1, 1]
  ]), n;
}
function Zr(e, t, n, r) {
  const { allMatrix: s, is3d: i } = e.state, o = ge(s, 100, 100, i ? 4 : 3), a = pt(o, [0, 0]);
  return nc(n, r).map(([l, c, u]) => {
    const f = [
      pt(o, c),
      pt(o, u)
    ], h = Zl(f), { vertical: d, horizontal: p } = oo(a, f), g = Ur(a, f) <= 0;
    return {
      multiple: l,
      centerSign: g,
      verticalSign: d,
      horizontalSign: p,
      lineConstants: h,
      line: [pt(t, c), pt(t, u)]
    };
  });
}
function Os(e, t, n, r) {
  const s = r ? e.map((i) => Ze(i, r)) : e;
  return [
    [s[0], s[1]],
    [s[1], s[3]],
    [s[3], s[2]],
    [s[2], s[0]]
  ].some((i) => {
    const o = Ur(n, i) <= 0;
    return !ao(t, i, o);
  });
}
function rc([e, t]) {
  const n = t[0] - e[0], r = t[1] - e[1];
  if (!n)
    return z(e[0]);
  if (!r)
    return z(e[1]);
  const s = r / n;
  return z((-s * e[0] + e[1]) / Math.sqrt(Math.pow(s, 2) + 1));
}
function sc([e, t]) {
  const n = t[0] - e[0], r = t[1] - e[1];
  if (!n)
    return [e[0], 0];
  if (!r)
    return [0, e[1]];
  const s = r / n, i = -s * e[0] + e[1];
  return [-i / (s + 1 / s), i / (s * s + 1)];
}
function ic(e, t, n, r, s) {
  const i = e.props.innerBounds, o = s * Math.PI / 180;
  if (!i)
    return [];
  const { left: a, top: l, width: c, height: u } = i, f = a - r[0], h = a + c - r[0], d = l - r[1], p = l + u - r[1], g = [
    [f, d],
    [h, d],
    [f, p],
    [h, p]
  ], m = pt(n, [0, 0]);
  if (!Os(n, g, m, 0))
    return [];
  const b = [], S = g.map((v) => [_t(v), lt([0, 0], v)]);
  return [
    [n[0], n[1]],
    [n[1], n[3]],
    [n[3], n[2]],
    [n[2], n[0]]
  ].forEach((v) => {
    const E = lt([0, 0], sc(v)), x = rc(v);
    b.push(...S.filter(([w]) => w && x <= w).map(([w, D]) => {
      const C = Math.acos(w ? x / w : 0), P = D + C, M = D - C;
      return [o + P - E, o + M - E];
    }).reduce((w, D) => (w.push(...D), w), []).filter((w) => !Os(t, g, m, w)).map((w) => V(w * 180 / Math.PI, wt)));
  }), b;
}
function oc(e) {
  const t = e.props.innerBounds, n = Ee();
  if (!t)
    return {
      boundMap: n,
      vertical: [],
      horizontal: []
    };
  const { pos1: r, pos2: s, pos3: i, pos4: o } = e.getRect(), a = [r, s, i, o], l = pt(a, [0, 0]), { left: c, top: u, width: f, height: h } = t, d = [
    [c, u],
    [c, u + h]
  ], p = [
    [c, u],
    [c + f, u]
  ], g = [
    [c + f, u],
    [c + f, u + h]
  ], m = [
    [c, u + h],
    [c + f, u + h]
  ], b = Zr(e, a, [0, 0], !1), S = [], v = [];
  return b.forEach((E) => {
    const { line: x, lineConstants: w } = E, { horizontal: D, vertical: C } = oo(l, x), P = Kt(x, w, p, C, 1, !0), M = Kt(x, w, m, C, 1, !0), y = Kt(x, w, d, D, 1, !0), T = Kt(x, w, g, D, 1, !0);
    P.isBound && !n.top && (S.push(u), n.top = !0), M.isBound && !n.bottom && (S.push(u + h), n.bottom = !0), y.isBound && !n.left && (v.push(c), n.left = !0), T.isBound && !n.right && (v.push(c + f), n.right = !0);
  }), {
    boundMap: n,
    horizontal: S,
    vertical: v
  };
}
function ac(e, t, n, r) {
  let s = t[0] - e[0], i = t[1] - e[1];
  if (z(s) < ft && (s = 0), z(i) < ft && (i = 0), !s)
    return r ? [0, 0] : [0, n];
  if (!i)
    return r ? [n, 0] : [0, 0];
  const o = i / s, a = e[1] - o * e[0];
  if (r) {
    const l = o * (t[0] + n) + a;
    return [n, l - t[1]];
  } else
    return [(t[1] + n - a) / o - t[0], n];
}
function vr(e, t, n, r, s) {
  const i = ac(e, t, n, r);
  if (!i)
    return {
      isOutside: !1,
      offset: [0, 0]
    };
  const o = Ft(e, t), a = Ft(i, e), l = Ft(i, t), c = a > o || l > o, [u, f] = Wt({
    datas: s,
    distX: i[0],
    distY: i[1]
  });
  return {
    offset: [u, f],
    isOutside: c
  };
}
function Mn(e, t) {
  return e.isBound ? e.offset : t.isSnap ? br(t).offset : 0;
}
function lc(e, [t, n], [r, s], [i, o], [a, l]) {
  let c = -a, u = -l;
  if (e && t && n) {
    c = 0, u = 0;
    const f = [];
    if (r && s ? f.push([0, l], [a, 0]) : r ? f.push([a, 0]) : s ? f.push([0, l]) : i && o ? f.push([0, l], [a, 0]) : i ? f.push([a, 0]) : o && f.push([0, l]), f.length) {
      f.sort((d, p) => _t(W([t, n], d)) - _t(W([t, n], p)));
      const h = f[0];
      if (h[0] && z(t) > ft)
        c = -h[0], u = n * z(t + c) / z(t) - n;
      else if (h[1] && z(n) > ft) {
        const d = n;
        u = -h[1], c = t * z(n + u) / z(d) - t;
      }
      if (e && s && r)
        if (z(c) > ft && z(c) < z(a)) {
          const d = z(a) / z(c);
          c *= d, u *= d;
        } else if (z(u) > ft && z(u) < z(l)) {
          const d = z(l) / z(u);
          c *= d, u *= d;
        } else
          c = Re(-a, c), u = Re(-l, u);
    }
  } else
    c = t || r ? -a : 0, u = n || s ? -l : 0;
  return [c, u];
}
function cc(e, t, n, r, s, i) {
  if (!Ge(e, "draggable"))
    return [
      {
        isSnap: !1,
        isBound: !1,
        offset: 0
      },
      {
        isSnap: !1,
        isBound: !1,
        offset: 0
      }
    ];
  const o = Qr(i.absolutePoses, [t, n]), { left: a, right: l, top: c, bottom: u } = zt(o), f = {
    horizontal: o.map((M) => M[1]),
    vertical: o.map((M) => M[0])
  }, h = Vr(e.props.snapDirections), d = qr(h, {
    left: a,
    right: l,
    top: c,
    bottom: u,
    center: (a + l) / 2,
    middle: (c + u) / 2
  }), { vertical: p, horizontal: g } = Fn(e, s, d, f), { vertical: m, horizontal: b } = ec(e, o, i), S = p.isSnap, v = g.isSnap, E = p.isBound || m.isBound, x = g.isBound || b.isBound, w = Re(p.offset, m.offset), D = Re(g.offset, b.offset), [C, P] = lc(r, [t, n], [E, x], [S, v], [w, D]);
  return [
    {
      isBound: E,
      isSnap: S,
      offset: C
    },
    {
      isBound: x,
      isSnap: v,
      offset: P
    }
  ];
}
function Fn(e, t, n, r = n) {
  const { horizontal: s, vertical: i } = Hr(Xn(e), r.vertical, r.horizontal), { horizontal: o, vertical: a } = t ? {
    horizontal: { isSnap: !1, index: -1 },
    vertical: { isSnap: !1, index: -1 }
  } : Yn(e, n.vertical, n.horizontal, void 0, void 0, void 0, void 0), l = Mn(s[0], o), c = Mn(i[0], a), u = z(l), f = z(c);
  return {
    horizontal: {
      isBound: s[0].isBound,
      isSnap: o.isSnap,
      snapIndex: o.index,
      offset: l,
      dist: u,
      bounds: s,
      snap: o
    },
    vertical: {
      isBound: i[0].isBound,
      isSnap: a.isSnap,
      snapIndex: a.index,
      offset: c,
      dist: f,
      bounds: i,
      snap: a
    }
  };
}
function Ms(e, t, n, r, s, i, o = [1, 1]) {
  const { horizontal: a, vertical: l } = Hr(t, n, r), { horizontal: c, vertical: u } = so(e, n, r, [], [], s, i, o), f = Mn(a[0], c), h = Mn(l[0], u), d = z(f), p = z(h);
  return {
    horizontal: {
      isBound: a[0].isBound,
      isSnap: c.isSnap,
      snapIndex: c.index,
      offset: f,
      dist: d,
      bounds: a,
      snap: c
    },
    vertical: {
      isBound: l[0].isBound,
      isSnap: u.isSnap,
      snapIndex: u.index,
      offset: h,
      dist: p,
      bounds: l,
      snap: u
    }
  };
}
function uc(e, t, n, r) {
  const s = lt(e, t) / Math.PI * 180, { vertical: { isBound: i, isSnap: o, dist: a }, horizontal: { isBound: l, isSnap: c, dist: u } } = n, f = s % 180, h = f < 3 || f > 177, d = f > 87 && f < 93;
  return u < a && (i || o && !d && (!r || !h)) ? "vertical" : l || c && !h && (!r || !d) ? "horizontal" : "";
}
function fc(e, t, n, r, s, i) {
  return n.map(([o, a]) => {
    const l = pt(t, o), c = pt(t, a), u = r ? hc(e, l, c, s) : Fn(e, s, {
      vertical: [c[0]],
      horizontal: [c[1]]
    }), { horizontal: {
      // dist: otherHorizontalDist,
      offset: f,
      isBound: h,
      isSnap: d
    }, vertical: {
      // dist: otherVerticalDist,
      offset: p,
      isBound: g,
      isSnap: m
    } } = u, b = W(a, o);
    if (!p && !f)
      return {
        isBound: g || h,
        isSnap: m || d,
        sign: b,
        offset: [0, 0]
      };
    const S = uc(l, c, u, r);
    if (!S)
      return {
        sign: b,
        isBound: !1,
        isSnap: !1,
        offset: [0, 0]
      };
    const v = S === "vertical";
    let E = [0, 0];
    return !r && z(a[0]) === 1 && z(a[1]) === 1 && o[0] !== a[0] && o[1] !== a[1] ? E = Wt({
      datas: i,
      distX: -p,
      distY: -f
    }) : E = vr(l, c, -(v ? p : f), v, i).offset, E = E.map((x, w) => x * (b[w] ? 2 / b[w] : 0)), {
      sign: b,
      isBound: v ? g : h,
      isSnap: v ? m : d,
      offset: E
    };
  });
}
function Ts(e, t) {
  return e.isBound ? e.offset : t.isSnap ? t.offset : 0;
}
function hc(e, t, n, r) {
  const { horizontal: s, vertical: i } = Ll(e, t, n), { horizontal: o, vertical: a } = r ? {
    horizontal: { isSnap: !1 },
    vertical: { isSnap: !1 }
  } : Kl(e, t, n), l = Ts(s, o), c = Ts(i, a), u = z(l), f = z(c);
  return {
    horizontal: {
      isBound: s.isBound,
      isSnap: o.isSnap,
      offset: l,
      dist: u
    },
    vertical: {
      isBound: i.isBound,
      isSnap: a.isSnap,
      offset: c,
      dist: f
    }
  };
}
function dc(e, t, n, r, s) {
  const i = [-n[0], -n[1]], { width: o, height: a } = e.state, l = e.props.bounds;
  let c = 1 / 0, u = 1 / 0;
  if (l) {
    const f = [
      [n[0], -n[1]],
      [-n[0], n[1]]
    ], { left: h = -1 / 0, top: d = -1 / 0, right: p = 1 / 0, bottom: g = 1 / 0 } = l;
    f.forEach((m) => {
      const b = m[0] !== i[0], S = m[1] !== i[1], v = pt(t, m), E = lt(r, v) * 360 / Math.PI;
      if (S) {
        const x = v.slice();
        (z(E - 360) < 2 || z(E - 180) < 2) && (x[1] = r[1]);
        const { offset: [, w], isOutside: D } = vr(r, x, (r[1] < v[1] ? g : d) - v[1], !1, s);
        isNaN(w) || (u = a + (D ? 1 : -1) * z(w));
      }
      if (b) {
        const x = v.slice();
        (z(E - 90) < 2 || z(E - 270) < 2) && (x[0] = r[0]);
        const { offset: [w], isOutside: D } = vr(r, x, (r[0] < v[0] ? p : h) - v[0], !0, s);
        isNaN(w) || (c = o + (D ? 1 : -1) * z(w));
      }
    });
  }
  return {
    maxWidth: c,
    maxHeight: u
  };
}
const vt = {
  name: "draggable",
  props: [
    "draggable",
    "throttleDrag",
    "throttleDragRotate",
    "hideThrottleDragRotateLine",
    "startDragRotate",
    "edgeDraggable"
  ],
  events: [
    "dragStart",
    "drag",
    "dragEnd",
    "dragGroupStart",
    "dragGroup",
    "dragGroupEnd"
  ],
  requestStyle() {
    return ["left", "top", "right", "bottom"];
  },
  requestChildStyle() {
    return ["left", "top", "right", "bottom"];
  },
  render(e, t) {
    const { hideThrottleDragRotateLine: n, throttleDragRotate: r, zoom: s } = e.props, { dragInfo: i, beforeOrigin: o } = e.getState();
    if (n || !r || !i)
      return [];
    const a = i.dist;
    if (!a[0] && !a[1])
      return [];
    const l = _t(a), c = lt(a, [0, 0]);
    return [
      Z("div", { className: L("line", "horizontal", "dragline", "dashed"), style: {
        width: `${l}px`,
        transform: `translate(${o[0]}px, ${o[1]}px) rotate(${c}rad) scaleY(${s})`
      } }, "dragRotateGuideline")
    ];
  },
  dragStart(e, t) {
    const { datas: n, parentEvent: r, parentGesto: s } = t, i = e.state, { gestos: o, style: a } = i;
    if (o.draggable)
      return !1;
    o.draggable = s || e.targetGesto, n.datas = {}, n.left = parseFloat(a.left || "") || 0, n.top = parseFloat(a.top || "") || 0, n.bottom = parseFloat(a.bottom || "") || 0, n.right = parseFloat(a.right || "") || 0, n.startValue = [0, 0], pe(e, t), jn(e, t, "translate"), _c(e, n), n.prevDist = [0, 0], n.prevBeforeDist = [0, 0], n.isDrag = !1, n.deltaOffset = [0, 0];
    const l = U(e, t, {
      set: (u) => {
        n.startValue = u;
      },
      ...kn(e, t)
    });
    return (r || Y(e, "onDragStart", l)) !== !1 ? (n.isDrag = !0, e.state.dragInfo = {
      startRect: e.getRect(),
      dist: [0, 0]
    }) : (o.draggable = null, n.isPinch = !1), n.isDrag ? l : !1;
  },
  drag(e, t) {
    if (!t)
      return;
    Gn(e, t, "translate");
    const { datas: n, parentEvent: r, parentFlag: s, isPinch: i, deltaOffset: o, useSnap: a, isRequest: l, isGroup: c, parentThrottleDrag: u } = t;
    let { distX: f, distY: h } = t;
    const { isDrag: d, prevDist: p, prevBeforeDist: g, startValue: m } = n;
    if (!d)
      return;
    o && (f += o[0], h += o[1]);
    const b = e.props, S = b.parentMoveable, v = c ? 0 : b.throttleDrag || u || 0, E = r ? 0 : b.throttleDragRotate || 0;
    let x = 0, w = !1, D = !1, C = !1, P = !1;
    if (!r && E > 0 && (f || h)) {
      const X = b.startDragRotate || 0, J = V(X + lt([0, 0], [f, h]) * 180 / Math.PI, E) - X, $ = h * Math.abs(Math.cos((J - 90) / 180 * Math.PI)), F = f * Math.abs(Math.cos(J / 180 * Math.PI)), H = _t([F, $]);
      x = J * Math.PI / 180, f = H * Math.cos(x), h = H * Math.sin(x);
    }
    if (!i && !r && !s) {
      const [X, J] = cc(e, f, h, E, !a && l || o, n);
      w = X.isSnap, D = X.isBound, C = J.isSnap, P = J.isBound;
      const $ = X.offset, F = J.offset;
      f += $, h += F;
    }
    const M = Q(Li({ datas: n, distX: f, distY: h }), m), y = Q(yl({ datas: n, distX: f, distY: h }), m);
    hs(y, wt), hs(M, wt), E || (!w && !D && (y[0] = V(y[0], v), M[0] = V(M[0], v)), !C && !P && (y[1] = V(y[1], v), M[1] = V(M[1], v)));
    const T = W(M, m), O = W(y, m), R = W(O, p), I = W(T, g);
    n.prevDist = O, n.prevBeforeDist = T, n.passDelta = R, n.passDist = O;
    const _ = n.left + T[0], A = n.top + T[1], B = n.right - T[0], N = n.bottom - T[1], G = $n(n, `translate(${y[0]}px, ${y[1]}px)`, `translate(${O[0]}px, ${O[1]}px)`);
    if (Wr(t, G), e.state.dragInfo.dist = r ? [0, 0] : O, !r && !S && R.every((X) => !X) && I.some((X) => !X))
      return;
    const { width: k, height: q } = e.state, j = U(e, t, {
      transform: G,
      dist: O,
      delta: R,
      translate: y,
      beforeDist: T,
      beforeDelta: I,
      beforeTranslate: M,
      left: _,
      top: A,
      right: B,
      bottom: N,
      width: k,
      height: q,
      isPinch: i,
      ...xt({
        transform: G
      }, t)
    });
    return !r && Y(e, "onDrag", j), j;
  },
  dragAfter(e, t) {
    const n = t.datas, { deltaOffset: r } = n;
    return r[0] || r[1] ? (n.deltaOffset = [0, 0], this.drag(e, { ...t, deltaOffset: r })) : !1;
  },
  dragEnd(e, t) {
    const { parentEvent: n, datas: r } = t;
    if (e.state.dragInfo = null, !r.isDrag)
      return;
    r.isDrag = !1;
    const s = Mt(e, t, {});
    return !n && Y(e, "onDragEnd", s), s;
  },
  dragGroupStart(e, t) {
    var f;
    const { datas: n, clientX: r, clientY: s } = t, i = this.dragStart(e, t);
    if (!i)
      return !1;
    const { childEvents: o, eventParams: a } = Qn(e, this, "dragStart", [r || 0, s || 0], t, !1, "draggable"), l = {
      ...i,
      targets: e.props.targets,
      events: a
    }, c = Y(e, "onDragGroupStart", l);
    n.isDrag = c !== !1;
    const u = ((f = o[0]) == null ? void 0 : f.datas.startValue) ?? [0, 0];
    return n.throttleOffset = [u[0] % 1, u[1] % 1], n.isDrag ? i : !1;
  },
  dragGroup(e, t) {
    const { datas: n } = t;
    if (!n.isDrag)
      return;
    const r = this.drag(e, {
      ...t,
      parentThrottleDrag: e.props.throttleDrag
    }), { passDelta: s } = t.datas, { eventParams: i } = Qn(e, this, "drag", s, t, !1, "draggable");
    if (!r)
      return;
    const o = {
      targets: e.props.targets,
      events: i,
      ...r
    };
    return Y(e, "onDragGroup", o), o;
  },
  dragGroupEnd(e, t) {
    const { isDrag: n, datas: r } = t;
    if (!r.isDrag)
      return;
    this.dragEnd(e, t);
    const { eventParams: s } = Qn(e, this, "dragEnd", [0, 0], t, !1, "draggable");
    return Y(e, "onDragGroupEnd", Mt(e, t, {
      targets: e.props.targets,
      events: s
    })), n;
  },
  /**
       * @method Moveable.Draggable#request
       * @param {object} [e] - the draggable's request parameter
       * @param {number} [e.x] - x position
       * @param {number} [e.y] - y position
       * @param {number} [e.deltaX] - X number to move
       * @param {number} [e.deltaY] - Y number to move
       * @return {Moveable.Requester} Moveable Requester
       * @example
  
       * // Instantly Request (requestStart - request - requestEnd)
       * // Use Relative Value
       * moveable.request("draggable", { deltaX: 10, deltaY: 10 }, true);
       * // Use Absolute Value
       * moveable.request("draggable", { x: 200, y: 100 }, true);
       *
       * // requestStart
       * const requester = moveable.request("draggable");
       *
       * // request
       * // Use Relative Value
       * requester.request({ deltaX: 10, deltaY: 10 });
       * requester.request({ deltaX: 10, deltaY: 10 });
       * requester.request({ deltaX: 10, deltaY: 10 });
       * // Use Absolute Value
       * moveable.request("draggable", { x: 200, y: 100 });
       * moveable.request("draggable", { x: 220, y: 100 });
       * moveable.request("draggable", { x: 240, y: 100 });
       *
       * // requestEnd
       * requester.requestEnd();
       */
  request(e) {
    const t = {}, n = e.getRect();
    let r = 0, s = 0, i = !1;
    return {
      isControl: !1,
      requestStart(o) {
        return i = o.useSnap, { datas: t, useSnap: i };
      },
      request(o) {
        return "x" in o ? r = o.x - n.left : "deltaX" in o && (r += o.deltaX), "y" in o ? s = o.y - n.top : "deltaY" in o && (s += o.deltaY), { datas: t, distX: r, distY: s, useSnap: i };
      },
      requestEnd() {
        return { datas: t, isDrag: !0, useSnap: i };
      }
    };
  },
  unset(e) {
    e.state.gestos.draggable = null, e.state.dragInfo = null;
  }
};
function co(e, t) {
  return {
    fixedPosition: pt(e, t),
    fixedDirection: t,
    fixedOffset: [0, 0]
  };
}
function pc(e, t) {
  const { allMatrix: n, is3d: r, width: s, height: i } = e, o = r ? 4 : 3, a = [
    s / 2 * (1 + t[0]),
    i / 2 * (1 + t[1])
  ];
  return {
    fixedPosition: ot(n, a, o),
    fixedDirection: t,
    fixedOffset: [0, 0]
  };
}
function uo(e, t) {
  const { allMatrix: n, is3d: r, width: s, height: i } = e, o = r ? 4 : 3, a = _l(t, s, i), l = ot(n, t, o), c = [
    s ? 0 : t[0],
    i ? 0 : t[1]
  ];
  return {
    fixedPosition: l,
    fixedDirection: a,
    fixedOffset: c
  };
}
const Rs = ns("resizable"), Sr = {
  name: "resizable",
  ableGroup: "size",
  canPinch: !0,
  props: [
    "resizable",
    "throttleResize",
    "renderDirections",
    "displayAroundControls",
    "keepRatio",
    "resizeFormat",
    "keepRatioFinally",
    "edge",
    "checkResizableError"
  ],
  events: [
    "resizeStart",
    "beforeResize",
    "resize",
    "resizeEnd",
    "resizeGroupStart",
    "beforeResizeGroup",
    "resizeGroup",
    "resizeGroupEnd"
  ],
  render: Ki("resizable"),
  dragControlCondition: Rs,
  viewClassName: es("resizable"),
  dragControlStart(e, t) {
    const { inputEvent: n, isPinch: r, isGroup: s, parentDirection: i, parentGesto: o, datas: a, parentFixedDirection: l, parentEvent: c } = t, u = yo(i, r, n, a), f = e.state, { target: h, width: d, height: p, gestos: g } = f;
    if (!u || !h || g.resizable)
      return !1;
    g.resizable = o || e.controlGesto, !r && pe(e, t), a.datas = {}, a.direction = u, a.startOffsetWidth = d, a.startOffsetHeight = p, a.prevWidth = 0, a.prevHeight = 0, a.minSize = [0, 0], a.startWidth = f.inlineCSSWidth || f.cssWidth, a.startHeight = f.inlineCSSHeight || f.cssHeight, a.maxSize = [1 / 0, 1 / 0], s || (a.minSize = [f.minOffsetWidth, f.minOffsetHeight], a.maxSize = [f.maxOffsetWidth, f.maxOffsetHeight]);
    const m = e.props.transformOrigin || "% %";
    a.transformOrigin = jt(m) ? m.split(" ") : m, a.startOffsetMatrix = f.offsetMatrix, a.startTransformOrigin = f.transformOrigin, a.isWidth = (t == null ? void 0 : t.parentIsWidth) ?? (!u[0] && !u[1] || u[0] || !u[1]);
    function b(C) {
      a.ratio = C && isFinite(C) ? C : 0;
    }
    a.startPositions = It(e.state);
    function S(C) {
      const P = co(a.startPositions, C);
      a.fixedDirection = P.fixedDirection, a.fixedPosition = P.fixedPosition, a.fixedOffset = P.fixedOffset;
    }
    function v(C) {
      const P = uo(e.state, C);
      a.fixedDirection = P.fixedDirection, a.fixedPosition = P.fixedPosition, a.fixedOffset = P.fixedOffset;
    }
    function E(C) {
      a.minSize = [
        K(`${C[0]}`, 0) || 0,
        K(`${C[1]}`, 0) || 0
      ];
    }
    function x(C) {
      const P = [C[0] || 1 / 0, C[1] || 1 / 0];
      (!He(P[0]) || isFinite(P[0])) && (P[0] = K(`${P[0]}`, 0) || 1 / 0), (!He(P[1]) || isFinite(P[1])) && (P[1] = K(`${P[1]}`, 0) || 1 / 0), a.maxSize = P;
    }
    b(d / p), S(l || [-u[0], -u[1]]), a.setFixedDirection = S, a.setFixedPosition = v, a.setMin = E, a.setMax = x;
    const w = U(e, t, {
      direction: u,
      startRatio: a.ratio,
      set: ([C, P]) => {
        a.startWidth = C, a.startHeight = P;
      },
      setMin: E,
      setMax: x,
      setRatio: b,
      setFixedDirection: S,
      setFixedPosition: v,
      setOrigin: (C) => {
        a.transformOrigin = C;
      },
      dragStart: vt.dragStart(e, new Me().dragStart([0, 0], t))
    }), D = c || Y(e, "onResizeStart", w);
    return a.startFixedDirection = a.fixedDirection, a.startFixedPosition = a.fixedPosition, D !== !1 && (a.isResize = !0, e.state.snapRenderInfo = {
      request: t.isRequest,
      direction: u
    }), a.isResize ? w : !1;
  },
  dragControl(e, t) {
    const { datas: n, parentFlag: r, isPinch: s, parentKeepRatio: i, dragClient: o, parentDist: a, useSnap: l, isRequest: c, isGroup: u, parentEvent: f, resolveMatrix: h } = t, { isResize: d, transformOrigin: p, startWidth: g, startHeight: m, prevWidth: b, prevHeight: S, minSize: v, maxSize: E, ratio: x, startOffsetWidth: w, startOffsetHeight: D, isWidth: C } = n;
    if (!d)
      return;
    if (h) {
      const { is3d: st } = e.state, { startOffsetMatrix: Nt, startTransformOrigin: ut } = n, gt = st ? 4 : 3;
      let Xt = De(Pn(t));
      const en = Math.sqrt(Xt.length);
      gt !== en && (Xt = kt(Xt, en, gt));
      const us = tn(Nt, Xt, ut, gt), sa = ge(us, w, D, gt);
      n.startPositions = sa, n.nextTargetMatrix = Xt, n.nextAllMatrix = us;
    }
    const P = he(e.props, "resizable"), { resizeFormat: M, throttleResize: y = r ? 0 : 1, parentMoveable: T, keepRatioFinally: O } = P, R = n.direction;
    let I = R, _ = 0, A = 0;
    !R[0] && !R[1] && (I = [1, 1]);
    const B = x && (i ?? P.keepRatio) || !1;
    function N() {
      const st = n.fixedDirection, Nt = Ro(I, B, n, t);
      _ = Nt.distWidth, A = Nt.distHeight;
      let ut = I[0] - st[0] || B ? Math.max(w + _, wt) : w, gt = I[1] - st[1] || B ? Math.max(D + A, wt) : D;
      return B && w && D && (C ? gt = ut / x : ut = gt * x), [ut, gt];
    }
    let [G, k] = N();
    f || (n.setFixedDirection(n.fixedDirection), Y(e, "onBeforeResize", U(e, t, {
      startFixedDirection: n.startFixedDirection,
      startFixedPosition: n.startFixedPosition,
      setFixedDirection(st) {
        return n.setFixedDirection(st), [G, k] = N(), [G, k];
      },
      setFixedPosition(st) {
        return n.setFixedPosition(st), [G, k] = N(), [G, k];
      },
      boundingWidth: G,
      boundingHeight: k,
      setSize(st) {
        [G, k] = st;
      }
    }, !0)));
    let q = o;
    o || (!r && s ? q = Gl(e, [0, 0]) : q = n.fixedPosition);
    let j = [0, 0];
    s || (j = Rc(e, G, k, R, q, !l && c, n)), a && (!a[0] && (j[0] = 0), !a[1] && (j[1] = 0));
    function X() {
      M && ([G, k] = M([
        G,
        k
      ])), G = V(G, y), k = V(k, y);
    }
    if (B) {
      I[0] && I[1] && j[0] && j[1] && (z(j[0]) > z(j[1]) ? j[1] = 0 : j[0] = 0);
      const st = !j[0] && !j[1];
      st && X(), I[0] && !I[1] || j[0] && !j[1] || st && C ? (G += j[0], k = G / x) : (!I[0] && I[1] || !j[0] && j[1] || st && !C) && (k += j[1], G = k * x);
    } else
      G += j[0], k += j[1], G = Math.max(0, G), k = Math.max(0, k);
    [G, k] = Rr([G, k], v, E, B ? x : !1), X(), B && (u || O) && (C ? k = G / x : G = k * x), _ = G - w, A = k - D;
    const J = [_ - b, A - S];
    n.prevWidth = _, n.prevHeight = A;
    const $ = Al(e, G, k, q, p, n);
    if (!T && J.every((st) => !st) && $.every((st) => !st))
      return;
    const F = vt.drag(e, Qe(t, e.state, $, !!s, !1, "draggable")), H = F.transform, rt = g + _, dt = m + A, ct = U(e, t, {
      width: rt,
      height: dt,
      offsetWidth: Math.round(G),
      offsetHeight: Math.round(k),
      startRatio: x,
      boundingWidth: G,
      boundingHeight: k,
      direction: R,
      dist: [_, A],
      delta: J,
      isPinch: !!s,
      drag: F,
      ...Do({
        style: {
          width: `${rt}px`,
          height: `${dt}px`
        },
        transform: H
      }, F, t)
    });
    return !f && Y(e, "onResize", ct), ct;
  },
  dragControlAfter(e, t) {
    const n = t.datas, { isResize: r, startOffsetWidth: s, startOffsetHeight: i, prevWidth: o, prevHeight: a } = n;
    if (!r || e.props.checkResizableError === !1)
      return;
    const { width: l, height: c } = e.state, u = l - (s + o), f = c - (i + a), h = z(u) > 3, d = z(f) > 3;
    if (h && (n.startWidth += u, n.startOffsetWidth += u, n.prevWidth += u), d && (n.startHeight += f, n.startOffsetHeight += f, n.prevHeight += f), h || d)
      return this.dragControl(e, t);
  },
  dragControlEnd(e, t) {
    const { datas: n, parentEvent: r } = t;
    if (!n.isResize)
      return;
    n.isResize = !1;
    const s = Mt(e, t, {});
    return !r && Y(e, "onResizeEnd", s), s;
  },
  dragGroupControlCondition: Rs,
  dragGroupControlStart(e, t) {
    const { datas: n } = t, r = this.dragControlStart(e, { ...t, isGroup: !0 });
    if (!r)
      return !1;
    const s = Gt(e, "resizable", t), { startOffsetWidth: i, startOffsetHeight: o } = n;
    function a() {
      const d = n.minSize;
      s.forEach((p) => {
        const { minSize: g, startOffsetWidth: m, startOffsetHeight: b } = p.datas, S = i * (m ? g[0] / m : 0), v = o * (b ? g[1] / b : 0);
        d[0] = Math.max(d[0], S), d[1] = Math.max(d[1], v);
      });
    }
    function l() {
      const d = n.maxSize;
      s.forEach((p) => {
        const { maxSize: g, startOffsetWidth: m, startOffsetHeight: b } = p.datas, S = i * (m ? g[0] / m : 0), v = o * (b ? g[1] / b : 0);
        d[0] = Math.min(d[0], S), d[1] = Math.min(d[1], v);
      });
    }
    const c = Vt(e, this, "dragControlStart", t, (d, p) => Dn(e, d, n, p));
    a(), l();
    const u = (d) => {
      r.setFixedDirection(d), c.forEach((p, g) => {
        p.setFixedDirection(d), Dn(e, p.moveable, n, s[g]);
      });
    };
    n.setFixedDirection = u;
    const f = {
      ...r,
      targets: e.props.targets,
      events: c.map((d) => ({
        ...d,
        setMin: (p) => {
          d.setMin(p), a();
        },
        setMax: (p) => {
          d.setMax(p), l();
        }
      })),
      setFixedDirection: u,
      setMin: (d) => {
        r.setMin(d), a();
      },
      setMax: (d) => {
        r.setMax(d), l();
      }
    }, h = Y(e, "onResizeGroupStart", f);
    return n.isResize = h !== !1, n.isResize ? r : !1;
  },
  dragGroupControl(e, t) {
    const { datas: n } = t;
    if (!n.isResize)
      return;
    const r = he(e.props, "resizable");
    Wn(e, "onBeforeResize", (d) => {
      Y(e, "onBeforeResizeGroup", U(e, t, {
        ...d,
        targets: r.targets
      }, !0));
    });
    const s = this.dragControl(e, { ...t, isGroup: !0 });
    if (!s)
      return;
    const { boundingWidth: i, boundingHeight: o, dist: a } = s, l = r.keepRatio, c = [
      i / (i - a[0]),
      o / (o - a[1])
    ], u = n.fixedPosition, f = Vt(e, this, "dragControl", t, (d, p) => {
      const [g, m] = mt(Ke(e.rotation / 180 * Math.PI, 3), [
        p.datas.originalX * c[0],
        p.datas.originalY * c[1],
        1
      ], 3);
      return {
        ...p,
        parentDist: null,
        parentScale: c,
        dragClient: Q(u, [g, m]),
        parentKeepRatio: l
      };
    }), h = {
      targets: r.targets,
      events: f,
      ...s
    };
    return Y(e, "onResizeGroup", h), h;
  },
  dragGroupControlEnd(e, t) {
    const { isDrag: n, datas: r } = t;
    if (!r.isResize)
      return;
    this.dragControlEnd(e, t);
    const s = Vt(e, this, "dragControlEnd", t), i = Mt(e, t, {
      targets: e.props.targets,
      events: s
    });
    return Y(e, "onResizeGroupEnd", i), n;
  },
  /**
       * @method Moveable.Resizable#request
       * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter
       * @return {Moveable.Requester} Moveable Requester
       * @example
  
       * // Instantly Request (requestStart - request - requestEnd)
       * // Use Relative Value
       * moveable.request("resizable", { deltaWidth: 10, deltaHeight: 10 }, true);
       *
       * // Use Absolute Value
       * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 }, true);
       *
       * // requestStart
       * const requester = moveable.request("resizable");
       *
       * // request
       * // Use Relative Value
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       *
       * // Use Absolute Value
       * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 });
       * moveable.request("resizable", { offsetWidth: 110, offsetHeight: 100 });
       * moveable.request("resizable", { offsetWidth: 120, offsetHeight: 100 });
       *
       * // requestEnd
       * requester.requestEnd();
       */
  request(e) {
    const t = {};
    let n = 0, r = 0, s = !1;
    const i = e.getRect();
    return {
      isControl: !0,
      requestStart(o) {
        return s = o.useSnap, {
          datas: t,
          parentDirection: o.direction || [1, 1],
          parentIsWidth: (o == null ? void 0 : o.horizontal) ?? !0,
          useSnap: s
        };
      },
      request(o) {
        return "offsetWidth" in o ? n = o.offsetWidth - i.offsetWidth : "deltaWidth" in o && (n += o.deltaWidth), "offsetHeight" in o ? r = o.offsetHeight - i.offsetHeight : "deltaHeight" in o && (r += o.deltaHeight), {
          datas: t,
          parentDist: [n, r],
          parentKeepRatio: o.keepRatio,
          useSnap: s
        };
      },
      requestEnd() {
        return { datas: t, isDrag: !0, useSnap: s };
      }
    };
  },
  unset(e) {
    e.state.gestos.resizable = null;
  }
};
function tr(e, t, n, r, s) {
  const i = e.props.groupable, o = e.state, a = o.is3d ? 4 : 3, l = t.origin, c = ot(
    e.state.rootMatrix,
    // TO-DO #710
    W([l[0], l[1]], i ? [0, 0] : [o.left, o.top]),
    a
  ), u = Q([s.left, s.top], c);
  t.startAbsoluteOrigin = u, t.prevDeg = lt(u, [n, r]) / Math.PI * 180, t.defaultDeg = t.prevDeg, t.prevSnapDeg = 0, t.loop = 0, t.startDist = Ft(u, [n, r]);
}
function Sn(e, t, n) {
  const { defaultDeg: r, prevDeg: s } = n;
  let i = s % 360, o = Math.floor(s / 360);
  i < 0 && (i += 360), i > e && i > 270 && e < 90 ? ++o : i < e && i < 90 && e > 270 && --o;
  const a = t * (o * 360 + e - r);
  return n.prevDeg = r + a, a;
}
function er(e, t, n, r) {
  return Sn(lt(r.startAbsoluteOrigin, [e, t]) / Math.PI * 180, n, r);
}
function nr(e, t, n, r, s, i) {
  const { throttleRotate: o = 0 } = e.props, a = n.prevSnapDeg;
  let l = 0, c = !1;
  if (i) {
    const f = Tc(e, t, r, s + r);
    c = f.isSnap, l = s + f.dist;
  }
  c || (l = V(s + r, o));
  const u = l - s;
  return n.prevSnapDeg = u, [u - a, u, l];
}
function fo(e, [t, n, r, s], i) {
  if (e === "none")
    return [];
  if (at(e))
    return e.map((f) => fo(f, [t, n, r, s], i)[0]);
  const [o, a] = (e || "top").split("-");
  let l = [t, n];
  o === "left" ? l = [r, t] : o === "right" ? l = [n, s] : o === "bottom" && (l = [s, r]);
  let c = [
    (l[0][0] + l[1][0]) / 2,
    (l[0][1] + l[1][1]) / 2
  ];
  const u = wo(l, i);
  if (a) {
    const f = a === "top" || a === "left", h = o === "bottom" || o === "left";
    c = l[f && !h || !f && h ? 0 : 1];
  }
  return [[c, u]];
}
function xr(e, t) {
  if (t.isRequest)
    return t.requestAble === "rotatable";
  const n = t.inputEvent.target;
  if (ht(n, L("rotation-control")) || e.props.rotateAroundControls && ht(n, L("around-control")) || ht(n, L("control")) && ht(n, L("rotatable")))
    return !0;
  const r = e.props.rotationTarget;
  return r ? rs(r, !0).some((s) => s ? n === s || n.contains(s) : !1) : !1;
}
const gc = `.rotation {
position: absolute;
height: 40px;
width: 1px;
transform-origin: 50% 100%;
height: calc(40px * var(--zoom));
top: auto;
left: 0;
bottom: 100%;
will-change: transform;
}
.rotation .rotation-line {
display: block;
width: 100%;
height: 100%;
transform-origin: 50% 50%;
}
.rotation .rotation-control {
border-color: #4af;
border-color: var(--moveable-color);
background:#fff;
cursor: alias;
}
:global .view-rotation-dragging, .rotatable.direction.control {
cursor: alias;
}
.rotatable.direction.control.move {
cursor: move;
}
`, mc = {
  name: "rotatable",
  canPinch: !0,
  props: [
    "rotatable",
    "rotationPosition",
    "throttleRotate",
    "renderDirections",
    "rotationTarget",
    "rotateAroundControls",
    "edge",
    "resolveAblesWithRotatable",
    "displayAroundControls"
  ],
  events: [
    "rotateStart",
    "beforeRotate",
    "rotate",
    "rotateEnd",
    "rotateGroupStart",
    "beforeRotateGroup",
    "rotateGroup",
    "rotateGroupEnd"
  ],
  css: [gc],
  viewClassName(e) {
    return e.isDragging("rotatable") ? L("view-rotation-dragging") : "";
  },
  render(e, t) {
    const { rotatable: n, rotationPosition: r, zoom: s, renderDirections: i, rotateAroundControls: o, resolveAblesWithRotatable: a } = he(e.props, "rotatable"), { renderPoses: l, direction: c } = e.getState();
    if (!n)
      return null;
    const u = fo(r, l, c), f = [];
    if (u.forEach(([h, d], p) => {
      f.push(Pe("div", { className: L("rotation"), style: {
        // tslint:disable-next-line: max-line-length
        transform: `translate(-50%) translate(${h[0]}px, ${h[1]}px) rotate(${d}rad)`
      }, children: [Z("div", { className: L("line rotation-line"), style: {
        transform: `scaleX(${s})`
      } }), Z("div", { className: L("control rotation-control"), style: {
        transform: `translate(0.5px) scale(${s})`
      } })] }, `rotation${p}`));
    }), i) {
      const h = _e(a || {}), d = {};
      h.forEach((g) => {
        a[g].forEach((m) => {
          d[m] = g;
        });
      });
      let p = [];
      at(i) && (p = i.map((g) => {
        const m = d[g];
        return {
          data: m ? { resolve: m } : {},
          classNames: m ? ["move"] : [],
          dir: g
        };
      })), f.push(...qi(e, "rotatable", p));
    }
    return o && f.push(...Qi(e)), f;
  },
  dragControlCondition: xr,
  dragControlStart(e, t) {
    var I;
    const { datas: n, clientX: r, clientY: s, parentRotate: i, parentFlag: o, isPinch: a, isRequest: l } = t, c = e.state, { target: u, left: f, top: h, direction: d, beforeDirection: p, targetTransform: g, moveableClientRect: m, offsetMatrix: b, targetMatrix: S, allMatrix: v, width: E, height: x } = c;
    if (!l && !u)
      return !1;
    const w = e.getRect();
    n.rect = w, n.transform = g, n.left = f, n.top = h;
    let D = (_) => {
      const A = uo(e.state, _);
      n.fixedDirection = A.fixedDirection, n.fixedOffset = A.fixedOffset, n.fixedPosition = A.fixedPosition, T && T.setFixedPosition(_);
    }, C = (_) => {
      const A = pc(e.state, _);
      n.fixedDirection = A.fixedDirection, n.fixedOffset = A.fixedOffset, n.fixedPosition = A.fixedPosition, T && T.setFixedDirection(_);
    }, P = r, M = s;
    if (l || a || o) {
      const _ = i || 0;
      n.beforeInfo = {
        origin: w.beforeOrigin,
        prevDeg: _,
        defaultDeg: _,
        prevSnapDeg: 0,
        startDist: 0
      }, n.afterInfo = {
        ...n.beforeInfo,
        origin: w.origin
      }, n.absoluteInfo = {
        ...n.beforeInfo,
        origin: w.origin,
        startValue: _
      };
    } else {
      const _ = (I = t.inputEvent) == null ? void 0 : I.target;
      if (_) {
        const B = _.getAttribute("data-direction") || "", N = xl[B];
        if (N) {
          n.isControl = !0, n.isAroundControl = ht(_, L("around-control")), n.controlDirection = N;
          const G = _.getAttribute("data-resolve");
          G && (n.resolveAble = G);
          const k = Nc(c.rootMatrix, c.renderPoses, m);
          [P, M] = pt(k, N);
        }
      }
      n.beforeInfo = { origin: w.beforeOrigin }, n.afterInfo = { origin: w.origin }, n.absoluteInfo = {
        origin: w.origin,
        startValue: w.rotation
      };
      const A = D;
      D = (B) => {
        const N = c.is3d ? 4 : 3, [G, k] = Q(Ei(S, N), B), q = mt(b, ue([G, k], N)), j = mt(v, ue([B[0], B[1]], N));
        A(B);
        const X = c.posDelta;
        n.beforeInfo.origin = W(q, X), n.afterInfo.origin = W(j, X), n.absoluteInfo.origin = W(j, X), tr(e, n.beforeInfo, P, M, m), tr(e, n.afterInfo, P, M, m), tr(e, n.absoluteInfo, P, M, m);
      }, C = (B) => {
        const N = pt([
          [0, 0],
          [E, 0],
          [0, x],
          [E, x]
        ], B);
        D(N);
      };
    }
    n.startClientX = P, n.startClientY = M, n.direction = d, n.beforeDirection = p, n.startValue = 0, n.datas = {}, jn(e, t, "rotate");
    let y = !1, T = !1;
    n.isControl && n.resolveAble && n.resolveAble === "resizable" && (T = Sr.dragControlStart(e, {
      ...new Me("resizable").dragStart([0, 0], t),
      parentPosition: n.controlPosition,
      parentFixedPosition: n.fixedPosition
    })), T || (y = vt.dragStart(e, new Me().dragStart([0, 0], t))), D(Hc(e));
    const O = U(e, t, {
      set: (_) => {
        n.startValue = _ * Math.PI / 180;
      },
      setFixedDirection: C,
      setFixedPosition: D,
      ...kn(e, t),
      dragStart: y,
      resizeStart: T
    }), R = Y(e, "onRotateStart", O);
    return n.isRotate = R !== !1, c.snapRenderInfo = {
      request: t.isRequest
    }, n.isRotate ? O : !1;
  },
  dragControl(e, t) {
    const { datas: n, clientDistX: r, clientDistY: s, parentRotate: i, parentFlag: o, isPinch: a, groupDelta: l, resolveMatrix: c } = t, { beforeDirection: u, beforeInfo: f, afterInfo: h, absoluteInfo: d, isRotate: p, startValue: g, rect: m, startClientX: b, startClientY: S } = n;
    if (!p)
      return;
    Gn(e, t, "rotate");
    const v = Cl(t), E = u * v, { parentMoveable: x } = e.props;
    let w = 0, D, C, P = 0, M, y, T = 0, O, R;
    const I = 180 / Math.PI * g, _ = d.startValue;
    let A = !1;
    const B = b + r, N = S + s;
    if (!o && "parentDist" in t) {
      const H = t.parentDist;
      D = H, M = H, O = H;
    } else a || o ? (D = Sn(i, u, f), M = Sn(i, E, h), O = Sn(i, E, d)) : (D = er(B, N, u, f), M = er(B, N, E, h), O = er(B, N, E, d), A = !0);
    if (C = I + D, y = I + M, R = _ + O, Y(e, "onBeforeRotate", U(e, t, {
      beforeRotation: C,
      rotation: y,
      absoluteRotation: R,
      setRotation(H) {
        M = H - I, D = M, O = M;
      }
    }, !0)), [w, D, C] = nr(e, m, f, D, I, A), [P, M, y] = nr(e, m, h, M, I, A), [T, O, R] = nr(e, m, d, O, _, A), !T && !P && !w && !x && !c)
      return;
    const G = $n(n, `rotate(${y}deg)`, `rotate(${M}deg)`);
    c && (n.fixedPosition = Nr(e, n.targetAllTransform, n.fixedDirection, n.fixedOffset, n));
    const k = Bl(e, M, n), q = W(Q(l || [0, 0], k), n.prevInverseDist || [0, 0]);
    n.prevInverseDist = k, n.requestValue = null;
    const j = Ni(e, G, q, a, t);
    let X = j;
    const J = Ft([B, N], d.startAbsoluteOrigin) - d.startDist;
    let $;
    if (n.resolveAble === "resizable") {
      const H = Sr.dragControl(e, {
        ...Qe(t, e.state, [t.deltaX, t.deltaY], !!a, !1, "resizable"),
        resolveMatrix: !0,
        parentDistance: J
      });
      H && ($ = H, X = Do(X, H, t));
    }
    const F = U(e, t, {
      delta: P,
      dist: M,
      rotate: y,
      rotation: y,
      beforeDist: D,
      beforeDelta: w,
      beforeRotate: C,
      beforeRotation: C,
      absoluteDist: O,
      absoluteDelta: T,
      absoluteRotate: R,
      absoluteRotation: R,
      isPinch: !!a,
      resize: $,
      ...j,
      ...X
    });
    return Y(e, "onRotate", F), F;
  },
  dragControlEnd(e, t) {
    const { datas: n } = t;
    if (!n.isRotate)
      return;
    n.isRotate = !1;
    const r = Mt(e, t, {});
    return Y(e, "onRotateEnd", r), r;
  },
  dragGroupControlCondition: xr,
  dragGroupControlStart(e, t) {
    const { datas: n } = t, { left: r, top: s, beforeOrigin: i } = e.state, o = this.dragControlStart(e, t);
    if (!o)
      return !1;
    o.set(n.beforeDirection * e.rotation);
    const a = Vt(e, this, "dragControlStart", t, (u, f) => {
      const { left: h, top: d, beforeOrigin: p } = u.state, g = Q(W([h, d], [r, s]), W(p, i));
      return f.datas.startGroupClient = g, f.datas.groupClient = g, { ...f, parentRotate: 0 };
    }), l = {
      ...o,
      targets: e.props.targets,
      events: a
    }, c = Y(e, "onRotateGroupStart", l);
    return n.isRotate = c !== !1, n.isRotate ? o : !1;
  },
  dragGroupControl(e, t) {
    const { datas: n } = t;
    if (!n.isRotate)
      return;
    Wn(e, "onBeforeRotate", (c) => {
      Y(e, "onBeforeRotateGroup", U(e, t, {
        ...c,
        targets: e.props.targets
      }, !0));
    });
    const r = this.dragControl(e, t);
    if (!r)
      return;
    const s = n.beforeDirection, i = r.beforeDist, o = i / 180 * Math.PI, a = Vt(e, this, "dragControl", t, (c, u) => {
      const f = u.datas.startGroupClient, [h, d] = u.datas.groupClient, [p, g] = Ze(f, o * s), m = [p - h, g - d];
      return u.datas.groupClient = [p, g], { ...u, parentRotate: i, groupDelta: m };
    });
    e.rotation = s * r.beforeRotation;
    const l = {
      targets: e.props.targets,
      events: a,
      set(c) {
        e.rotation = c;
      },
      setGroupRotation(c) {
        e.rotation = c;
      },
      ...r
    };
    return Y(e, "onRotateGroup", l), l;
  },
  dragGroupControlEnd(e, t) {
    const { isDrag: n, datas: r } = t;
    if (!r.isRotate)
      return;
    this.dragControlEnd(e, t);
    const s = Vt(e, this, "dragControlEnd", t), i = Mt(e, t, {
      targets: e.props.targets,
      events: s
    });
    return Y(e, "onRotateGroupEnd", i), n;
  },
  /**
       * @method Moveable.Rotatable#request
       * @param {object} [e] - the Resizable's request parameter
       * @param {number} [e.deltaRotate=0] -  delta number of rotation
       * @param {number} [e.rotate=0] - absolute number of moveable's rotation
       * @return {Moveable.Requester} Moveable Requester
       * @example
  
       * // Instantly Request (requestStart - request - requestEnd)
       * moveable.request("rotatable", { deltaRotate: 10 }, true);
       *
       * * moveable.request("rotatable", { rotate: 10 }, true);
       *
       * // requestStart
       * const requester = moveable.request("rotatable");
       *
       * // request
       * requester.request({ deltaRotate: 10 });
       * requester.request({ deltaRotate: 10 });
       * requester.request({ deltaRotate: 10 });
       *
       * requester.request({ rotate: 10 });
       * requester.request({ rotate: 20 });
       * requester.request({ rotate: 30 });
       *
       * // requestEnd
       * requester.requestEnd();
       */
  request(e) {
    const t = {};
    let n = 0;
    const r = e.getRotation();
    return {
      isControl: !0,
      requestStart() {
        return { datas: t };
      },
      request(s) {
        return "deltaRotate" in s ? n += s.deltaRotate : "rotate" in s && (n = s.rotate - r), { datas: t, parentDist: n };
      },
      requestEnd() {
        return { datas: t, isDrag: !0 };
      }
    };
  }
};
function bc(e, t) {
  const { direction: n, classNames: r, size: s, pos: i, zoom: o, key: a } = e, l = n === "horizontal", c = l ? "Y" : "X";
  return t.createElement("div", {
    key: a,
    className: r.join(" "),
    style: {
      [l ? "width" : "height"]: `${s}`,
      transform: `translate(${i[0]}, ${i[1]}) translate${c}(-50%) scale${c}(${o})`
    }
  });
}
function Kr(e, t) {
  return bc({
    ...e,
    classNames: [
      L("line", "guideline", e.direction),
      ...e.classNames
    ].filter((n) => n),
    size: e.size || `${e.sizeValue}px`,
    pos: e.pos || e.posValue.map((n) => `${V(n, 0.1)}px`)
  }, t);
}
function zs(e, t, n, r, s, i, o, a) {
  const { zoom: l } = e.props;
  return n.map(({ type: c, pos: u }, f) => {
    const h = [0, 0];
    return h[o] = r, h[o ? 0 : 1] = -s + u, Kr({
      key: `${t}TargetGuideline${f}`,
      classNames: [L("target", "bold", c)],
      posValue: h,
      sizeValue: i,
      zoom: l,
      direction: t
    }, a);
  });
}
function _s(e, t, n, r, s, i) {
  const { zoom: o, isDisplayInnerSnapDigit: a } = e.props, l = t === "horizontal" ? Qt : te, c = s[l.start], u = s[l.end];
  return n.filter(({ hide: f, elementRect: h }) => {
    if (f)
      return !1;
    if (a && h) {
      const d = h.rect;
      if (d[l.start] <= c && u <= d[l.end])
        return !1;
    }
    return !0;
  }).map((f, h) => {
    const { pos: d, size: p, element: g, className: m } = f, b = [-r[0] + d[0], -r[1] + d[1]];
    return Kr({
      key: `${t}-default-guideline-${h}`,
      classNames: g ? [L("bold"), m] : [L("normal"), m],
      direction: t,
      posValue: b,
      sizeValue: p,
      zoom: o
    }, i);
  });
}
function ke(e, t, n, r, s, i, o, a) {
  const { snapDigit: l = 0, isDisplaySnapDigit: c = !0, snapDistFormat: u = (m, b) => m, zoom: f } = e.props, h = t === "horizontal" ? "X" : "Y", d = t === "vertical" ? "height" : "width", p = Math.abs(s), g = c ? parseFloat(p.toFixed(l)) : 0;
  return Pe("div", { className: L("guideline-group", t), style: {
    left: `${i[0]}px`,
    top: `${i[1]}px`,
    [d]: `${p}px`
  }, children: [Kr({
    direction: t,
    classNames: [L(n), o],
    size: "100%",
    posValue: [0, 0],
    sizeValue: p,
    zoom: f
  }, a), Z("div", { className: L("size-value", "gap"), style: {
    transform: `translate${h}(-50%) scale(${f})`
  }, children: g > 0 ? u(g, t) : "" })] }, `${t}-${n}-guideline-${r}`);
}
function vc(e, t, n, r) {
  const s = e === "vertical" ? 0 : 1, i = e === "vertical" ? 1 : 0, o = s ? Qt : te, a = n[o.start], l = n[o.end];
  return Oo(t, (c) => c.pos[s]).map((c) => {
    const u = [], f = [], h = [];
    return c.forEach((d) => {
      const p = d.element, g = d.elementRect.rect;
      if (g[o.end] < a)
        u.push(d);
      else if (l < g[o.start])
        f.push(d);
      else if (g[o.start] <= a && l <= g[o.end] && r) {
        const m = d.pos, b = {
          element: p,
          rect: { ...g, [o.end]: g[o.start] }
        }, S = {
          element: p,
          rect: { ...g, [o.start]: g[o.end] }
        }, v = [0, 0], E = [0, 0];
        v[s] = m[s], v[i] = m[i], E[s] = m[s], E[i] = m[i] + d.size, u.push({
          type: e,
          pos: v,
          size: 0,
          elementRect: b,
          direction: "",
          elementDirection: "end"
        }), f.push({
          type: e,
          pos: E,
          size: 0,
          elementRect: S,
          direction: "",
          elementDirection: "start"
        });
      }
    }), u.sort((d, p) => p.pos[i] - d.pos[i]), f.sort((d, p) => d.pos[i] - p.pos[i]), {
      total: c,
      start: u,
      end: f,
      inner: h
    };
  });
}
function Sc(e, t, n, r, s) {
  const { isDisplayInnerSnapDigit: i } = e.props, o = [];
  return ["vertical", "horizontal"].forEach((a) => {
    const l = t.filter((m) => m.type === a), c = a === "vertical" ? 1 : 0, u = c ? 0 : 1, f = vc(a, l, r, i), h = c ? te : Qt, d = c ? Qt : te, p = r[h.start], g = r[h.end];
    f.forEach(({ total: m, start: b, end: S, inner: v }) => {
      const E = n[u] + m[0].pos[u] - r[d.start];
      let x = r;
      b.forEach((w) => {
        const D = w.elementRect.rect, C = x[h.start] - D[h.end];
        if (C > 0) {
          const P = [0, 0];
          P[c] = n[c] + x[h.start] - p - C, P[u] = E, o.push(ke(e, a, "dashed", o.length, C, P, w.className, s));
        }
        x = D;
      }), x = r, S.forEach((w) => {
        const D = w.elementRect.rect, C = D[h.start] - x[h.end];
        if (C > 0) {
          const P = [0, 0];
          P[c] = n[c] + x[h.end] - p, P[u] = E, o.push(ke(e, a, "dashed", o.length, C, P, w.className, s));
        }
        x = D;
      }), v.forEach((w) => {
        const D = w.elementRect.rect, C = p - D[h.start], P = D[h.end] - g, M = [0, 0], y = [0, 0];
        M[c] = n[c] - C, M[u] = E, y[c] = n[c] + g - p, y[u] = E, o.push(ke(e, a, "dashed", o.length, C, M, w.className, s)), o.push(ke(e, a, "dashed", o.length, P, y, w.className, s));
      });
    });
  }), o;
}
function xc(e, t, n, r, s) {
  const i = [];
  return ["horizontal", "vertical"].forEach((o) => {
    const a = t.filter((m) => m.type === o).slice(0, 1), l = o === "vertical" ? 0 : 1, c = l ? 0 : 1, u = l ? te : Qt, f = l ? Qt : te, h = r[u.start], d = r[u.end], p = r[f.start], g = r[f.end];
    a.forEach(({ gap: m, gapRects: b }) => {
      const S = Math.max(p, ...b.map(({ rect: x }) => x[f.start])), v = Math.min(g, ...b.map(({ rect: x }) => x[f.end])), E = (S + v) / 2;
      S === v || E === (p + g) / 2 || b.forEach(({ rect: x, className: w }) => {
        const D = [n[0], n[1]];
        if (x[u.end] < h)
          D[l] += x[u.end] - h;
        else if (d < x[u.start])
          D[l] += x[u.start] - h - m;
        else
          return;
        D[c] += E - p, i.push(ke(e, l ? "vertical" : "horizontal", "gap", i.length, m, D, w, s));
      });
    });
  }), i;
}
function Er(e) {
  var M;
  const t = e.state, { containerClientRect: n, hasFixed: r } = t, { overflow: s, scrollHeight: i, scrollWidth: o, clientHeight: a, clientWidth: l, clientLeft: c, clientTop: u } = n, { snapGap: f = !0, verticalGuidelines: h, horizontalGuidelines: d, snapThreshold: p = 5, maxSnapElementGuidelineDistance: g = 1 / 0, isDisplayGridGuidelines: m } = e.props, { top: b, left: S, bottom: v, right: E } = zt(It(e.state)), x = {
    top: b,
    left: S,
    bottom: v,
    right: E,
    center: (S + E) / 2,
    middle: (b + v) / 2
  };
  let D = [...yc(e)];
  const C = (((M = t.snapThresholdInfo) == null ? void 0 : M.multiples) ?? [1, 1]).map((y) => y * p);
  f && D.push(...Ec(e, x, C));
  const P = {
    ...t.snapOffset || {
      left: 0,
      top: 0,
      bottom: 0,
      right: 0
    }
  };
  if (D.push(...Cc(e, s ? o : l, s ? i : a, c, u, P, m)), r) {
    const { left: y, top: T } = n;
    P.left += y, P.top += T, P.right += y, P.bottom += T;
  }
  return D.push(...po(d || !1, h || !1, s ? o : l, s ? i : a, c, u, P)), D = D.filter(({ element: y, elementRect: T, type: O }) => {
    if (!y || !T)
      return !0;
    const R = T.rect;
    return ho(x, R, O, g);
  }), D;
}
function Ec(e, t, n) {
  const { maxSnapElementGuidelineDistance: r = 1 / 0, maxSnapElementGapDistance: s = 1 / 0 } = e.props, i = e.state.elementRects, o = [];
  return [
    ["vertical", Qt, te],
    ["horizontal", te, Qt]
  ].forEach(([a, l, c]) => {
    const u = t[l.start], f = t[l.end], h = t[l.center], d = t[c.start], p = t[c.end], g = {
      left: n[0],
      top: n[1]
    };
    function m(v) {
      const E = v.rect, x = g[l.start];
      return E[l.end] < u + x ? u - E[l.end] : f - x < E[l.start] ? E[l.start] - f : -1;
    }
    const b = i.filter((v) => {
      const E = v.rect;
      return E[c.start] > p || E[c.end] < d ? !1 : m(v) > 0;
    }).sort((v, E) => m(v) - m(E)), S = [];
    b.forEach((v) => {
      b.forEach((E) => {
        if (v === E)
          return;
        const { rect: x } = v, { rect: w } = E, D = x[c.start], C = x[c.end], P = w[c.start], M = w[c.end];
        D > M || P > C || S.push([v, E]);
      });
    }), S.forEach(([v, E]) => {
      const { rect: x } = v, { rect: w } = E, D = x[l.start], C = x[l.end], P = w[l.start], M = w[l.end], y = g[l.start];
      let T = 0, O = 0, R = !1, I = !1, _ = !1;
      if (C <= u && f <= P) {
        if (I = !0, T = (P - C - (f - u)) / 2, O = C + T + (f - u) / 2, z(O - h) > y)
          return;
      } else if (C < P && M < u + y) {
        if (R = !0, T = P - C, O = M + T, z(O - u) > y)
          return;
      } else if (C < P && f - y < D) {
        if (_ = !0, T = P - C, O = D - T, z(O - f) > y)
          return;
      } else
        return;
      T && ho(t, w, a, r) && (T > s || o.push({
        type: a,
        pos: a === "vertical" ? [O, 0] : [0, O],
        element: E.element,
        size: 0,
        className: E.className,
        isStart: R,
        isCenter: I,
        isEnd: _,
        gap: T,
        hide: !0,
        gapRects: [v, E],
        direction: "",
        elementDirection: ""
      }));
    });
  }), o;
}
function wc(e, t, n, r) {
  var h, d;
  const s = e.props, i = e.state, { snapGridAll: o } = s, { snapGridWidth: a = 0, snapGridHeight: l = 0 } = s, { snapRenderInfo: c } = i, u = c && (((h = c.direction) == null ? void 0 : h[0]) || ((d = c.direction) == null ? void 0 : d[1])), f = e.moveables;
  if (o && f && u && (a || l)) {
    if (i.snapThresholdInfo)
      return;
    i.snapThresholdInfo = {
      multiples: [1, 1],
      offset: [0, 0]
    };
    const p = e.getRect(), g = p.children, m = c.direction;
    if (g) {
      const b = m.map((v, E) => {
        const { snapSize: x, posName: w, sizeName: D, clientOffset: C } = E === 0 ? {
          snapSize: a,
          posName: "left",
          sizeName: "width",
          clientOffset: r.left - t
        } : {
          snapSize: l,
          posName: "top",
          sizeName: "height",
          clientOffset: r.top - n
        };
        if (!x)
          return {
            dir: v,
            multiple: 1,
            snapSize: x,
            snapOffset: 0
          };
        const P = p[D], M = p[w], y = Sa(g.map((B) => [
          B[w] - M,
          B[D],
          P - B[D] - B[w] + M
        ])).filter((B) => B).sort((B, N) => B - N), T = y[0], O = y.map((B) => V(B / T, 0.1) * x);
        let R = 1;
        const I = V(P / T, 0.1);
        for (R = 1; R <= 10 && !O.every((B) => B * R % 1 === 0); ++R)
          ;
        const _ = (-v + 1) / 2, A = En(M - C, M - C + P, _, 1 - _);
        return {
          multiple: I * R,
          dir: v,
          snapSize: x,
          snapOffset: Math.round(A / x)
        };
      }), S = b.map((v) => v.multiple || 1);
      i.snapThresholdInfo.multiples = S, i.snapThresholdInfo.offset = b.map((v) => v.snapOffset), b.forEach((v, E) => {
        v.snapSize;
      });
    }
  } else
    i.snapThresholdInfo = null;
}
function Cc(e, t, n, r = 0, s = 0, i, o) {
  const a = e.props, l = e.state;
  let { snapGridWidth: c = 0, snapGridHeight: u = 0 } = a;
  const f = [], { left: h, top: d } = i;
  let p = [0, 0];
  wc(e, r, s, i);
  const g = l.snapThresholdInfo, m = c, b = u;
  if (g && (c *= g.multiples[0] || 1, u *= g.multiples[1] || 1, p = g.offset), u) {
    const S = (v) => {
      f.push({
        type: "horizontal",
        pos: [
          h,
          V(p[1] * b + v - s + d, 0.1)
        ],
        className: L("grid-guideline"),
        size: t,
        hide: !o,
        direction: "",
        grid: !0
      });
    };
    for (let v = 0; v <= n * 2; v += u)
      S(v);
    for (let v = -u; v >= -n; v -= u)
      S(v);
  }
  if (c) {
    const S = (v) => {
      f.push({
        type: "vertical",
        pos: [
          V(p[0] * m + v - r + h, 0.1),
          d
        ],
        className: L("grid-guideline"),
        size: n,
        hide: !o,
        direction: "",
        grid: !0
      });
    };
    for (let v = 0; v <= t * 2; v += c)
      S(v);
    for (let v = -c; v >= -t; v -= c)
      S(v);
  }
  return f;
}
function ho(e, t, n, r) {
  return n === "horizontal" ? z(e.right - t.left) <= r || z(e.left - t.right) <= r || e.left <= t.right && t.left <= e.right : n === "vertical" ? z(e.bottom - t.top) <= r || z(e.top - t.bottom) <= r || e.top <= t.bottom && t.top <= e.bottom : !0;
}
function yc(e) {
  const t = e.state, { elementGuidelines: n = [] } = e.props;
  if (!n.length)
    return t.elementRects = [], [];
  const r = (t.elementRects || []).filter((u) => !u.refresh), s = n.map((u) => Et(u) && "element" in u ? {
    ...u,
    element: Lt(u.element, !0)
  } : {
    element: Lt(u, !0)
  }).filter((u) => u.element), { maintained: i, added: o } = Se(r.map((u) => u.element), s.map((u) => u.element)), a = [];
  i.forEach(([u, f]) => {
    a[f] = r[u];
  }), Pc(e, o.map((u) => s[u])).map((u, f) => {
    a[o[f]] = u;
  }), t.elementRects = a;
  const l = Vr(e.props.elementSnapDirections), c = [];
  return a.forEach((u) => {
    const { element: f, top: h = l.top, left: d = l.left, right: p = l.right, bottom: g = l.bottom, center: m = l.center, middle: b = l.middle, className: S, rect: v } = u, { horizontal: E, vertical: x, horizontalNames: w, verticalNames: D } = qr({
      top: h,
      right: p,
      left: d,
      bottom: g,
      center: m,
      middle: b
    }, v), C = v.top, P = v.left, M = v.right - P, y = v.bottom - C, T = [M, y];
    x.forEach((O, R) => {
      c.push({
        type: "vertical",
        element: f,
        pos: [V(O, 0.1), C],
        size: y,
        sizes: T,
        className: S,
        elementRect: u,
        elementDirection: Cs[D[R]] || D[R],
        direction: ""
      });
    }), E.forEach((O, R) => {
      c.push({
        type: "horizontal",
        element: f,
        pos: [P, V(O, 0.1)],
        size: M,
        sizes: T,
        className: S,
        elementRect: u,
        elementDirection: Cs[w[R]] || w[R],
        direction: ""
      });
    });
  }), c;
}
function Is(e, t) {
  return e ? e.map((n) => {
    const r = Et(n) ? n : { pos: n }, s = r.pos;
    return He(s) ? r : {
      ...r,
      pos: K(s, t)
    };
  }) : [];
}
function po(e, t, n, r, s = 0, i = 0, o = { left: 0, top: 0, right: 0, bottom: 0 }) {
  const a = [], { left: l, top: c, bottom: u, right: f } = o, h = n + f - l, d = r + u - c;
  return Is(e, d).forEach((p) => {
    a.push({
      type: "horizontal",
      pos: [
        l,
        V(p.pos - i + c, 0.1)
      ],
      size: h,
      className: p.className,
      direction: ""
    });
  }), Is(t, h).forEach((p) => {
    a.push({
      type: "vertical",
      pos: [
        V(p.pos - s + l, 0.1),
        c
      ],
      size: d,
      className: p.className,
      direction: ""
    });
  }), a;
}
function Pc(e, t) {
  if (!t.length)
    return [];
  const n = e.props.groupable, r = e.state, {
    containerClientRect: s,
    // targetClientRect: {
    //     top: clientTop,
    //     left: clientLeft,
    // },
    rootMatrix: i,
    is3d: o,
    offsetDelta: a
  } = r, l = o ? 4 : 3, [c, u] = Ul(i, s, l), f = n ? 0 : a[0], h = n ? 0 : a[1];
  return t.map((d) => {
    const p = d.element.getBoundingClientRect(), g = p.left - c - f, m = p.top - u - h, b = m + p.height, S = g + p.width, [v, E] = ze(i, [g, m], l), [x, w] = ze(i, [S, b], l);
    return {
      ...d,
      rect: {
        left: v,
        right: x,
        top: E,
        bottom: w,
        center: (v + x) / 2,
        middle: (E + w) / 2
      }
    };
  });
}
function hn(e) {
  const t = e.state, n = t.container, r = e.props.snapContainer || n;
  if (t.snapContainer === r && t.guidelines && t.guidelines.length)
    return !1;
  const s = t.containerClientRect, i = {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  };
  if (n !== r) {
    const o = Lt(r, !0);
    if (o) {
      const a = We(o), l = js(t, [
        a.left - s.left,
        a.top - s.top
      ]), c = js(t, [
        a.right - s.right,
        a.bottom - s.bottom
      ]);
      i.left = V(l[0], 1e-5), i.top = V(l[1], 1e-5), i.right = V(c[0], 1e-5), i.bottom = V(c[1], 1e-5);
    }
  }
  return t.snapContainer = r, t.snapOffset = i, t.guidelines = Er(e), t.enableSnap = !0, !0;
}
function go(e, t, n, r, s, i) {
  const o = ge(e, t, n, i ? 4 : 3), a = pt(o, r);
  return Qr(o, W(s, a));
}
function Bs(e) {
  return e ? e / z(e) : 0;
}
function Dc(e, t, n, r, s, i) {
  const { fixedDirection: o } = i, a = Ql(n, o, r), l = Zr(e, t, n, r), c = [
    ...fc(e, t, a, r, s, i),
    ...lo(e, l, i)
  ], u = On(c, 0), f = On(c, 1);
  return {
    width: {
      isBound: u.isBound,
      offset: u.offset[0]
    },
    height: {
      isBound: f.isBound,
      offset: f.offset[1]
    }
  };
}
function Oc(e, t, n, r, s, i, o, a, l) {
  const c = pt(t, o), { horizontal: { offset: u }, vertical: { offset: f } } = Fn(e, a, {
    vertical: [c[0]],
    horizontal: [c[1]]
  });
  if (V(f, pr) || V(u, pr)) {
    const [h, d] = Wt({
      datas: l,
      distX: -f,
      distY: -u
    }), p = Math.min(s || 1 / 0, n + o[0] * h), g = Math.min(i || 1 / 0, r + o[1] * d);
    return [p - n, g - r];
  }
  return [0, 0];
}
function mo(e, t, n, r, s, i, o, a) {
  const l = It(e.state), c = e.props.keepRatio;
  let u = 0, f = 0;
  for (let h = 0; h < 2; ++h) {
    const d = t(u, f), { width: p, height: g } = Dc(e, d, s, c, o, a), m = p.isBound, b = g.isBound;
    let S = p.offset, v = g.offset;
    if (h === 1 && (m || (S = 0), b || (v = 0)), h === 0 && o && !m && !b)
      return [0, 0];
    if (c) {
      const E = z(S) * (n ? 1 / n : 1), x = z(v) * (r ? 1 / r : 1);
      (m && b ? E < x : b || !m && E < x) ? S = n * v / r : v = r * S / n;
    }
    u += S, f += v;
  }
  if (!c && s[0] && s[1]) {
    const { maxWidth: h, maxHeight: d } = dc(e, l, s, i, a), [p, g] = Oc(e, t(u, f).map((m) => m.map((b) => V(b, pr))), n + u, r + f, h, d, s, o, a);
    u += p, f += g;
  }
  return [u, f];
}
function Fe(e) {
  return e < 0 && (e = e % 360 + 360), e %= 360, e;
}
function Mc(e, t) {
  t = Fe(t);
  const n = Math.floor(e / 360), r = n * 360 + 360 - t, s = n * 360 + t;
  return z(e - r) < z(e - s) ? r : s;
}
function rr(e, t) {
  e = Fe(e), t = Fe(t);
  const n = Fe(e - t);
  return Math.min(n, 360 - n);
}
function Tc(e, t, n, r) {
  const s = e.props, i = s[to] ?? 5, o = s[eo];
  if (Ge(e, "rotatable")) {
    const { pos1: a, pos2: l, pos3: c, pos4: u, origin: f } = t, h = n * Math.PI / 180, d = [a, l, c, u].map((b) => W(b, f)), p = d.map((b) => Ze(b, h)), g = [
      ...Nl(e, d, p, f, n),
      ...ic(e, d, p, f, n)
    ];
    g.sort((b, S) => z(b - n) - z(S - n));
    const m = g.length > 0;
    if (m)
      return {
        isSnap: m,
        dist: m ? g[0] : n
      };
  }
  if (o != null && o.length && i) {
    const l = o.slice().sort((c, u) => rr(c, r) - rr(u, r))[0];
    if (rr(l, r) <= i)
      return {
        isSnap: !0,
        dist: n + Mc(r, l) - r
      };
  }
  return {
    isSnap: !1,
    dist: n
  };
}
function Rc(e, t, n, r, s, i, o) {
  if (!Ge(e, "resizable"))
    return [0, 0];
  const { fixedDirection: a, nextAllMatrix: l } = o, { allMatrix: c, is3d: u } = e.state;
  return mo(e, (f, h) => go(l || c, t + f, n + h, a, s, u), t, n, r, s, i, o);
}
function zc(e, t, n, r, s) {
  if (!Ge(e, "scalable"))
    return [0, 0];
  const { startOffsetWidth: i, startOffsetHeight: o, fixedPosition: a, fixedDirection: l, is3d: c } = s, u = mo(e, (f, h) => go(Rl(s, Q(t, [
    f / i,
    h / o
  ])), i, o, l, a, c), i, o, n, a, r, s);
  return [u[0] / i, u[1] / o];
}
function _c(e, t) {
  t.absolutePoses = It(e.state);
}
function As(e) {
  const t = [];
  return e.forEach((n) => {
    n.guidelineInfos.forEach(({ guideline: r }) => {
      Ot(t, (s) => s.guideline === r) || (r.direction = "", t.push({ guideline: r, posInfo: n }));
    });
  }), t.map(({ guideline: n, posInfo: r }) => ({
    ...n,
    direction: r.direction
  }));
}
function Gs(e, t, n, r, s, i) {
  const { vertical: o, horizontal: a } = Hr(Xn(e, i), t, n), l = Ee();
  o.forEach((h) => {
    h.isBound && (h.direction === "start" && (l.left = !0), h.direction === "end" && (l.right = !0), r.push({
      type: "bounds",
      pos: h.pos
    }));
  }), a.forEach((h) => {
    h.isBound && (h.direction === "start" && (l.top = !0), h.direction === "end" && (l.bottom = !0), s.push({
      type: "bounds",
      pos: h.pos
    }));
  });
  const { boundMap: c, vertical: u, horizontal: f } = oc(e);
  return u.forEach((h) => {
    qt(r, ({ type: d, pos: p }) => d === "bounds" && p === h) >= 0 || r.push({
      type: "bounds",
      pos: h
    });
  }), f.forEach((h) => {
    qt(s, ({ type: d, pos: p }) => d === "bounds" && p === h) >= 0 || s.push({
      type: "bounds",
      pos: h
    });
  }), {
    boundMap: l,
    innerBoundMap: c
  };
}
const Ic = ns("", ["resizable", "scalable"]), Bc = {
  name: "snappable",
  dragRelation: "strong",
  props: [
    "snappable",
    "snapContainer",
    "snapDirections",
    "elementSnapDirections",
    "snapGap",
    "snapGridWidth",
    "snapGridHeight",
    "isDisplaySnapDigit",
    "isDisplayInnerSnapDigit",
    "isDisplayGridGuidelines",
    "snapDigit",
    "snapThreshold",
    "snapRenderThreshold",
    "snapGridAll",
    to,
    eo,
    no,
    ro,
    "horizontalGuidelines",
    "verticalGuidelines",
    "elementGuidelines",
    "bounds",
    "innerBounds",
    "snapDistFormat",
    "maxSnapElementGuidelineDistance",
    "maxSnapElementGapDistance"
  ],
  events: ["snap", "bound"],
  css: [
    `:host {
--bounds-color: #d66;
}
.guideline {
pointer-events: none;
z-index: 2;
}
.guideline.bounds {
background: #d66;
background: var(--bounds-color);
}
.guideline-group {
position: absolute;
top: 0;
left: 0;
}
.guideline-group .size-value {
position: absolute;
color: #f55;
font-size: 12px;
font-size: calc(12px * var(--zoom));
font-weight: bold;
}
.guideline-group.horizontal .size-value {
transform-origin: 50% 100%;
transform: translateX(-50%);
left: 50%;
bottom: 5px;
bottom: calc(2px + 3px * var(--zoom));
}
.guideline-group.vertical .size-value {
transform-origin: 0% 50%;
top: 50%;
transform: translateY(-50%);
left: 5px;
left: calc(2px + 3px * var(--zoom));
}
.guideline.gap {
background: #f55;
}
.size-value.gap {
color: #f55;
}
`
  ],
  render(e, t) {
    const n = e.state, { top: r, left: s, pos1: i, pos2: o, pos3: a, pos4: l, snapRenderInfo: c } = n, { snapRenderThreshold: u = 1 } = e.props;
    if (!c || !c.render || !Ge(e, ""))
      return Ce(e, "boundMap", Ee(), (G) => JSON.stringify(G)), Ce(e, "innerBoundMap", Ee(), (G) => JSON.stringify(G)), [];
    n.guidelines = Er(e);
    const f = Math.min(i[0], o[0], a[0], l[0]), h = Math.min(i[1], o[1], a[1], l[1]), d = c.externalPoses || [], p = It(e.state), g = [], m = [], b = [], S = [], v = [], { width: E, height: x, top: w, left: D, bottom: C, right: P } = zt(p), M = {
      left: D,
      right: P,
      top: w,
      bottom: C,
      center: (D + P) / 2,
      middle: (w + C) / 2
    }, y = d.length > 0, T = y ? zt(d) : {};
    if (!c.request) {
      if (c.direction && v.push(Jl(e, p, c.direction, u, u)), c.snap) {
        const G = zt(p);
        c.center && (G.middle = (G.top + G.bottom) / 2, G.center = (G.left + G.right) / 2), v.push(ys(e, G, u, u));
      }
      y && (c.center && (T.middle = (T.top + T.bottom) / 2, T.center = (T.left + T.right) / 2), v.push(ys(e, T, u, u))), v.forEach((G) => {
        const { vertical: { posInfos: k }, horizontal: { posInfos: q } } = G;
        g.push(...k.filter(({ guidelineInfos: j }) => j.some(({ guideline: X }) => !X.hide)).map((j) => ({
          type: "snap",
          pos: j.pos
        }))), m.push(...q.filter(({ guidelineInfos: j }) => j.some(({ guideline: X }) => !X.hide)).map((j) => ({
          type: "snap",
          pos: j.pos
        }))), b.push(...As(k)), S.push(...As(q));
      });
    }
    const { boundMap: O, innerBoundMap: R } = Gs(e, [D, P], [w, C], g, m);
    y && Gs(e, [T.left, T.right], [T.top, T.bottom], g, m, c.externalBounds);
    const I = [...b, ...S], _ = I.filter((G) => G.element && !G.gapRects), A = I.filter((G) => G.gapRects).sort((G, k) => G.gap - k.gap);
    Y(e, "onSnap", {
      guidelines: I.filter(({ element: G }) => !G),
      elements: _,
      gaps: A
    }, !0);
    const B = Ce(e, "boundMap", O, (G) => JSON.stringify(G), Ee()), N = Ce(e, "innerBoundMap", R, (G) => JSON.stringify(G), Ee());
    return (O === B || R === N) && Y(e, "onBound", {
      bounds: O,
      innerBounds: R
    }, !0), [
      ...Sc(e, _, [f, h], M, t),
      ...xc(e, A, [f, h], M, t),
      ..._s(e, "horizontal", S, [s, r], M, t),
      ..._s(e, "vertical", b, [s, r], M, t),
      ...zs(e, "horizontal", m, f, r, E, 0, t),
      ...zs(e, "vertical", g, h, s, x, 1, t)
    ];
  },
  dragStart(e, t) {
    e.state.snapRenderInfo = {
      request: t.isRequest,
      snap: !0,
      center: !0
    }, hn(e);
  },
  drag(e) {
    const t = e.state;
    hn(e) || (t.guidelines = Er(e)), t.snapRenderInfo && (t.snapRenderInfo.render = !0);
  },
  pinchStart(e) {
    this.unset(e);
  },
  dragEnd(e) {
    this.unset(e);
  },
  dragControlCondition(e, t) {
    if (Ic(e, t) || xr(e, t))
      return !0;
    if (!t.isRequest && t.inputEvent)
      return ht(t.inputEvent.target, L("snap-control"));
  },
  dragControlStart(e) {
    e.state.snapRenderInfo = null, hn(e);
  },
  dragControl(e) {
    this.drag(e);
  },
  dragControlEnd(e) {
    this.unset(e);
  },
  dragGroupStart(e, t) {
    this.dragStart(e, t);
  },
  dragGroup(e) {
    this.drag(e);
  },
  dragGroupEnd(e) {
    this.unset(e);
  },
  dragGroupControlStart(e) {
    e.state.snapRenderInfo = null, hn(e);
  },
  dragGroupControl(e) {
    this.drag(e);
  },
  dragGroupControlEnd(e) {
    this.unset(e);
  },
  unset(e) {
    const t = e.state;
    t.enableSnap = !1, t.guidelines = [], t.snapRenderInfo = null, t.elementRects = [];
  }
};
function Ac(e, t) {
  return [e[0] * t[0], e[1] * t[1]];
}
function L(...e) {
  return wl(Fr, ...e);
}
function bo(e) {
  e();
}
function Gc(e) {
  return !e || e === "none" ? [1, 0, 0, 1, 0, 0] : Et(e) ? e : De(e);
}
function Le(e, t, n) {
  return yn(t, fe(n, t), e, fe(n.map((r) => -r), t));
}
function $c(e, t, n) {
  return t === "%" ? Jr(e.ownerSVGElement)[n ? "width" : "height"] / 100 : 1;
}
function kc(e) {
  return jc(ts(e, ":before")).map((n, r) => {
    const { value: s, unit: i } = ae(n);
    return s * $c(e, i, r === 0);
  });
}
function Tn(e) {
  return e ? e.split(" ") : ["0", "0"];
}
function jc(e) {
  return Tn(e.transformOrigin);
}
function vo(e) {
  const n = Pt(e)("transform");
  if (n && n !== "none")
    return n;
  if ("transform" in e) {
    const s = e.transform.baseVal;
    if (!s)
      return "";
    const i = s.length;
    if (!i)
      return "";
    const o = [];
    for (let a = 0; a < i; ++a) {
      const l = s[a].matrix;
      o.push(`matrix(${["a", "b", "c", "d", "e", "f"].map((c) => l[c]).join(", ")})`);
    }
    return o.join(" ");
  }
  return "";
}
function Ue(e, t, n, r, s) {
  var g, m;
  const i = Ir(e) || ee(e);
  let o = !1, a, l;
  if (!e || n)
    a = e;
  else {
    const b = (g = e == null ? void 0 : e.assignedSlot) == null ? void 0 : g.parentElement, S = e.parentElement;
    b ? (o = !0, l = S, a = b) : a = S;
  }
  let c = !1, u = e === t || a === t, f = "relative", h = 1;
  const d = parseFloat(s == null ? void 0 : s("zoom")) || 1, p = s == null ? void 0 : s("position");
  for (; a && a !== i; ) {
    t === a && (u = !0);
    const b = Pt(a), S = a.tagName.toLowerCase(), v = vo(a), E = b("willChange"), x = parseFloat(b("zoom")) || 1;
    if (f = b("position"), r && x !== 1) {
      h = x;
      break;
    }
    if (
      // offsetParent is the parentElement if the target's zoom is not 1 and not absolute.
      !n && r && d !== 1 && p && p !== "absolute" || S === "svg" || S === "foreignobject" || f !== "static" || v && v !== "none" || E === "transform"
    )
      break;
    const w = (m = e == null ? void 0 : e.assignedSlot) == null ? void 0 : m.parentNode, D = a.parentNode;
    w && (o = !0, l = D);
    const C = D;
    if (C && C.nodeType === 11) {
      a = C.host, c = !0, f = Pt(a)("position");
      break;
    }
    a = C, f = "relative";
  }
  return {
    offsetZoom: h,
    hasSlot: o,
    parentSlotElement: l,
    isCustomElement: c,
    isStatic: f === "static",
    isEnd: u || !a || a === i,
    offsetParent: a || i
  };
}
function Xc(e, t) {
  const n = e.tagName.toLowerCase();
  let r = e.offsetLeft, s = e.offsetTop;
  const i = Pt(e), o = Tr(r);
  let a = !o, l, c;
  return !a && (n !== "svg" || e.ownerSVGElement) ? (l = Ai ? kc(e) : Tn(i("transformOrigin")).map((u) => parseFloat(u)), c = l.slice(), a = !0, n === "svg" ? (r = 0, s = 0) : [r, s, l[0], l[1]] = Lc(e, l, e === t && t.tagName.toLowerCase() === "g")) : (l = Tn(i("transformOrigin")).map((u) => parseFloat(u)), c = l.slice()), {
    tagName: n,
    isSVG: o,
    hasOffset: a,
    offset: [r || 0, s || 0],
    origin: l,
    targetOrigin: c
  };
}
function So(e, t) {
  const n = Pt(e), r = Pt(ee(e)), s = r("position");
  if (!t && (!s || s === "static"))
    return [0, 0];
  let i = parseInt(r("marginLeft"), 10), o = parseInt(r("marginTop"), 10);
  return n("position") === "absolute" && ((n("top") !== "auto" || n("bottom") !== "auto") && (o = 0), (n("left") !== "auto" || n("right") !== "auto") && (i = 0)), [i, o];
}
function wr(e) {
  e.forEach((t) => {
    const n = t.matrix;
    n && (t.matrix = kt(n, 3, 4));
  });
}
function Yc(e) {
  let t = e.parentElement, n = !1;
  const r = ee(e);
  for (; t; ) {
    const s = ts(t).transform;
    if (s && s !== "none") {
      n = !0;
      break;
    }
    if (t === r)
      break;
    t = t.parentElement;
  }
  return {
    fixedContainer: t || r,
    hasTransform: n
  };
}
function Ln(e, t = e.length > 9) {
  return `${t ? "matrix3d" : "matrix"}(${wi(e, !t).join(",")})`;
}
function Jr(e) {
  const t = e.clientWidth, n = e.clientHeight;
  if (!e)
    return { x: 0, y: 0, width: 0, height: 0, clientWidth: t, clientHeight: n };
  const r = e.viewBox, s = r && r.baseVal || {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  return {
    x: s.x,
    y: s.y,
    width: s.width || t,
    height: s.height || n,
    clientWidth: t,
    clientHeight: n
  };
}
function Fc(e, t) {
  const { width: n, height: r, clientWidth: s, clientHeight: i } = Jr(e), o = s / n, a = i / r, l = e.preserveAspectRatio.baseVal, c = l.align, u = l.meetOrSlice, f = [0, 0], h = [o, a], d = [0, 0];
  if (c !== 1) {
    const g = (c - 2) % 3, m = Math.floor((c - 2) / 3);
    f[0] = n * g / 2, f[1] = r * m / 2;
    const b = u === 2 ? Math.max(a, o) : Math.min(o, a);
    h[0] = b, h[1] = b, d[0] = (s - n) / 2 * g, d[1] = (i - r) / 2 * m;
  }
  const p = Ar(h, t);
  return [p[t * (t - 1)], p[t * (t - 1) + 1]] = d, Le(p, t, f);
}
function Lc(e, t, n) {
  const r = e.tagName.toLowerCase();
  if (!e.getBBox || !n && r === "g")
    return [0, 0, 0, 0];
  const i = Pt(e)("transform-box") === "fill-box", o = e.getBBox(), a = Jr(e.ownerSVGElement);
  let l = o.x, c = o.y;
  r === "foreignobject" && !l && !c && (l = parseFloat(e.getAttribute("x")) || 0, c = parseFloat(e.getAttribute("y")) || 0);
  const u = l - a.x, f = c - a.y, h = i ? t[0] : t[0] - u, d = i ? t[1] : t[1] - f;
  return [u, f, h, d];
}
function ot(e, t, n) {
  return mt(e, ue(t, n), n);
}
function ge(e, t, n, r) {
  return [
    [0, 0],
    [t, 0],
    [0, n],
    [t, n]
  ].map((s) => ot(e, s, r));
}
function zt(e) {
  const t = e.map((c) => c[0]), n = e.map((c) => c[1]), r = Math.min(...t), s = Math.min(...n), i = Math.max(...t), o = Math.max(...n), a = i - r, l = o - s;
  return {
    left: r,
    top: s,
    right: i,
    bottom: o,
    width: a,
    height: l
  };
}
function $s(e, t, n, r) {
  const s = ge(e, t, n, r);
  return zt(s);
}
function Wc(e, t, n, r, s) {
  const i = e.target, o = e.origin, a = t.matrix, { offsetWidth: l, offsetHeight: c } = Eo(i), u = n.getBoundingClientRect();
  let f = [0, 0];
  n === ee(n) && (f = So(i, !0));
  const h = i.getBoundingClientRect(), d = h.left - u.left + n.scrollLeft - (n.clientLeft || 0) + f[0], p = h.top - u.top + n.scrollTop - (n.clientTop || 0) + f[1], g = h.width, m = h.height, b = yn(r, s, a), { left: S, top: v, width: E, height: x } = $s(b, l, c, r), w = ot(b, o, r), D = W(w, [S, v]), C = [
    d + D[0] * g / E,
    p + D[1] * m / x
  ], P = [0, 0];
  let M = 0;
  for (; ++M < 10; ) {
    const y = $t(s, r);
    [P[0], P[1]] = W(ot(y, C, r), ot(y, w, r));
    const T = yn(r, s, fe(P, r), a), { left: O, top: R } = $s(T, l, c, r), I = O - d, _ = R - p;
    if (z(I) < 2 && z(_) < 2)
      break;
    C[0] -= I, C[1] -= _;
  }
  return P.map((y) => Math.round(y));
}
function Nc(e, t, n) {
  const s = e.length === 16 ? 4 : 3, i = t.map((l) => ot(e, l, s)), { left: o, top: a } = n;
  return i.map((l) => [l[0] + o, l[1] + a]);
}
function _t(e) {
  return Math.sqrt(e[0] * e[0] + e[1] * e[1]);
}
function xo(e, t) {
  return _t([t[0] - e[0], t[1] - e[1]]);
}
function je(e, t, n = 1, r = lt(e, t)) {
  const s = xo(e, t);
  return {
    transform: `translateY(-50%) translate(${e[0]}px, ${e[1]}px) rotate(${r}rad) scaleY(${n})`,
    width: `${s}px`
  };
}
function Rn(e, t, ...n) {
  const r = n.length, s = n.reduce((o, a) => o + a[0], 0) / r, i = n.reduce((o, a) => o + a[1], 0) / r;
  return {
    transform: `translateZ(0px) translate(${s}px, ${i}px) rotate(${e}rad) scale(${t})`
  };
}
function he(e, t) {
  const n = e[t];
  return Et(n) ? {
    ...e,
    ...n
  } : e;
}
function Eo(e) {
  const t = e && !Tr(e.offsetWidth);
  let n = 0, r = 0, s = 0, i = 0, o = 0, a = 0, l = 0, c = 0, u = 0, f = 0, h = 0, d = 0, p = 1 / 0, g = 1 / 0, m = 1 / 0, b = 1 / 0, S = 0, v = 0, E = !1;
  if (e)
    if (!t && e.ownerSVGElement) {
      const x = e.getBBox();
      E = !0, n = x.width, r = x.height, o = n, a = r, l = n, c = r, s = n, i = r;
    } else {
      const x = Pt(e), w = e.style, D = x("boxSizing") === "border-box", C = parseFloat(x("borderLeftWidth")) || 0, P = parseFloat(x("borderRightWidth")) || 0, M = parseFloat(x("borderTopWidth")) || 0, y = parseFloat(x("borderBottomWidth")) || 0, T = parseFloat(x("paddingLeft")) || 0, O = parseFloat(x("paddingRight")) || 0, R = parseFloat(x("paddingTop")) || 0, I = parseFloat(x("paddingBottom")) || 0, _ = T + O, A = R + I, B = C + P, N = M + y, G = _ + B, k = A + N, q = x("position");
      let j = 0, X = 0;
      if ("clientLeft" in e) {
        let J = null;
        if (q === "absolute" ? J = Ue(e, ee(e)).offsetParent : J = e.parentElement, J) {
          const $ = Pt(J);
          j = parseFloat($("width")), X = parseFloat($("height"));
        }
      }
      u = Math.max(_, K(x("minWidth"), j) || 0), f = Math.max(A, K(x("minHeight"), X) || 0), p = K(x("maxWidth"), j), g = K(x("maxHeight"), X), isNaN(p) && (p = 1 / 0), isNaN(g) && (g = 1 / 0), S = K(w.width, 0) || 0, v = K(w.height, 0) || 0, o = parseFloat(x("width")) || 0, a = parseFloat(x("height")) || 0, l = z(o - S) < 1 ? Bt(u, S || o, p) : o, c = z(a - v) < 1 ? Bt(f, v || a, g) : a, n = l, r = c, s = l, i = c, D ? (m = p, b = g, h = u, d = f, l = n - G, c = r - k) : (m = p + G, b = g + k, h = u + G, d = f + k, n = l + G, r = c + k), s = l + _, i = c + A;
    }
  return {
    svg: E,
    offsetWidth: n,
    offsetHeight: r,
    clientWidth: s,
    clientHeight: i,
    contentWidth: l,
    contentHeight: c,
    inlineCSSWidth: S,
    inlineCSSHeight: v,
    cssWidth: o,
    cssHeight: a,
    minWidth: u,
    minHeight: f,
    maxWidth: p,
    maxHeight: g,
    minOffsetWidth: h,
    minOffsetHeight: d,
    maxOffsetWidth: m,
    maxOffsetHeight: b
  };
}
function wo(e, t) {
  return lt(t > 0 ? e[0] : e[1], t > 0 ? e[1] : e[0]);
}
function dn() {
  return {
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    right: 0,
    bottom: 0,
    clientLeft: 0,
    clientTop: 0,
    clientWidth: 0,
    clientHeight: 0,
    scrollWidth: 0,
    scrollHeight: 0
  };
}
function Co(e, t) {
  const n = e === ee(e) || e === Ir(e), r = {
    clientLeft: e.clientLeft,
    clientTop: e.clientTop,
    clientWidth: e.clientWidth,
    clientHeight: e.clientHeight,
    scrollWidth: e.scrollWidth,
    scrollHeight: e.scrollHeight,
    overflow: !1
  };
  return n && (r.clientHeight = Math.max(t.height, r.clientHeight), r.scrollHeight = Math.max(t.height, r.scrollHeight)), r.overflow = Pt(e)("overflow") !== "visible", {
    ...t,
    ...r
  };
}
function sr(e, t, n, r) {
  const { left: s, right: i, top: o, bottom: a } = e, l = t.top, c = t.left, u = {
    left: c + s,
    top: l + o,
    right: c + i,
    bottom: l + a,
    width: i - s,
    height: a - o
  };
  return n && r ? Co(n, u) : u;
}
function We(e, t) {
  let n = 0, r = 0, s = 0, i = 0;
  if (e) {
    const a = e.getBoundingClientRect();
    n = a.left, r = a.top, s = a.width, i = a.height;
  }
  const o = {
    left: n,
    top: r,
    width: s,
    height: i,
    right: n + s,
    bottom: r + i
  };
  return e && t ? Co(e, o) : o;
}
function Hc(e) {
  const { groupable: t, svgOrigin: n } = e.props, { offsetWidth: r, offsetHeight: s, svg: i, transformOrigin: o } = e.getState();
  return !t && i && n ? ss(n, r, s) : o;
}
function yo(e, t, n, r) {
  let s;
  if (e)
    s = e;
  else if (t)
    s = [0, 0];
  else {
    const i = n.target;
    s = Po(i, r);
  }
  return s;
}
function Po(e, t) {
  if (!e)
    return;
  const n = e.getAttribute("data-rotation") || "", r = e.getAttribute("data-direction");
  if (t.deg = n, !r)
    return;
  const s = [0, 0];
  return r.indexOf("w") > -1 && (s[0] = -1), r.indexOf("e") > -1 && (s[0] = 1), r.indexOf("n") > -1 && (s[1] = -1), r.indexOf("s") > -1 && (s[1] = 1), s;
}
function Qr(e, t) {
  return [
    Q(t, e[0]),
    Q(t, e[1]),
    Q(t, e[2]),
    Q(t, e[3])
  ];
}
function It({ left: e, top: t, pos1: n, pos2: r, pos3: s, pos4: i }) {
  return Qr([n, r, s, i], [e, t]);
}
function Cr(e, t) {
  e[t ? "controlAbles" : "targetAbles"].forEach((n) => {
    n.unset && n.unset(e);
  });
}
function we(e, t) {
  const n = t ? "controlGesto" : "targetGesto", r = e[n];
  (r == null ? void 0 : r.isIdle()) === !1 && Cr(e, t), r == null || r.unset(), e[n] = null;
}
function xt(e, t) {
  if (t) {
    const n = Ae(t);
    n.nextStyle = {
      ...n.nextStyle,
      ...e
    };
  }
  return {
    style: e,
    cssText: _e(e).map((n) => `${ga(n, "-")}: ${e[n]};`).join("")
  };
}
function Do(e, t, n) {
  const r = t.afterTransform || t.transform;
  return {
    ...xt({
      ...e.style,
      ...t.style,
      transform: r
    }, n),
    afterTransform: r,
    transform: e.transform
  };
}
function U(e, t, n, r) {
  const s = t.datas;
  s.datas || (s.datas = {});
  const i = {
    ...n,
    target: e.state.target,
    clientX: t.clientX,
    clientY: t.clientY,
    inputEvent: t.inputEvent,
    currentTarget: e,
    moveable: e,
    datas: s.datas,
    isRequest: t.isRequest,
    isRequestChild: t.isRequestChild,
    isFirstDrag: !!t.isFirstDrag,
    isTrusted: t.isTrusted !== !1,
    stopAble() {
      s.isEventStart = !1;
    },
    stopDrag() {
      var o;
      (o = t.stop) == null || o.call(t);
    }
  };
  return s.isStartEvent ? r || (s.lastEvent = i) : s.isStartEvent = !0, i;
}
function Mt(e, t, n) {
  const r = t.datas, s = "isDrag" in n ? n.isDrag : t.isDrag;
  return r.datas || (r.datas = {}), {
    isDrag: s,
    ...n,
    moveable: e,
    target: e.state.target,
    clientX: t.clientX,
    clientY: t.clientY,
    inputEvent: t.inputEvent,
    currentTarget: e,
    lastEvent: r.lastEvent,
    isDouble: t.isDouble,
    datas: r.datas,
    isFirstDrag: !!t.isFirstDrag
  };
}
function Wn(e, t, n) {
  e._emitter.on(t, n);
}
function Y(e, t, n, r, s) {
  return e.triggerEvent(t, n, r, s);
}
function ts(e, t) {
  return yt(e).getComputedStyle(e, t);
}
function pn(e, t, n) {
  const r = {}, s = {};
  return e.filter((i) => {
    const o = i.name;
    if (r[o] || !t.some((a) => i[a]))
      return !1;
    if (!n && i.ableGroup) {
      if (s[i.ableGroup])
        return !1;
      s[i.ableGroup] = !0;
    }
    return r[o] = !0, !0;
  });
}
function yr(e, t) {
  return e === t || e == null && t == null;
}
function ks(...e) {
  const t = e.length - 1;
  for (let n = 0; n < t; ++n) {
    const r = e[n];
    if (!Tr(r))
      return r;
  }
  return e[t];
}
function Oo(e, t) {
  const n = [], r = [];
  return e.forEach((s, i) => {
    const o = t(s, i, e), a = r.indexOf(o), l = n[a] || [];
    a === -1 && (r.push(o), n.push(l)), l.push(s);
  }), n;
}
function Vc(e, t) {
  const n = [], r = {};
  return e.forEach((s, i) => {
    const o = t(s, i, e);
    let a = r[o];
    a || (a = [], r[o] = a, n.push(a)), a.push(s);
  }), n;
}
function Mo(e) {
  return e.reduce((t, n) => t.concat(n), []);
}
function Re(...e) {
  return e.sort((t, n) => z(n) - z(t)), e[0];
}
function ze(e, t, n) {
  return mt($t(e, n), ue(t, n), n);
}
function qc(e, t) {
  const { is3d: n, rootMatrix: r } = e, s = n ? 4 : 3;
  return [t.distX, t.distY] = ze(r, [t.distX, t.distY], s), t;
}
function Tt(e, t, n, r) {
  if (!n[0] && !n[1])
    return t;
  const s = ot(e, [Bs(n[0] || 1), 0], r), i = ot(e, [0, Bs(n[1] || 1)], r), o = ot(e, [n[0] / _t(s), n[1] / _t(i)], r);
  return Q(t, o);
}
function At(e, t, n) {
  return n ? `${e / t * 100}%` : `${e}px`;
}
function zn(e) {
  return z(e) <= wt ? 0 : e;
}
function es(e) {
  return (t) => {
    if (!t.isDragging(e))
      return "";
    const r = $l(t, e).deg;
    return r ? L(`view-control-rotation${r}`) : "";
  };
}
function ns(e, t = [e]) {
  return (n, r) => {
    if (r.isRequest)
      return t.some((i) => r.requestAble === i) ? r.parentDirection : !1;
    const s = r.inputEvent.target;
    return ht(s, L("direction")) && (!e || ht(s, L(e)));
  };
}
function Uc(e, t, n) {
  const r = Oe(e, {
    "x%": (E) => E / 100 * t.offsetWidth,
    "y%": (E) => E / 100 * t.offsetHeight
  }), s = e.slice(0, n < 0 ? void 0 : n), i = e.slice(0, n < 0 ? void 0 : n + 1), o = e[n] || "", a = n < 0 ? [] : e.slice(n), l = n < 0 ? [] : e.slice(n + 1), c = r.slice(0, n < 0 ? void 0 : n), u = r.slice(0, n < 0 ? void 0 : n + 1), f = r[n] ?? Oe([""])[0], h = n < 0 ? [] : r.slice(n), d = n < 0 ? [] : r.slice(n + 1), p = f ? [f] : [], g = ve(c), m = ve(u), b = ve(h), S = ve(d), v = tt(g, b, 4);
  return {
    transforms: e,
    beforeFunctionMatrix: g,
    beforeFunctionMatrix2: m,
    targetFunctionMatrix: ve(p),
    afterFunctionMatrix: b,
    afterFunctionMatrix2: S,
    allFunctionMatrix: v,
    beforeFunctions: c,
    beforeFunctions2: u,
    targetFunction: p[0],
    afterFunctions: h,
    afterFunctions2: d,
    beforeFunctionTexts: s,
    beforeFunctionTexts2: i,
    targetFunctionText: o,
    afterFunctionTexts: a,
    afterFunctionTexts2: l
  };
}
function Zc(e) {
  return !e || !Et(e) || le(e) ? !1 : at(e) || "length" in e;
}
function Lt(e, t) {
  return e ? le(e) ? e : jt(e) ? t ? document.querySelector(e) : e : In(e) ? e() : di(e) ? e : "current" in e ? e.current : e : null;
}
function rs(e, t) {
  return e ? (Zc(e) ? [].slice.call(e) : [e]).reduce((r, s) => jt(s) && t ? [
    ...r,
    ...[].slice.call(document.querySelectorAll(s))
  ] : (at(s) ? r.push(rs(s, t)) : r.push(Lt(s, t)), r), []) : [];
}
function Kc(e, t, n) {
  let r = lt(e, t) / Math.PI * 180;
  return r = n >= 0 ? r : 180 - r, r = r >= 0 ? r : 360 + r, r;
}
function js(e, t) {
  const { rootMatrix: n, is3d: r } = e;
  let i = $t(n, r ? 4 : 3);
  return r || (i = kt(i, 3, 4)), i[12] = 0, i[13] = 0, i[14] = 0, vn(i, t);
}
function To(e, t, n, r, s) {
  const [i, o] = e;
  let a = 0, l = 0;
  if (s && i && o) {
    const c = lt([0, 0], t), u = lt([0, 0], r), f = _t(t), h = Math.cos(c - u) * f;
    if (!r[0])
      l = h, a = l * n;
    else if (!r[1])
      a = h, l = a / n;
    else {
      const d = r[0] * i, p = r[1] * o;
      let g = Math.atan2(d + t[0], p + t[1]), m = Math.atan2(d, p);
      g < 0 && (g += Math.PI * 2), m < 0 && (m += Math.PI * 2);
      let b = 0;
      z(g - m) < Math.PI / 2 || z(g - m) > Math.PI / 2 * 3 || (m += Math.PI), b = g - m, b > Math.PI * 2 ? b -= Math.PI * 2 : b > Math.PI ? b = 2 * Math.PI - b : b < -Math.PI && (b = -2 * Math.PI - b);
      const S = _t([d + t[0], p + t[1]]) * Math.cos(b);
      a = S * Math.sin(m) - d, l = S * Math.cos(m) - p, r[0] < 0 && (a *= -1), r[1] < 0 && (l *= -1);
    }
  } else
    a = r[0] * t[0], l = r[1] * t[1];
  return [a, l];
}
function Ro(e, t, n, r) {
  const { ratio: s, startOffsetWidth: i, startOffsetHeight: o } = n;
  let a = 0, l = 0;
  const { distX: c, distY: u, pinchScale: f, parentDistance: h, parentDist: d, parentScale: p } = r, g = n.fixedDirection, m = [0, 1].map((S) => z(e[S] - g[S])), b = [0, 1].map((S) => {
    let v = m[S];
    return v !== 0 && (v = 2 / v), v;
  });
  if (d)
    a = d[0], l = d[1], t && (a ? l || (l = a / s) : a = l * s);
  else if (He(f))
    a = (f - 1) * i, l = (f - 1) * o;
  else if (p)
    a = (p[0] - 1) * i, l = (p[1] - 1) * o;
  else if (h) {
    const S = i * m[0], v = o * m[1], E = _t([S, v]);
    a = h / E * S * b[0], l = h / E * v * b[1];
  } else {
    let S = Wt({ datas: n, distX: c, distY: u });
    S = b.map((v, E) => S[E] * v), [a, l] = To([i, o], S, s, e, t);
  }
  return {
    // direction,
    // sizeDirection,
    distWidth: a,
    distHeight: l
  };
}
function Pr(e, t) {
  if (t) {
    if (e === "left")
      return { x: "0%", y: "50%" };
    if (e === "top")
      return { x: "50%", y: "50%" };
    if (e === "center")
      return { x: "50%", y: "50%" };
    if (e === "right")
      return { x: "100%", y: "50%" };
    if (e === "bottom")
      return { x: "50%", y: "100%" };
    const [n, r] = e.split(" "), s = Pr(n || ""), i = Pr(r || ""), o = {
      ...s,
      ...i
    }, a = {
      x: "50%",
      y: "50%"
    };
    return o.x && (a.x = o.x), o.y && (a.y = o.y), o.value && (o.x && !o.y && (a.y = o.value), !o.x && o.y && (a.x = o.value)), a;
  }
  return e === "left" ? { x: "0%" } : e === "right" ? { x: "100%" } : e === "top" ? { y: "0%" } : e === "bottom" ? { y: "100%" } : e ? e === "center" ? { value: "50%" } : { value: e } : {};
}
function ss(e, t, n) {
  const { x: r, y: s } = Pr(e, !0);
  return [K(r, t) || 0, K(s, n) || 0];
}
function Jc(e, t, n) {
  const r = e.map((i) => W(i, t)), s = r.map((i) => Ze(i, n));
  return {
    prev: r,
    next: s,
    result: s.map((i) => Q(i, t))
  };
}
function zo(e, t) {
  return e.length === t.length && e.every((n, r) => {
    const s = t[r], i = at(n), o = at(s);
    return i && o ? zo(n, s) : !i && !o ? n === s : !1;
  });
}
function Ce(e, t, n, r, s) {
  const i = e._store;
  let o = i[t];
  if (!(t in i))
    if (s != null)
      i[t] = s, o = s;
    else
      return i[t] = n, n;
  return o === n || r(o) === r(n) ? o : (i[t] = n, n);
}
function St(e) {
  return e >= 0 ? 1 : -1;
}
function z(e) {
  return Math.abs(e);
}
function ir(e, t) {
  return xa(e).map((n) => t(n));
}
function _o(e) {
  return He(e) ? {
    top: e,
    left: e,
    right: e,
    bottom: e
  } : {
    left: e.left || 0,
    top: e.top || 0,
    right: e.right || 0,
    bottom: e.bottom || 0
  };
}
const Qc = Je("pinchable", {
  props: ["pinchable"],
  events: [
    "pinchStart",
    "pinch",
    "pinchEnd",
    "pinchGroupStart",
    "pinchGroup",
    "pinchGroupEnd"
  ],
  dragStart() {
    return !0;
  },
  pinchStart(e, t) {
    const { datas: n, targets: r, angle: s, originalDatas: i } = t, { pinchable: o, ables: a } = e.props;
    if (!o)
      return !1;
    const l = `onPinch${r ? "Group" : ""}Start`, c = `drag${r ? "Group" : ""}ControlStart`, u = (o === !0 ? e.controlAbles : a.filter((p) => o.indexOf(p.name) > -1)).filter((p) => p.canPinch && p[c]), f = U(e, t, {});
    r && (f.targets = r);
    const h = Y(e, l, f);
    n.isPinch = h !== !1, n.ables = u;
    const d = n.isPinch;
    return d ? (u.forEach((p) => {
      if (i[p.name] = i[p.name] || {}, !p[c])
        return;
      const g = {
        ...t,
        datas: i[p.name],
        parentRotate: s,
        isPinch: !0
      };
      p[c](e, g);
    }), e.state.snapRenderInfo = {
      request: t.isRequest,
      direction: [0, 0]
    }, d) : !1;
  },
  pinch(e, t) {
    const { datas: n, scale: r, distance: s, originalDatas: i, inputEvent: o, targets: a, angle: l } = t;
    if (!n.isPinch)
      return;
    const c = s * (1 - 1 / r), u = U(e, t, {});
    a && (u.targets = a), Y(e, `onPinch${a ? "Group" : ""}`, u);
    const h = n.ables, d = `drag${a ? "Group" : ""}Control`;
    return h.forEach((p) => {
      p[d] && p[d](e, {
        ...t,
        datas: i[p.name],
        inputEvent: o,
        resolveMatrix: !0,
        pinchScale: r,
        parentDistance: c,
        parentRotate: l,
        isPinch: !0
      });
    }), u;
  },
  pinchEnd(e, t) {
    const { datas: n, isPinch: r, inputEvent: s, targets: i, originalDatas: o } = t;
    if (!n.isPinch)
      return;
    const a = `onPinch${i ? "Group" : ""}End`, l = Mt(e, t, {
      isDrag: r
    });
    i && (l.targets = i), Y(e, a, l);
    const c = n.ables, u = `drag${i ? "Group" : ""}ControlEnd`;
    return c.forEach((f) => {
      f[u] && f[u](e, {
        ...t,
        isDrag: r,
        datas: o[f.name],
        inputEvent: s,
        isPinch: !0
      });
    }), r;
  },
  pinchGroupStart(e, t) {
    return this.pinchStart(e, {
      ...t,
      targets: e.props.targets
    });
  },
  pinchGroup(e, t) {
    return this.pinch(e, { ...t, targets: e.props.targets });
  },
  pinchGroupEnd(e, t) {
    return this.pinchEnd(e, { ...t, targets: e.props.targets });
  }
}), Xs = ns("scalable"), tu = {
  name: "scalable",
  ableGroup: "size",
  canPinch: !0,
  props: [
    "scalable",
    "throttleScale",
    "renderDirections",
    "keepRatio",
    "edge",
    "displayAroundControls"
  ],
  events: [
    "scaleStart",
    "beforeScale",
    "scale",
    "scaleEnd",
    "scaleGroupStart",
    "beforeScaleGroup",
    "scaleGroup",
    "scaleGroupEnd"
  ],
  render: Ki("scalable"),
  dragControlCondition: Xs,
  viewClassName: es("scalable"),
  dragControlStart(e, t) {
    const { datas: n, isPinch: r, inputEvent: s, parentDirection: i } = t, o = yo(i, r, s, n), { width: a, height: l, targetTransform: c, target: u, pos1: f, pos2: h, pos4: d } = e.state;
    if (!o || !u)
      return !1;
    r || pe(e, t), n.datas = {}, n.transform = c, n.prevDist = [1, 1], n.direction = o, n.startOffsetWidth = a, n.startOffsetHeight = l, n.startValue = [1, 1];
    const p = !o[0] && !o[1] || o[0] || !o[1];
    jn(e, t, "scale"), n.isWidth = p;
    function g(x) {
      n.ratio = x && isFinite(x) ? x : 0;
    }
    n.startPositions = It(e.state);
    function m(x) {
      const w = co(n.startPositions, x);
      n.fixedDirection = w.fixedDirection, n.fixedPosition = w.fixedPosition, n.fixedOffset = w.fixedOffset;
    }
    n.setFixedDirection = m, g(Ft(f, h) / Ft(h, d)), m([-o[0], -o[1]]);
    const b = (x) => {
      n.minScaleSize = x;
    }, S = (x) => {
      n.maxScaleSize = x;
    };
    b([-1 / 0, -1 / 0]), S([1 / 0, 1 / 0]);
    const v = U(e, t, {
      direction: o,
      set: (x) => {
        n.startValue = x;
      },
      setRatio: g,
      setFixedDirection: m,
      setMinScaleSize: b,
      setMaxScaleSize: S,
      ...kn(e, t),
      dragStart: vt.dragStart(e, new Me().dragStart([0, 0], t))
    }), E = Y(e, "onScaleStart", v);
    return n.startFixedDirection = n.fixedDirection, E !== !1 && (n.isScale = !0, e.state.snapRenderInfo = {
      request: t.isRequest,
      direction: o
    }), n.isScale ? v : !1;
  },
  dragControl(e, t) {
    Gn(e, t, "scale");
    const { datas: n, parentKeepRatio: r, parentFlag: s, isPinch: i, dragClient: o, isRequest: a, useSnap: l, resolveMatrix: c } = t, { prevDist: u, direction: f, startOffsetWidth: h, startOffsetHeight: d, isScale: p, startValue: g, isWidth: m, ratio: b } = n;
    if (!p)
      return !1;
    const S = e.props, { throttleScale: v, parentMoveable: E } = S;
    let x = f;
    !f[0] && !f[1] && (x = [1, 1]);
    const w = b && (r ?? S.keepRatio) || !1, D = e.state, C = [g[0], g[1]];
    function P() {
      const { distWidth: $, distHeight: F } = Ro(x, w, n, t), H = h ? (h + $) / h : 1, rt = d ? (d + F) / d : 1;
      g[0] || (C[0] = $ / h), g[1] || (C[1] = F / d);
      let dt = (x[0] || w ? H : 1) * C[0], ct = (x[1] || w ? rt : 1) * C[1];
      return dt === 0 && (dt = St(u[0]) * cn), ct === 0 && (ct = St(u[1]) * cn), [dt, ct];
    }
    let M = P();
    if (!i && e.props.groupable) {
      const F = (D.snapRenderInfo || {}).direction;
      at(F) && (F[0] || F[1]) && (D.snapRenderInfo = { direction: f, request: t.isRequest });
    }
    Y(e, "onBeforeScale", U(e, t, {
      scale: M,
      setFixedDirection($) {
        return n.setFixedDirection($), M = P(), M;
      },
      startFixedDirection: n.startFixedDirection,
      setScale($) {
        M = $;
      }
    }, !0));
    let y = [M[0] / C[0], M[1] / C[1]], T = o, O = [0, 0];
    const R = St(y[0] * y[1]), I = !o && !s && i;
    if (I || c ? T = Nr(e, n.targetAllTransform, [0, 0], [0, 0], n) : o || (T = n.fixedPosition), i || (O = zc(e, y, f, !l && a, n)), w) {
      x[0] && x[1] && O[0] && O[1] && (Math.abs(O[0] * h) > Math.abs(O[1] * d) ? O[1] = 0 : O[0] = 0);
      const $ = !O[0] && !O[1];
      if ($ && (m ? y[0] = V(y[0] * C[0], v) / C[0] : y[1] = V(y[1] * C[1], v) / C[1]), x[0] && !x[1] || O[0] && !O[1] || $ && m) {
        y[0] += O[0];
        const F = h * y[0] * C[0] / b;
        y[1] = St(R * y[0]) * z(F / d / C[1]);
      } else if (!x[0] && x[1] || !O[0] && O[1] || $ && !m) {
        y[1] += O[1];
        const F = d * y[1] * C[1] * b;
        y[0] = St(R * y[1]) * z(F / h / C[0]);
      }
    } else
      y[0] += O[0], y[1] += O[1], O[0] || (y[0] = V(y[0] * C[0], v) / C[0]), O[1] || (y[1] = V(y[1] * C[1], v) / C[1]);
    y[0] === 0 && (y[0] = St(u[0]) * cn), y[1] === 0 && (y[1] = St(u[1]) * cn), M = Ac(y, [C[0], C[1]]);
    const _ = [h, d];
    let A = [h * M[0], d * M[1]];
    A = Rr(A, n.minScaleSize, n.maxScaleSize, w ? b : !1), M = ir(2, ($) => _[$] ? A[$] / _[$] : A[$]), y = ir(2, ($) => M[$] / C[$]);
    const B = ir(2, ($) => u[$] ? y[$] / u[$] : y[$]), N = `scale(${y.join(", ")})`, G = `scale(${M.join(", ")})`, k = $n(n, G, N), q = !g[0] || !g[1], j = zl(e, q ? G : N, n.fixedDirection, T, n.fixedOffset, n, q), X = I ? j : W(j, n.prevInverseDist || [0, 0]);
    if (n.prevDist = y, n.prevInverseDist = j, M[0] === u[0] && M[1] === u[1] && X.every(($) => !$) && !E && !I)
      return !1;
    const J = U(e, t, {
      offsetWidth: h,
      offsetHeight: d,
      direction: f,
      scale: M,
      dist: y,
      delta: B,
      isPinch: !!i,
      ...Ni(e, k, X, i, t)
    });
    return Y(e, "onScale", J), J;
  },
  dragControlEnd(e, t) {
    const { datas: n } = t;
    if (!n.isScale)
      return !1;
    n.isScale = !1;
    const r = Mt(e, t, {});
    return Y(e, "onScaleEnd", r), r;
  },
  dragGroupControlCondition: Xs,
  dragGroupControlStart(e, t) {
    const { datas: n } = t, r = this.dragControlStart(e, t);
    if (!r)
      return !1;
    const s = Gt(e, "resizable", t);
    n.moveableScale = e.scale;
    const i = Vt(e, this, "dragControlStart", t, (c, u) => Dn(e, c, n, u)), o = (c) => {
      r.setFixedDirection(c), i.forEach((u, f) => {
        u.setFixedDirection(c), Dn(e, u.moveable, n, s[f]);
      });
    };
    n.setFixedDirection = o;
    const a = {
      ...r,
      targets: e.props.targets,
      events: i,
      setFixedDirection: o
    }, l = Y(e, "onScaleGroupStart", a);
    return n.isScale = l !== !1, n.isScale ? a : !1;
  },
  dragGroupControl(e, t) {
    const { datas: n } = t;
    if (!n.isScale)
      return;
    Wn(e, "onBeforeScale", (u) => {
      Y(e, "onBeforeScaleGroup", U(e, t, {
        ...u,
        targets: e.props.targets
      }, !0));
    });
    const r = this.dragControl(e, t);
    if (!r)
      return;
    const { dist: s } = r, i = n.moveableScale;
    e.scale = [s[0] * i[0], s[1] * i[1]];
    const o = e.props.keepRatio, a = n.fixedPosition, l = Vt(e, this, "dragControl", t, (u, f) => {
      const [h, d] = mt(Ke(e.rotation / 180 * Math.PI, 3), [f.datas.originalX * s[0], f.datas.originalY * s[1], 1], 3);
      return {
        ...f,
        parentDist: null,
        parentScale: s,
        parentKeepRatio: o,
        // recalculate child fixed position for parent group's dragging.
        dragClient: Q(a, [h, d])
      };
    }), c = {
      targets: e.props.targets,
      events: l,
      ...r
    };
    return Y(e, "onScaleGroup", c), c;
  },
  dragGroupControlEnd(e, t) {
    const { isDrag: n, datas: r } = t;
    if (!r.isScale)
      return;
    this.dragControlEnd(e, t);
    const s = Vt(e, this, "dragControlEnd", t), i = Mt(e, t, {
      targets: e.props.targets,
      events: s
    });
    return Y(e, "onScaleGroupEnd", i), n;
  },
  /**
       * @method Moveable.Scalable#request
       * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter
       * @return {Moveable.Requester} Moveable Requester
       * @example
  
       * // Instantly Request (requestStart - request - requestEnd)
       * moveable.request("scalable", { deltaWidth: 10, deltaHeight: 10 }, true);
       *
       * // requestStart
       * const requester = moveable.request("scalable");
       *
       * // request
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       *
       * // requestEnd
       * requester.requestEnd();
       */
  request() {
    const e = {};
    let t = 0, n = 0, r = !1;
    return {
      isControl: !0,
      requestStart(s) {
        return r = s.useSnap, {
          datas: e,
          parentDirection: s.direction || [1, 1],
          useSnap: r
        };
      },
      request(s) {
        return t += s.deltaWidth, n += s.deltaHeight, {
          datas: e,
          parentDist: [t, n],
          parentKeepRatio: s.keepRatio,
          useSnap: r
        };
      },
      requestEnd() {
        return { datas: e, isDrag: !0, useSnap: r };
      }
    };
  }
};
function Ut(e, t) {
  return e.map((n, r) => En(n, t[r], 1, 2));
}
function Ys(e, t, n) {
  const r = lt(e, t), i = lt(e, n) - r;
  return i >= 0 ? i : i + 2 * Math.PI;
}
function eu(e, t) {
  const n = Ys(e[0], e[1], e[2]), r = Ys(t[0], t[1], t[2]), s = Math.PI;
  return !(n >= s && r <= s || n <= s && r >= s);
}
const nu = {
  name: "warpable",
  ableGroup: "size",
  props: [
    "warpable",
    "renderDirections",
    "edge",
    "displayAroundControls"
  ],
  events: ["warpStart", "warp", "warpEnd"],
  viewClassName: es("warpable"),
  render(e, t) {
    const { resizable: n, scalable: r, warpable: s, zoom: i } = e.props;
    if (n || r || !s)
      return [];
    const { pos1: o, pos2: a, pos3: l, pos4: c } = e.state, u = Ut(o, a), f = Ut(a, o), h = Ut(o, l), d = Ut(l, o), p = Ut(l, c), g = Ut(c, l), m = Ut(a, c), b = Ut(c, a);
    return [
      Z("div", { className: L("line"), style: je(u, p, i) }, "middeLine1"),
      Z("div", { className: L("line"), style: je(f, g, i) }, "middeLine2"),
      Z("div", { className: L("line"), style: je(h, m, i) }, "middeLine3"),
      Z("div", { className: L("line"), style: je(d, b, i) }, "middeLine4"),
      ...Ji(e, "warpable", t)
    ];
  },
  dragControlCondition(e, t) {
    if (t.isRequest)
      return !1;
    const n = t.inputEvent.target;
    return ht(n, L("direction")) && ht(n, L("warpable"));
  },
  dragControlStart(e, t) {
    const { datas: n, inputEvent: r } = t, { target: s } = e.props, { target: i } = r, o = Po(i, n);
    if (!o || !s)
      return !1;
    const a = e.state, { transformOrigin: l, is3d: c, targetTransform: u, targetMatrix: f, width: h, height: d, left: p, top: g } = a;
    n.datas = {}, n.targetTransform = u, n.warpTargetMatrix = c ? f : kt(f, 3, 4), n.targetInverseMatrix = xi($t(n.warpTargetMatrix, 4), 3, 4), n.direction = o, n.left = p, n.top = g, n.poses = [
      [0, 0],
      [h, 0],
      [0, d],
      [h, d]
    ].map((S) => W(S, l)), n.nextPoses = n.poses.map(([S, v]) => mt(n.warpTargetMatrix, [S, v, 0, 1], 4)), n.startValue = nt(4), n.prevMatrix = nt(4), n.absolutePoses = It(a), n.posIndexes = Wi(o), pe(e, t), jn(e, t, "matrix3d"), a.snapRenderInfo = {
      request: t.isRequest,
      direction: o
    };
    const m = U(e, t, {
      set: (S) => {
        n.startValue = S;
      },
      ...kn(e, t)
    });
    return Y(e, "onWarpStart", m) !== !1 && (n.isWarp = !0), n.isWarp;
  },
  dragControl(e, t) {
    const { datas: n, isRequest: r } = t;
    let { distX: s, distY: i } = t;
    const { targetInverseMatrix: o, prevMatrix: a, isWarp: l, startValue: c, poses: u, posIndexes: f, absolutePoses: h } = n;
    if (!l)
      return !1;
    if (Gn(e, t, "matrix3d"), Ge(e, "warpable")) {
      const x = f.map((C) => h[C]);
      x.length > 1 && x.push([
        (x[0][0] + x[1][0]) / 2,
        (x[0][1] + x[1][1]) / 2
      ]);
      const { horizontal: w, vertical: D } = Fn(e, r, {
        horizontal: x.map((C) => C[1] + i),
        vertical: x.map((C) => C[0] + s)
      });
      i -= w.offset, s -= D.offset;
    }
    const d = Wt({ datas: n, distX: s, distY: i }, !0), p = n.nextPoses.slice();
    if (f.forEach((x) => {
      p[x] = Q(p[x], d);
    }), !Sl.every((x) => eu(x.map((w) => u[w]), x.map((w) => p[w]))))
      return !1;
    const g = Gr(u[0], u[2], u[1], u[3], p[0], p[2], p[1], p[3]);
    if (!g.length)
      return !1;
    const m = tt(o, g, 4), b = Fi(n, m, !0), S = tt($t(a, 4), b, 4);
    n.prevMatrix = b;
    const v = tt(c, b, 4), E = $n(n, `matrix3d(${v.join(", ")})`, `matrix3d(${b.join(", ")})`);
    return Wr(t, E), Y(e, "onWarp", U(e, t, {
      delta: S,
      matrix: v,
      dist: b,
      multiply: tt,
      transform: E,
      ...xt({
        transform: E
      }, t)
    })), !0;
  },
  dragControlEnd(e, t) {
    const { datas: n, isDrag: r } = t;
    return n.isWarp ? (n.isWarp = !1, Y(e, "onWarpEnd", Mt(e, t, {})), r) : !1;
  }
}, ru = L("area-pieces"), gn = L("area-piece"), Io = L("avoid"), su = L("view-dragging");
function or(e) {
  const t = e.areaElement;
  if (!t)
    return;
  const { width: n, height: r } = e.state;
  hi(t, Io), t.style.cssText += `left: 0px; top: 0px; width: ${n}px; height: ${r}px`;
}
function Fs(e) {
  return Pe("div", { className: ru, children: [Z("div", { className: gn }), Z("div", { className: gn }), Z("div", { className: gn }), Z("div", { className: gn })] }, "area_pieces");
}
const Bo = {
  name: "dragArea",
  props: ["dragArea", "passDragArea"],
  events: ["click", "clickGroup"],
  render(e, t) {
    const { target: n, dragArea: r, groupable: s, passDragArea: i } = e.props, { width: o, height: a, renderPoses: l } = e.getState(), c = i ? L("area", "pass") : L("area");
    if (s)
      return [
        Z("div", { ref: Rt(e, "areaElement"), className: c }, "area"),
        Fs()
      ];
    if (!n || !r)
      return [];
    const u = Gr([0, 0], [o, 0], [0, a], [o, a], l[0], l[1], l[2], l[3]), f = u.length ? Ln(u, !0) : "none";
    return [
      Z("div", { ref: Rt(e, "areaElement"), className: c, style: {
        top: "0px",
        left: "0px",
        width: `${o}px`,
        height: `${a}px`,
        transformOrigin: "0 0",
        transform: f
      } }, "area"),
      Fs()
    ];
  },
  dragStart(e, { datas: t, clientX: n, clientY: r, inputEvent: s }) {
    if (!s)
      return !1;
    t.isDragArea = !1;
    const i = e.areaElement, o = e.state, { moveableClientRect: a, renderPoses: l, rootMatrix: c, is3d: u } = o, { left: f, top: h } = a, { left: d, top: p, width: g, height: m } = zt(l), b = u ? 4 : 3;
    let [S, v] = ze(c, [n - f, r - h], b);
    S -= d, v -= p;
    const E = [
      { left: d, top: p, width: g, height: v - 10 },
      { left: d, top: p, width: S - 10, height: m },
      {
        left: d,
        top: p + v + 10,
        width: g,
        height: m - v - 10
      },
      {
        left: d + S + 10,
        top: p,
        width: g - S - 10,
        height: m
      }
    ], x = [].slice.call(i.nextElementSibling.children);
    E.forEach((w, D) => {
      x[D].style.cssText = `left: ${w.left}px;top: ${w.top}px; width: ${w.width}px; height: ${w.height}px;`;
    }), Ht(i, Io), o.disableNativeEvent = !0;
  },
  drag(e, { datas: t, inputEvent: n }) {
    if (this.enableNativeEvent(e), !n)
      return !1;
    t.isDragArea || (t.isDragArea = !0, or(e));
  },
  dragEnd(e, t) {
    this.enableNativeEvent(e);
    const { inputEvent: n, datas: r } = t;
    if (!n)
      return !1;
    r.isDragArea || or(e);
  },
  dragGroupStart(e, t) {
    return this.dragStart(e, t);
  },
  dragGroup(e, t) {
    return this.drag(e, t);
  },
  dragGroupEnd(e, t) {
    return this.dragEnd(e, t);
  },
  unset(e) {
    or(e), e.state.disableNativeEvent = !1;
  },
  enableNativeEvent(e) {
    const t = e.state;
    t.disableNativeEvent && ui(() => {
      t.disableNativeEvent = !1;
    });
  }
}, iu = Je("origin", {
  props: ["origin", "svgOrigin"],
  render(e, t) {
    const { zoom: n, svgOrigin: r, groupable: s } = e.props, { beforeOrigin: i, rotation: o, svg: a, allMatrix: l, is3d: c, left: u, top: f, offsetWidth: h, offsetHeight: d } = e.getState();
    let p;
    if (!s && a && r) {
      const [g, m] = ss(r, h, d), S = ot(l, [g, m], c ? 4 : 3);
      p = Rn(o, n, W(S, [u, f]));
    } else
      p = Rn(o, n, i);
    return [
      Z("div", { className: L("control", "origin"), style: p }, "beforeOrigin")
    ];
  }
});
function ou(e) {
  const t = e.scrollContainer;
  return [t.scrollLeft, t.scrollTop];
}
const au = {
  name: "scrollable",
  canPinch: !0,
  props: [
    "scrollable",
    "scrollContainer",
    "scrollThreshold",
    "scrollThrottleTime",
    "getScrollPosition",
    "scrollOptions"
  ],
  events: ["scroll", "scrollGroup"],
  dragRelation: "strong",
  dragStart(e, t) {
    const n = e.props, { scrollContainer: r = e.getContainer(), scrollOptions: s } = n, i = new vi(), o = Lt(r, !0);
    t.datas.dragScroll = i, e.state.dragScroll = i;
    const a = t.isControl ? "controlGesto" : "targetGesto", l = t.targets;
    i.on("scroll", ({ container: c, direction: u }) => {
      const f = U(e, t, {
        scrollContainer: c,
        direction: u
      }), h = l ? "onScrollGroup" : "onScroll";
      l && (f.targets = l), Y(e, h, f);
    }).on("move", ({ offsetX: c, offsetY: u, inputEvent: f }) => {
      e[a].scrollBy(c, u, f.inputEvent, !1);
    }).on("scrollDrag", ({ next: c }) => {
      c(e[a].getCurrentEvent());
    }), i.dragStart(t, {
      container: o,
      ...s
    });
  },
  checkScroll(e, t) {
    const n = t.datas.dragScroll;
    if (!n)
      return;
    const { scrollContainer: r = e.getContainer(), scrollThreshold: s = 0, scrollThrottleTime: i = 0, getScrollPosition: o = ou, scrollOptions: a } = e.props;
    return n.drag(t, {
      container: r,
      threshold: s,
      throttleTime: i,
      getScrollPosition: (l) => o({
        scrollContainer: l.container,
        direction: l.direction
      }),
      ...a
    }), !0;
  },
  drag(e, t) {
    return this.checkScroll(e, t);
  },
  dragEnd(e, t) {
    t.datas.dragScroll.dragEnd(), t.datas.dragScroll = null;
  },
  dragControlStart(e, t) {
    return this.dragStart(e, { ...t, isControl: !0 });
  },
  dragControl(e, t) {
    return this.drag(e, t);
  },
  dragControlEnd(e, t) {
    return this.dragEnd(e, t);
  },
  dragGroupStart(e, t) {
    return this.dragStart(e, { ...t, targets: e.props.targets });
  },
  dragGroup(e, t) {
    return this.drag(e, { ...t, targets: e.props.targets });
  },
  dragGroupEnd(e, t) {
    return this.dragEnd(e, { ...t, targets: e.props.targets });
  },
  dragGroupControlStart(e, t) {
    return this.dragStart(e, {
      ...t,
      targets: e.props.targets,
      isControl: !0
    });
  },
  dragGroupControl(e, t) {
    return this.drag(e, { ...t, targets: e.props.targets });
  },
  dragGroupControEnd(e, t) {
    return this.dragEnd(e, { ...t, targets: e.props.targets });
  },
  unset(e) {
    var n;
    const t = e.state;
    (n = t.dragScroll) == null || n.dragEnd(), t.dragScroll = null;
  }
}, Ao = {
  name: "",
  props: [
    "target",
    "dragTargetSelf",
    "dragTarget",
    "dragContainer",
    "container",
    "warpSelf",
    "rootContainer",
    "useResizeObserver",
    "useMutationObserver",
    "zoom",
    "dragFocusedInput",
    "transformOrigin",
    "ables",
    "className",
    "pinchThreshold",
    "pinchOutside",
    "triggerAblesSimultaneously",
    "checkInput",
    "cspNonce",
    "translateZ",
    "hideDefaultLines",
    "props",
    "flushSync",
    "stopPropagation",
    "preventClickEventOnDrag",
    "preventClickDefault",
    "viewContainer",
    "persistData",
    "useAccuratePosition",
    "firstRenderState",
    "linePadding",
    "controlPadding",
    "preventDefault",
    "preventRightClick",
    "preventWheelClick",
    "requestStyles"
  ],
  events: ["changeTargets"]
}, lu = Je("padding", {
  props: ["padding"],
  render(e, t) {
    const n = e.props;
    if (n.dragArea)
      return [];
    const { left: r, top: s, right: i, bottom: o } = _o(n.padding || {}), { renderPoses: a, pos1: l, pos2: c, pos3: u, pos4: f } = e.getState(), h = [l, c, u, f], d = [];
    return r > 0 && d.push([0, 2]), s > 0 && d.push([0, 1]), i > 0 && d.push([1, 3]), o > 0 && d.push([2, 3]), d.map(([p, g], m) => {
      const b = h[p], S = h[g], v = a[p], E = a[g], x = Gr([0, 0], [100, 0], [0, 100], [100, 100], b, S, v, E);
      if (x.length)
        return Z("div", { className: L("padding"), style: {
          transform: Ln(x, !0)
        } }, `padding${m}`);
    });
  }
}), Ls = ["nw", "ne", "se", "sw"];
function mn(e, t) {
  const n = e[0] + e[1], r = n > t ? t / n : 1;
  return e[0] *= r, e[1] = t - e[1] * r, e;
}
const cu = [1, 2, 5, 6], uu = [0, 3, 4, 7], se = [1, -1, -1, 1], ie = [1, 1, -1, -1];
function is(e, t, n, r, s = 0, i = 0, o = n, a = r) {
  const l = [];
  let c = !1;
  const u = e.filter((h) => !h.virtual), f = u.map((h) => {
    const { horizontal: d, vertical: p, pos: g } = h;
    if (p && !c && (c = !0, l.push("/")), c) {
      const m = Math.max(0, p === 1 ? g[1] - i : a - g[1]);
      return l.push(At(m, r, t)), m;
    } else {
      const m = Math.max(0, d === 1 ? g[0] - s : o - g[0]);
      return l.push(At(m, n, t)), m;
    }
  });
  return {
    radiusPoses: u,
    styles: l,
    raws: f
  };
}
function Go(e) {
  const t = [0, 0], n = [0, 0], r = e.length;
  for (let s = 0; s < r; ++s) {
    const i = e[s];
    i.sub && (i.horizontal && (t[1] === 0 && (t[0] = s), t[1] = s - t[0] + 1, n[0] = s + 1), i.vertical && (n[1] === 0 && (n[0] = s), n[1] = s - n[0] + 1));
  }
  return {
    horizontalRange: t,
    verticalRange: n
  };
}
function $o(e, t, n, r, s, i = [0, 0], o = !1) {
  const a = e.indexOf("/"), l = (a > -1 ? e.slice(0, a) : e).length, c = e.slice(0, l), u = e.slice(l + 1), f = c.length, h = u.length, d = h > 0, [p = "0px", g = p, m = p, b = g] = c, [S = p, v = d ? S : g, E = d ? S : m, x = d ? v : b] = u, w = [p, g, m, b].map((T) => K(T, t)), D = [S, v, E, x].map((T) => K(T, n)), C = w.slice(), P = D.slice();
  [C[0], C[1]] = mn([C[0], C[1]], t), [C[3], C[2]] = mn([C[3], C[2]], t), [P[0], P[3]] = mn([P[0], P[3]], n), [P[1], P[2]] = mn([P[1], P[2]], n);
  const M = o ? C : C.slice(0, Math.max(i[0], f)), y = o ? P : P.slice(0, Math.max(i[1], h));
  return [
    ...M.map((T, O) => {
      const R = Ls[O];
      return {
        virtual: O >= f,
        horizontal: se[O],
        vertical: 0,
        pos: [
          r + T,
          s + (ie[O] === -1 ? n : 0)
        ],
        sub: !0,
        raw: w[O],
        direction: R
      };
    }),
    ...y.map((T, O) => {
      const R = Ls[O];
      return {
        virtual: O >= h,
        horizontal: 0,
        vertical: ie[O],
        pos: [
          r + (se[O] === -1 ? t : 0),
          s + T
        ],
        sub: !0,
        raw: D[O],
        direction: R
      };
    })
  ];
}
function fu(e, t, n, r, s = t.length) {
  const { horizontalRange: i, verticalRange: o } = Go(e.slice(r)), a = n - r;
  let l = 0;
  if (a === 0)
    l = s;
  else if (a > 0 && a < i[1])
    l = i[1] - a;
  else if (a >= o[0])
    l = o[0] + o[1] - a;
  else
    return;
  e.splice(n, l), t.splice(n, l);
}
function hu(e, t, n, r, s, i, o, a, l, c = 0, u = 0) {
  const { horizontalRange: f, verticalRange: h } = Go(e.slice(n));
  if (r > -1) {
    const d = se[r] === 1 ? i - c : a - i;
    for (let p = f[1]; p <= r; ++p) {
      const g = ie[p] === 1 ? u : l;
      let m = 0;
      if (r === p ? m = i : p === 0 ? m = c + d : se[p] === -1 && (m = a - (t[n][0] - c)), e.splice(n + p, 0, {
        horizontal: se[p],
        vertical: 0,
        pos: [m, g]
      }), t.splice(n + p, 0, [m, g]), p === 0)
        break;
    }
  } else if (s > -1) {
    const d = ie[s] === 1 ? o - u : l - o;
    if (f[1] === 0 && h[1] === 0) {
      const g = [c + d, u];
      e.push({
        horizontal: se[0],
        vertical: 0,
        pos: g
      }), t.push(g);
    }
    const p = h[0];
    for (let g = h[1]; g <= s; ++g) {
      const m = se[g] === 1 ? c : a;
      let b = 0;
      if (s === g ? b = o : g === 0 ? b = u + d : ie[g] === 1 ? b = t[n + p][1] : ie[g] === -1 && (b = l - (t[n + p][1] - u)), e.push({
        horizontal: 0,
        vertical: ie[g],
        pos: [m, b]
      }), t.push([m, b]), g === 0)
        break;
    }
  }
}
function du(e, t = e.map((n) => n.raw)) {
  const n = e.map((s, i) => s.horizontal ? t[i] : null).filter((s) => s != null), r = e.map((s, i) => s.vertical ? t[i] : null).filter((s) => s != null);
  return {
    horizontals: n,
    verticals: r
  };
}
const pu = [
  [0, -1, "n"],
  [1, 0, "e"]
], gu = [
  [-1, -1, "nw"],
  [0, -1, "n"],
  [1, -1, "ne"],
  [1, 0, "e"],
  [1, 1, "se"],
  [0, 1, "s"],
  [-1, 1, "sw"],
  [-1, 0, "w"]
];
function os(e, t, n) {
  const { clipRelative: r } = e.props, { width: s, height: i } = e.state, { type: o, poses: a } = t, l = o === "rect", c = o === "circle";
  if (o === "polygon")
    return n.map((u) => `${At(u[0], s, r)} ${At(u[1], i, r)}`);
  if (l || o === "inset") {
    const u = n[1][1], f = n[3][0], h = n[7][0], d = n[5][1];
    if (l)
      return [u, f, d, h].map((g) => `${g}px`);
    const p = [u, s - f, i - d, h].map((g, m) => At(g, m % 2 ? s : i, r));
    if (n.length > 8) {
      const [g, m] = W(n[4], n[0]);
      p.push("round", ...is(a.slice(8).map((b, S) => ({
        ...b,
        pos: n[S]
      })), r, g, m, h, u, f, d).styles);
    }
    return p;
  } else if (c || o === "ellipse") {
    const u = n[0], f = At(z(n[1][1] - u[1]), c ? Math.sqrt((s * s + i * i) / 2) : i, r), h = c ? [f] : [At(z(n[2][0] - u[0]), s, r), f];
    return h.push("at", At(u[0], s, r), At(u[1], i, r)), h;
  }
}
function _n(e, t, n, r) {
  const s = [r, (r + t) / 2, t], i = [e, (e + n) / 2, n];
  return gu.map(([o, a, l]) => {
    const c = s[o + 1], u = i[a + 1];
    return {
      vertical: z(a),
      horizontal: z(o),
      direction: l,
      pos: [c, u]
    };
  });
}
function ko(e) {
  const t = [1 / 0, -1 / 0], n = [1 / 0, -1 / 0];
  return e.forEach(({ pos: r }) => {
    t[0] = Math.min(t[0], r[0]), t[1] = Math.max(t[1], r[0]), n[0] = Math.min(n[0], r[1]), n[1] = Math.max(n[1], r[1]);
  }), [z(t[1] - t[0]), z(n[1] - n[0])];
}
function Ws(e, t, n, r, s) {
  if (!e)
    return;
  let i = s;
  if (!i) {
    const u = Pt(e), f = u("clipPath");
    i = f !== "none" ? f : u("clip");
  }
  if ((!i || i === "none" || i === "auto") && (i = r, !i))
    return;
  const { prefix: o = i, value: a = "" } = ci(i), l = o === "circle";
  let c = " ";
  if (o === "polygon") {
    const u = oe(a || "0% 0%, 100% 0%, 100% 100%, 0% 100%");
    c = ",";
    const f = u.map((d) => {
      const [p, g] = d.split(" ");
      return {
        vertical: 1,
        horizontal: 1,
        pos: [K(p, t), K(g, n)]
      };
    }), h = ce(f.map((d) => d.pos));
    return {
      type: o,
      clipText: i,
      poses: f,
      splitter: c,
      left: h.minX,
      right: h.maxX,
      top: h.minY,
      bottom: h.maxY
    };
  } else if (l || o === "ellipse") {
    let u = "", f = "", h = 0, d = 0;
    const p = Jt(a);
    if (l) {
      let b = "";
      [b = "50%", , u = "50%", f = "50%"] = p, h = K(b, Math.sqrt((t * t + n * n) / 2)), d = h;
    } else {
      let b = "", S = "";
      [b = "50%", S = "50%", , u = "50%", f = "50%"] = p, h = K(b, t), d = K(S, n);
    }
    const g = [
      K(u, t),
      K(f, n)
    ], m = [
      {
        vertical: 1,
        horizontal: 1,
        pos: g,
        direction: "nesw"
      },
      ...pu.slice(0, l ? 1 : 2).map((b) => ({
        vertical: z(b[1]),
        horizontal: b[0],
        direction: b[2],
        sub: !0,
        pos: [g[0] + b[0] * h, g[1] + b[1] * d]
      }))
    ];
    return {
      type: o,
      clipText: i,
      radiusX: h,
      radiusY: d,
      left: g[0] - h,
      top: g[1] - d,
      right: g[0] + h,
      bottom: g[1] + d,
      poses: m,
      splitter: c
    };
  } else if (o === "inset") {
    const u = Jt(a || "0 0 0 0"), f = u.indexOf("round"), h = (f > -1 ? u.slice(0, f) : u).length, d = u.slice(h + 1), [p, g = p, m = p, b = g] = u.slice(0, h), [S, v] = [p, m].map((M) => K(M, n)), [E, x] = [b, g].map((M) => K(M, t)), w = t - x, D = n - v, C = $o(d, w - E, D - S, E, S), P = [
      ..._n(S, w, D, E),
      ...C
    ];
    return {
      type: "inset",
      clipText: i,
      poses: P,
      top: S,
      left: E,
      right: w,
      bottom: D,
      radius: d,
      splitter: c
    };
  } else if (o === "rect") {
    const u = oe(a || `0px, ${t}px, ${n}px, 0px`);
    c = ",";
    const [f, h, d, p] = u.map((m) => {
      const { value: b } = ae(m);
      return b;
    }), g = _n(f, h, d, p);
    return {
      type: "rect",
      clipText: i,
      poses: g,
      top: f,
      right: h,
      bottom: d,
      left: p,
      values: u,
      splitter: c
    };
  }
}
function mu(e, t, n, r, s) {
  const { direction: i, sub: o } = e[t], a = e.map(() => [0, 0]), l = i ? i.split("") : [];
  if (r && t < 8) {
    const c = l.filter((m) => m === "w" || m === "e"), u = l.filter((m) => m === "n" || m === "s"), f = c[0], h = u[0];
    a[t] = n;
    const [d, p] = ko(e), g = d && p ? d / p : 0;
    if (g && s) {
      const m = (t + 4) % 8, b = e[m].pos, S = [0, 0];
      i.indexOf("w") > -1 ? S[0] = -1 : i.indexOf("e") > -1 && (S[0] = 1), i.indexOf("n") > -1 ? S[1] = -1 : i.indexOf("s") > -1 && (S[1] = 1);
      const v = To([d, p], n, g, S, !0), E = d + v[0], x = p + v[1];
      let w = b[1], D = b[1], C = b[0], P = b[0];
      S[0] === -1 ? C = P - E : S[0] === 1 ? P = C + E : (C = C - E / 2, P = P + E / 2), S[1] === -1 ? w = D - x : (S[1] === 1 || (w = D - x / 2), D = w + x);
      const M = _n(w, P, D, C);
      e.forEach((y, T) => {
        a[T][0] = M[T].pos[0] - y.pos[0], a[T][1] = M[T].pos[1] - y.pos[1];
      });
    } else
      e.forEach((m, b) => {
        const { direction: S } = m;
        S && (S.indexOf(f) > -1 && (a[b][0] = n[0]), S.indexOf(h) > -1 && (a[b][1] = n[1]));
      }), f && (a[1][0] = n[0] / 2, a[5][0] = n[0] / 2), h && (a[3][1] = n[1] / 2, a[7][1] = n[1] / 2);
  } else i && !o ? l.forEach((c) => {
    const u = c === "n" || c === "s";
    e.forEach((f, h) => {
      const { direction: d, horizontal: p, vertical: g } = f;
      !d || d.indexOf(c) === -1 || (a[h] = [
        u || !p ? 0 : n[0],
        !u || !g ? 0 : n[1]
      ]);
    });
  }) : a[t] = n;
  return a;
}
function bu(e, t) {
  const [n, r] = Yi(e, t), { clipPath: s, clipIndex: i } = t.datas, { type: o, poses: a, splitter: l } = s, c = a.map((h) => h.pos);
  if (o === "polygon")
    c.splice(i, 0, [n, r]);
  else if (o === "inset") {
    const h = cu.indexOf(i), d = uu.indexOf(i), p = a.length;
    if (hu(a, c, 8, h, d, n, r, c[4][0], c[4][1], c[0][0], c[0][1]), p === a.length)
      return;
  } else
    return;
  const u = os(e, s, c), f = `${o}(${u.join(l)})`;
  Y(e, "onClip", U(e, t, {
    clipEventType: "added",
    clipType: o,
    poses: c,
    clipStyles: u,
    clipStyle: f,
    distX: 0,
    distY: 0,
    ...xt({
      clipPath: f
    }, t)
  }));
}
function vu(e, t) {
  const { clipPath: n, clipIndex: r } = t.datas, { type: s, poses: i, splitter: o } = n, a = i.map((f) => f.pos), l = a.length;
  if (s === "polygon")
    i.splice(r, 1), a.splice(r, 1);
  else if (s === "inset") {
    if (r < 8 || (fu(i, a, r, 8, l), l === i.length))
      return;
  } else
    return;
  const c = os(e, n, a), u = `${s}(${c.join(o)})`;
  Y(e, "onClip", U(e, t, {
    clipEventType: "removed",
    clipType: s,
    poses: a,
    clipStyles: c,
    clipStyle: u,
    distX: 0,
    distY: 0,
    ...xt({
      clipPath: u
    }, t)
  }));
}
const Su = {
  name: "clippable",
  props: [
    "clippable",
    "defaultClipPath",
    "customClipPath",
    "keepRatio",
    "clipRelative",
    "clipArea",
    "dragWithClip",
    "clipTargetBounds",
    "clipVerticalGuidelines",
    "clipHorizontalGuidelines",
    "clipSnapThreshold"
  ],
  events: ["clipStart", "clip", "clipEnd"],
  css: [
    `.control.clip-control {
background: #6d6;
cursor: pointer;
}
.control.clip-control.clip-radius {
background: #d66;
}
.line.clip-line {
background: #6e6;
cursor: move;
z-index: 1;
}
.clip-area {
position: absolute;
top: 0;
left: 0;
}
.clip-ellipse {
position: absolute;
cursor: move;
border: 1px solid #6d6;
border: var(--zoompx) solid #6d6;
border-radius: 50%;
transform-origin: 0px 0px;
}`,
    `:host {
--bounds-color: #d66;
}`,
    `.guideline {
pointer-events: none;
z-index: 2;
}`,
    `.line.guideline.bounds {
background: #d66;
background: var(--bounds-color);
}`
  ],
  render(e, t) {
    const { customClipPath: n, defaultClipPath: r, clipArea: s, zoom: i, groupable: o } = e.props, { target: a, width: l, height: c, allMatrix: u, is3d: f, left: h, top: d, pos1: p, pos2: g, pos3: m, pos4: b, clipPathState: S, snapBoundInfos: v, rotation: E } = e.getState();
    if (!a || o)
      return [];
    const x = Ws(a, l, c, r || "inset", S || n);
    if (!x)
      return [];
    const w = f ? 4 : 3, D = x.type, P = x.poses.map((I) => {
      const _ = ot(u, I.pos, w);
      return [_[0] - h, _[1] - d];
    });
    let M = [], y = [];
    const T = D === "rect", O = D === "inset", R = D === "polygon";
    if (T || O || R) {
      const I = O ? P.slice(0, 8) : P;
      y = I.map((_, A) => {
        const B = A === 0 ? I[I.length - 1] : I[A - 1], N = lt(B, _), G = xo(B, _);
        return Z("div", { className: L("line", "clip-line", "snap-control"), "data-clip-index": A, style: {
          width: `${G}px`,
          transform: `translate(${B[0]}px, ${B[1]}px) rotate(${N}rad) scaleY(${i})`
        } }, `clipLine${A}`);
      });
    }
    if (M = P.map((I, _) => Z("div", { className: L("control", "clip-control", "snap-control"), "data-clip-index": _, style: {
      transform: `translate(${I[0]}px, ${I[1]}px) rotate(${E}rad) scale(${i})`
    } }, `clipControl${_}`)), O && M.push(...P.slice(8).map((I, _) => Z("div", { className: L("control", "clip-control", "clip-radius", "snap-control"), "data-clip-index": 8 + _, style: {
      transform: `translate(${I[0]}px, ${I[1]}px) rotate(${E}rad) scale(${i})`
    } }, `clipRadiusControl${_}`))), D === "circle" || D === "ellipse") {
      const { left: I, top: _, radiusX: A, radiusY: B } = x, [N, G] = W(ot(u, [I, _], w), ot(u, [0, 0], w));
      let k = "none";
      if (!s) {
        const q = Math.max(10, A / 5, B / 5), j = [];
        for (let X = 0; X <= q; ++X) {
          const J = Math.PI * 2 / q * X;
          j.push([
            A + (A - i) * Math.cos(J),
            B + (B - i) * Math.sin(J)
          ]);
        }
        j.push([A, -2]), j.push([-2, -2]), j.push([-2, B * 2 + 2]), j.push([A * 2 + 2, B * 2 + 2]), j.push([A * 2 + 2, -2]), j.push([A, -2]), k = `polygon(${j.map((X) => `${X[0]}px ${X[1]}px`).join(", ")})`;
      }
      M.push(Z("div", { className: L("clip-ellipse", "snap-control"), style: {
        width: `${A * 2}px`,
        height: `${B * 2}px`,
        clipPath: k,
        transform: `translate(${-h + N}px, ${-d + G}px) ${Ln(u)}`
      } }, "clipEllipse"));
    }
    if (s) {
      const { width: I, height: _, left: A, top: B } = zt([p, g, m, b, ...P]);
      if (R || T || O) {
        const N = O ? P.slice(0, 8) : P;
        M.push(Z("div", { className: L("clip-area", "snap-control"), style: {
          width: `${I}px`,
          height: `${_}px`,
          transform: `translate(${A}px, ${B}px)`,
          clipPath: `polygon(${N.map((G) => `${G[0] - A}px ${G[1] - B}px`).join(", ")})`
        } }, "clipArea"));
      }
    }
    return v && ["vertical", "horizontal"].forEach((I) => {
      const _ = v[I], A = I === "horizontal";
      _.isSnap && y.push(..._.snap.posInfos.map(({ pos: B }, N) => {
        const G = W(ot(u, A ? [0, B] : [B, 0], w), [h, d]), k = W(ot(u, A ? [l, B] : [B, c], w), [h, d]);
        return qe(t, "", G, k, i, `clip${I}snap${N}`, "guideline");
      })), _.isBound && y.push(..._.bounds.map(({ pos: B }, N) => {
        const G = W(ot(u, A ? [0, B] : [B, 0], w), [h, d]), k = W(ot(u, A ? [l, B] : [B, c], w), [h, d]);
        return qe(t, "", G, k, i, `clip${I}bounds${N}`, "guideline", "bounds", "bold");
      }));
    }), [...M, ...y];
  },
  dragControlCondition(e, t) {
    return t.inputEvent && (t.inputEvent.target.getAttribute("class") || "").indexOf("clip") > -1;
  },
  dragStart(e, t) {
    const n = e.props, { dragWithClip: r = !0 } = n;
    return r ? !1 : this.dragControlStart(e, t);
  },
  drag(e, t) {
    return this.dragControl(e, { ...t, isDragTarget: !0 });
  },
  dragEnd(e, t) {
    return this.dragControlEnd(e, t);
  },
  dragControlStart(e, t) {
    const n = e.state, { defaultClipPath: r, customClipPath: s } = e.props, { target: i, width: o, height: a } = n, l = t.inputEvent ? t.inputEvent.target : null, c = l && l.getAttribute("class") || "", u = t.datas, f = Ws(i, o, a, r || "inset", s);
    if (!f)
      return !1;
    const { clipText: h, type: d, poses: p } = f;
    return Y(e, "onClipStart", U(e, t, {
      clipType: d,
      clipStyle: h,
      poses: p.map((m) => m.pos)
    })) === !1 ? (u.isClipStart = !1, !1) : (u.isControl = c && c.indexOf("clip-control") > -1, u.isLine = c.indexOf("clip-line") > -1, u.isArea = c.indexOf("clip-area") > -1 || c.indexOf("clip-ellipse") > -1, u.clipIndex = l ? parseInt(l.getAttribute("data-clip-index"), 10) : -1, u.clipPath = f, u.isClipStart = !0, n.clipPathState = h, pe(e, t), !0);
  },
  dragControl(e, t) {
    const { datas: n, originalDatas: r, isDragTarget: s } = t;
    if (!n.isClipStart)
      return !1;
    const { isControl: i, isLine: o, isArea: a, clipIndex: l, clipPath: c } = n;
    if (!c)
      return !1;
    const u = he(e.props, "clippable"), { keepRatio: f } = u;
    let h = 0, d = 0;
    const p = r.draggable, g = Wt(t);
    s && p ? [h, d] = p.prevBeforeDist : [h, d] = g;
    const m = [h, d], b = e.state, { width: S, height: v } = b, E = !a && !i && !o, { type: x, poses: w, splitter: D } = c, C = w.map(($) => $.pos);
    E && (h = -h, d = -d);
    const P = !i || w[l].direction === "nesw", M = x === "inset" || x === "rect";
    let y = w.map(() => [0, 0]);
    if (i && !P) {
      const { horizontal: $, vertical: F } = w[l], H = [h * z($), d * z(F)];
      y = mu(w, l, H, M, f);
    } else P && (y = C.map(() => [h, d]));
    const T = C.map(($, F) => Q($, y[F])), O = [...T];
    b.snapBoundInfos = null;
    const R = c.type === "circle", I = c.type === "ellipse";
    if (R || I) {
      const $ = zt(T), F = z($.bottom - $.top), H = z(I ? $.right - $.left : F), rt = T[0][1] + F, dt = T[0][0] - H, ct = T[0][0] + H;
      R && (O.push([ct, $.bottom]), y.push([1, 0])), O.push([$.left, rt]), y.push([0, 1]), O.push([dt, $.bottom]), y.push([1, 0]);
    }
    const _ = po((u.clipHorizontalGuidelines || []).map(($) => K(`${$}`, v)), (u.clipVerticalGuidelines || []).map(($) => K(`${$}`, S)), S, v);
    let A = [], B = [];
    if (R || I)
      A = [O[4][0], O[2][0]], B = [O[1][1], O[3][1]];
    else if (M) {
      const $ = [
        O[0],
        O[2],
        O[4],
        O[6]
      ], F = [y[0], y[2], y[4], y[6]];
      A = $.filter((H, rt) => F[rt][0]).map((H) => H[0]), B = $.filter((H, rt) => F[rt][1]).map((H) => H[1]);
    } else
      A = O.filter(($, F) => y[F][0]).map(($) => $[0]), B = O.filter(($, F) => y[F][1]).map(($) => $[1]);
    const N = [0, 0], { horizontal: G, vertical: k } = Ms(_, u.clipTargetBounds && {
      left: 0,
      top: 0,
      right: S,
      bottom: v
    }, A, B, 5, 5);
    let q = G.offset, j = k.offset;
    if (G.isBound && (N[1] += q), k.isBound && (N[0] += j), (I || R) && y[0][0] === 0 && y[0][1] === 0) {
      const $ = zt(T);
      let F = $.bottom - $.top, H = I ? $.right - $.left : F;
      const rt = k.isBound ? z(j) : k.snapIndex === 0 ? -j : j, dt = G.isBound ? z(q) : G.snapIndex === 0 ? -q : q;
      H -= rt, F -= dt, R && (F = io(k, G) > 0 ? F : H, H = F);
      const ct = O[0];
      O[1][1] = ct[1] - F, O[2][0] = ct[0] + H, O[3][1] = ct[1] + F, O[4][0] = ct[0] - H;
    } else if (M && f && i) {
      const [$, F] = ko(w), H = $ && F ? $ / F : 0, dt = w[l].direction || "";
      let ct = O[1][1], st = O[5][1], Nt = O[7][0], ut = O[3][0];
      z(q) <= z(j) ? q = St(q) * z(j) / H : j = St(j) * z(q) * H, dt.indexOf("w") > -1 ? Nt -= j : dt.indexOf("e") > -1 ? ut -= j : (Nt += j / 2, ut -= j / 2), dt.indexOf("n") > -1 ? ct -= q : dt.indexOf("s") > -1 ? st -= q : (ct += q / 2, st -= q / 2);
      const gt = _n(ct, ut, st, Nt);
      O.forEach((Xt, en) => {
        [Xt[0], Xt[1]] = gt[en].pos;
      });
    } else
      O.forEach(($, F) => {
        const H = y[F];
        H[0] && ($[0] -= j), H[1] && ($[1] -= q);
      });
    const X = os(e, c, T), J = `${x}(${X.join(D)})`;
    if (b.clipPathState = J, R || I)
      A = [O[4][0], O[2][0]], B = [O[1][1], O[3][1]];
    else if (M) {
      const $ = [
        O[0],
        O[2],
        O[4],
        O[6]
      ];
      A = $.map((F) => F[0]), B = $.map((F) => F[1]);
    } else
      A = O.map(($) => $[0]), B = O.map(($) => $[1]);
    if (b.snapBoundInfos = Ms(_, u.clipTargetBounds && {
      left: 0,
      top: 0,
      right: S,
      bottom: v
    }, A, B, 1, 1), p) {
      const { is3d: $, allMatrix: F } = b, H = $ ? 4 : 3;
      let rt = N;
      s && (rt = [
        m[0] + N[0] - g[0],
        m[1] + N[1] - g[1]
      ]), p.deltaOffset = tt(F, [rt[0], rt[1], 0, 0], H);
    }
    return Y(e, "onClip", U(e, t, {
      clipEventType: "changed",
      clipType: x,
      poses: T,
      clipStyle: J,
      clipStyles: X,
      distX: h,
      distY: d,
      ...xt({
        [x === "rect" ? "clip" : "clipPath"]: J
      }, t)
    })), !0;
  },
  dragControlEnd(e, t) {
    this.unset(e);
    const { isDrag: n, datas: r, isDouble: s } = t, { isLine: i, isClipStart: o, isControl: a } = r;
    return o ? (Y(e, "onClipEnd", Mt(e, t, {})), s && (a ? vu(e, t) : i && bu(e, t)), s || n) : !1;
  },
  unset(e) {
    e.state.clipPathState = "", e.state.snapBoundInfos = null;
  }
}, xu = {
  name: "originDraggable",
  props: ["originDraggable", "originRelative"],
  events: ["dragOriginStart", "dragOrigin", "dragOriginEnd"],
  css: [
    `:host[data-able-origindraggable] .control.origin {
pointer-events: auto;
}`
  ],
  dragControlCondition(e, t) {
    return t.isRequest ? t.requestAble === "originDraggable" : ht(t.inputEvent.target, L("origin"));
  },
  dragControlStart(e, t) {
    const { datas: n } = t;
    pe(e, t);
    const r = U(e, t, {
      dragStart: vt.dragStart(e, new Me().dragStart([0, 0], t))
    }), s = Y(e, "onDragOriginStart", r);
    return n.startOrigin = e.state.transformOrigin, n.startTargetOrigin = e.state.targetOrigin, n.prevOrigin = [0, 0], n.isDragOrigin = !0, s === !1 ? (n.isDragOrigin = !1, !1) : r;
  },
  dragControl(e, t) {
    const { datas: n, isPinch: r, isRequest: s } = t;
    if (!n.isDragOrigin)
      return !1;
    const [i, o] = Wt(t), a = e.state, { width: l, height: c, offsetMatrix: u, targetMatrix: f, is3d: h } = a, { originRelative: d = !0 } = e.props, p = h ? 4 : 3;
    let g = [i, o];
    if (s) {
      const M = t.distOrigin;
      (M[0] || M[1]) && (g = M);
    }
    const m = Q(n.startOrigin, g), b = Q(n.startTargetOrigin, g), S = W(g, n.prevOrigin), v = tn(u, f, m, p), E = e.getRect(), x = zt(ge(v, l, c, p)), w = [E.left - x.left, E.top - x.top];
    n.prevOrigin = g;
    const D = [
      At(b[0], l, d),
      At(b[1], c, d)
    ].join(" "), C = vt.drag(e, Qe(t, e.state, w, !!r)), P = U(e, t, {
      width: l,
      height: c,
      origin: m,
      dist: g,
      delta: S,
      transformOrigin: D,
      drag: C,
      ...xt({
        transformOrigin: D,
        transform: C.transform
      }, t),
      afterTransform: C.transform
    });
    return Y(e, "onDragOrigin", P), P;
  },
  dragControlEnd(e, t) {
    const { datas: n } = t;
    return n.isDragOrigin ? (Y(e, "onDragOriginEnd", Mt(e, t, {})), !0) : !1;
  },
  dragGroupControlCondition(e, t) {
    return this.dragControlCondition(e, t);
  },
  dragGroupControlStart(e, t) {
    return !!this.dragControlStart(e, t);
  },
  dragGroupControl(e, t) {
    const n = this.dragControl(e, t);
    return n ? (e.transformOrigin = n.transformOrigin, !0) : !1;
  },
  /**
      * @method Moveable.OriginDraggable#request
      * @param {object} e - the OriginDraggable's request parameter
      * @param {number} [e.x] - x position
      * @param {number} [e.y] - y position
      * @param {number} [e.deltaX] - x number to move
      * @param {number} [e.deltaY] - y number to move
      * @param {array} [e.deltaOrigin] - left, top number to move transform-origin
      * @param {array} [e.origin] - transform-origin position
      * @param {number} [e.isInstant] - Whether to execute the request instantly
      * @return {Moveable.Requester} Moveable Requester
      * @example
  
      * // Instantly Request (requestStart - request - requestEnd)
      * // Use Relative Value
      * moveable.request("originDraggable", { deltaX: 10, deltaY: 10 }, true);
      * // Use Absolute Value
      * moveable.request("originDraggable", { x: 200, y: 100 }, true);
      * // Use Transform Value
      * moveable.request("originDraggable", { deltaOrigin: [10, 0] }, true);
      * moveable.request("originDraggable", { origin: [100, 0] }, true);
      * // requestStart
      * const requester = moveable.request("originDraggable");
      *
      * // request
      * // Use Relative Value
      * requester.request({ deltaX: 10, deltaY: 10 });
      * requester.request({ deltaX: 10, deltaY: 10 });
      * requester.request({ deltaX: 10, deltaY: 10 });
      * // Use Absolute Value
      * moveable.request("originDraggable", { x: 200, y: 100 });
      * moveable.request("originDraggable", { x: 220, y: 100 });
      * moveable.request("originDraggable", { x: 240, y: 100 });
      *
      * // requestEnd
      * requester.requestEnd();
      */
  request(e) {
    const t = {}, n = e.getRect();
    let r = 0, s = 0;
    const i = n.transformOrigin, o = [0, 0];
    return {
      isControl: !0,
      requestStart() {
        return { datas: t };
      },
      request(a) {
        return "deltaOrigin" in a ? (o[0] += a.deltaOrigin[0], o[1] += a.deltaOrigin[1]) : "origin" in a ? (o[0] = a.origin[0] - i[0], o[1] = a.origin[1] - i[1]) : ("x" in a ? r = a.x - n.left : "deltaX" in a && (r += a.deltaX), "y" in a ? s = a.y - n.top : "deltaY" in a && (s += a.deltaY)), { datas: t, distX: r, distY: s, distOrigin: o };
      },
      requestEnd() {
        return { datas: t, isDrag: !0 };
      }
    };
  }
};
function Eu(e, t, n, r) {
  const s = e.filter(({ virtual: l, horizontal: c }) => c && !l).length, i = e.filter(({ virtual: l, vertical: c }) => c && !l).length;
  let o = -1;
  if (t === 0 && (s === 0 ? o = 0 : s === 1 && (o = 1)), t === 2 && (s <= 2 ? o = 2 : s <= 3 && (o = 3)), t === 3 && (i === 0 ? o = 4 : i < 4 && (o = 7)), t === 1 && (i <= 1 ? o = 5 : i <= 2 && (o = 6)), o === -1 || !e[o].virtual)
    return;
  const a = e[o];
  wu(e, o), o < 4 ? a.pos[0] = n : a.pos[1] = r;
}
function wu(e, t) {
  t < 4 ? e.slice(0, t + 1).forEach((n) => {
    n.virtual = !1;
  }) : (e[0].virtual && (e[0].virtual = !1), e.slice(4, t + 1).forEach((n) => {
    n.virtual = !1;
  }));
}
function Cu(e, t) {
  t < 4 ? e.slice(t, 4).forEach((n) => {
    n.virtual = !0;
  }) : e.slice(t).forEach((n) => {
    n.virtual = !0;
  });
}
function Ns(e, t, n, r = [0, 0], s) {
  let i = [];
  return !e || e === "0px" ? i = [] : i = Jt(e), $o(i, t, n, 0, 0, r, s);
}
function Hs(e, t, n, r, s) {
  const i = e.state, { width: o, height: a } = i, { raws: l, styles: c, radiusPoses: u } = is(s, e.props.roundRelative, o, a), { horizontals: f, verticals: h } = du(u, l), d = c.join(" ");
  i.borderRadiusState = d;
  const p = U(e, t, {
    horizontals: f,
    verticals: h,
    borderRadius: d,
    width: o,
    height: a,
    delta: r,
    dist: n,
    ...xt({
      borderRadius: d
    }, t)
  });
  return Y(e, "onRound", p), p;
}
function Vs(e) {
  var r;
  const { style: t } = e.getState();
  let n = t.borderRadius || "";
  if (!n && e.props.groupable) {
    const s = e.moveables[0], i = e.getTargets()[0];
    i && ((s == null ? void 0 : s.props.target) === i ? (n = ((r = e.moveables[0]) == null ? void 0 : r.state.style.borderRadius) ?? "", t.borderRadius = n) : (n = ts(i).borderRadius, t.borderRadius = n));
  }
  return n;
}
const yu = {
  name: "roundable",
  props: [
    "roundable",
    "roundRelative",
    "minRoundControls",
    "maxRoundControls",
    "roundClickable",
    "roundPadding",
    "isDisplayShadowRoundControls"
  ],
  events: [
    "roundStart",
    "round",
    "roundEnd",
    "roundGroupStart",
    "roundGroup",
    "roundGroupEnd"
  ],
  css: [
    `.control.border-radius {
background: #d66;
cursor: pointer;
z-index: 3;
}`,
    `.control.border-radius.vertical {
background: #d6d;
z-index: 2;
}`,
    `.control.border-radius.virtual {
opacity: 0.5;
z-index: 1;
}`,
    `:host.round-line-clickable .line.direction {
cursor: pointer;
}`
  ],
  className(e) {
    const t = e.props.roundClickable;
    return t === !0 || t === "line" ? L("round-line-clickable") : "";
  },
  requestStyle() {
    return ["borderRadius"];
  },
  requestChildStyle() {
    return ["borderRadius"];
  },
  render(e, t) {
    const { target: n, width: r, height: s, allMatrix: i, is3d: o, left: a, top: l, borderRadiusState: c } = e.getState(), { minRoundControls: u = [0, 0], maxRoundControls: f = [4, 4], zoom: h, roundPadding: d = 0, isDisplayShadowRoundControls: p, groupable: g } = e.props;
    if (!n)
      return null;
    const m = c || Vs(e), b = o ? 4 : 3, S = Ns(m, r, s, u, !0);
    if (!S)
      return null;
    let v = 0, E = 0;
    const x = g ? [0, 0] : [a, l];
    return S.map((w, D) => {
      const C = w.horizontal, P = w.vertical, M = w.direction || "", y = [...w.pos];
      E += Math.abs(C), v += Math.abs(P), C && M.indexOf("n") > -1 && (y[1] -= d), P && M.indexOf("w") > -1 && (y[0] -= d), C && M.indexOf("s") > -1 && (y[1] += d), P && M.indexOf("e") > -1 && (y[0] += d);
      const T = W(ot(i, y, b), x), O = p && p !== "horizontal", R = w.vertical ? v <= f[1] && (O || !w.virtual) : E <= f[0] && (p || !w.virtual);
      return Z("div", { className: L("control", "border-radius", w.vertical ? "vertical" : "", w.virtual ? "virtual" : ""), "data-radius-index": D, style: {
        display: R ? "block" : "none",
        transform: `translate(${T[0]}px, ${T[1]}px) scale(${h})`
      } }, `borderRadiusControl${D}`);
    });
  },
  dragControlCondition(e, t) {
    if (!t.inputEvent || t.isRequest)
      return !1;
    const n = t.inputEvent.target.getAttribute("class") || "";
    return n.indexOf("border-radius") > -1 || n.indexOf("moveable-line") > -1 && n.indexOf("moveable-direction") > -1;
  },
  dragGroupControlCondition(e, t) {
    return this.dragControlCondition(e, t);
  },
  dragControlStart(e, t) {
    const { inputEvent: n, datas: r } = t, s = n.target, i = s.getAttribute("class") || "", o = i.indexOf("border-radius") > -1, a = i.indexOf("moveable-line") > -1 && i.indexOf("moveable-direction") > -1, l = o ? parseInt(s.getAttribute("data-radius-index"), 10) : -1;
    let c = -1;
    if (a) {
      const v = s.getAttribute("data-line-key") || "";
      v && (c = parseInt(v.replace(/render-line-/g, ""), 10), isNaN(c) && (c = -1));
    }
    if (!o && !a)
      return !1;
    const u = U(e, t, {});
    if (Y(e, "onRoundStart", u) === !1)
      return !1;
    r.lineIndex = c, r.controlIndex = l, r.isControl = o, r.isLine = a, pe(e, t);
    const { roundRelative: h, minRoundControls: d = [0, 0] } = e.props, p = e.state, { width: g, height: m } = p;
    r.isRound = !0, r.prevDist = [0, 0];
    const b = Vs(e), S = Ns(b || "", g, m, d, !0) || [];
    return r.controlPoses = S, p.borderRadiusState = is(S, h, g, m).styles.join(" "), u;
  },
  dragControl(e, t) {
    const { datas: n } = t, r = n.controlPoses;
    if (!n.isRound || !n.isControl || !r.length)
      return !1;
    const s = n.controlIndex, [i, o] = Wt(t), a = [i, o], l = W(a, n.prevDist), { maxRoundControls: c = [4, 4] } = e.props, { width: u, height: f } = e.state, h = r[s], d = h.vertical, p = h.horizontal, g = r.map((b) => {
      const { horizontal: S, vertical: v } = b, E = [
        S * p * a[0],
        v * d * a[1]
      ];
      if (S) {
        if (c[0] === 1)
          return E;
        if (c[0] < 4 && S !== p)
          return E;
      } else {
        if (c[1] === 0)
          return E[1] = v * p * a[0] / u * f, E;
        if (d) {
          if (c[1] === 1)
            return E;
          if (c[1] < 4 && v !== d)
            return E;
        }
      }
      return [0, 0];
    });
    g[s] = a;
    const m = r.map((b, S) => ({
      ...b,
      pos: Q(b.pos, g[S])
    }));
    return s < 4 ? m.slice(0, s + 1).forEach((b) => {
      b.virtual = !1;
    }) : m.slice(4, s + 1).forEach((b) => {
      b.virtual = !1;
    }), n.prevDist = [i, o], Hs(e, t, a, l, m);
  },
  dragControlEnd(e, t) {
    const n = e.state;
    n.borderRadiusState = "";
    const { datas: r, isDouble: s } = t;
    if (!r.isRound)
      return !1;
    const { isControl: i, controlIndex: o, isLine: a, lineIndex: l } = r, c = r.controlPoses, u = c.filter(({ virtual: d }) => d).length, { roundClickable: f = !0 } = e.props;
    if (s && f) {
      if (i && (f === !0 || f === "control"))
        Cu(c, o);
      else if (a && (f === !0 || f === "line")) {
        const [d, p] = Yi(e, t);
        Eu(c, l, d, p);
      }
      u !== c.filter(({ virtual: d }) => d).length && Hs(e, t, [0, 0], [0, 0], c);
    }
    const h = Mt(e, t, {});
    return Y(e, "onRoundEnd", h), n.borderRadiusState = "", h;
  },
  dragGroupControlStart(e, t) {
    const n = this.dragControlStart(e, t);
    if (!n)
      return !1;
    const r = e.moveables, s = e.props.targets, i = Gt(e, "roundable", t), o = {
      targets: e.props.targets,
      events: i.map((a, l) => ({
        ...a,
        target: s[l],
        moveable: r[l],
        currentTarget: r[l]
      })),
      ...n
    };
    return Y(e, "onRoundGroupStart", o), n;
  },
  dragGroupControl(e, t) {
    const n = this.dragControl(e, t);
    if (!n)
      return !1;
    const r = e.moveables, s = e.props.targets, i = Gt(e, "roundable", t), o = {
      targets: e.props.targets,
      events: i.map((a, l) => ({
        ...a,
        target: s[l],
        moveable: r[l],
        currentTarget: r[l],
        ...xt({
          borderRadius: n.borderRadius
        }, a)
      })),
      ...n
    };
    return Y(e, "onRoundGroup", o), o;
  },
  dragGroupControlEnd(e, t) {
    const n = e.moveables, r = e.props.targets, s = Gt(e, "roundable", t);
    Wn(e, "onRound", (a) => {
      const l = {
        targets: e.props.targets,
        events: s.map((c, u) => ({
          ...c,
          target: r[u],
          moveable: n[u],
          currentTarget: n[u],
          ...xt({
            borderRadius: a.borderRadius
          }, c)
        })),
        ...a
      };
      Y(e, "onRoundGroup", l);
    });
    const i = this.dragControlEnd(e, t);
    if (!i)
      return !1;
    const o = {
      targets: e.props.targets,
      events: s.map((a, l) => {
        var c;
        return {
          ...a,
          target: r[l],
          moveable: n[l],
          currentTarget: n[l],
          lastEvent: (c = a.datas) == null ? void 0 : c.lastEvent
        };
      }),
      ...i
    };
    return Y(e, "onRoundGroupEnd", o), o;
  },
  unset(e) {
    e.state.borderRadiusState = "";
  }
};
function Pu(e, t) {
  const r = nt(t ? 4 : 3), s = `matrix${t ? "3d" : ""}(${r.join(",")})`;
  return e === s || e === "matrix(1,0,0,1,0,0)";
}
const jo = {
  isPinch: !0,
  name: "beforeRenderable",
  props: [],
  events: [
    "beforeRenderStart",
    "beforeRender",
    "beforeRenderEnd",
    "beforeRenderGroupStart",
    "beforeRenderGroup",
    "beforeRenderGroupEnd"
  ],
  dragRelation: "weak",
  setTransform(e, t) {
    const { is3d: n, targetMatrix: r, inlineTransform: s } = e.state, i = n ? `matrix3d(${r.join(",")})` : `matrix(${wi(r, !0)})`, o = !s || s === "none" ? i : s;
    t.datas.startTransforms = Pu(o, n) ? [] : Jt(o);
  },
  resetStyle(e) {
    const t = e.datas;
    t.nextStyle = {}, t.nextTransforms = e.datas.startTransforms, t.nextTransformAppendedIndexes = [];
  },
  fillDragStartParams(e, t) {
    return U(e, t, {
      setTransform: (n) => {
        t.datas.startTransforms = at(n) ? n : Jt(n);
      },
      isPinch: !!t.isPinch
    });
  },
  fillDragParams(e, t) {
    return U(e, t, {
      isPinch: !!t.isPinch
    });
  },
  dragStart(e, t) {
    this.setTransform(e, t), this.resetStyle(t), Y(e, "onBeforeRenderStart", this.fillDragStartParams(e, t));
  },
  drag(e, t) {
    t.datas.startTransforms || this.setTransform(e, t), this.resetStyle(t), Y(e, "onBeforeRender", U(e, t, {
      isPinch: !!t.isPinch
    }));
  },
  dragEnd(e, t) {
    t.datas.startTransforms || (this.setTransform(e, t), this.resetStyle(t)), Y(e, "onBeforeRenderEnd", U(e, t, {
      isPinch: !!t.isPinch,
      isDrag: t.isDrag
    }));
  },
  dragGroupStart(e, t) {
    this.dragStart(e, t);
    const n = Gt(e, "beforeRenderable", t), r = e.moveables, s = n.map((i, o) => {
      const a = r[o];
      return this.setTransform(a, i), this.resetStyle(i), this.fillDragStartParams(a, i);
    });
    Y(e, "onBeforeRenderGroupStart", U(e, t, {
      isPinch: !!t.isPinch,
      targets: e.props.targets,
      setTransform() {
      },
      events: s
    }));
  },
  dragGroup(e, t) {
    this.drag(e, t);
    const n = Gt(e, "beforeRenderable", t), r = e.moveables, s = n.map((i, o) => {
      const a = r[o];
      return this.resetStyle(i), this.fillDragParams(a, i);
    });
    Y(e, "onBeforeRenderGroup", U(e, t, {
      isPinch: !!t.isPinch,
      targets: e.props.targets,
      events: s
    }));
  },
  dragGroupEnd(e, t) {
    this.dragEnd(e, t), Y(e, "onBeforeRenderGroupEnd", U(e, t, {
      isPinch: !!t.isPinch,
      isDrag: t.isDrag,
      targets: e.props.targets
    }));
  },
  dragControlStart(e, t) {
    return this.dragStart(e, t);
  },
  dragControl(e, t) {
    return this.drag(e, t);
  },
  dragControlEnd(e, t) {
    return this.dragEnd(e, t);
  },
  dragGroupControlStart(e, t) {
    return this.dragGroupStart(e, t);
  },
  dragGroupControl(e, t) {
    return this.dragGroup(e, t);
  },
  dragGroupControlEnd(e, t) {
    return this.dragGroupEnd(e, t);
  }
}, Xo = {
  name: "renderable",
  props: [],
  events: [
    "renderStart",
    "render",
    "renderEnd",
    "renderGroupStart",
    "renderGroup",
    "renderGroupEnd"
  ],
  dragRelation: "weak",
  dragStart(e, t) {
    Y(e, "onRenderStart", U(e, t, {
      isPinch: !!t.isPinch
    }));
  },
  drag(e, t) {
    Y(e, "onRender", this.fillDragParams(e, t));
  },
  dragAfter(e, t) {
    return this.drag(e, t);
  },
  dragEnd(e, t) {
    Y(e, "onRenderEnd", this.fillDragEndParams(e, t));
  },
  dragGroupStart(e, t) {
    Y(e, "onRenderGroupStart", U(e, t, {
      isPinch: !!t.isPinch,
      targets: e.props.targets
    }));
  },
  dragGroup(e, t) {
    const n = Gt(e, "beforeRenderable", t), r = e.moveables, s = n.map((i, o) => {
      const a = r[o];
      return this.fillDragParams(a, i);
    });
    Y(e, "onRenderGroup", U(e, t, {
      isPinch: !!t.isPinch,
      targets: e.props.targets,
      transform: un(t),
      transformObject: {},
      ...xt(fn(t)),
      events: s
    }));
  },
  dragGroupEnd(e, t) {
    const n = Gt(e, "beforeRenderable", t), r = e.moveables, s = n.map((i, o) => {
      const a = r[o];
      return this.fillDragEndParams(a, i);
    });
    Y(e, "onRenderGroupEnd", U(e, t, {
      isPinch: !!t.isPinch,
      isDrag: t.isDrag,
      targets: e.props.targets,
      events: s,
      transformObject: {},
      transform: un(t),
      ...xt(fn(t))
    }));
  },
  dragControlStart(e, t) {
    return this.dragStart(e, t);
  },
  dragControl(e, t) {
    return this.drag(e, t);
  },
  dragControlAfter(e, t) {
    return this.dragAfter(e, t);
  },
  dragControlEnd(e, t) {
    return this.dragEnd(e, t);
  },
  dragGroupControlStart(e, t) {
    return this.dragGroupStart(e, t);
  },
  dragGroupControl(e, t) {
    return this.dragGroup(e, t);
  },
  dragGroupControlEnd(e, t) {
    return this.dragGroupEnd(e, t);
  },
  fillDragParams(e, t) {
    const n = {};
    return Oe(Pn(t) || []).forEach((r) => {
      n[r.name] = r.functionValue;
    }), U(e, t, {
      isPinch: !!t.isPinch,
      transformObject: n,
      transform: un(t),
      ...xt(fn(t))
    });
  },
  fillDragEndParams(e, t) {
    const n = {};
    return Oe(Pn(t) || []).forEach((r) => {
      n[r.name] = r.functionValue;
    }), U(e, t, {
      isPinch: !!t.isPinch,
      isDrag: t.isDrag,
      transformObject: n,
      transform: un(t),
      ...xt(fn(t))
    });
  }
};
function Ne(e, t, n, r, s, i, o) {
  i.clientDistX = i.distX, i.clientDistY = i.distY;
  const a = s === "Start", l = s === "End", c = s === "After", u = e.state.target, f = i.isRequest, h = r.indexOf("Control") > -1;
  if (!u || a && h && !f && e.areaElement === i.inputEvent.target)
    return !1;
  const d = [...t];
  if (f) {
    const M = i.requestAble;
    d.some((y) => y.name === M) || d.push(...e.props.ables.filter((y) => y.name === M));
  }
  if (!d.length || d.every((M) => M.dragRelation))
    return !1;
  const p = i.inputEvent;
  let g;
  l && p && (g = document.elementFromPoint(i.clientX, i.clientY) || p.target);
  let m = !1;
  const b = () => {
    var M;
    m = !0, (M = i.stop) == null || M.call(i);
  }, S = a && (!e.targetGesto || !e.controlGesto || !e.targetGesto.isFlag() || !e.controlGesto.isFlag());
  S && e.updateRect(s, !0, !1);
  const v = i.datas, E = h ? "controlGesto" : "targetGesto", x = e[E], w = (M, y, T) => {
    if (!(y in M) || x !== e[E])
      return !1;
    const O = M.name, R = v[O] || (v[O] = {});
    if (a && (R.isEventStart = !T || !M[T] || M[T](e, i)), !R.isEventStart)
      return !1;
    const I = M[y](e, {
      ...i,
      stop: b,
      datas: R,
      originalDatas: v,
      inputTarget: g
    });
    return e._emitter.off(), a && I === !1 && (R.isEventStart = !1), I;
  };
  S && d.forEach((M) => {
    M.unset && M.unset(e);
  }), w(jo, `drag${r}${s}`);
  let D = 0, C = 0;
  n.forEach((M) => {
    if (m)
      return !1;
    const y = `${M}${r}${s}`, T = `${M}${r}Condition`;
    s === "" && !f && qc(e.state, i);
    let O = d.filter((_) => _[y]);
    O = O.filter((_, A) => _.name && O.indexOf(_) === A);
    const I = O.filter((_) => w(_, y, T)).length;
    m && ++D, I && ++C, !m && a && O.length && !I && (D += O.filter((_) => {
      const A = _.name;
      return v[A].isEventStart ? _.dragRelation !== "strong" : !1;
    }).length ? 1 : 0);
  }), (!c || C) && w(Xo, `drag${r}${s}`);
  const P = x !== e[E] || D === n.length;
  return (l || m || P) && (e.state.gestos = {}, e.moveables && e.moveables.forEach((M) => {
    M.state.gestos = {};
  }), d.forEach((M) => {
    M.unset && M.unset(e);
  })), a && !P && !f && C && e.props.preventDefault && (i == null || i.preventDefault()), e.isUnmounted || P ? !1 : ((!a && C && !o || l) && (e.props.flushSync || bo)(() => {
    e.updateRect(l ? s : "", !0, !1), e.forceUpdate();
  }), !a && !l && !c && C && !o && Ne(e, t, n, r, s + "After", i), !0);
}
function as(e, t) {
  return (n, r = n.inputEvent.target) => {
    var a;
    const s = r, i = e.areaElement, o = e._dragTarget;
    return !o || !t && ((a = e.controlGesto) != null && a.isFlag()) ? !1 : s === o || o.contains(s) || s === i || !e.isMoveableElement(s) && !e.controlBox.contains(s) || ht(s, "moveable-area") || ht(s, "moveable-padding") || ht(s, "moveable-edgeDraggable");
  };
}
function Yo(e, t, n) {
  const r = e.controlBox, s = [], i = e.props, o = i.dragArea, a = e.state.target, l = i.dragTarget;
  s.push(r), (!o || l) && s.push(t), !o && l && a && t !== a && i.dragTargetSelf && s.push(a);
  const c = as(e);
  return Lo(e, s, "targetAbles", n, {
    dragStart: c,
    pinchStart: c
  });
}
function Fo(e, t) {
  const n = e.controlBox, r = [];
  r.push(n);
  const s = as(e, !0), i = (o, a = o.inputEvent.target) => a === n ? !0 : !s(o, a);
  return Lo(e, r, "controlAbles", t, {
    dragStart: i,
    pinchStart: i
  });
}
function Lo(e, t, n, r, s = {}) {
  const i = n === "targetAbles", { pinchOutside: o, pinchThreshold: a, preventClickEventOnDrag: l, preventClickDefault: c, checkInput: u, dragFocusedInput: f, preventDefault: h = !0, preventRightClick: d = !0, preventWheelClick: p = !0, dragContainer: g } = e.props, m = Lt(g, !0), b = {
    preventDefault: h,
    preventRightClick: d,
    preventWheelClick: p,
    container: m || yt(e.getControlBoxElement()),
    pinchThreshold: a,
    pinchOutside: o,
    preventClickEventOnDrag: i ? l : !1,
    preventClickEventOnDragStart: i ? c : !1,
    preventClickEventByCondition: i ? null : (E) => e.controlBox.contains(E.target),
    checkInput: i ? u : !1,
    dragFocusedInput: f
  }, S = new Bn(t, b), v = r === "Control";
  return ["drag", "pinch"].forEach((E) => {
    ["Start", "", "End"].forEach((x) => {
      S.on(`${E}${x}`, (w) => {
        var T;
        const D = w.eventType, C = E === "drag" && w.isPinch;
        if (s[D] && !s[D](w)) {
          w.stop();
          return;
        }
        if (C)
          return;
        const P = E === "drag" ? [E] : ["drag", E], M = [...e[n]];
        Ne(e, M, P, r, x, w) ? (e.props.stopPropagation || x === "Start" && v) && ((T = w == null ? void 0 : w.inputEvent) == null || T.stopPropagation()) : w.stop();
      });
    });
  }), S;
}
class Du {
  constructor(t, n, r) {
    Object.defineProperty(this, "target", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "moveable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "eventName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "ables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_onEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        const i = this.eventName, o = this.moveable;
        o.state.disableNativeEvent || this.ables.forEach((a) => {
          a[i](o, {
            inputEvent: s
          });
        });
      }
    }), t.addEventListener(r.toLowerCase(), this._onEvent);
  }
  setAbles(t) {
    this.ables = t;
  }
  destroy() {
    this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent), this.target = null, this.moveable = null;
  }
}
function Wo(e, t) {
  const n = kr(t), r = n.className;
  return ia((s, i) => {
    const { className: o = "", cspNonce: a, ...l } = s, c = oa(null);
    return aa(i, () => c.current, []), la(() => {
      const u = n.inject(c.current, {
        nonce: s.cspNonce
      });
      return () => {
        u.destroy();
      };
    }, []), Mr(e, {
      ref: c,
      "data-styled-id": r,
      className: `${o} ${r}`,
      ...l
    });
  });
}
function Ou(e, t, n = t, r) {
  var _;
  const { matrixes: s, is3d: i, targetMatrix: o, transformOrigin: a, targetOrigin: l, offsetContainer: c, hasFixed: u, zoom: f } = Vi(e, t), { matrixes: h, is3d: d, offsetContainer: p, zoom: g } = Yl(c, n), m = r, b = 4, S = e.tagName.toLowerCase() !== "svg" && "ownerSVGElement" in e;
  let v = o, E = nt(b), x = nt(b), w = nt(b), D = nt(b);
  const C = s.length, P = h.map((A) => ({
    ...A,
    matrix: A.matrix ? [...A.matrix] : void 0
  })).reverse();
  s.reverse(), !i && m && (v = kt(v, 3, 4), wr(s)), !d && m && wr(P), P.forEach((A) => {
    x = tt(x, A.matrix, b);
  });
  const M = n || ee(e), y = ((_ = P[0]) == null ? void 0 : _.target) || Ue(M, M, !0).offsetParent, T = P.slice(1).reduce((A, B) => tt(A, B.matrix, b), nt(b));
  s.forEach((A, B) => {
    if (C - 2 === B && (w = E.slice()), C - 1 === B && (D = E.slice()), !A.matrix) {
      const N = s[B + 1], G = Wc(A, N, y, b, tt(T, E, b));
      A.matrix = fe(G, b);
    }
    E = tt(E, A.matrix, b);
  });
  const O = !S && i;
  v || (v = nt(O ? 4 : 3));
  const R = Ln(S && v.length === 16 ? kt(v, 4, 3) : v, O), I = x;
  return x = xi(x, b, b), {
    hasZoom: f !== 1 || g !== 1,
    hasFixed: u,
    matrixes: s,
    rootMatrix: x,
    originalRootMatrix: I,
    beforeMatrix: w,
    offsetMatrix: D,
    allMatrix: E,
    targetMatrix: v,
    targetTransform: R,
    inlineTransform: e.style.transform,
    transformOrigin: a,
    targetOrigin: l,
    is3d: m,
    offsetContainer: c,
    offsetRootContainer: p
  };
}
function Mu(e, t, n = t, r) {
  let s = 0, i = 0, o = 0, a = {};
  const l = Eo(e);
  if (e && (s = l.offsetWidth, i = l.offsetHeight), e) {
    const u = Ou(
      e,
      t,
      n,
      r
      // prevMatrix, prevRootMatrix, prevN,
    ), f = ye(u.allMatrix, u.transformOrigin, s, i);
    a = {
      ...u,
      ...f
    };
    const h = ye(u.allMatrix, [50, 50], 100, 100);
    o = wo([h.pos1, h.pos2], h.direction);
  }
  const c = 4;
  return {
    hasZoom: !1,
    width: s,
    height: i,
    rotation: o,
    ...l,
    originalRootMatrix: nt(c),
    rootMatrix: nt(c),
    beforeMatrix: nt(c),
    offsetMatrix: nt(c),
    allMatrix: nt(c),
    targetMatrix: nt(c),
    targetTransform: "",
    inlineTransform: "",
    transformOrigin: [0, 0],
    targetOrigin: [0, 0],
    is3d: !0,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    origin: [0, 0],
    pos1: [0, 0],
    pos2: [0, 0],
    pos3: [0, 0],
    pos4: [0, 0],
    direction: 1,
    hasFixed: !1,
    offsetContainer: null,
    offsetRootContainer: null,
    matrixes: [],
    ...a
  };
}
function Dr(e, t, n, r, s, i = []) {
  let o = 1, a = [0, 0], l = dn(), c = dn(), u = dn(), f = dn(), h = [0, 0];
  const d = {}, p = Mu(t, n, s, !0);
  if (t) {
    const g = Pt(t);
    i.forEach((v) => {
      d[v] = g(v);
    });
    const m = p.is3d ? 4 : 3, b = ye(p.offsetMatrix, Q(p.transformOrigin, Ei(p.targetMatrix, m)), p.width, p.height);
    o = b.direction, a = Q(b.origin, [
      b.left - p.left,
      b.top - p.top
    ]), f = We(p.offsetRootContainer);
    const S = Ue(r, r, !0).offsetParent || p.offsetRootContainer;
    if (p.hasZoom) {
      const v = ye(tt(p.originalRootMatrix, p.allMatrix), p.transformOrigin, p.width, p.height), E = ye(p.originalRootMatrix, Tn(Pt(S)("transformOrigin")).map((x) => parseFloat(x)), S.offsetWidth, S.offsetHeight);
      if (l = sr(v, f), u = sr(E, f, S, !0), e) {
        const x = v.left, w = v.top;
        c = sr({
          left: x,
          top: w,
          bottom: w,
          right: w
        }, f);
      }
    } else {
      l = We(t), u = Xl(S), e && (c = We(e));
      const { left: v, top: E, clientLeft: x, clientTop: w } = u, D = [
        l.left - v,
        l.top - E
      ];
      h = W(ze(p.rootMatrix, D, 4), [x + p.left, w + p.top]);
    }
  }
  return {
    targetClientRect: l,
    containerClientRect: u,
    moveableClientRect: c,
    rootContainerClientRect: f,
    beforeDirection: o,
    beforeOrigin: a,
    originalBeforeOrigin: a,
    target: t,
    style: d,
    offsetDelta: h,
    ...p
  };
}
function qs(e) {
  let { pos1: t, pos2: n, pos3: r, pos4: s } = e;
  if (!t || !n || !r || !s)
    return null;
  const i = ce([t, n, r, s]), o = [i.minX, i.minY], a = W(e.origin, o);
  return t = W(t, o), n = W(n, o), r = W(r, o), s = W(s, o), {
    ...e,
    left: e.left,
    top: e.top,
    posDelta: o,
    pos1: t,
    pos2: n,
    pos3: r,
    pos4: s,
    origin: a,
    beforeOrigin: a,
    // originalBeforeOrigin: origin,
    isPersisted: !0
  };
}
class de extends Or.PureComponent {
  constructor() {
    super(...arguments), Object.defineProperty(this, "state", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        container: null,
        gestos: {},
        renderLines: [
          [
            [0, 0],
            [0, 0]
          ],
          [
            [0, 0],
            [0, 0]
          ],
          [
            [0, 0],
            [0, 0]
          ],
          [
            [0, 0],
            [0, 0]
          ]
        ],
        renderPoses: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        disableNativeEvent: !1,
        posDelta: [0, 0],
        ...Dr(null)
      }
    }), Object.defineProperty(this, "renderState", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "enabledAbles", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "targetAbles", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "controlAbles", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "controlBox", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "areaElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "targetGesto", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "controlGesto", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "rotation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "scale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [1, 1]
    }), Object.defineProperty(this, "isMoveableMounted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "isUnmounted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        mouseEnter: null,
        mouseLeave: null
      }
    }), Object.defineProperty(this, "_emitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ie()
    }), Object.defineProperty(this, "_prevOriginalDragTarget", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_originalDragTarget", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_prevDragTarget", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_dragTarget", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_prevPropTarget", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_propTarget", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_prevDragArea", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isPropTargetChanged", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_hasFirstTarget", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_reiszeObserver", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_observerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_mutationObserver", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_rootContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_viewContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_viewClassNames", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_store", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "checkUpdateRect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        if (this.isDragging())
          return;
        const t = this.props.parentMoveable;
        if (t) {
          t.checkUpdateRect();
          return;
        }
        ba(this._observerId), this._observerId = ui(() => {
          this.isDragging() || this.updateRect();
        });
      }
    }), Object.defineProperty(this, "_onPreventClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (t) => {
        t.stopPropagation(), t.preventDefault();
      }
    });
  }
  render() {
    const t = this.props, n = this.getState(), { parentPosition: r, className: s, target: i, zoom: o, cspNonce: a, translateZ: l, cssStyled: c, groupable: u, linePadding: f, controlPadding: h } = t;
    this._checkUpdateRootContainer(), this.checkUpdate(), this.updateRenderPoses();
    const [d, p] = r || [0, 0], { left: g, top: m, target: b, direction: S, hasFixed: v, offsetDelta: E } = n, x = t.targets, w = this.isDragging(), D = {};
    this.getEnabledAbles().forEach((O) => {
      D[`data-able-${O.name.toLowerCase()}`] = !0;
    });
    const C = this._getAbleClassName(), P = x && x.length && (b || u) || i || !this._hasFirstTarget && this.state.isPersisted, M = this.controlBox || this.props.firstRenderState || this.props.persistData, y = [g - d, m - p];
    !u && t.useAccuratePosition && (y[0] += E[0], y[1] += E[1]);
    const T = {
      position: v ? "fixed" : "absolute",
      display: P ? "block" : "none",
      visibility: M ? "visible" : "hidden",
      transform: `translate3d(${y[0]}px, ${y[1]}px, ${l})`,
      "--zoom": o,
      "--zoompx": `${o}px`
    };
    return f && (T["--moveable-line-padding"] = f), h && (T["--moveable-control-padding"] = h), Pe(c, { cspNonce: a, ref: Rt(this, "controlBox"), className: `${L("control-box", S === -1 ? "reverse" : "", w ? "dragging" : "")} ${C} ${s}`, ...D, onClick: this._onPreventClick, style: T, children: [this.renderAbles(), this._renderLines()] });
  }
  componentDidMount() {
    this.isMoveableMounted = !0, this.isUnmounted = !1;
    const t = this.props, { parentMoveable: n, container: r } = t;
    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateTargets(), this._updateNativeEvents(), this._updateEvents(), this.updateCheckInput(), this._updateObserver(this.props), !r && !n && !this.state.isPersisted && (this.updateRect("", !1, !1), this.forceUpdate());
  }
  componentDidUpdate(t) {
    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateNativeEvents(), this._updateTargets(), this._updateEvents(), this.updateCheckInput(), this._updateObserver(t);
  }
  componentWillUnmount() {
    var r, s;
    this.isMoveableMounted = !1, this.isUnmounted = !0, this._emitter.off(), (r = this._reiszeObserver) == null || r.disconnect(), (s = this._mutationObserver) == null || s.disconnect(), this._viewContainer && this._changeAbleViewClassNames([]), we(this, !1), we(this, !0);
    const n = this.events;
    for (const i in n) {
      const o = n[i];
      o && o.destroy();
    }
  }
  getTargets() {
    const t = this.props.target;
    return t ? [t] : [];
  }
  /**
   * Get the able used in MoveableManager.
   * @method Moveable#getAble
   * @param - able name
   */
  getAble(t) {
    const n = this.props.ables || [];
    return Ot(n, (r) => r.name === t);
  }
  getContainer() {
    const { parentMoveable: t, wrapperMoveable: n, container: r } = this.props;
    return r || n && n.getContainer() || t && t.getContainer() || this.controlBox.parentElement;
  }
  /**
   * Returns the element of the control box.
   * @method Moveable#getControlBoxElement
   */
  getControlBoxElement() {
    return this.controlBox;
  }
  /**
   * Target element to be dragged in moveable
   * @method Moveable#getDragElement
   */
  getDragElement() {
    return this._dragTarget;
  }
  /**
   * Check if the target is an element included in the moveable.
   * @method Moveable#isMoveableElement
   * @param - the target
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * window.addEventListener("click", e => {
   *     if (!moveable.isMoveableElement(e.target)) {
   *         moveable.target = e.target;
   *     }
   * });
   */
  isMoveableElement(t) {
    var n;
    return t && (((n = t.getAttribute) == null ? void 0 : n.call(t, "class")) || "").indexOf(Fr) > -1;
  }
  /**
   * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)
   * @method Moveable#dragStart
   * @param - external `MouseEvent`or `TouchEvent`
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (!moveable.isMoveableElement(e.target)) {
   *          moveable.dragStart(e);
   *     }
   * });
   */
  dragStart(t, n = t.target) {
    const r = this.targetGesto, s = this.controlGesto;
    return r && as(this)({ inputEvent: t }, n) ? r.isFlag() || r.triggerDragStart(t) : s && this.isMoveableElement(n) && (s.isFlag() || s.triggerDragStart(t)), this;
  }
  /**
   * Hit test an element or rect on a moveable target.
   * (100% = 100)
   * @method Moveable#hitTest
   * @param - element or rect to test
   * @return - Get hit test rate (rate > 0 is hitted)
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (moveable.hitTest(e.target) > 0) {
   *          console.log("hiited");
   *     }
   * });
   */
  hitTest(t) {
    const { target: n, pos1: r, pos2: s, pos3: i, pos4: o, targetClientRect: a } = this.state;
    if (!n)
      return 0;
    let l;
    if (le(t)) {
      const m = t.getBoundingClientRect();
      l = {
        left: m.left,
        top: m.top,
        width: m.width,
        height: m.height
      };
    } else
      l = { width: 0, height: 0, ...t };
    const { left: c, top: u, width: f, height: h } = l, d = ur([r, s, o, i], a), p = Ga(d, [
      [c, u],
      [c + f, u],
      [c + f, u + h],
      [c, u + h]
    ]), g = Ye(d);
    return !p || !g ? 0 : Math.min(100, p / g * 100);
  }
  /**
   * Whether the coordinates are inside Moveable
   * @method Moveable#isInside
   * @param - x coordinate
   * @param - y coordinate
   * @return - True if the coordinate is in moveable or false
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (moveable.isInside(e.clientX, e.clientY)) {
   *          console.log("inside");
   *     }
   * });
   */
  isInside(t, n) {
    const { target: r, pos1: s, pos2: i, pos3: o, pos4: a, targetClientRect: l } = this.state;
    return r ? Cn([t, n], ur([s, i, a, o], l)) : !1;
  }
  /**
   * If the width, height, left, and top of all elements change, update the shape of the moveable.
   * @method Moveable#updateRect
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * window.addEventListener("resize", e => {
   *     moveable.updateRect();
   * });
   */
  updateRect(t, n, r = !0) {
    const s = this.props, i = !s.parentPosition && !s.wrapperMoveable;
    i && Te(!0);
    const o = s.parentMoveable, l = this.state.target || s.target, c = this.getContainer(), u = o ? o._rootContainer : this._rootContainer, f = Dr(this.controlBox, l, c, c, u || c, this._getRequestStyles());
    if (!l && this._hasFirstTarget && s.persistData) {
      const h = qs(s.persistData);
      for (const d in h)
        f[d] = h[d];
    }
    i && Te(), this.updateState(f, o ? !1 : r);
  }
  /**
   * Check if the moveable state is being dragged.
   * @method Moveable#isDragging
   * @param - If you want to check if able is dragging, specify ableName.
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * // false
   * console.log(moveable.isDragging());
   *
   * moveable.on("drag", () => {
   *   // true
   *   console.log(moveable.isDragging());
   * });
   */
  isDragging(t) {
    var s, i;
    const n = this.targetGesto, r = this.controlGesto;
    return n != null && n.isFlag() ? t ? !!((s = n.getEventData()[t]) != null && s.isEventStart) : !0 : r != null && r.isFlag() ? t ? !!((i = r.getEventData()[t]) != null && i.isEventStart) : !0 : !1;
  }
  /**
   * If the width, height, left, and top of the only target change, update the shape of the moveable.
   * Use `.updateRect()` method
   * @method Moveable#updateTarget
   * @deprecated
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * moveable.updateTarget();
   */
  updateTarget(t) {
    this.updateRect(t, !0);
  }
  /**
   * You can get the vertex information, position and offset size information of the target based on the container.
   * @method Moveable#getRect
   * @return - The Rect Info
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * const rectInfo = moveable.getRect();
   */
  getRect() {
    const t = this.state, n = It(this.state), [r, s, i, o] = n, a = zt(n), { width: l, height: c } = t, { width: u, height: f, left: h, top: d } = a, p = [t.left, t.top], g = Q(p, t.origin), m = Q(p, t.beforeOrigin), b = t.transformOrigin;
    return {
      width: u,
      height: f,
      left: h,
      top: d,
      pos1: r,
      pos2: s,
      pos3: i,
      pos4: o,
      offsetWidth: l,
      offsetHeight: c,
      beforeOrigin: m,
      origin: g,
      transformOrigin: b,
      rotation: this.getRotation()
    };
  }
  /**
   * Get a manager that manages the moveable's state and props.
   * @method Moveable#getManager
   * @return - The Rect Info
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * const manager = moveable.getManager(); // real moveable class instance
   */
  getManager() {
    return this;
  }
  /**
   * You can stop the dragging currently in progress through a method from outside.
   * @method Moveable#stopDrag
   * @return - The Rect Info
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * moveable.stopDrag();
   */
  stopDrag(t) {
    if (!t || t === "target") {
      const n = this.targetGesto;
      (n == null ? void 0 : n.isIdle()) === !1 && Cr(this, !1), n == null || n.stop();
    }
    if (!t || t === "control") {
      const n = this.controlGesto;
      (n == null ? void 0 : n.isIdle()) === !1 && Cr(this, !0), n == null || n.stop();
    }
  }
  getRotation() {
    const { pos1: t, pos2: n, direction: r } = this.state;
    return Kc(t, n, r);
  }
  /**
   * Request able through a method rather than an event.
   * At the moment of execution, requestStart is executed,
   * and then request and requestEnd can be executed through Requester.
   * @method Moveable#request
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}
   * @param - ableName
   * @param - request to be able params.
   * @param - If isInstant is true, request and requestEnd are executed immediately.
   * @return - Able Requester. If there is no request in able, nothing will work.
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("draggable", { deltaX: 10, deltaY: 10 }, true);
   *
   * // Start move
   * const requester = moveable.request("draggable");
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.requestEnd();
   */
  request(t, n = {}, r) {
    const s = this, i = s.props, o = i.parentMoveable || i.wrapperMoveable || s, a = o.props.ables, l = i.groupable, c = Ot(a, (m) => m.name === t);
    if (this.isDragging() || !c || !c.request)
      return {
        request() {
          return this;
        },
        requestEnd() {
          return this;
        }
      };
    const u = c.request(s), f = r || n.isInstant, h = u.isControl ? "controlAbles" : "targetAbles", d = `${l ? "Group" : ""}${u.isControl ? "Control" : ""}`, p = [...o[h]], g = {
      request(m) {
        return Ne(s, p, ["drag"], d, "", {
          ...u.request(m),
          requestAble: t,
          isRequest: !0
        }, f), g;
      },
      requestEnd() {
        return Ne(s, p, ["drag"], d, "End", {
          ...u.requestEnd(),
          requestAble: t,
          isRequest: !0
        }, f), g;
      }
    };
    return Ne(s, p, ["drag"], d, "Start", {
      ...u.requestStart(n),
      requestAble: t,
      isRequest: !0
    }, f), f ? g.request(n).requestEnd() : g;
  }
  /**
   * moveable is the top level that manages targets
   * `Single`: MoveableManager instance
   * `Group`: MoveableGroup instance
   * `IndividualGroup`: MoveableIndividaulGroup instance
   * Returns leaf target MoveableManagers.
   */
  getMoveables() {
    return [this];
  }
  /**
   * Remove the Moveable object and the events.
   * @method Moveable#destroy
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * moveable.destroy();
   */
  destroy() {
    this.componentWillUnmount();
  }
  updateRenderPoses() {
    const t = this.getState(), n = this.props, r = n.padding, { originalBeforeOrigin: s, transformOrigin: i, allMatrix: o, is3d: a, pos1: l, pos2: c, pos3: u, pos4: f, left: h, top: d, isPersisted: p } = t, g = n.zoom || 1;
    if (!r && g <= 1) {
      t.renderPoses = [l, c, u, f], t.renderLines = [
        [l, c],
        [c, f],
        [f, u],
        [u, l]
      ];
      return;
    }
    const { left: m, top: b, bottom: S, right: v } = _o(r || {}), E = a ? 4 : 3;
    let x = [];
    p ? x = i : this.controlBox && n.groupable ? x = s : x = Q(s, [h, d]);
    const w = yn(E, fe(x.map((y) => -y), E), o, fe(i, E)), D = Tt(w, l, [-m, -b], E), C = Tt(w, c, [v, -b], E), P = Tt(w, u, [-m, S], E), M = Tt(w, f, [v, S], E);
    t.renderPoses = [D, C, P, M], t.renderLines = [
      [D, C],
      [C, M],
      [M, P],
      [P, D]
    ];
    {
      const y = g / 2;
      t.renderLines = [
        [
          Tt(w, l, [-m - y, -b], E),
          Tt(w, c, [v + y, -b], E)
        ],
        [
          Tt(w, c, [v, -b - y], E),
          Tt(w, f, [v, S + y], E)
        ],
        [
          Tt(w, f, [v + y, S], E),
          Tt(w, u, [-m - y, S], E)
        ],
        [
          Tt(w, u, [-m, S + y], E),
          Tt(w, l, [-m, -b - y], E)
        ]
      ];
    }
  }
  checkUpdate() {
    this._isPropTargetChanged = !1;
    const { target: t, container: n, parentMoveable: r } = this.props, { target: s, container: i } = this.state;
    if (!s && !t)
      return;
    this.updateAbles();
    const o = !yr(s, t);
    if (!(o || !yr(i, n)))
      return;
    const l = n || this.controlBox;
    l && this.unsetAbles(), this.updateState({ target: t, container: n }), !r && l && this.updateRect("End", !1, !1), this._isPropTargetChanged = o;
  }
  waitToChangeTarget() {
    return new Promise(() => {
    });
  }
  triggerEvent(t, n) {
    const r = this.props;
    if (this._emitter.trigger(t, n), r.parentMoveable && n.isRequest && !n.isRequestChild)
      return r.parentMoveable.triggerEvent(t, n, !0);
    const s = r[t];
    return s && s(n);
  }
  useCSS(t, n) {
    const r = this.props.customStyledMap, s = t + n;
    return r[s] || (r[s] = Wo(t, n)), r[s];
  }
  getState() {
    var i;
    const t = this.props;
    (t.target || (i = t.targets) != null && i.length) && (this._hasFirstTarget = !0);
    const n = this.controlBox, r = t.persistData, s = t.firstRenderState;
    if (s && !n)
      return s;
    if (!this._hasFirstTarget && r) {
      const o = qs(r);
      if (o)
        return this.updateState(o, !1), this.state;
    }
    return this.state.isPersisted = !1, this.state;
  }
  updateSelectors() {
  }
  unsetAbles() {
    this.targetAbles.forEach((t) => {
      t.unset && t.unset(this);
    });
  }
  updateAbles(t = this.props.ables, n = "") {
    const s = this.props.triggerAblesSimultaneously, i = this.getEnabledAbles(t), o = `drag${n}Start`, a = `pinch${n}Start`, l = `drag${n}ControlStart`, c = pn(i, [o, a], s), u = pn(i, [l], s);
    this.enabledAbles = i, this.targetAbles = c, this.controlAbles = u;
  }
  updateState(t, n) {
    if (n) {
      if (this.isUnmounted)
        return;
      this.setState(t);
    } else {
      const r = this.state;
      for (const s in t)
        r[s] = t[s];
    }
  }
  getEnabledAbles(t = this.props.ables) {
    const n = this.props;
    return t.filter((r) => r && (r.always && n[r.name] !== !1 || n[r.name]));
  }
  renderAbles() {
    const n = this.props.triggerAblesSimultaneously, r = {
      createElement: Mr
    };
    return this.renderState = {}, Vc(Mo(pn(this.getEnabledAbles(), ["render"], n).map(({ render: s }) => s(this, r) || [])).filter((s) => s), ({ key: s }) => s).map((s) => s[0]);
  }
  updateCheckInput() {
    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);
  }
  _getRequestStyles() {
    return this.getEnabledAbles().reduce((n, r) => {
      var i;
      const s = ((i = r.requestStyle) == null ? void 0 : i.call(r)) ?? [];
      return [...n, ...s];
    }, [...this.props.requestStyles || []]);
  }
  _updateObserver(t) {
    this._updateResizeObserver(t), this._updateMutationObserver(t);
  }
  _updateEvents() {
    const t = this.targetAbles.length, n = this.controlAbles.length, r = this._dragTarget;
    (!t && this.targetGesto || this._isTargetChanged(!0)) && (we(this, !1), this.updateState({ gestos: {} })), n || we(this, !0), r && t && !this.targetGesto && (this.targetGesto = Yo(this, r, "")), !this.controlGesto && n && (this.controlGesto = Fo(this, "Control"));
  }
  _updateTargets() {
    const t = this.props;
    this._prevPropTarget = this._propTarget, this._prevDragTarget = this._dragTarget, this._prevOriginalDragTarget = this._originalDragTarget, this._prevDragArea = t.dragArea, this._propTarget = t.target, this._originalDragTarget = t.dragTarget || t.target, this._dragTarget = Lt(this._originalDragTarget, !0);
  }
  _renderLines() {
    const t = this.props, { zoom: n, hideDefaultLines: r, hideChildMoveableDefaultLines: s, parentMoveable: i } = t;
    if (r || i && s)
      return [];
    const o = this.getState(), a = {};
    return o.renderLines.map((l, c) => qe(a, "", l[0], l[1], n, `render-line-${c}`));
  }
  _isTargetChanged(t) {
    const n = this.props, r = n.dragTarget || n.target, s = this._prevOriginalDragTarget, i = this._prevDragArea, o = n.dragArea;
    return !o && s !== r || (t || o) && i !== o || this._prevPropTarget != this._propTarget;
  }
  _updateNativeEvents() {
    const n = this.props.dragArea ? this.areaElement : this.state.target, r = this.events, s = _e(r);
    if (this._isTargetChanged())
      for (const o in r) {
        const a = r[o];
        a && a.destroy(), r[o] = null;
      }
    if (!n)
      return;
    const i = this.enabledAbles;
    s.forEach((o) => {
      const a = pn(i, [o]), l = a.length > 0;
      let c = r[o];
      if (!l) {
        c && (c.destroy(), r[o] = null);
        return;
      }
      c || (c = new Du(n, this, o), r[o] = c), c.setAbles(a);
    });
  }
  _checkUpdateRootContainer() {
    const t = this.props.rootContainer;
    !this._rootContainer && t && (this._rootContainer = Lt(t, !0));
  }
  _checkUpdateViewContainer() {
    const t = this.props.viewContainer;
    !this._viewContainer && t && (this._viewContainer = Lt(t, !0)), this._viewContainer && this._changeAbleViewClassNames([
      ...this._getAbleViewClassNames(),
      this.isDragging() ? su : ""
    ]);
  }
  _changeAbleViewClassNames(t) {
    const n = this._viewContainer, r = Oo(t.filter(Boolean), (a) => a).map(([a]) => a), s = this._viewClassNames, { removed: i, added: o } = An(s, r);
    i.forEach((a) => {
      hi(n, s[a]);
    }), o.forEach((a) => {
      Ht(n, r[a]);
    }), this._viewClassNames = r;
  }
  _getAbleViewClassNames() {
    return (this.getEnabledAbles().map((t) => {
      var n;
      return ((n = t.viewClassName) == null ? void 0 : n.call(t, this)) || "";
    }).join(" ") + ` ${this._getAbleClassName("-view")}`).split(/\s+/g);
  }
  _getAbleClassName(t = "") {
    const n = this.getEnabledAbles(), r = this.targetGesto, s = this.controlGesto, i = r != null && r.isFlag() ? r.getEventData() : {}, o = s != null && s.isFlag() ? s.getEventData() : {};
    return n.map((a) => {
      var u, f, h;
      const l = a.name;
      let c = ((u = a.className) == null ? void 0 : u.call(a, this)) || "";
      return ((f = i[l]) != null && f.isEventStart || (h = o[l]) != null && h.isEventStart) && (c += ` ${L(`${l}${t}-dragging`)}`), c.trim();
    }).filter(Boolean).join(" ");
  }
  _updateResizeObserver(t) {
    var o;
    const n = this.props, r = n.target, s = yt(this.getControlBoxElement());
    if (!s.ResizeObserver || !r || !n.useResizeObserver) {
      (o = this._reiszeObserver) == null || o.disconnect();
      return;
    }
    if (t.target === r && this._reiszeObserver)
      return;
    const i = new s.ResizeObserver(this.checkUpdateRect);
    i.observe(r, {
      box: "border-box"
    }), this._reiszeObserver = i;
  }
  _updateMutationObserver(t) {
    var o;
    const n = this.props, r = n.target, s = yt(this.getControlBoxElement());
    if (!s.MutationObserver || !r || !n.useMutationObserver) {
      (o = this._mutationObserver) == null || o.disconnect();
      return;
    }
    if (t.target === r && this._mutationObserver)
      return;
    const i = new s.MutationObserver((a) => {
      for (const l of a)
        l.type === "attributes" && l.attributeName === "style" && this.checkUpdateRect();
    });
    i.observe(r, {
      attributes: !0
    }), this._mutationObserver = i;
  }
}
Object.defineProperty(de, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    dragTargetSelf: !1,
    target: null,
    dragTarget: null,
    container: null,
    rootContainer: null,
    origin: !0,
    parentMoveable: null,
    wrapperMoveable: null,
    isWrapperMounted: !1,
    parentPosition: null,
    warpSelf: !1,
    svgOrigin: "",
    dragContainer: null,
    useResizeObserver: !1,
    useMutationObserver: !1,
    preventDefault: !0,
    preventRightClick: !0,
    preventWheelClick: !0,
    linePadding: 0,
    controlPadding: 0,
    ables: [],
    pinchThreshold: 20,
    dragArea: !1,
    passDragArea: !1,
    transformOrigin: "",
    className: "",
    zoom: 1,
    triggerAblesSimultaneously: !1,
    padding: {},
    pinchOutside: !0,
    checkInput: !1,
    dragFocusedInput: !1,
    groupable: !1,
    hideDefaultLines: !1,
    cspNonce: "",
    translateZ: 0,
    cssStyled: null,
    customStyledMap: {},
    props: {},
    stopPropagation: !1,
    preventClickDefault: !1,
    preventClickEventOnDrag: !0,
    flushSync: bo,
    firstRenderState: null,
    persistData: null,
    viewContainer: null,
    requestStyles: [],
    useAccuratePosition: !1
  }
});
const ls = {
  name: "groupable",
  props: [
    "defaultGroupRotate",
    "useDefaultGroupRotate",
    "defaultGroupOrigin",
    "groupable",
    "groupableProps",
    "targetGroups",
    "hideChildMoveableDefaultLines"
  ],
  events: [],
  render(e, t) {
    var h;
    const n = e.props;
    let r = n.targets || [];
    const { left: s, top: i, isPersisted: o } = e.getState(), a = n.zoom || 1, l = e.renderGroupRects;
    let c = ((h = n.persistData) == null ? void 0 : h.children) || [];
    o ? r = c.map(() => null) : c = [];
    const u = Ce(e, "parentPosition", [s, i], (d) => d.join(",")), f = Ce(e, "requestStyles", e.getRequestChildStyles(), (d) => d.join(","));
    return e.moveables = e.moveables.slice(0, r.length), [
      ...r.map((d, p) => Z(de, { ref: ji(e, "moveables", p), target: d, origin: !1, requestStyles: f, cssStyled: n.cssStyled, customStyledMap: n.customStyledMap, useResizeObserver: n.useResizeObserver, useMutationObserver: n.useMutationObserver, hideChildMoveableDefaultLines: n.hideChildMoveableDefaultLines, parentMoveable: e, parentPosition: [s, i], persistData: c[p], zoom: a }, "moveable" + p)),
      ...Mo(l.map(({ pos1: d, pos2: p, pos3: g, pos4: m }, b) => {
        const S = [d, p, g, m];
        return [
          [0, 1],
          [1, 3],
          [3, 2],
          [2, 0]
        ].map(([v, E], x) => qe(t, "", W(S[v], u), W(S[E], u), a, `group-rect-${b}-${x}`));
      }))
    ];
  }
}, Tu = Je("clickable", {
  props: ["clickable"],
  events: ["click", "clickGroup"],
  always: !0,
  dragRelation: "weak",
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  dragStart() {
  },
  dragControlStart() {
  },
  dragGroupStart(e, t) {
    t.datas.inputTarget = t.inputEvent && t.inputEvent.target;
  },
  dragEnd(e, t) {
    const n = e.props.target, r = t.inputEvent, s = t.inputTarget, o = !e.isMoveableElement(s) && e.controlBox.contains(s);
    if (!r || !s || t.isDrag || e.isMoveableElement(s) || o)
      return;
    const a = n.contains(s);
    Y(e, "onClick", U(e, t, {
      isDouble: t.isDouble,
      inputTarget: s,
      isTarget: n === s,
      moveableTarget: e.props.target,
      containsTarget: a
    }));
  },
  dragGroupEnd(e, t) {
    const n = t.inputEvent, r = t.inputTarget;
    if (!n || !r || t.isDrag || e.isMoveableElement(r) || // External event duplicate target or dragAreaElement
    t.datas.inputTarget === r)
      return;
    const s = e.props.targets;
    let i = s.indexOf(r);
    const o = i > -1;
    let a = !1;
    i === -1 && (i = qt(s, (l) => l.contains(r)), a = i > -1), Y(e, "onClickGroup", U(e, t, {
      isDouble: t.isDouble,
      targets: s,
      inputTarget: r,
      targetIndex: i,
      isTarget: o,
      containsTarget: a,
      moveableTarget: s[i]
    }));
  },
  dragControlEnd(e, t) {
    this.dragEnd(e, t);
  },
  dragGroupControlEnd(e, t) {
    this.dragEnd(e, t);
  }
});
function be(e) {
  let t = e.originalDatas.draggable;
  return t || (e.originalDatas.draggable = {}, t = e.originalDatas.draggable), { ...e, datas: t };
}
const Ru = Je("edgeDraggable", {
  css: [
    `.edge.edgeDraggable.line {
cursor: move;
}`
  ],
  render(e, t) {
    const n = e.props, r = n.edgeDraggable;
    return r ? Zi(t, "edgeDraggable", r, e.getState().renderPoses, n.zoom) : [];
  },
  dragCondition(e, t) {
    var s;
    const n = e.props, r = (s = t.inputEvent) == null ? void 0 : s.target;
    return !n.edgeDraggable || !r ? !1 : !n.draggable && ht(r, L("direction")) && ht(r, L("edge")) && ht(r, L("edgeDraggable"));
  },
  dragStart(e, t) {
    return vt.dragStart(e, be(t));
  },
  drag(e, t) {
    return vt.drag(e, be(t));
  },
  dragEnd(e, t) {
    return vt.dragEnd(e, be(t));
  },
  dragGroupCondition(e, t) {
    var s;
    const n = e.props, r = (s = t.inputEvent) == null ? void 0 : s.target;
    return !n.edgeDraggable || !r ? !1 : !n.draggable && ht(r, L("direction")) && ht(r, L("line"));
  },
  dragGroupStart(e, t) {
    return vt.dragGroupStart(e, be(t));
  },
  dragGroup(e, t) {
    return vt.dragGroup(e, be(t));
  },
  dragGroupEnd(e, t) {
    return vt.dragGroupEnd(e, be(t));
  },
  unset(e) {
    return vt.unset(e);
  }
}), No = {
  name: "individualGroupable",
  props: ["individualGroupable", "individualGroupableProps"],
  events: []
}, zu = [
  jo,
  Ao,
  Bc,
  Qc,
  vt,
  Ru,
  Sr,
  tu,
  nu,
  mc,
  au,
  lu,
  iu,
  xu,
  Su,
  yu,
  ls,
  No,
  Tu,
  Bo,
  Xo
];
function Us([e, t, n], r) {
  return (e * r[0] + t * r[1] + n) / Math.sqrt(e * e + t * t);
}
function bn([e, t], n) {
  return -e * n[0] - t * n[1];
}
function Zs(e, t) {
  return Math.max(...e.map(([n, r, s, i]) => Math.max(n[t], r[t], s[t], i[t])));
}
function Ks(e, t) {
  return Math.min(...e.map(([n, r, s, i]) => Math.min(n[t], r[t], s[t], i[t])));
}
function _u(e, t) {
  let n = [0, 0], r = [0, 0], s = [0, 0], i = [0, 0], o = 0, a = 0;
  if (!e.length)
    return {
      pos1: n,
      pos2: r,
      pos3: s,
      pos4: i,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: o,
      height: a,
      rotation: t
    };
  const l = V(t, wt);
  if (l % 90) {
    const d = l / 180 * Math.PI, p = Math.tan(d), g = -1 / p, m = [gr, xs], b = [
      [0, 0],
      [0, 0]
    ], S = [gr, xs], v = [
      [0, 0],
      [0, 0]
    ];
    e.forEach((T) => {
      T.forEach((O) => {
        const R = Us([-p, 1, 0], O), I = Us([-g, 1, 0], O);
        m[0] > R && (b[0] = O, m[0] = R), m[1] < R && (b[1] = O, m[1] = R), S[0] > I && (v[0] = O, S[0] = I), S[1] < I && (v[1] = O, S[1] = I);
      });
    });
    const [E, x] = b, [w, D] = v, C = [-p, 1, bn([-p, 1], E)], P = [-p, 1, bn([-p, 1], x)], M = [-g, 1, bn([-g, 1], w)], y = [-g, 1, bn([-g, 1], D)];
    [n, r, s, i] = [
      [C, M],
      [C, y],
      [P, M],
      [P, y]
    ].map(([T, O]) => Br(T, O)[0]), o = S[1] - S[0], a = m[1] - m[0];
  } else {
    const d = Ks(e, 0), p = Ks(e, 1), g = Zs(e, 0), m = Zs(e, 1);
    n = [d, p], r = [g, p], s = [d, m], i = [g, m], o = g - d, a = m - p, l % 180 && ([n, r, s, i] = [s, n, i, r], o = m - p, a = g - d);
  }
  l % 360 > 180 && ([n, r, s, i] = [i, s, r, n]);
  const { minX: c, minY: u, maxX: f, maxY: h } = ce([n, r, s, i]);
  return {
    pos1: n,
    pos2: r,
    pos3: s,
    pos4: i,
    width: o,
    height: a,
    minX: c,
    minY: u,
    maxX: f,
    maxY: h,
    rotation: t
  };
}
function Ho(e, t) {
  const n = t.map((r) => {
    if (at(r)) {
      const s = Ho(e, r), i = s.length;
      return i > 1 ? s : i === 1 ? s[0] : null;
    } else {
      const s = Ot(e, ({ manager: i }) => i.props.target === r);
      return s ? (s.finded = !0, s.manager) : null;
    }
  }).filter(Boolean);
  return n.length === 1 && at(n[0]) ? n[0] : n;
}
class Vo extends de {
  constructor() {
    super(...arguments), Object.defineProperty(this, "differ", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new bi()
    }), Object.defineProperty(this, "moveables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "transformOrigin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "50% 50%"
    }), Object.defineProperty(this, "renderGroupRects", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_targetGroups", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_hasFirstTargets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  componentDidMount() {
    super.componentDidMount();
  }
  checkUpdate() {
    this._isPropTargetChanged = !1, this.updateAbles();
  }
  getTargets() {
    return this.props.targets;
  }
  updateRect(t, n, r = !0) {
    var j;
    const s = this.state;
    if (!this.controlBox || s.isPersisted)
      return;
    Te(!0), this.moveables.forEach((X) => {
      X.updateRect(t, !1, !1);
    });
    const i = this.props, o = this.moveables, a = s.target || i.target, l = o.map((X) => ({
      finded: !1,
      manager: X
    })), c = this.props.targetGroups || [], u = Ho(l, c), f = i.useDefaultGroupRotate;
    u.push(...l.filter(({ finded: X }) => !X).map(({ manager: X }) => X));
    const h = [], d = !n || t !== "" && i.updateGroup;
    let p = i.defaultGroupRotate || 0;
    if (!this._hasFirstTargets) {
      const X = (j = i.persistData) == null ? void 0 : j.rotation;
      X != null && (p = X);
    }
    function g(X, J, $) {
      const F = X.map((ut) => {
        if (at(ut)) {
          const gt = g(ut, J), Xt = [gt.pos1, gt.pos2, gt.pos3, gt.pos4];
          return h.push(gt), { poses: Xt, rotation: gt.rotation };
        } else
          return {
            poses: It(ut.state),
            rotation: ut.getRotation()
          };
      }), H = F.map(({ rotation: ut }) => ut);
      let rt = 0;
      const dt = H[0], ct = H.every((ut) => Math.abs(dt - ut) < 0.1);
      d ? rt = !f && ct ? dt : p : rt = !f && !$ && ct ? dt : J;
      const st = F.map(({ poses: ut }) => ut);
      return _u(st, rt);
    }
    const m = g(u, this.rotation, !0);
    d && (this.rotation = m.rotation, this.transformOrigin = i.defaultGroupOrigin || "50% 50%", this.scale = [1, 1]), this._targetGroups = c, this.renderGroupRects = h;
    const b = this.transformOrigin, S = this.rotation, v = this.scale, { width: E, height: x, minX: w, minY: D } = m, C = Jc([
      [0, 0],
      [E, 0],
      [0, x],
      [E, x]
    ], ss(b, E, x), this.rotation / 180 * Math.PI), { minX: P, minY: M } = ce(C.result), y = ` rotate(${S}deg) scale(${St(v[0])}, ${St(v[1])})`, T = `translate(${-P}px, ${-M}px)${y}`;
    this.controlBox.style.transform = `translate3d(${w}px, ${D}px, ${this.props.translateZ || 0})`, a.style.cssText += `left:0px;top:0px;transform-origin:${b};width:${E}px;height:${x}px;transform: ${T}`, s.width = E, s.height = x;
    const O = this.getContainer(), R = Dr(this.controlBox, a, this.controlBox, this.getContainer(), this._rootContainer || O, []), I = [R.left, R.top], [_, A, B, N] = It(R), G = ce([_, A, B, N]), k = [G.minX, G.minY], q = St(v[0] * v[1]);
    R.pos1 = W(_, k), R.pos2 = W(A, k), R.pos3 = W(B, k), R.pos4 = W(N, k), R.left = w - R.left + k[0], R.top = D - R.top + k[1], R.origin = W(Q(I, R.origin), k), R.beforeOrigin = W(Q(I, R.beforeOrigin), k), R.originalBeforeOrigin = Q(I, R.originalBeforeOrigin), R.transformOrigin = W(Q(I, R.transformOrigin), k), a.style.transform = `translate(${-P - k[0]}px, ${-M - k[1]}px)` + y, Te(), this.updateState({
      ...R,
      posDelta: k,
      direction: q,
      beforeDirection: q
    }, r);
  }
  getRect() {
    return {
      ...super.getRect(),
      children: this.moveables.map((t) => t.getRect())
    };
  }
  triggerEvent(t, n, r) {
    if (r || t.indexOf("Group") > -1)
      return super.triggerEvent(t, n);
    this._emitter.trigger(t, n);
  }
  getRequestChildStyles() {
    return this.getEnabledAbles().reduce((n, r) => {
      var i;
      const s = ((i = r.requestChildStyle) == null ? void 0 : i.call(r)) ?? [];
      return [...n, ...s];
    }, []);
  }
  getMoveables() {
    return [...this.moveables];
  }
  updateAbles() {
    super.updateAbles([...this.props.ables, ls], "Group");
  }
  _updateTargets() {
    super._updateTargets(), this._originalDragTarget = this.props.dragTarget || this.areaElement, this._dragTarget = Lt(this._originalDragTarget, !0);
  }
  _updateEvents() {
    const t = this.state, n = this.props, r = this._prevDragTarget, s = n.dragTarget || this.areaElement, i = n.targets, { added: o, changed: a, removed: l } = this.differ.update(i), c = o.length || l.length;
    (c || this._prevOriginalDragTarget !== this._originalDragTarget) && (we(this, !1), we(this, !0), this.updateState({ gestos: {} })), r !== s && (t.target = null), t.target || (t.target = this.areaElement, this.controlBox.style.display = "block"), t.target && (this.targetGesto || (this.targetGesto = Yo(this, this._dragTarget, "Group")), this.controlGesto || (this.controlGesto = Fo(this, "GroupControl")));
    const u = !yr(t.container, n.container);
    u && (t.container = n.container), (u || c || this.transformOrigin !== (n.defaultGroupOrigin || "50% 50%") || a.length || i.length && !zo(this._targetGroups, n.targetGroups || [])) && (this.updateRect(), this._hasFirstTargets = !0), this._isPropTargetChanged = !!c;
  }
  _updateObserver() {
  }
}
Object.defineProperty(Vo, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    ...de.defaultProps,
    transformOrigin: ["50%", "50%"],
    groupable: !0,
    dragArea: !0,
    keepRatio: !0,
    targets: [],
    defaultGroupRotate: 0,
    defaultGroupOrigin: "50% 50%"
  }
});
class Iu extends de {
  constructor() {
    super(...arguments), Object.defineProperty(this, "moveables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  render() {
    const t = this.props, { cspNonce: n, cssStyled: r, persistData: s } = t;
    let i = t.targets || [];
    const o = i.length, a = this.isUnmounted || !o;
    let l = (s == null ? void 0 : s.children) ?? [];
    return a && !o && l.length ? i = l.map(() => null) : a || (l = []), Z(r, { cspNonce: n, ref: Rt(this, "controlBox"), className: L("control-box"), children: i.map((c, u) => {
      var h;
      const f = ((h = t.individualGroupableProps) == null ? void 0 : h.call(t, c, u)) ?? {};
      return Z(de, { ref: ji(this, "moveables", u), ...t, ...f, target: c, wrapperMoveable: this, isWrapperMounted: this.isMoveableMounted, persistData: l[u] }, "moveable" + u);
    }) });
  }
  componentDidMount() {
  }
  componentDidUpdate() {
  }
  getTargets() {
    return this.props.targets;
  }
  updateRect(t, n, r = !0) {
    Te(!0), this.moveables.forEach((s) => {
      s.updateRect(t, n, r);
    }), Te();
  }
  getRect() {
    return {
      ...super.getRect(),
      children: this.moveables.map((t) => t.getRect())
    };
  }
  request(t, n = {}, r) {
    const s = this.moveables.map((a) => a.request(t, { ...n, isInstant: !1 }, !1)), i = r || n.isInstant, o = {
      request(a) {
        return s.forEach((l) => l.request(a)), this;
      },
      requestEnd() {
        return s.forEach((a) => a.requestEnd()), this;
      }
    };
    return i ? o.request(n).requestEnd() : o;
  }
  dragStart(t, n = t.target) {
    const r = n, s = Ot(this.moveables, (i) => {
      const o = i.getTargets()[0], a = i.getControlBoxElement(), l = i.getDragElement();
      return !o || !l ? !1 : l === r || l.contains(r) || l !== o && o === r || o.contains(r) || a === r || a.contains(r);
    });
    return s && s.dragStart(t, n), this;
  }
  hitTest() {
    return 0;
  }
  isInside() {
    return !1;
  }
  isDragging() {
    return !1;
  }
  getDragElement() {
    return null;
  }
  getMoveables() {
    return [...this.moveables];
  }
  updateRenderPoses() {
  }
  checkUpdate() {
  }
  triggerEvent() {
  }
  updateAbles() {
  }
  _updateEvents() {
  }
  _updateObserver() {
  }
}
function qo(e, t) {
  const n = [];
  return e.forEach((r) => {
    if (r) {
      if (jt(r)) {
        t[r] && n.push(...t[r]);
        return;
      }
      at(r) ? n.push(...qo(r, t)) : n.push(r);
    }
  }), n;
}
function Uo(e, t) {
  const n = [];
  return e.forEach((r) => {
    if (r) {
      if (jt(r)) {
        t[r] && n.push(...t[r]);
        return;
      }
      at(r) ? n.push(Uo(r, t)) : n.push(r);
    }
  }), n;
}
function Zo(e, t) {
  return e.length !== t.length || e.some((n, r) => {
    const s = t[r];
    return !n && !s ? !1 : n != s ? at(n) && at(s) ? Zo(n, s) : !0 : !1;
  });
}
function Bu(e, t, n) {
  t.forEach((r) => {
    r in e || (e[r] = function(...s) {
      const i = this[n][r](...s);
      return i === this[n] ? this : i;
    });
  });
}
class Nn extends Or.PureComponent {
  constructor() {
    super(...arguments), Object.defineProperty(this, "moveable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "refTargets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "selectorMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_differ", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new bi()
    }), Object.defineProperty(this, "_elementTargets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_tmpRefTargets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_tmpSelectorMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_onChangeTargets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    });
  }
  static makeStyled() {
    const t = {};
    this.getTotalAbles().forEach(({ css: s }) => {
      s && s.forEach((i) => {
        t[i] = !0;
      });
    });
    const r = _e(t).join(`
`);
    this.defaultStyled = Wo("div", Xi(Fr, vl + r));
  }
  static getTotalAbles() {
    return [
      Ao,
      ls,
      No,
      Bo,
      ...this.defaultAbles
    ];
  }
  render() {
    const t = this.constructor;
    t.defaultStyled || t.makeStyled();
    const { ables: n, props: r, ...s } = this.props, [i, o] = this._updateRefs(!0), a = qo(i, o);
    let l = a.length > 1;
    const u = [...t.getTotalAbles(), ...n || []], f = {
      ...s,
      ...r || {},
      ables: u,
      cssStyled: t.defaultStyled,
      customStyledMap: t.customStyledMap
    };
    this._elementTargets = a;
    let h = null;
    const d = this.moveable, p = s.persistData;
    if (p != null && p.children && (l = !0), s.individualGroupable)
      return Z(Iu, { ref: Rt(this, "moveable"), ...f, target: null, targets: a }, "individual-group");
    if (l) {
      const g = Uo(i, o);
      if (d && !d.props.groupable && !d.props.individualGroupable) {
        const m = d.props.target;
        m && a.indexOf(m) > -1 && (h = { ...d.state });
      }
      return Z(Vo, { ref: Rt(this, "moveable"), ...f, ...s.groupableProps ?? {}, target: null, targets: a, targetGroups: g, firstRenderState: h }, "group");
    } else {
      const g = a[0];
      if (d && (d.props.groupable || d.props.individualGroupable)) {
        const m = d.moveables || [], b = Ot(m, (S) => S.props.target === g);
        b && (h = { ...b.state });
      }
      return Z(de, { ref: Rt(this, "moveable"), ...f, target: g, firstRenderState: h }, "single");
    }
  }
  componentDidMount() {
    Bu(this, El, "moveable"), this._checkChangeTargets();
  }
  componentDidUpdate() {
    this._checkChangeTargets();
  }
  componentWillUnmount() {
    this.selectorMap = {}, this.refTargets = [];
  }
  /**
   * Get targets set in moveable through target or targets of props.
   * @method Moveable#getTargets
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body, {
   *    target: [targetRef, ".target", document.querySelectorAll(".target")],
   * });
   *
   * console.log(moveable.getTargets());
   */
  getTargets() {
    var t;
    return ((t = this.moveable) == null ? void 0 : t.getTargets()) ?? [];
  }
  /**
   * If the element list corresponding to the selector among the targets is changed, it is updated.
   * @method Moveable#updateSelectors
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body, {
   *    target: ".target",
   * });
   *
   * moveable.updateSelectors();
   */
  updateSelectors() {
    this.selectorMap = {}, this._updateRefs(), this.forceUpdate();
  }
  /**
   * User changes target and waits for target to change.
   * @method Moveable#waitToChangeTarget
   * @story combination-with-other-components--components-selecto
   * @example
   * document.querySelector(".target").addEventListener("mousedown", e => {
   *   moveable.waitToChangeTarget().then(() => {
   *      moveable.dragStart(e, e.currentTarget);
   *   });
   *   moveable.target = e.currentTarget;
   * });
   */
  waitToChangeTarget() {
    let t;
    return this._onChangeTargets = () => {
      this._onChangeTargets = null, t();
    }, new Promise((n) => {
      t = n;
    });
  }
  waitToChangeTargets() {
    return this.waitToChangeTarget();
  }
  getManager() {
    return this.moveable;
  }
  getMoveables() {
    return this.moveable.getMoveables();
  }
  getDragElement() {
    return this.moveable.getDragElement();
  }
  _updateRefs(t) {
    const n = this.refTargets, r = rs(this.props.target || this.props.targets), s = typeof document < "u";
    let i = Zo(n, r);
    const o = this.selectorMap, a = {};
    return this.refTargets.forEach(function l(c) {
      jt(c) ? o[c] ? a[c] = o[c] : s && (i = !0, a[c] = [].slice.call(document.querySelectorAll(c))) : at(c) && c.forEach(l);
    }), this._tmpRefTargets = r, this._tmpSelectorMap = a, [r, a, !t && i];
  }
  _checkChangeTargets() {
    var a, l, c;
    this.refTargets = this._tmpRefTargets, this.selectorMap = this._tmpSelectorMap;
    const { added: t, removed: n } = this._differ.update(this._elementTargets);
    (t.length || n.length) && ((l = (a = this.props).onChangeTargets) == null || l.call(a, {
      moveable: this.moveable,
      targets: this._elementTargets
    }), (c = this._onChangeTargets) == null || c.call(this));
    const [s, i, o] = this._updateRefs();
    this.refTargets = s, this.selectorMap = i, o && this.forceUpdate();
  }
}
Object.defineProperty(Nn, "defaultAbles", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: []
});
Object.defineProperty(Nn, "customStyledMap", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {}
});
Object.defineProperty(Nn, "defaultStyled", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: null
});
class Au extends Nn {
}
Object.defineProperty(Au, "defaultAbles", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: zu
});
const Gu = Ii(), $u = Gu.browser.name === "safari", me = "infinite-viewer-", Js = `${me}wrapper`, Qs = `${me}scroll-area`, ku = `${me}scroll-bar`, Ko = `${me}horizontal-scroll-bar`, Jo = `${me}vertical-scroll-bar`, ti = `${me}scroll-thumb`, Qo = kr(Xi(me, `
{
    position: relative;
    overscroll-behavior: none;
}
.wrapper {
    position: absolute;
    width: 100%;
    height: 100%;
    overflow: auto;
    scrollbar-width: none;
    top: 0;
    left: 0;
    will-change: scroll-position;
}
.restrict-wrapper {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
}
.wrapper::-webkit-scrollbar {
    display: none;
}
.scroll-area {
    position:absolute;
    top:0;
    left:0;
    transform-origin: 0 0;
}
.scroll-bar {
    position:absolute;
    width: 10px;
    height: 10px;
    box-sizing: border-box;
    right: 0;
    bottom: 0;
    overflow: hidden;
}
.horizontal-scroll-bar {
    width: calc(100% - 20px);
    right: 10px;
    height: 14px;
}
.vertical-scroll-bar {
    height: calc(100% - 20px);
    bottom: 10px;
    width: 14px;
}
.scroll-thumb {
    position:relative;
    opacity: 0.7;
    background: #333;
    border-radius: 3px;
    left: 0px;
    top: 0px;
    z-index: 10;
    width: 6px;
    height: 6px;
    transition: all ease 0.2s;
    opacity: 0;
}
.scroll-bar:hover .scroll-thumb {
    border-radius: 5px;
    opacity: 1;
}
.horizontal-scroll-bar .scroll-thumb {
    margin: 4px 0px;
    transition-property: opacity, margin, height, border-radius;
}
.vertical-scroll-bar .scroll-thumb {
    margin: 0px 4px;
    transition-property: opacity, margin, width, border-radius;
}
.horizontal-scroll-bar:hover .scroll-thumb {
    height: 10px;
    margin: 2px 0px;
}
.vertical-scroll-bar:hover .scroll-thumb {
    width: 10px;
    margin: 0px 2px;
}
`)), bt = {
  margin: 500,
  threshold: 100,
  zoom: 1,
  zoomX: 1,
  zoomY: 1,
  rangeX: [-1 / 0, 1 / 0],
  rangeY: [-1 / 0, 1 / 0],
  rangeOffsetX: [0, 0],
  rangeOffsetY: [0, 0],
  wrapperElement: null,
  scrollAreaElement: null,
  horizontalScrollElement: null,
  verticalScrollElement: null,
  usePinch: !1,
  useAutoZoom: !1,
  useMouseDrag: !1,
  pinchThreshold: 30,
  cspNonce: "",
  maxPinchWheel: 1 / 0,
  wheelScale: 0.01,
  displayHorizontalScroll: !0,
  displayVerticalScroll: !0,
  useTransform: !0,
  useWheelPinch: !0,
  zoomRange: [1e-3, 1 / 0],
  wheelPinchKey: "ctrl",
  useWheelScroll: $u,
  zoomOffsetX: "50%",
  zoomOffsetY: "50%",
  translateZ: 0,
  useGesture: !0,
  useResizeObserver: !1,
  pinchDirection: "all",
  preventWheelClick: !0,
  useBounceScrollBar: !1,
  useOverflowScroll: !1
}, ei = (e) => 1 - Math.pow(1 - e, 3), ni = {
  horizontal: {
    pos: "Left",
    coord: "X",
    size: "Width"
  },
  vertical: {
    pos: "Top",
    coord: "Y",
    size: "Height"
  }
}, ta = Qo.className, cs = [
  "margin",
  "threshold",
  "zoomOffsetX",
  "zoomOffsetY",
  "zoom",
  "zoomX",
  "zoomY",
  "rangeX",
  "rangeY",
  "rangeOffsetX",
  "rangeOffsetY",
  "usePinch",
  "useMouseDrag",
  "pinchThreshold",
  "maxPinchWheel",
  "wheelScale",
  "displayVerticalScroll",
  "displayHorizontalScroll",
  "translateZ",
  "useAutoZoom",
  "wheelPinchKey",
  "zoomRange",
  "zoomRangeX",
  "zoomRangeY",
  "pinchDirection",
  "useOverflowScroll"
], ju = [
  // ignore target, container,
  ...cs,
  "preventWheelClick",
  "useWheelPinch",
  "useWheelScroll",
  "useGesture",
  "cspNonce",
  "wrapperElement",
  "scrollAreaElement",
  "verticalScrollElement",
  "horizontalScrollElement",
  "useResizeObserver",
  "wheelContainer",
  "useBounceScrollBar"
], ea = [
  "scroll",
  "abortPinch",
  "dragStart",
  "dragEnd",
  "pinchStart",
  "pinch"
], Xu = [
  "getScrollLeft",
  "getScrollTop",
  "getScrollWidth",
  "getScrollHeight",
  "getContainerWidth",
  "getContainerHeight",
  "getViewportWidth",
  "getViewportHeight",
  "getViewportScrollWidth",
  "getViewportScrollHeight",
  "scrollTo",
  "scrollBy",
  "zoomBy",
  "scrollCenter",
  "getContainer",
  "getViewport",
  "getWrapper",
  "setZoom",
  "getRangeX",
  "getRangeY",
  "resize",
  "getZoom",
  "getZoomX",
  "getZoomY",
  "getWheelContainer",
  "setTo",
  "setBy"
], Yu = 1e-6;
function Fu(e) {
  const { deltaX: t, deltaY: n, datas: r } = e, s = Date.now(), i = r.speed;
  if (!i) {
    r.speed = [0, 0], r.time = s;
    return;
  }
  const o = s - r.time;
  r.speed = [
    i[0] / 2 + t / o,
    i[1] / 2 + n / o
  ];
}
function na(e, t) {
  const n = Math.sqrt(e[0] * e[0] + e[1] * e[1]);
  return Math.abs(n / t);
}
function Lu(e, t) {
  const n = na(e, t);
  return [-e[0] / 2 * n, -e[1] / 2 * n];
}
function Yt(e) {
  return Math.abs(e);
}
function Wu(e, t, n, r, s) {
  const i = s || isFinite(n[0]) ? n[0] : Math.min(-1, Math.floor(e / t)) * t - r, o = s || isFinite(n[1]) ? n[1] : Math.max(1, Math.ceil(e / t)) * t + r;
  return [i, o];
}
function ri(e, t) {
  return e ?? t;
}
function si(e, t, n) {
  const r = n.duration, s = n.easing || ((l) => 1 - Math.pow(1 - l, 3)), i = Date.now();
  let o = i;
  const a = () => {
    const l = Date.now();
    let c = l - i;
    r < c && (c = r);
    const u = s(c / r), f = s((o - i) / r);
    o = l, e(u - f), !(c >= r) && t(a);
  };
  t(a);
}
class ii extends Ie {
  constructor(t, n, r) {
    super(), Object.defineProperty(this, "type", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "isAppend", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "thumbElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "barElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "gesto", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "scrollSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "isHorizontal", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_onDragStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        const c = this.isHorizontal, u = l.inputEvent.target, f = l.datas, h = this.thumbElement === u;
        h || setTimeout(() => {
          requestAnimationFrame(() => {
            const d = this.thumbElement.getBoundingClientRect(), p = d[c ? "left" : "top"], g = d[c ? "width" : "height"], m = p + g, b = l[c ? "clientX" : "clientY"];
            if (p <= b && b <= m)
              return;
            const S = this.size, v = S * S / this.scrollSize;
            this.scrollBy(p < b ? v : -v);
          });
        }, 100), f.isThumb = h, l.inputEvent.stopPropagation(), l.inputEvent.preventDefault();
      }
    }), Object.defineProperty(this, "_onDrag", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        l.datas.isThumb && this.scrollBy(this.isHorizontal ? l.deltaX : l.deltaY);
      }
    }), Object.defineProperty(this, "_onWheel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        const c = this.isHorizontal ? l.deltaX : l.deltaY;
        c && l.preventDefault(), this.trigger("scroll", {
          delta: c
        });
      }
    });
    const s = n === "horizontal", i = Dt(t);
    let o, a = r;
    r ? o = r.querySelector(`.${ti}`) : (a = i.createElement("div"), o = i.createElement("div"), a.insertBefore(o, null), this.isAppend = !0), Ht(a, s ? Ko : Jo), Ht(a, ku), Ht(o, ti), this.thumbElement = o, this.barElement = a, this.isHorizontal = s, this.gesto = new Bn(a, {
      container: yt(i)
    }).on("dragStart", (l) => this._onDragStart(l)).on("drag", (l) => this._onDrag(l)), it(this.barElement, "wheel", this._onWheel, {
      passive: !1
    });
  }
  scrollBy(t, n) {
    const r = t / this.size;
    this.trigger("scroll", {
      delta: n ? t : this.scrollSize * r
    });
  }
  render(t, n, r, s) {
    this.size = r, this.scrollSize = s;
    const i = t && V(s - r, 1e-3) > 0 ? 1 : 0, [o, a] = this.isHorizontal ? ["X", "width"] : ["Y", "height"], l = r / s * 100, c = Math.max(0, n) / s * 100;
    this.thumbElement.style.cssText += `${a}: ${l}%;opacity: ${i};transform: translate${o}(${100 / l * c}%)`;
  }
  destroy() {
    et(this.barElement, "wheel", this._onWheel), this.gesto.off(), this.off();
  }
}
function Nu(e, t) {
  const n = e.prototype;
  t.forEach((r) => {
    const s = {
      enumerable: !0,
      configurable: !0,
      get() {
        return this.options[r];
      }
    }, i = xn(`set ${r}`);
    n[i] ? s.set = function(o) {
      this[i](o);
    } : s.set = function(o) {
      this.options[r] = o;
    }, Object.defineProperty(n, r, s);
  });
}
let ra = class extends Ie {
  /**
   * @sort 1
   */
  constructor(t, n = {}, r = {}) {
    super(), Object.defineProperty(this, "_containerElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "options", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "injectResult", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "wrapperElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "scrollAreaElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "horizontalScrollbar", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "verticalScrollbar", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "gesto", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "offsetX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "offsetY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "containerWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "containerHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "viewportWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "viewportHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "viewportScrollWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "viewportScrollHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "scrollLeft", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "scrollTop", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_scrollTimer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_zoomTimer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_viewportElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_wheelContainerElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "dragFlag", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "isLoop", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_tempScale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [1, 1]
    }), Object.defineProperty(this, "_tempRect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_tempRectTimer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_onDestroys", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_asLeft", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_asTop", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "resize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const { offsetWidth: s, offsetHeight: i } = this._containerElement, { offsetWidth: o, offsetHeight: a, scrollWidth: l, scrollHeight: c } = this._viewportElement;
        this.containerWidth = s, this.containerHeight = i, this.viewportWidth = o, this.viewportHeight = a, this.viewportScrollWidth = Math.max(o, l), this.viewportScrollHeight = Math.max(a, c), this.render(), this._scrollBy(0, 0);
      }
    }), Object.defineProperty(this, "_onScroll", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const { scrollLeft: s, scrollTop: i } = this.wrapperElement, { zoom: o = bt.zoom } = this, a = s - this.scrollLeft, l = i - this.scrollTop, c = this.getScrollLeft(), u = this.getScrollTop();
        this.isLoop && (this.isLoop = !1), this.scrollLeft = s, this.scrollTop = i, this.scrollTo(c + a / o, u + l / o);
      }
    }), Object.defineProperty(this, "onWheel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        const i = this.options, o = i.pinchDirection, a = i.maxPinchWheel || 1 / 0, l = s[`${this.wheelPinchKey}Key`] || s.ctrlKey;
        if (i.useWheelPinch && l) {
          let c = s.deltaY;
          const u = c >= 0 ? 1 : -1, f = Math.min(a, Math.abs(c));
          c = u * f;
          const h = -c, d = Math.max(1 + h * (i.wheelScale || 0.01), Yu);
          clearTimeout(this._tempRectTimer), this._tempRectTimer = window.setTimeout(() => {
            this._tempRect = null;
          }, 100), this._triggerPinch({
            distance: f,
            scale: d,
            rotation: 0,
            zoom: this.zoom * d,
            zoomX: this.zoomX * (o === "vertical" ? 1 : d),
            zoomY: this.zoomY * (o === "horizontal" ? 1 : d),
            inputEvent: s,
            isWheel: !0,
            clientX: s.clientX,
            clientY: s.clientY,
            ratioX: 0,
            ratioY: 0
          });
        } else if (i.useWheelScroll) {
          let c = s.deltaX, u = s.deltaY;
          s.shiftKey && !c && (c = u, u = 0), this.scrollBy(c / this.zoomX, u / this.zoomY);
        } else
          return;
        s.preventDefault();
      }
    }), Object.defineProperty(this, "onGestureStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        this._tempScale = [this.zoomX, this.zoomY], this._setClientRect(), s.preventDefault();
      }
    }), Object.defineProperty(this, "onGestureChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        if (s.preventDefault(), this.gesto.isFlag() || !this._tempScale) {
          this._tempScale = [1, 1];
          return;
        }
        const i = s.scale, o = this._tempScale[0], a = this._tempScale[1], l = this.options.pinchDirection;
        this._triggerPinch({
          distance: 0,
          scale: i,
          rotation: s.rotation,
          inputEvent: s,
          isWheel: !0,
          zoom: (o + a) * i / 2,
          zoomX: o * (l === "vertical" ? 1 : i),
          zoomY: a * (l === "horizontal" ? 1 : i),
          clientX: s.clientX,
          clientY: s.clientY,
          ratioX: 0,
          ratioY: 0
        });
      }
    }), Object.defineProperty(this, "onGestureEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
      }
    }), le(n) ? (this._viewportElement = n, this.options = {
      ...bt,
      ...r
    }) : (this._viewportElement = t.children[0], this.options = {
      ...bt,
      ...n
    }), this.init();
  }
  /**
   * Get Container Element
   */
  getContainer() {
    return this._containerElement;
  }
  /**
   * Get Wheel Container Element
   */
  getWheelContainer() {
    return this._wheelContainerElement;
  }
  /**
   * Get Viewport Element
   */
  getViewport() {
    return this._viewportElement;
  }
  /**
   * Get Wrapper Element
   */
  getWrapper() {
    return this.wrapperElement;
  }
  /**
   * Get Scroll Area Element
   */
  geScrollArea() {
    return this.scrollAreaElement;
  }
  /**
   * Destroy elements, properties, and events.
   */
  destroy() {
    this.off(), this.gesto.unset(), this.verticalScrollbar.destroy(), this.horizontalScrollbar.destroy(), this.injectResult.destroy();
    const t = this._containerElement;
    this._onDestroys.forEach((n) => {
      n();
    }), et(this.wrapperElement, "scroll", this._onScroll), et(this._wheelContainerElement, "wheel", this.onWheel), et(t, "gesturestart", this.onGestureStart), et(t, "gesturechange", this.onGestureChange), et(t, "gesturesend", this.onGestureEnd), this.gesto = null, this.injectResult = null, this._containerElement = null, this._viewportEPropertieslement = null, this.options = null;
  }
  /**
   * Gets the number of pixels that an element's content is scrolled vertically.
   */
  getScrollTop(t = {}) {
    let n = !1, r = !1;
    Et(t) ? (n = t.range, r = t.absolute) : n = t;
    const s = this.zoomY, i = this.scrollTop / s + this.offsetY + (n ? Yt(this.getRangeY()[0]) : 0);
    return r ? i * s : i;
  }
  /**
   * Gets the number of pixels that an element's content is scrolled vertically.
   */
  getScrollLeft(t = {}) {
    let n = !1, r = !1;
    Et(t) ? (n = t.range, r = t.absolute) : n = t;
    const s = this.zoomX, i = this.scrollLeft / s + this.offsetX + (n ? Yt(this.getRangeX()[0]) : 0);
    return r ? i * s : i;
  }
  /**
   * Gets measurement of the width of an element's content with overflow
   */
  getScrollWidth(t) {
    const n = this._getScrollRangeX(), r = this.zoomX, s = this.containerWidth / r + Yt(n[0]) + n[1];
    return t ? s : s * r;
  }
  /**
   * Gets measurement of the height of an element's content with overflow
   */
  getScrollHeight(t) {
    const n = this._getScrollRangeY(), r = this.zoomY, s = this.containerHeight / r + Yt(n[0]) + n[1];
    return t ? s : s * r;
  }
  /**
   * Scroll the element to the center
   */
  scrollCenter(t = {}) {
    this.resize();
    const n = this.zoomX, r = this.zoomY;
    let s = -(this.containerWidth / n - this.viewportWidth) / 2, i = -(this.containerHeight / r - this.viewportHeight) / 2;
    return t.absolute && (s *= n, i *= r), t.horizontal === !1 && (s = this.getScrollLeft()), t.vertical === !1 && (i = this.getScrollTop()), this.scrollTo(s, i, t);
  }
  /**
   * Move to that position or zoom.
   * @since 0.25.0
   */
  setTo(t) {
    const { x: n = this.getScrollLeft(), y: r = this.getScrollTop(), zoom: s = [this.getZoomX(), this.getZoomY()], duration: i } = t, { zoomX: o, zoomY: a, zoomRange: l } = this;
    let { zoomOffsetX: c = bt.zoomOffsetX, zoomOffsetY: u = bt.zoomOffsetY } = this;
    "zoomOffsetX" in t && (c = t.zoomOffsetX), "zoomOffsetY" in t && (u = t.zoomOffsetY);
    const [f, h] = at(s) ? s : [s, s], d = this.zoomRangeX || l, p = this.zoomRangeY || l, g = Bt(f, d[0], d[1]), m = Bt(h, p[0], p[1]), b = K(`${c}`, this.viewportWidth) * (1 / o - 1 / g), S = K(`${u}`, this.viewportHeight) * (1 / a - 1 / m);
    this.scrollTo(n - b, r - S, {
      duration: i
    }), this.setZoom(s, {
      zoomOffsetX: c,
      zoomOffsetY: u,
      duration: i,
      zoomBase: "fixed"
    });
  }
  /**
   * Move by the position or zoom delta value.
   * @since 0.25.0
   */
  setBy(t) {
    const { x: n = 0, y: r = 0, zoom: s = [0, 0] } = t, [i, o] = at(s) ? s : [s, s];
    this.setTo({
      ...t,
      x: this.getScrollLeft() + n,
      y: this.getScrollTop() + r,
      zoom: [this.zoomX + i, this.zoomY + o]
    });
  }
  /**
   * Scrolls the container by the given amount.
   */
  scrollBy(t, n, r) {
    if (this._pauseScrollAnimation(), !r || !r.duration) {
      let s = this.getScrollLeft(), i = this.getScrollTop();
      return r != null && r.absolute && (s *= this.zoomX, i *= this.zoomY), this._scrollTo(s + t, i + n, r);
    } else
      return this._startScrollAnimation([t, n], r), !0;
  }
  /**
   * Scrolls the container to set of coordinates.
   * @param scrollLeft
   * @param scrollTop
   */
  scrollTo(t, n, r) {
    if (this._pauseScrollAnimation(), !r || !r.duration)
      return this._scrollTo(t, n, r);
    {
      let s = this.getScrollLeft(), i = this.getScrollTop();
      return r != null && r.absolute && (s *= this.zoomX, i *= this.zoomY), this.scrollBy(t - s, n - i, r);
    }
  }
  /**
   * Set viewer zoom by the given amount
   */
  zoomBy(t, n) {
    this._pauseZoomAnimation();
    const [r, s] = at(t) ? t : [t, t];
    !n || !n.duration ? this._setZoom([this.zoomX + r, this.zoomY + s], n) : this._startZoomAnimation([r, s], n);
  }
  /**
   * Set viewer zoom
   */
  setZoom(t, n) {
    if (this._pauseZoomAnimation(), !n || !n.duration)
      this._setZoom(t, n);
    else {
      const [r, s] = at(t) ? t : [t, t];
      this._startZoomAnimation([r - this.zoomX, s - this.zoomY], n);
    }
  }
  getViewportWidth() {
    return this.viewportWidth;
  }
  getViewportHeight() {
    return this.viewportWidth;
  }
  getViewportScrollWidth() {
    return this.viewportScrollWidth;
  }
  getViewportScrollHeight() {
    return this.viewportScrollHeight;
  }
  getContainerWidth() {
    return this.containerWidth;
  }
  getContainerHeight() {
    return this.containerHeight;
  }
  /**
   * Get viewer zoom
   */
  getZoom() {
    return (this.zoomX + this.zoomY) / 2;
  }
  /**
   * Get viewer zoomX
   * @since 0.20.0
   */
  getZoomX() {
    return this.zoomX;
  }
  /**
   * Get viewer zoom
   * @since 0.20.0
   */
  getZoomY() {
    return this.zoomY;
  }
  /**
   * get x ranges
   */
  getRangeX(t, n) {
    return this._getRangeCoord("horizontal", t, n);
  }
  /**
   * get y ranges
   */
  getRangeY(t, n) {
    return this._getRangeCoord("vertical", t, n);
  }
  init() {
    const t = this._containerElement, n = this.options, r = Dt(t), s = yt(t);
    let i = n.wrapperElement || t.querySelector(`.${Js}`), o = n.scrollAreaElement || t.querySelector(`.${Qs}`);
    const a = n.horizontalScrollElement || t.querySelector(`.${Ko}`), l = n.verticalScrollElement || t.querySelector(`.${Jo}`);
    i || (i = r.createElement("div"), i.insertBefore(this._viewportElement, null), t.insertBefore(i, null)), this.wrapperElement = i, o || (o = r.createElement("div"), i.insertBefore(o, i.firstChild)), this.scrollAreaElement = o, Ht(t, ta), Ht(i, Js), Ht(o, Qs);
    const c = new ii(t, "horizontal", a), u = new ii(t, "vertical", l);
    this.horizontalScrollbar = c, this.verticalScrollbar = u, c.on("scroll", (d) => {
      this.scrollBy(d.delta / this.zoomX, 0);
    }), u.on("scroll", (d) => {
      this.scrollBy(0, d.delta / this.zoomY);
    }), c.isAppend && t.insertBefore(c.barElement, null), u.isAppend && t.insertBefore(u.barElement, null), this.injectResult = Qo.inject(t, {
      nonce: this.options.cspNonce
    });
    const f = n.wheelContainer;
    let h = null;
    if (f && (jt(f) ? h = r.querySelector(f) : le(f) ? h = f : ("value" in f || "current" in f) && (h = f.current || f.value)), h || (h = t), this._wheelContainerElement = h, this.gesto = new Bn(t, {
      container: yt(t),
      events: ["touch", "mouse"],
      preventWheelClick: this.options.preventWheelClick ?? !0
    }).on("dragStart", (d) => {
      const { inputEvent: p, stop: g, datas: m } = d;
      if (!this.useMouseDrag && d.isMouseEvent) {
        g();
        return;
      }
      if (this._pauseScrollAnimation(), this.dragFlag = !1, this.trigger("dragStart", d) === !1) {
        g();
        return;
      }
      p.preventDefault(), m.startEvent = p;
    }).on("drag", (d) => {
      !this.options.usePinch || d.isPinch || this.useMouseDrag && d.isMouseEvent ? (this.trigger("drag", {
        ...d,
        inputEvent: d.inputEvent
      }), Fu(d), this.scrollBy(-d.deltaX / this.zoomX, -d.deltaY / this.zoomY)) : !this.dragFlag && d.movement > n.pinchThreshold && (this.dragFlag = !0, this.trigger("abortPinch", {
        inputEvent: d.datas.startEvent || d.inputEvent
      }));
    }).on("dragEnd", (d) => {
      this.trigger("dragEnd", {
        isDrag: d.isDrag,
        isDouble: d.isDouble,
        inputEvent: d.inputEvent
      }), this._startScrollAnimationBySpeed(d.datas.speed);
    }).on("pinchStart", ({ inputEvent: d, datas: p, stop: g }) => {
      d.preventDefault(), this._pauseScrollAnimation(), p.startZoom = [this.zoomX, this.zoomY], this.trigger("pinchStart", {
        inputEvent: d
      }) === !1 && g(), this._setClientRect();
    }).on("pinch", (d) => {
      const p = d.scale, g = this.options.pinchDirection;
      this._triggerPinch({
        rotation: d.rotation,
        distance: d.distance,
        scale: d.scale,
        inputEvent: d.inputEvent,
        isWheel: !1,
        zoom: d.datas.startZoom * p,
        zoomX: this.zoomX * (g === "vertical" ? 1 : p),
        zoomY: this.zoomY * (g === "horizontal" ? 1 : p),
        clientX: d.clientX,
        clientY: d.clientY,
        ratioX: 0,
        ratioY: 0
      });
    }).on("pinchEnd", () => {
      this._tempRect = null;
    }), it(i, "scroll", this._onScroll), n.useResizeObserver) {
      const d = new s.ResizeObserver(() => {
        this.resize();
      });
      d.observe(this._viewportElement), d.observe(this._containerElement), this._onDestroys.push(() => {
        d.disconnect();
      });
    } else
      it(s, "resize", this.resize), this._onDestroys.push(() => {
        et(s, "resize", this.resize);
      });
    (n.useWheelPinch || n.useWheelScroll) && it(h, "wheel", this.onWheel, {
      passive: !1
    }), n.useGesture && (it(t, "gesturestart", this.onGestureStart, {
      passive: !1
    }), it(t, "gesturechange", this.onGestureChange, {
      passive: !1
    })), this.resize();
  }
  render() {
    const { offsetX: t, offsetY: n, zoomX: r = bt.zoomX, zoomY: s = bt.zoomY, translateZ: i = 0, rangeX: o, rangeY: a, containerWidth: l, containerHeight: c } = this, { useTransform: u = bt.useTransform } = this.options;
    let f = -t * r, h = -n * s;
    this.scrollAreaElement.style.cssText = `width:calc(100% + ${this.getScrollAreaWidth()}px);height:calc(100% + ${this.getScrollAreaHeight()}px);`;
    const d = this._viewportElement.style;
    u === !1 ? d.cssText += `position: relative; left: ${f}px; top: ${h}px; ` : d.cssText += `transform-origin: 0 0;transform:translate3d(${f}px, ${h}px, ${i}px) scale(${r}, ${s});`, this.renderScroll();
  }
  renderScroll() {
    const { zoomX: t, zoomY: n, containerWidth: r, containerHeight: s } = this, i = this.horizontalScrollbar, o = this.verticalScrollbar;
    if (this.options.useBounceScrollBar) {
      const a = this.getScrollLeft(!0) * t, l = this.getRangeX(!0), c = r + Yt(l[0]) + Yt(l[1]), u = this.getScrollTop(!0) * n, f = this.getRangeY(!0), h = s + Yt(f[0]) + Yt(f[1]);
      i.render(this.displayHorizontalScroll, a, r, c), o.render(this.displayVerticalScroll, u, s, h);
    } else {
      const a = this._getScrollRangeX(), l = this._getScrollRangeY(), c = this.getScrollLeft(), u = this.getScrollTop(), f = this.containerWidth + Yt(a[0]) + a[1], h = this.containerHeight + Yt(l[0]) + l[1];
      i.render(this.displayHorizontalScroll, c - a[0], r, f), o.render(this.displayVerticalScroll, u - l[0], s, h);
    }
  }
  move(t, n) {
    const r = this.wrapperElement;
    r.scrollLeft = t, r.scrollTop = n;
  }
  setDisplayVerticalScroll(t) {
    this.options.displayVerticalScroll = t, this.renderScroll();
  }
  setDisplayHorizontalScroll(t) {
    this.options.displayHorizontalScroll = t, this.renderScroll();
  }
  _startZoomAnimation(t, n) {
    if (!t)
      return;
    const r = n.duration, s = n.easing || ei;
    si((i) => this._setZoom([this.zoomX + t[0] * i, this.zoomY + t[1] * i], n), (i) => {
      this._zoomTimer = requestAnimationFrame(i);
    }, {
      easing: s,
      duration: r
    });
  }
  _startScrollAnimation(t, n) {
    if (!t[0] && !t[1])
      return;
    const r = n.duration, s = n.easing || ei;
    si((i) => this._scrollBy(t[0] * i, t[1] * i, n), (i) => {
      this._scrollTimer = requestAnimationFrame(i);
    }, {
      easing: s,
      duration: r
    });
  }
  _startScrollAnimationBySpeed(t) {
    if (!t || !t[0] && !t[1])
      return;
    const n = -6e-4, r = na(t, n), s = Lu(t, n);
    return this._startScrollAnimation(s, {
      duration: r
    });
  }
  _pauseScrollAnimation() {
    cancelAnimationFrame(this._scrollTimer), this._scrollTimer = 0;
  }
  _pauseZoomAnimation() {
    cancelAnimationFrame(this._zoomTimer), this._zoomTimer = 0;
  }
  getScrollAreaWidth() {
    const [t, n] = this.getRangeX(!0);
    return t || n ? this.margin * 2 : 0;
  }
  getScrollAreaHeight() {
    const [t, n] = this.getRangeY(!0);
    return t || n ? this.margin * 2 : 0;
  }
  _triggerPinch(t) {
    const { clientX: n, clientY: r, zoomX: s, zoomY: i } = t;
    this.useAutoZoom && this._zoomByClient([s, i], n, r), this._tempRect || this._setClientRect();
    const o = this.zoomRange, a = this.zoomRangeX || o, l = this.zoomRangeY || o, { left: c, top: u, width: f, height: h } = this._tempRect, d = (n - c) / f * 100, p = (r - u) / h * 100;
    this.trigger("pinch", {
      ...t,
      zoom: Bt((s + i) / 2, o[0], o[1]),
      zoomX: Bt(s, a[0], a[1]),
      zoomY: Bt(i, l[0], l[1]),
      ratioX: d,
      ratioY: p
    });
  }
  _setClientRect() {
    const t = this.getContainer().getBoundingClientRect();
    this._tempRect = {
      left: t.left,
      top: t.top,
      width: t.width,
      height: t.height
    };
  }
  _zoomByClient(t, n, r) {
    this._tempRect || this._setClientRect();
    const { left: s, top: i, width: o, height: a } = this._tempRect, l = this.options, c = l.zoomOffsetX, u = l.zoomOffsetY;
    l.zoomOffsetX = `${(n - s) / o * 100}%`, l.zoomOffsetY = `${(r - i) / a * 100}%`, this._setZoom(t, {
      zoomBase: "screen"
    }), l.zoomOffsetX = c, l.zoomOffsetY = u;
  }
  _setZoom(t, n = {}) {
    const r = n.zoomBase, { containerWidth: s, containerHeight: i, zoomX: o, zoomY: a, zoomRange: l } = this;
    let { zoomOffsetX: c = bt.zoomOffsetX, zoomOffsetY: u = bt.zoomOffsetY } = this;
    "zoomOffsetX" in n && (c = n.zoomOffsetX), "zoomOffsetY" in n && (u = n.zoomOffsetY);
    const f = this.getScrollLeft(), h = this.getScrollTop(), [d, p] = at(t) ? t : [t, t], g = this.zoomRangeX || l, m = this.zoomRangeY || l, b = Bt(d, g[0], g[1]), S = Bt(p, m[0], m[1]), v = this.options;
    v.zoomX = b, v.zoomY = S, v.zoom = (b + S) / 2;
    const E = this.getScrollLeft(), x = this.getScrollTop();
    let w = 0, D = 0;
    r === "fixed" ? (w = K(`${c}`, this.viewportWidth), D = K(`${u}`, this.viewportHeight)) : r === "viewport" ? (w = (-f + K(`${c}`, this.viewportWidth)) * o, D = (-h + K(`${u}`, this.viewportHeight)) * a) : (w = K(`${c}`, s), D = K(`${u}`, i));
    const C = f + w / o, P = h + D / a, M = E + w / b, y = x + D / S;
    this._scrollBy(C - M, P - y, {
      zoom: !!(b - o || S - a)
    }), this.render();
  }
  _scrollBy(t, n, r) {
    let s = this.getScrollLeft(), i = this.getScrollTop();
    return r != null && r.absolute && (s *= this.zoomX, i *= this.zoomY), this._scrollTo(s + t, i + n, r);
  }
  _scrollTo(t, n, r) {
    const { scrollLeft: s, scrollTop: i } = this, o = r == null ? void 0 : r.absolute;
    this._scrollToType("horizontal", t, o), this._scrollToType("vertical", n, o);
    const a = this.scrollLeft, l = this.scrollTop;
    this.render();
    const c = this.getScrollLeft(), u = this.getScrollTop();
    return this._emitScrollEvent(c, u, r == null ? void 0 : r.zoom), Math.round(s) !== a || Math.round(i) !== l ? (this.isLoop = !0, this.move(a, l), requestAnimationFrame(() => {
      if (!this.isLoop)
        return;
      this.isLoop = !1;
      const { scrollLeft: f, scrollTop: h } = this.wrapperElement;
      this.scrollLeft = f, this.scrollTop = h, (a !== Math.round(f) || l !== Math.round(h)) && this._scrollTo(c, u);
    }), !1) : !0;
  }
  _scrollToType(t, n, r) {
    const s = ni[t], { margin: i = bt.margin, threshold: o = bt.threshold } = this, a = this[`scroll${s.pos}`], [l, c] = this[`getRange${s.coord}`](!0, !0);
    let u = Math.round(a);
    const f = this[`getScrollArea${s.size}`](), h = this[`zoom${s.coord}`];
    r && (n = n / h);
    const d = n * h;
    if (l === c)
      u = l, n = l / h;
    else if (d - o <= l) {
      const p = Math.max(0, d - l);
      u = p, n = (l + p) / h;
    } else if (d + o >= c) {
      const p = Math.max(0, c - d);
      u = f - p, n = (c - p) / h;
    } else u < o ? u += i : u > f - o && (u -= i);
    u = Math.round(u), this[`scroll${s.pos}`] = u, this[`offset${s.coord}`] = n - u / h;
  }
  _getRangeCoord(t, n, r) {
    const { margin: s = bt.margin, threshold: i } = this, o = ni[t], a = ri(this[`range${o.coord}`], bt[`range${o.coord}`]), l = ri(this[`rangeOffset${o.coord}`], bt[`rangeOffset${o.coord}`]), c = this[`zoom${o.coord}`], u = Wu(this[`getScroll${o.pos}`](), s, a, i, r);
    return n ? [
      u[0] * c + l[0],
      this.options.useOverflowScroll ? Math.max(this[`viewport${o.size}`] * c - this[`container${o.size}`], u[1] * c + l[1]) : u[1] * c + l[1]
    ] : [u[0] + l[0], u[1] + l[1]];
  }
  _emitScrollEvent(t, n, r) {
    const s = this._asLeft, i = this._asTop;
    !r && s === t && i === n || (this._asLeft = t, this._asTop = n, this.trigger("scroll", {
      scrollLeft: t,
      scrollTop: n,
      zoomX: this.zoomX,
      zoomY: this.zoomY
    }));
  }
  _getScrollRangeX() {
    const t = this.getScrollLeft(), n = this.rangeX, r = n[0];
    let s = n[1];
    this.useOverflowScroll && isFinite(s) && (s = Math.max(s, this.viewportWidth - this.containerWidth / this.zoomX));
    const i = Math.min(0, isFinite(r) ? Math.min(r, t) : t), o = Math.max(0, isFinite(s) ? Math.max(s, t) : t), a = this.viewportScrollWidth, l = Math.max(this.containerWidth / this.zoomX, a) - a;
    return [Math.min(0, l + i), o];
  }
  _getScrollRangeY() {
    const t = this.getScrollTop(), n = this.rangeY, r = n[0];
    let s = n[1];
    this.useOverflowScroll && isFinite(s) && (s = Math.max(s, this.viewportHeight - this.containerHeight / this.zoomY));
    const i = Math.min(0, isFinite(r) ? Math.min(r, t) : t), o = Math.max(0, isFinite(s) ? Math.max(s, t) : t), a = this.viewportScrollHeight, l = Math.max(this.containerHeight / this.zoomY, a) - a;
    return [Math.min(0, l + i), o];
  }
};
Nu(ra, [...cs]);
const oi = ea.map((e) => xn(`on ${e}`));
function Hu(e, t, n, r = {}) {
  t.forEach((s) => {
    const i = r[s] || s;
    i in e || (e[i] = function(...o) {
      const a = this[n][s](...o);
      return a === this[n] ? this : a;
    });
  });
}
class Ku extends Or.PureComponent {
  constructor() {
    super(...arguments), Object.defineProperty(this, "infiniteViewer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "containerElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "wrapperElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "scrollAreaElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "horizontalScrollElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "verticalScrollElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  render() {
    const t = this.props.className;
    return Pe("div", { className: `${t || ""} ${ta}`, ref: Rt(this, "containerElement"), children: [Pe("div", { className: "infinite-viewer-wrapper", ref: Rt(this, "wrapperElement"), children: [Z("div", { className: "infinite-viewer-scroll-area", ref: Rt(this, "scrollAreaElement") }), this.props.children] }), Z("div", { className: "infinite-viewer-scroll-bar infinite-viewer-horizontal-scroll-bar", ref: Rt(this, "horizontalScrollElement"), children: Z("div", { className: "infinite-viewer-scroll-thumb" }) }), Z("div", { className: "infinite-viewer-scroll-bar infinite-viewer-vertical-scroll-bar", ref: Rt(this, "verticalScrollElement"), children: Z("div", { className: "infinite-viewer-scroll-thumb" }) })] });
  }
  componentDidMount() {
    const t = this.props, n = {};
    ju.forEach((r) => {
      r in t && typeof t[r] < "u" && (n[r] = t[r]);
    }), this.infiniteViewer = new ra(this.containerElement, this.scrollAreaElement.nextElementSibling, {
      ...n,
      wrapperElement: this.wrapperElement,
      scrollAreaElement: this.scrollAreaElement,
      horizontalScrollElement: this.horizontalScrollElement,
      verticalScrollElement: this.verticalScrollElement
    }), Hu(this, Xu, "infiniteViewer"), ea.forEach((r, s) => {
      this.infiniteViewer.on(r, (i) => {
        const o = this.props;
        (o[oi[s]] && o[oi[s]](i)) === !1 && i.stop();
      });
    });
  }
  componentDidUpdate(t) {
    const n = this.props, r = this.infiniteViewer;
    cs.forEach((s) => {
      s in n && r[s] !== n[s] && (r[s] = n[s]);
    });
  }
  componentWillUnmount() {
    this.infiniteViewer.destroy();
  }
  getElement() {
    return this.containerElement;
  }
}
export {
  Au as Moveable,
  Uu as Selection,
  Ku as Viewer
};
