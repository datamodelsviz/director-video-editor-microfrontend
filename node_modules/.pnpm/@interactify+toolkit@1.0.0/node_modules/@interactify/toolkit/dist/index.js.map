{"version":3,"file":"index.js","sources":["../src/lib/utility/consts.ts","../src/lib/utility/utils.ts","../src/lib/utility/dom.ts","../src/lib/event-emitter/event-emitter.ts","../src/lib/gesto/utils.ts","../src/lib/gesto/client-store.ts","../src/lib/gesto/gesto.ts","../src/lib/differ/list-differ.ts","../src/lib/differ/consts.ts","../src/lib/differ/children-differ.ts","../src/lib/drag-scroll/drag-scroll.ts","../src/lib/overlap-area/utils.ts","../src/lib/overlap-area/overlap-area.ts","../src/lib/matrix/index.ts","../src/lib/css-to-mat/css-to-matrix.ts","../src/lib/selecto/utils.ts","../src/lib/css-styled/utils.ts","../src/lib/css-styled/styled.ts","../src/lib/selecto/consts.ts","../src/lib/selecto/selecto.tsx","../src/lib/moveable/ables/able-manager.ts","../node_modules/.pnpm/@egjs+agent@2.4.4/node_modules/@egjs/agent/dist/agent.esm.js","../src/lib/moveable/consts.ts","../src/lib/utility/framework.ts","../src/lib/moveable/gesto/custom-gesto.ts","../src/lib/moveable/utils/calculate-element-position.ts","../src/lib/moveable/gesto/gesto-utils.ts","../src/lib/moveable/gesto/gesto-data.ts","../src/lib/moveable/utils/get-matrix-stack-info.ts","../src/lib/moveable/store/store.ts","../src/lib/moveable/group-utils.ts","../src/lib/moveable/render-directions.tsx","../src/lib/moveable/ables/snappable/bounds.ts","../src/lib/moveable/ables/snappable/utils.ts","../src/lib/moveable/ables/snappable/names.ts","../src/lib/moveable/ables/snappable/snap.ts","../src/lib/moveable/ables/snappable/inner-bounds.ts","../src/lib/moveable/ables/snappable/snap-bounds.ts","../src/lib/moveable/ables/draggable.tsx","../src/lib/moveable/utils/get-fixed-direction.ts","../src/lib/moveable/ables/resizable.ts","../src/lib/moveable/ables/rotatable.tsx","../src/lib/moveable/ables/snappable/render.tsx","../src/lib/moveable/ables/snappable/get-total-guidelines.ts","../src/lib/moveable/ables/snappable.tsx","../src/lib/moveable/utils.ts","../src/lib/moveable/ables/pinchable.ts","../src/lib/moveable/ables/scalable.ts","../src/lib/moveable/ables/warpable.tsx","../src/lib/moveable/classnames.ts","../src/lib/moveable/ables/drag-area.tsx","../src/lib/moveable/ables/Origin.tsx","../src/lib/moveable/ables/scrollable.ts","../src/lib/moveable/ables/default.ts","../src/lib/moveable/ables/padding.tsx","../src/lib/moveable/ables/roundable/border-radius.tsx","../src/lib/moveable/ables/clippable/utils.tsx","../src/lib/moveable/ables/clippable.tsx","../src/lib/moveable/ables/origin-draggable.tsx","../src/lib/moveable/ables/roundable.tsx","../src/lib/moveable/ables/before-renderable.ts","../src/lib/moveable/ables/renderable.ts","../src/lib/moveable/gesto/get-able-gesto.ts","../src/lib/moveable/event-manager.ts","../src/lib/react-css-styled/styled.tsx","../src/lib/moveable/utils/calculate-matrix-stack.ts","../src/lib/moveable/utils/get-element-info.ts","../src/lib/moveable/utils/get-moveable-target-info.ts","../src/lib/moveable/utils/persist.ts","../src/lib/moveable/moveable-manager.tsx","../src/lib/moveable/ables/groupable.tsx","../src/lib/moveable/ables/clickable.ts","../src/lib/moveable/ables/edge-draggable.tsx","../src/lib/moveable/ables/individual-groupable.tsx","../src/lib/moveable/ables/consts.ts","../src/lib/moveable/snappable/utils.ts","../src/lib/moveable/moveable-group.tsx","../src/lib/moveable/moveable-individual-group.tsx","../src/lib/moveable/initial-moveable.tsx","../src/lib/moveable/moveable.tsx","../src/lib/infinite-viewer/consts.ts","../src/lib/infinite-viewer/utils.ts","../src/lib/infinite-viewer/scroll-bar.ts","../src/lib/infinite-viewer/infinite-viewer.tsx","../src/lib/react-infinite-viewer/consts.ts","../src/lib/react-infinite-viewer/infinite-viewer.tsx"],"sourcesContent":["/**\n * @namespace\n * @name Consts\n */\n\nimport { IObject, OpenCloseCharacter } from \"./types\";\n\n/**\n* get string \"rgb\"\n* @memberof Color\n* @example\nimport {RGB} from \"utility\";\n\nconsole.log(RGB); // \"rgb\"\n*/\nexport const RGB = \"rgb\";\n/**\n* get string \"rgba\"\n* @memberof Color\n* @example\nimport {RGBA} from \"utility\";\n\nconsole.log(RGBA); // \"rgba\"\n*/\nexport const RGBA = \"rgba\";\n/**\n* get string \"hsl\"\n* @memberof Color\n* @example\nimport {HSL} from \"utility\";\n\nconsole.log(HSL); // \"hsl\"\n*/\nexport const HSL = \"hsl\";\n/**\n* get string \"hsla\"\n* @memberof Color\n* @example\nimport {HSLA} from \"utility\";\n\nconsole.log(HSLA); // \"hsla\"\n*/\nexport const HSLA = \"hsla\";\n/**\n* gets an array of color models.\n* @memberof Color\n* @example\nimport {COLOR_MODELS} from \"utility\";\n\nconsole.log(COLOR_MODELS); // [\"rgb\", \"rgba\", \"hsl\", \"hsla\"];\n*/\nexport const COLOR_MODELS = [RGB, RGBA, HSL, HSLA];\n\n/**\n* get string \"function\"\n* @memberof Consts\n* @example\nimport {FUNCTION} from \"utility\";\n\nconsole.log(FUNCTION); // \"function\"\n*/\nexport const FUNCTION = \"function\";\n/**\n* get string \"property\"\n* @memberof Consts\n* @example\nimport {PROPERTY} from \"utility\";\n\nconsole.log(PROPERTY); // \"property\"\n*/\nexport const PROPERTY = \"property\";\n/**\n* get string \"array\"\n* @memberof Consts\n* @example\nimport {ARRAY} from \"utility\";\n\nconsole.log(ARRAY); // \"array\"\n*/\nexport const ARRAY = \"array\";\n/**\n* get string \"object\"\n* @memberof Consts\n* @example\nimport {OBJECT} from \"utility\";\n\nconsole.log(OBJECT); // \"object\"\n*/\nexport const OBJECT = \"object\";\n/**\n* get string \"string\"\n* @memberof Consts\n* @example\nimport {STRING} from \"utility\";\n\nconsole.log(STRING); // \"string\"\n*/\nexport const STRING = \"string\";\n/**\n* get string \"number\"\n* @memberof Consts\n* @example\nimport {NUMBER} from \"utility\";\n\nconsole.log(NUMBER); // \"number\"\n*/\nexport const NUMBER = \"number\";\n/**\n* get string \"undefined\"\n* @memberof Consts\n* @example\nimport {UNDEFINED} from \"utility\";\n\nconsole.log(UNDEFINED); // \"undefined\"\n*/\nexport const UNDEFINED = \"undefined\";\n\n/**\n* Check whether the environment is window or node.js.\n* @memberof Consts\n* @example\nimport {IS_WINDOW} from \"utility\";\n\nconsole.log(IS_WINDOW); // false in node.js\nconsole.log(IS_WINDOW); // true in browser\n*/\nexport const IS_WINDOW = typeof window !== UNDEFINED;\n\n/**\n* Check whether the environment is window or node.js.\n* @memberof Consts\n* @name document\n* @example\nimport {IS_WINDOW} from \"utility\";\n\nconsole.log(IS_WINDOW); // false in node.js\nconsole.log(IS_WINDOW); // true in browser\n*/\nconst doc = (typeof document !== UNDEFINED && document) as Document; // FIXME: this type maybe false\n\nexport { doc as document };\n\nconst prefixes: string[] = [\"webkit\", \"ms\", \"moz\", \"o\"];\n\n/**\n * @namespace CrossBrowser\n */\n\n/**\n* Get a CSS property with a vendor prefix that supports cross browser.\n* @function\n* @param {string} property - A CSS property\n* @return {string} CSS property with cross-browser vendor prefix\n* @memberof CrossBrowser\n* @example\nimport {getCrossBrowserProperty} from \"utility\";\n\nconsole.log(getCrossBrowserProperty(\"transform\")); // \"transform\", \"-ms-transform\", \"-webkit-transform\"\nconsole.log(getCrossBrowserProperty(\"filter\")); // \"filter\", \"-webkit-filter\"\n*/\nexport const getCrossBrowserProperty = /*#__PURE__*/ (property: string) => {\n  if (!doc) {\n    return \"\";\n  }\n  const styles = (doc.body || doc.documentElement).style as any;\n  const length = prefixes.length;\n\n  if (typeof styles[property] !== UNDEFINED) {\n    return property;\n  }\n  for (let i = 0; i < length; ++i) {\n    const name = `-${prefixes[i]}-${property}`;\n\n    if (typeof styles[name] !== UNDEFINED) {\n      return name;\n    }\n  }\n  return \"\";\n};\n\n/**\n* get string \"transfrom\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {TRANSFORM} from \"utility\";\n\nconsole.log(TRANSFORM); // \"transform\", \"-ms-transform\", \"-webkit-transform\"\n*/\nexport const TRANSFORM = /*#__PURE__*/ getCrossBrowserProperty(\"transform\");\n/**\n* get string \"filter\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {FILTER} from \"utility\";\n\nconsole.log(FILTER); // \"filter\", \"-ms-filter\", \"-webkit-filter\"\n*/\nexport const FILTER = /*#__PURE__*/ getCrossBrowserProperty(\"filter\");\n/**\n* get string \"animation\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {ANIMATION} from \"utility\";\n\nconsole.log(ANIMATION); // \"animation\", \"-ms-animation\", \"-webkit-animation\"\n*/\nexport const ANIMATION = /*#__PURE__*/ getCrossBrowserProperty(\"animation\");\n/**\n* get string \"keyframes\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {KEYFRAMES} from \"utility\";\n\nconsole.log(KEYFRAMES); // \"keyframes\", \"-ms-keyframes\", \"-webkit-keyframes\"\n*/\nexport const KEYFRAMES = /*#__PURE__*/ ANIMATION.replace(\n  \"animation\",\n  \"keyframes\"\n);\n\nexport const OPEN_CLOSED_CHARACTERS: OpenCloseCharacter[] = [\n  { open: \"(\", close: \")\" },\n  { open: `\"`, close: `\"` },\n  { open: `'`, close: `'` },\n  { open: `\\\\\"`, close: `\\\\\"` },\n  { open: `\\\\'`, close: `\\\\'` },\n];\nexport const TINY_NUM = 0.0000001;\nexport const REVERSE_TINY_NUM = 1 / TINY_NUM;\nexport const DEFAULT_UNIT_PRESETS: IObject<\n  (pos: number, size?: number) => number\n> = {\n  cm: (pos) => (pos * 96) / 2.54,\n  mm: (pos) => (pos * 96) / 254,\n  in: (pos) => pos * 96,\n  pt: (pos) => (pos * 96) / 72,\n  pc: (pos) => (pos * 96) / 6,\n  \"%\": (pos, size) => (pos * size!) / 100,\n  vw: (pos, size = window.innerWidth) => (pos / 100) * size,\n  vh: (pos, size = window.innerHeight) => (pos / 100) * size,\n  vmax: (pos, size = Math.max(window.innerWidth, window.innerHeight)) =>\n    (pos / 100) * size,\n  vmin: (pos, size = Math.min(window.innerWidth, window.innerHeight)) =>\n    (pos / 100) * size,\n};\n","/* Class Decorator */\n\nimport {\n  DEFAULT_UNIT_PRESETS,\n  FUNCTION,\n  IS_WINDOW,\n  NUMBER,\n  OBJECT,\n  OPEN_CLOSED_CHARACTERS,\n  STRING,\n  TINY_NUM,\n  UNDEFINED,\n} from \"./consts\";\nimport { IObject, OpenCloseCharacter, SplitOptions } from \"./types\";\n\n/**\n * Gets the direction of the shape.\n * @function\n * @memberof Utils\n */\nexport function getShapeDirection(points: number[][]): 1 | -1 {\n  const center = getCenterPoint(points);\n  const pos1Rad = getRad(center, points[0]);\n  const pos2Rad = getRad(center, points[1]);\n\n  return (pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI) ||\n    (pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI)\n    ? 1\n    : -1;\n}\n\n/**\n * Get the average point of all points.\n * @function\n * @memberof Utils\n */\nexport function getCenterPoint(points: number[][]): number[] {\n  return [0, 1].map((i) => average(points.map((pos) => pos[i])));\n}\n\n/**\n * Get the angle of two points. (0 <= rad < 359)\n * @function\n * @memberof Utils\n */\nexport function getRad(pos1: number[], pos2: number[]): number {\n  const distX = pos2[0] - pos1[0];\n  const distY = pos2[1] - pos1[1];\n  const rad = Math.atan2(distY, distX);\n\n  return rad >= 0 ? rad : rad + Math.PI * 2;\n}\n\n/**\n * Average all numbers.\n * @function\n * @memberof Utils\n */\nexport function average(nums: number[]) {\n  const length = nums.length;\n  let total = 0;\n\n  for (let i = length - 1; i >= 0; --i) {\n    total += nums[i];\n  }\n  return length ? total / length : 0;\n}\n\n/**\n * Get the distance between two points.\n * @function\n * @memberof Utils\n */\nexport function getDist(a: number[], b?: number[]) {\n  return Math.sqrt(\n    Math.pow((b ? b[0] : 0) - a[0], 2) + Math.pow((b ? b[1] : 0) - a[1], 2)\n  );\n}\n\n/**\n* Returns the index of the first element in the array that satisfies the provided testing function.\n* @function\n* @memberof CrossBrowser\n* @param - The array `findIndex` was called upon.\n* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.\n* @param - Returns defaultIndex if not found by the function.\n* @example\nimport { findIndex } from \"utility\";\n\nfindIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1\n*/\nexport function findIndex<T>(\n  arr: T[],\n  callback: (element: T, index: number, arr: T[]) => any,\n  defaultIndex: number = -1\n): number {\n  const length = arr.length;\n\n  for (let i = 0; i < length; ++i) {\n    if (callback(arr[i], i, arr)) {\n      return i;\n    }\n  }\n  return defaultIndex;\n}\n\n/**\n * throttle number depending on the unit.\n * @function\n * @memberof Utils\n */\nexport function throttle(num: number, unit?: number) {\n  if (!unit) {\n    return num;\n  }\n  const reverseUnit = 1 / unit;\n  return Math.round(num / unit) / reverseUnit;\n}\n\n/**\n * throttle number array depending on the unit.\n * @function\n * @memberof Utils\n */\nexport function throttleArray(nums: number[], unit?: number) {\n  nums.forEach((_, i) => {\n    nums[i] = throttle(nums[i], unit);\n  });\n  return nums;\n}\n\n/**\n* Returns the value of the first element in the array that satisfies the provided testing function.\n* @function\n* @memberof CrossBrowser\n* @param - The array `find` was called upon.\n* @param - A function to execute on each value in the array,\n* @param - Returns defalutValue if not found by the function.\n* @example\nimport { find } from \"utility\";\n\nfind([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // {a: 2}\n*/\nexport function find<T>(\n  arr: T[],\n  callback: (element: T, index: number, arr: T[]) => any,\n  defalutValue?: T\n): T | undefined {\n  const index = findIndex(arr, callback);\n\n  return index > -1 ? arr[index] : defalutValue;\n}\n\nexport function isObject(value: any): value is IObject<any> {\n  return value && typeof value === OBJECT;\n}\n\n/**\n* Check the type that the value is string.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isString} from \"utility\";\n\nconsole.log(isString(\"1234\")); // true\nconsole.log(isString(undefined)); // false\nconsole.log(isString(1)); // false\nconsole.log(isString(null)); // false\n*/\nexport function isString(value: any): value is string {\n  return typeof value === STRING;\n}\n\n/**\n* Check the type that the value is isArray.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isArray} from \"utility\";\n\nconsole.log(isArray([])); // true\nconsole.log(isArray({})); // false\nconsole.log(isArray(undefined)); // false\nconsole.log(isArray(null)); // false\n*/\nexport function isArray(value: any): value is any[] {\n  return Array.isArray(value);\n}\n\n/**\n* transform strings to camel-case\n* @memberof Utils\n* @param {String} text - string\n* @return {String} camel-case string\n* @example\nimport {camelize} from \"utility\";\n\nconsole.log(camelize(\"transform-origin\")); // transformOrigin\nconsole.log(camelize(\"abcd_efg\")); // abcdEfg\nconsole.log(camelize(\"abcd efg\")); // abcdEfg\n*/\nexport function camelize(str: string) {\n  return str.replace(/[\\s-_]+([^\\s-_])/g, (all, letter) =>\n    letter.toUpperCase()\n  );\n}\n\n/**\n* transform a camelized string into a lowercased string.\n* @memberof Utils\n* @param {string} text - a camel-cased string\n* @param {string} [separator=\"-\"] - a separator\n* @return {string}  a lowercased string\n* @example\nimport {decamelize} from \"utility\";\n\nconsole.log(decamelize(\"transformOrigin\")); // transform-origin\nconsole.log(decamelize(\"abcdEfg\", \"_\")); // abcd_efg\n*/\nexport function decamelize(str: string, separator: string = \"-\") {\n  return str.replace(\n    /([a-z])([A-Z])/g,\n    (all, letter, letter2) => `${letter}${separator}${letter2.toLowerCase()}`\n  );\n}\n\n/**\n* Check the type that the value is function.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isFunction} from \"utility\";\n\nconsole.log(isFunction(function a() {})); // true\nconsole.log(isFunction(() => {})); // true\nconsole.log(isFunction(\"1234\")); // false\nconsole.log(isFunction(1)); // false\nconsole.log(isFunction(null)); // false\n*/\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === FUNCTION;\n}\n\n/**\n* Check the type that the value is undefined.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {boolean} true if the type is correct, false otherwise\n* @example\nimport {isUndefined} from \"utility\";\n\nconsole.log(isUndefined(undefined)); // true\nconsole.log(isUndefined(\"\")); // false\nconsole.log(isUndefined(1)); // false\nconsole.log(isUndefined(null)); // false\n*/\nexport function isUndefined(value: any): value is undefined {\n  return typeof value === UNDEFINED;\n}\n\nexport function isNumber(value: any): value is number {\n  return typeof value === NUMBER;\n}\n\nfunction isEqualSeparator(character: string, separator: string) {\n  const isCharacterSpace = character === \"\" || character == \" \";\n  const isSeparatorSpace = separator === \"\" || separator == \" \";\n\n  return (isSeparatorSpace && isCharacterSpace) || character === separator;\n}\n\n/**\n * calculate between min, max\n * @function\n * @memberof Utils\n */\nexport function between(value: number, min: number, max: number): number {\n  return Math.max(min, Math.min(value, max));\n}\n\n/**\n* divide text by number and unit.\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {} divided texts\n* @example\nimport {splitUnit} from \"utility\";\n\nconsole.log(splitUnit(\"10px\"));\n// {prefix: \"\", value: 10, unit: \"px\"}\nconsole.log(splitUnit(\"-10px\"));\n// {prefix: \"\", value: -10, unit: \"px\"}\nconsole.log(splitUnit(\"a10%\"));\n// {prefix: \"a\", value: 10, unit: \"%\"}\n*/\nexport function splitUnit(text: string): {\n  prefix: string;\n  unit: string;\n  value: number;\n} {\n  const matches = /^([^\\d|e|\\-|\\+]*)((?:\\d|\\.|-|e-|e\\+)+)(\\S*)$/g.exec(text);\n\n  if (!matches) {\n    return { prefix: \"\", unit: \"\", value: NaN };\n  }\n  const prefix = matches[1];\n  const value = matches[2];\n  const unit = matches[3];\n\n  return { prefix, unit, value: parseFloat(value) };\n}\n\n/**\n* divide text by comma.\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {Array} divided texts\n* @example\nimport {splitComma} from \"utility\";\n\nconsole.log(splitComma(\"a,b,c,d,e,f,g\"));\n// [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\nconsole.log(splitComma(\"'a,b',c,'d,e',f,g\"));\n// [\"'a,b'\", \"c\", \"'d,e'\", \"f\", \"g\"]\n*/\nexport function splitComma(text: string): string[] {\n  // divide comma(,)\n  // \"[^\"]*\"|'[^']*'\n  return splitText(text, \",\");\n}\n/**\n* divide text by bracket \"(\", \")\".\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {object} divided texts\n* @example\nimport {splitBracket} from \"utility\";\n\nconsole.log(splitBracket(\"a(1, 2)\"));\n// {prefix: \"a\", value: \"1, 2\", suffix: \"\"}\nconsole.log(splitBracket(\"a(1, 2)b\"));\n// {prefix: \"a\", value: \"1, 2\", suffix: \"b\"}\n*/\nexport function splitBracket(text: string) {\n  const matches = /([^(]*)\\(([\\s\\S]*)\\)([\\s\\S]*)/g.exec(text);\n\n  if (!matches || matches.length < 4) {\n    return {};\n  } else {\n    return { prefix: matches[1], value: matches[2], suffix: matches[3] };\n  }\n}\n\n/**\n * calculate bound size\n * @function\n * @memberof Utils\n */\nexport function calculateBoundSize(\n  size: number[],\n  minSize: number[],\n  maxSize: number[],\n  keepRatio?: number | boolean\n): number[] {\n  if (!keepRatio) {\n    return size.map((value, i) => between(value, minSize[i], maxSize[i]));\n  }\n  let [width, height] = size;\n\n  const ratio = keepRatio === true ? width / height : keepRatio;\n  // width : height = minWidth : minHeight;\n  const [minWidth, minHeight] = checkBoundSize(size, minSize, false, ratio);\n  const [maxWidth, maxHeight] = checkBoundSize(size, maxSize, true, ratio);\n\n  if (width < minWidth || height < minHeight) {\n    width = minWidth;\n    height = minHeight;\n  } else if (width > maxWidth || height > maxHeight) {\n    width = maxWidth;\n    height = maxHeight;\n  }\n  return [width, height];\n}\n\nexport function checkBoundSize(\n  targetSize: number[],\n  compareSize: number[],\n  isMax: boolean,\n  ratio = targetSize[0] / targetSize[1]\n) {\n  return (\n    [\n      [\n        throttle(compareSize[0], TINY_NUM),\n        throttle(compareSize[0] / ratio, TINY_NUM),\n      ],\n      [\n        throttle(compareSize[1] * ratio, TINY_NUM),\n        throttle(compareSize[1], TINY_NUM),\n      ],\n    ].filter((size) =>\n      size.every((value, i) => {\n        const defaultSize = compareSize[i];\n        const throttledSize = throttle(defaultSize, TINY_NUM);\n\n        return isMax\n          ? value <= defaultSize || value <= throttledSize\n          : value >= defaultSize || value >= throttledSize;\n      })\n    )[0] || targetSize\n  );\n}\n\n/**\n * @function\n * @memberof Utils\n */\nexport function getKeys(obj: IObject<any>): string[] {\n  return Object.keys(obj);\n}\n\n/**\n* window.cancelAnimationFrame() method with cross browser.\n* @function\n* @memberof CrossBrowser\n* @param {number} handle - the id obtained through requestAnimationFrame method\n* @return {void}\n* @example\nimport { requestAnimationFrame, cancelAnimationFrame } from \"utility\";\n\nconst id = requestAnimationFrame((timestamp) => {\n  console.log(timestamp);\n});\n\ncancelAnimationFrame(id);\n*/\nexport const cancelAnimationFrame = /*#__PURE__*/ (() => {\n  const caf =\n    IS_WINDOW &&\n    (window.cancelAnimationFrame ||\n      (window as any).webkitCancelAnimationFrame ||\n      (window as any).mozCancelAnimationFrame ||\n      (window as any).msCancelAnimationFrame);\n\n  return caf\n    ? (caf.bind(window) as (handle: number) => void)\n    : (handle: number) => {\n        clearTimeout(handle);\n      };\n})();\n\n/**\n* window.requestAnimationFrame() method with cross browser.\n* @function\n* @memberof CrossBrowser\n* @param {FrameRequestCallback} callback - The function to call when it's time to update your animation for the next repaint.\n* @return {number} id\n* @example\nimport {requestAnimationFrame} from \"utility\";\n\nrequestAnimationFrame((timestamp) => {\n  console.log(timestamp);\n});\n*/\nexport const requestAnimationFrame = /*#__PURE__*/ (() => {\n  const firstTime = now();\n\n  const raf =\n    IS_WINDOW &&\n    (window.requestAnimationFrame ||\n      (window as any).webkitRequestAnimationFrame ||\n      (window as any).mozRequestAnimationFrame ||\n      (window as any).msRequestAnimationFrame);\n\n  return raf\n    ? (raf.bind(window) as (callback: FrameRequestCallback) => number)\n    : (callback: FrameRequestCallback) => {\n        const currTime = now();\n        const id = setTimeout(() => {\n          callback(currTime - firstTime);\n        }, 1000 / 60);\n\n        return id as any as number;\n      };\n})();\n\n/**\n* Date.now() method\n* @memberof CrossBrowser\n* @return {number} milliseconds\n* @example\nimport {now} from \"utility\";\n\nconsole.log(now()); // 12121324241(milliseconds)\n*/\nexport function now() {\n  return Date.now ? Date.now() : new Date().getTime();\n}\n\nfunction findOpen(\n  openCharacter: OpenCloseCharacter,\n  texts: string[],\n  index: number,\n  length: number,\n  openCloseCharacters: OpenCloseCharacter[]\n) {\n  const isIgnore = findIgnore(openCharacter, texts, index);\n\n  if (!isIgnore) {\n    return findClose(\n      openCharacter,\n      texts,\n      index + 1,\n      length,\n      openCloseCharacters\n    );\n  }\n  return index;\n}\n\nfunction findIgnore(\n  character: OpenCloseCharacter,\n  texts: string[],\n  index: number\n) {\n  if (!character.ignore) {\n    return null;\n  }\n  const otherText = texts.slice(Math.max(index - 3, 0), index + 3).join(\"\");\n\n  return new RegExp(character.ignore).exec(otherText);\n}\nfunction findClose(\n  closeCharacter: OpenCloseCharacter,\n  texts: string[],\n  index: number,\n  length: number,\n  openCloseCharacters: OpenCloseCharacter[]\n) {\n  for (let i = index; i < length; ++i) {\n    const character = texts[i].trim();\n\n    if (\n      character === closeCharacter.close &&\n      !findIgnore(closeCharacter, texts, i)\n    ) {\n      return i;\n    }\n    let nextIndex = i;\n    // re open\n    const openCharacter = find(\n      openCloseCharacters,\n      ({ open }) => open === character\n    );\n\n    if (openCharacter) {\n      nextIndex = findOpen(\n        openCharacter,\n        texts,\n        i,\n        length,\n        openCloseCharacters\n      );\n    }\n    if (nextIndex === -1) {\n      break;\n    }\n    i = nextIndex;\n  }\n  return -1;\n}\n\nexport function splitText(\n  text: string,\n  splitOptions: string | SplitOptions\n): string[] {\n  const {\n    separator = \",\",\n    isSeparateFirst,\n    isSeparateOnlyOpenClose,\n    isSeparateOpenClose = isSeparateOnlyOpenClose,\n    openCloseCharacters = OPEN_CLOSED_CHARACTERS,\n  } = isString(splitOptions)\n    ? ({\n        separator: splitOptions,\n      } as SplitOptions)\n    : splitOptions;\n  const openClosedText = openCloseCharacters\n    .map(({ open, close }) => {\n      if (open === close) {\n        return open;\n      }\n      return `${open}|${close}`;\n    })\n    .join(\"|\");\n  const regexText = `(\\\\s*${separator}\\\\s*|${openClosedText}|\\\\s+)`;\n  const regex = new RegExp(regexText, \"g\");\n  const texts = text.split(regex).filter((chr) => {\n    return chr && chr !== \"undefined\";\n  });\n  const length = texts.length;\n  const values: string[] = [];\n  let tempValues: string[] = [];\n\n  function resetTemp() {\n    if (tempValues.length) {\n      values.push(tempValues.join(\"\"));\n      tempValues = [];\n\n      return true;\n    }\n    return false;\n  }\n  for (let i = 0; i < length; ++i) {\n    const character = texts[i].trim();\n    let nextIndex = i;\n\n    const openCharacter = find(\n      openCloseCharacters,\n      ({ open }) => open === character\n    );\n    const closeCharacter = find(\n      openCloseCharacters,\n      ({ close }) => close === character\n    );\n\n    if (openCharacter) {\n      nextIndex = findOpen(\n        openCharacter,\n        texts,\n        i,\n        length,\n        openCloseCharacters\n      );\n\n      if (nextIndex !== -1 && isSeparateOpenClose) {\n        if (resetTemp() && isSeparateFirst) {\n          break;\n        }\n        values.push(texts.slice(i, nextIndex + 1).join(\"\"));\n        i = nextIndex;\n\n        if (isSeparateFirst) {\n          break;\n        }\n        continue;\n      }\n    } else if (closeCharacter && !findIgnore(closeCharacter, texts, i)) {\n      const nextOpenCloseCharacters = [...openCloseCharacters];\n\n      nextOpenCloseCharacters.splice(\n        openCloseCharacters.indexOf(closeCharacter),\n        1\n      );\n\n      return splitText(text, {\n        separator,\n        isSeparateFirst,\n        isSeparateOnlyOpenClose,\n        isSeparateOpenClose,\n        openCloseCharacters: nextOpenCloseCharacters,\n      });\n    } else if (\n      isEqualSeparator(character, separator) &&\n      !isSeparateOnlyOpenClose\n    ) {\n      resetTemp();\n      if (isSeparateFirst) {\n        break;\n      }\n      continue;\n    }\n\n    if (nextIndex === -1) {\n      nextIndex = length - 1;\n    }\n    tempValues.push(texts.slice(i, nextIndex + 1).join(\"\"));\n    i = nextIndex;\n  }\n  if (tempValues.length) {\n    values.push(tempValues.join(\"\"));\n  }\n  return values;\n}\n\n/**\n* divide text by space.\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {Array} divided texts\n* @example\nimport {spliceSpace} from \"utility\";\n\nconsole.log(splitSpace(\"a b c d e f g\"));\n// [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\nconsole.log(splitSpace(\"'a,b' c 'd,e' f g\"));\n// [\"'a,b'\", \"c\", \"'d,e'\", \"f\", \"g\"]\n*/\nexport function splitSpace(text: string) {\n  // divide comma(space)\n  return splitText(text, \"\");\n}\n\n/**\n * Returns the inner product of two numbers(`a1`, `a2`) by two criteria(`b1`, `b2`).\n * @memberof Utils\n * @param - The first number\n * @param - The second number\n * @param - The first number to base on the inner product\n * @param - The second number to base on the inner product\n * @return - Returns the inner product\nimport { dot } from \"utility\";\n\nconsole.log(dot(0, 15, 2, 3)); // 6\nconsole.log(dot(5, 15, 2, 3)); // 9\nconsole.log(dot(5, 15, 1, 1)); // 10\n */\nexport function dot(a1: number, a2: number, b1: number, b2: number) {\n  return (a1 * b2 + a2 * b1) / (b1 + b2);\n}\n\n/**\n * convert unit size to px size\n * @function\n * @memberof Utils\n */\nexport function convertUnitSize(\n  pos: string,\n  size: number | IObject<((pos: number) => number) | number>\n) {\n  const { value, unit } = splitUnit(pos);\n\n  if (isObject(size)) {\n    const sizeFunction = size[unit];\n    if (sizeFunction) {\n      if (isFunction(sizeFunction)) {\n        return sizeFunction(value);\n      } else if (DEFAULT_UNIT_PRESETS[unit]) {\n        return DEFAULT_UNIT_PRESETS[unit](value, sizeFunction);\n      }\n    }\n  } else if (unit === \"%\") {\n    return (value * size) / 100;\n  }\n  if (DEFAULT_UNIT_PRESETS[unit]) {\n    return DEFAULT_UNIT_PRESETS[unit](value);\n  }\n  return value;\n}\n\n/**\n * @function\n * @memberof Utils\n */\nexport function flat<Type>(arr: Type[][]): Type[] {\n  return arr.reduce((prev, cur) => {\n    return prev.concat(cur);\n  }, []);\n}\n\n/**\n * @function\n * @memberof Utils\n */\nexport function counter(num: number): number[] {\n  const nums: number[] = [];\n\n  for (let i = 0; i < num; ++i) {\n    nums.push(i);\n  }\n\n  return nums;\n}\n\n/**\n * @function\n * @memberof Utils\n */\nexport function pushSet<T>(elements: T[], element: T) {\n  if (elements.indexOf(element) === -1) {\n    elements.push(element);\n  }\n}\n","import { IEventMap } from \"./types\";\nimport { isObject } from \"./utils\";\n\n/**\n* Checks if the specified class value exists in the element's class attribute.\n* @memberof DOM\n* @param element - target\n* @param className - the class name to search\n* @return {boolean} return false if the class is not found.\n* @example\nimport {hasClass} from \"utility\";\n\nconsole.log(hasClass(element, \"start\")); // true or false\n*/\nexport function hasClass(element: Element, className: string) {\n  if (element.classList) {\n    return element.classList.contains(className);\n  }\n  return !!element.className.match(new RegExp(`(\\\\s|^)${className}(\\\\s|$)`));\n}\n\n/**\n* Add the specified class value. If these classe already exist in the element's class attribute they are ignored.\n* @memberof DOM\n* @param element - target\n* @param className - the class name to add\n* @example\nimport {addClass} from \"utility\";\n\naddClass(element, \"start\");\n*/\nexport function addClass(element: Element, className: string) {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    element.className += ` ${className}`;\n  }\n}\n\n/**\n* Removes the specified class value.\n* @memberof DOM\n* @param element - target\n* @param className - the class name to remove\n* @example\nimport {removeClass} from \"utility\";\n\nremoveClass(element, \"start\");\n*/\nexport function removeClass(element: Element, className: string) {\n  if (element.classList) {\n    element.classList.remove(className);\n  } else {\n    const reg = new RegExp(`(\\\\s|^)${className}(\\\\s|$)`);\n\n    element.className = element.className.replace(reg, \" \");\n  }\n}\n\nexport function getDocument(el?: Node) {\n  return el?.ownerDocument || document;\n}\n\nexport function getDocumentElement(el?: Node) {\n  return getDocument(el).documentElement;\n}\n\nexport function getDocumentBody(el?: Node) {\n  return getDocument(el).body;\n}\n\nexport function isWindow(val: any): val is Window {\n  return val && \"postMessage\" in val && \"blur\" in val && \"self\" in val;\n}\n\nexport function isNode(el?: any): el is Node {\n  return (\n    isObject(el) &&\n    el.nodeName &&\n    el.nodeType &&\n    \"parentNode\" in el &&\n    \"ownerDocument\" in el\n  );\n}\n\nexport function getWindow(el?: Node) {\n  return el?.ownerDocument?.defaultView || window;\n}\n\nexport function addEvent<K extends keyof IEventMap>(\n  el: EventTarget,\n  type: K,\n  listener: (e: IEventMap[K]) => void,\n  options?: boolean | AddEventListenerOptions\n): void;\n/**\n  * Sets up a function that will be called whenever the specified event is delivered to the target\n  * @memberof DOM\n  * @param - event target\n  * @param - A case-sensitive string representing the event type to listen for.\n  * @param - The object which receives a notification (an object that implements the Event interface) when an event of the specified type occurs\n  * @param - An options object that specifies characteristics about the event listener.\n  * @example\n  import {addEvent} from \"utility\";\n  \n  addEvent(el, \"click\", e => {\n    console.log(e);\n  });\n  */\nexport function addEvent(\n  el: EventTarget,\n  type: string,\n  listener: (e: Event) => void,\n  options?: boolean | AddEventListenerOptions\n) {\n  el.addEventListener(type, listener, options);\n}\n\nexport function removeEvent<K extends keyof IEventMap>(\n  el: EventTarget,\n  type: K,\n  listener: (e: IEventMap[K]) => void,\n  options?: boolean | EventListenerOptions\n): void;\n/**\n  * removes from the EventTarget an event listener previously registered with EventTarget.addEventListener()\n  * @memberof DOM\n  * @param - event target\n  * @param - A case-sensitive string representing the event type to listen for.\n  * @param - The EventListener function of the event handler to remove from the event target.\n  * @param - An options object that specifies characteristics about the event listener.\n  * @example\n  import {addEvent, removeEvent} from \"utility\";\n  const listener = e => {\n    console.log(e);\n  };\n  addEvent(el, \"click\", listener);\n  removeEvent(el, \"click\", listener);\n  */\nexport function removeEvent(\n  el: EventTarget,\n  type: string,\n  listener: (e: Event) => void,\n  options?: boolean | EventListenerOptions\n) {\n  el.removeEventListener(type, listener, options);\n}\n","import { findIndex, isObject } from \"../utility\";\nimport {\n  EventListener,\n  EventHash,\n  EventInfo,\n  EventOptions,\n  OnEvent,\n  TargetParam,\n} from \"./types\";\n\n/**\n * Implement EventEmitter on object or component.\n */\nclass EventEmitter<\n  Events extends {} = { [key: string]: { [key: string]: any } }\n> {\n  private _events: {\n    [name: string]: EventInfo[];\n  } = {};\n  public on<Name extends keyof Events, Param = Events[Name]>(\n    eventName: Name,\n    listener: EventListener<Param, this>\n  ): this;\n  public on(events: EventHash<Events, this>): this;\n  /**\n   * Add a listener to the registered event.\n   * @param - Name of the event to be added\n   * @param - listener function of the event to be added\n   * @example\n   * import EventEmitter from \"@scena/event-emitter\";\n   * cosnt emitter = new EventEmitter();\n   *\n   * // Add listener in \"a\" event\n   * emitter.on(\"a\", () => {\n   * });\n   * // Add listeners\n   * emitter.on({\n   *  a: () => {},\n   *  b: () => {},\n   * });\n   */\n  public on(\n    eventName: string | object,\n    listener?: EventListener<Events[any], this>\n  ): this {\n    if (isObject(eventName)) {\n      for (const name in eventName) {\n        this.on<any>(name, eventName[name as keyof typeof eventName]);\n      }\n    } else {\n      this._addEvent(eventName as string, listener!, {});\n    }\n    return this;\n  }\n  public off<Name extends keyof Events, Param = Events[Name]>(\n    eventName?: Name,\n    listener?: EventListener<Param, this>\n  ): this;\n  public off(events: EventHash<Events, this>): this;\n  /**\n   * Remove listeners registered in the event target.\n   * @param - Name of the event to be removed\n   * @param - listener function of the event to be removed\n   * @example\n   * import EventEmitter from \"@scena/event-emitter\";\n   * cosnt emitter = new EventEmitter();\n   *\n   * // Remove all listeners.\n   * emitter.off();\n   *\n   * // Remove all listeners in \"A\" event.\n   * emitter.off(\"a\");\n   *\n   *\n   * // Remove \"listener\" listener in \"a\" event.\n   * emitter.off(\"a\", listener);\n   */\n  public off(\n    eventName?: string | object,\n    listener?: EventListener<Events[any], this>\n  ): this {\n    if (!eventName) {\n      this._events = {};\n    } else if (isObject(eventName)) {\n      for (const name in eventName) {\n        this.off<any>(name);\n      }\n    } else if (!listener) {\n      this._events[eventName as string] = [];\n    } else {\n      const events = this._events[eventName as string];\n\n      if (events) {\n        const index = findIndex(events, (e) => e.listener === listener);\n\n        if (index > -1) {\n          events.splice(index, 1);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Add a disposable listener and Use promise to the registered event.\n   * @param - Name of the event to be added\n   * @param - disposable listener function of the event to be added\n   * @example\n   * import EventEmitter from \"@scena/event-emitter\";\n   * cosnt emitter = new EventEmitter();\n   *\n   * // Add a disposable listener in \"a\" event\n   * emitter.once(\"a\", () => {\n   * });\n   *\n   * // Use Promise\n   * emitter.once(\"a\").then(e => {\n   * });\n   */\n  public once<Name extends keyof Events & string, Param = Events[Name]>(\n    eventName: Name,\n    listener?: EventListener<Param, this>\n  ): Promise<OnEvent<Param, this>> {\n    if (listener) {\n      this._addEvent(eventName, listener, { once: true });\n    }\n    return new Promise<OnEvent<Param, this>>((resolve) => {\n      this._addEvent(eventName, resolve, { once: true });\n    });\n  }\n  public emit<Name extends keyof Events, Param = Events[Name]>(\n    eventName: {} extends Param ? Name : never\n  ): boolean;\n  public emit<Name extends keyof Events, Param = Events[Name]>(\n    eventName: Name,\n    param: TargetParam<Param>\n  ): boolean;\n  /**\n   * Fires an event to call listeners.\n   * @param - Event name\n   * @param - Event parameter\n   * @return If false, stop the event.\n   * @example\n   *\n   * import EventEmitter from \"@scena/event-emitter\";\n   *\n   *\n   * const emitter = new EventEmitter();\n   *\n   * emitter.on(\"a\", e => {\n   * });\n   *\n   *\n   * emitter.emit(\"a\", {\n   *   a: 1,\n   * });\n   */\n  public emit(eventName: string, param: TargetParam<any> = {}): boolean {\n    const events = this._events[eventName];\n\n    if (!eventName || !events) {\n      return true;\n    }\n    let isStop = false;\n\n    param.eventType = eventName;\n    param.stop = () => {\n      isStop = true;\n    };\n    param.currentTarget = this;\n\n    [...events].forEach((info) => {\n      info.listener(param);\n      if (info.once) {\n        this.off<any>(eventName, info.listener);\n      }\n    });\n\n    return !isStop;\n  }\n  public trigger<Name extends keyof Events, Param = Events[Name]>(\n    eventName: {} extends TargetParam<Param> ? Name : never\n  ): boolean;\n  public trigger<Name extends keyof Events, Param = Events[Name]>(\n    eventName: Name,\n    param: TargetParam<Param>\n  ): boolean;\n  /**\n   * Fires an event to call listeners.\n   * @param - Event name\n   * @param - Event parameter\n   * @return If false, stop the event.\n   * @example\n   *\n   * import EventEmitter from \"@scena/event-emitter\";\n   *\n   *\n   * const emitter = new EventEmitter();\n   *\n   * emitter.on(\"a\", e => {\n   * });\n   *\n   *\n   * emitter.emit(\"a\", {\n   *   a: 1,\n   * });\n   */ /**\n   * Fires an event to call listeners.\n   * @param - Event name\n   * @param - Event parameter\n   * @return If false, stop the event.\n   * @example\n   *\n   * import EventEmitter from \"@scena/event-emitter\";\n   *\n   *\n   * const emitter = new EventEmitter();\n   *\n   * emitter.on(\"a\", e => {\n   * });\n   *\n   * // emit\n   * emitter.trigger(\"a\", {\n   *   a: 1,\n   * });\n   */\n  public trigger<Name extends keyof Events>(\n    eventName: Name,\n    param: TargetParam<any> = {}\n  ): boolean {\n    return this.emit<any>(eventName, param);\n  }\n\n  private _addEvent(\n    eventName: string,\n    listener: EventListener<Events[any], this>,\n    options: Partial<EventOptions>\n  ) {\n    const events = this._events;\n\n    events[eventName] = events[eventName] || [];\n\n    const listeners = events[eventName];\n\n    listeners.push({ listener, ...options });\n  }\n}\n\nexport default EventEmitter;\n","import { Client, Position } from \"./types\";\nimport { IArrayFormat } from \"../utility\";\n\nexport function getRad(pos1: number[], pos2: number[]) {\n  const distX = pos2[0] - pos1[0];\n  const distY = pos2[1] - pos1[1];\n  const rad = Math.atan2(distY, distX);\n\n  return rad >= 0 ? rad : rad + Math.PI * 2;\n}\n\nexport function getRotatiion(touches: Client[]) {\n  return (\n    (getRad(\n      [touches[0].clientX, touches[0].clientY],\n      [touches[1].clientX, touches[1].clientY]\n    ) /\n      Math.PI) *\n    180\n  );\n}\n\nexport function isMultiTouch(e: any): e is TouchEvent {\n  return e.touches && e.touches.length >= 2;\n}\nexport function getEventClients(e: any): Client[] {\n  if (!e) {\n    return [];\n  }\n  if (e.touches) {\n    return getClients(e.touches);\n  } else {\n    return [getClient(e)];\n  }\n}\nexport function isMouseEvent(e: any): e is MouseEvent {\n  return e && (e.type.indexOf(\"mouse\") > -1 || \"button\" in e);\n}\nexport function getPosition(\n  clients: Client[],\n  prevClients: Client[],\n  startClients: Client[]\n): Position {\n  const length = startClients.length;\n  const { clientX, clientY, originalClientX, originalClientY } =\n    getAverageClient(clients, length);\n  const { clientX: prevX, clientY: prevY } = getAverageClient(\n    prevClients,\n    length\n  );\n\n  const { clientX: startX, clientY: startY } = getAverageClient(\n    startClients,\n    length\n  );\n  const deltaX = clientX - prevX;\n  const deltaY = clientY - prevY;\n  const distX = clientX - startX;\n  const distY = clientY - startY;\n\n  return {\n    clientX: originalClientX!,\n    clientY: originalClientY!,\n    deltaX,\n    deltaY,\n    distX,\n    distY,\n  };\n}\nexport function getDist(clients: Client[]) {\n  return Math.sqrt(\n    Math.pow(clients[0].clientX - clients[1].clientX, 2) +\n      Math.pow(clients[0].clientY - clients[1].clientY, 2)\n  );\n}\nexport function getClients(touches: IArrayFormat<Touch>) {\n  const length = Math.min(touches.length, 2);\n  const clients = [];\n\n  for (let i = 0; i < length; ++i) {\n    clients.push(getClient(touches[i]));\n  }\n  return clients;\n}\nexport function getClient(e: MouseEvent | Touch): Client {\n  return {\n    clientX: e.clientX,\n    clientY: e.clientY,\n  };\n}\nexport function getAverageClient(\n  clients: Client[],\n  length = clients.length\n): Required<Client> {\n  const sumClient: Required<Client> = {\n    clientX: 0,\n    clientY: 0,\n    originalClientX: 0,\n    originalClientY: 0,\n  };\n  const minLength = Math.min(clients.length, length);\n\n  for (let i = 0; i < minLength; ++i) {\n    const client = clients[i];\n\n    sumClient.originalClientX +=\n      \"originalClientX\" in client ? client.originalClientX! : client.clientX;\n    sumClient.originalClientY +=\n      \"originalClientY\" in client ? client.originalClientY! : client.clientY;\n    sumClient.clientX += client.clientX;\n    sumClient.clientY += client.clientY;\n  }\n  if (!length) {\n    return sumClient;\n  }\n  return {\n    clientX: sumClient.clientX / length,\n    clientY: sumClient.clientY / length,\n    originalClientX: sumClient.originalClientX / length,\n    originalClientY: sumClient.originalClientY / length,\n  };\n}\nexport function plueClient(client1: Client, client2: Client) {\n  return {\n    clientX: client1.clientX + client2.clientX,\n    clientY: client1.clientY + client2.clientY,\n  };\n}\n\nexport function minusClient(client1: Client, client2: Client) {\n  return {\n    clientX: client1.clientX - client2.clientX,\n    clientY: client1.clientY - client2.clientY,\n  };\n}\n","import { Client, Position } from \"./types\";\nimport { getPosition, getDist, getRotatiion, getAverageClient } from \"./utils\";\n\nexport class ClientStore {\n    public prevClients: Client[] = [];\n    public startClients: Client[] = [];\n    public movement = 0;\n    public length  = 0;\n    constructor(clients: Client[]) {\n        this.startClients = clients;\n        this.prevClients = clients;\n        this.length = clients.length;\n    }\n    public getAngle(clients: Client[] = this.prevClients) {\n        return getRotatiion(clients);\n    }\n    public getRotation(clients: Client[] = this.prevClients) {\n        return getRotatiion(clients) - getRotatiion(this.startClients);\n    }\n    public getPosition(clients: Client[] = this.prevClients, isAdd?: boolean) {\n        const position = getPosition(clients || this.prevClients, this.prevClients, this.startClients);\n\n        const { deltaX, deltaY } = position;\n\n        this.movement += Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n        this.prevClients = clients;\n\n        return position;\n    }\n    public getPositions(clients: Client[] = this.prevClients) {\n        const prevClients = this.prevClients;\n        const startClients = this.startClients;\n        const minLength = Math.min(this.length, prevClients.length);\n        const positions: Position[] = [];\n\n        for (let i = 0; i < minLength; ++i) {\n            positions[i] = getPosition([clients[i]], [prevClients[i]], [startClients[i]]);\n        }\n\n        return positions;\n    }\n    public getMovement(clients?: Client[]) {\n        const movement = this.movement;\n\n        if (!clients) {\n            return movement;\n        }\n        const currentClient = getAverageClient(clients, this.length);\n        const prevClient = getAverageClient(this.prevClients, this.length);\n        const deltaX = currentClient.clientX - prevClient.clientX;\n        const deltaY = currentClient.clientY - prevClient.clientY;\n\n        return Math.sqrt(deltaX * deltaX + deltaY * deltaY) + movement;\n    }\n    public getDistance(clients = this.prevClients) {\n        return getDist(clients);\n    }\n    public getScale(clients = this.prevClients) {\n        return getDist(clients) / getDist(this.startClients);\n    }\n    public move(deltaX: number, deltaY: number) {\n        this.startClients.forEach(client => {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n        this.prevClients.forEach(client => {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n    }\n}\n","import { Client, OnDrag, GestoOptions, GestoEvents } from \"./types\";\nimport { getEventClients, isMouseEvent, isMultiTouch } from \"./utils\";\nimport EventEmitter, { TargetParam } from \"../event-emitter\";\nimport {\n  addEvent,\n  removeEvent,\n  now,\n  IObject,\n  getWindow,\n  isWindow,\n} from \"../utility\";\nimport { ClientStore } from \"./client-store\";\n\nconst INPUT_TAGNAMES = [\"textarea\", \"input\"];\n/**\n * You can set up drag, pinch events in any browser.\n */\nclass Gesto extends EventEmitter<GestoEvents> {\n  public options: GestoOptions = {};\n\n  private flag = false;\n  private pinchFlag = false;\n  private data: IObject<any> = {};\n  private isDrag = false;\n  private isPinch = false;\n\n  private clientStores: ClientStore[] = [];\n  private targets: Array<Element | Window> = [];\n  private prevTime: number = 0;\n  private doubleFlag: boolean = false;\n  private _useMouse = false;\n  private _useTouch = false;\n  private _useDrag = false;\n  private _dragFlag = false;\n  private _isTrusted = false;\n  private _isMouseEvent = false;\n  private _isSecondaryButton = false;\n  private _preventMouseEvent = false;\n  private _prevInputEvent: any = null;\n  private _isDragAPI = false;\n  private _isIdle = true;\n  private _preventMouseEventId = 0;\n  private _window: WindowProxy = window;\n\n  /**\n   *\n   */\n  constructor(\n    targets: Array<Element | Window> | Element | Window,\n    options: GestoOptions = {}\n  ) {\n    super();\n    const elements = [].concat(targets as any) as Array<Element | Window>;\n    const firstTarget = elements[0];\n\n    this._window = isWindow(firstTarget) ? firstTarget : getWindow(firstTarget);\n    this.options = {\n      checkInput: false,\n      container:\n        firstTarget && !(\"document\" in firstTarget)\n          ? getWindow(firstTarget)\n          : firstTarget,\n      preventRightClick: true,\n      preventWheelClick: true,\n      preventClickEventOnDragStart: false,\n      preventClickEventOnDrag: false,\n      preventClickEventByCondition: null,\n      preventDefault: true,\n      checkWindowBlur: false,\n      keepDragging: false,\n      pinchThreshold: 0,\n      events: [\"touch\", \"mouse\"],\n      ...options,\n    };\n\n    const { container, events, checkWindowBlur } = this.options;\n\n    this._useDrag = events!.indexOf(\"drag\") > -1;\n    this._useTouch = events!.indexOf(\"touch\") > -1;\n    this._useMouse = events!.indexOf(\"mouse\") > -1;\n    this.targets = elements;\n\n    if (this._useDrag) {\n      elements.forEach((el) => {\n        addEvent(el, \"dragstart\", this.onDragStart);\n      });\n    }\n    if (this._useMouse) {\n      elements.forEach((el) => {\n        addEvent(el, \"mousedown\", this.onDragStart);\n        addEvent(el, \"mousemove\", this._passCallback);\n      });\n      addEvent(container!, \"contextmenu\", this._onContextMenu);\n    }\n    if (checkWindowBlur) {\n      addEvent(getWindow(), \"blur\", this.onBlur);\n    }\n    if (this._useTouch) {\n      const passive = {\n        passive: false,\n      };\n      elements.forEach((el) => {\n        addEvent(el, \"touchstart\", this.onDragStart, passive);\n        addEvent(el, \"touchmove\", this._passCallback, passive);\n      });\n    }\n  }\n  /**\n   * Stop Gesto's drag events.\n   */\n  public stop() {\n    this.isDrag = false;\n    this.data = {};\n    this.clientStores = [];\n    this.pinchFlag = false;\n    this.doubleFlag = false;\n    this.prevTime = 0;\n    this.flag = false;\n    this._isIdle = true;\n\n    this._allowClickEvent();\n    this._dettachDragEvent();\n    this._isDragAPI = false;\n  }\n  /**\n   * The total moved distance\n   */\n  public getMovement(clients?: Client[]) {\n    return (\n      this.getCurrentStore().getMovement(clients) +\n      this.clientStores.slice(1).reduce((prev, cur) => {\n        return prev + cur.movement;\n      }, 0)\n    );\n  }\n  /**\n   * Whether to drag\n   */\n  public isDragging(): boolean {\n    return this.isDrag;\n  }\n  /**\n   * Whether the operation of gesto is finished and is in idle state\n   */\n  public isIdle(): boolean {\n    return this._isIdle;\n  }\n  /**\n   * Whether to start drag\n   */\n  public isFlag(): boolean {\n    return this.flag;\n  }\n  /**\n   * Whether to start pinch\n   */\n  public isPinchFlag() {\n    return this.pinchFlag;\n  }\n  /**\n   * Whether to start double click\n   */\n  public isDoubleFlag() {\n    return this.doubleFlag;\n  }\n  /**\n   * Whether to pinch\n   */\n  public isPinching() {\n    return this.isPinch;\n  }\n\n  /**\n   * If a scroll event occurs, it is corrected by the scroll distance.\n   */\n  public scrollBy(\n    deltaX: number,\n    deltaY: number,\n    e: any,\n    isCallDrag: boolean = true\n  ) {\n    if (!this.flag) {\n      return;\n    }\n    this.clientStores[0].move(deltaX, deltaY);\n    isCallDrag && this.onDrag(e, true);\n  }\n  /**\n   * Create a virtual drag event.\n   */\n  public move(\n    [deltaX, deltaY]: number[],\n    inputEvent: any\n  ): TargetParam<OnDrag> {\n    const store = this.getCurrentStore();\n    const nextClients = store.prevClients;\n\n    return this.moveClients(\n      nextClients.map(({ clientX, clientY }) => {\n        return {\n          clientX: clientX + deltaX,\n          clientY: clientY + deltaY,\n          originalClientX: clientX,\n          originalClientY: clientY,\n        };\n      }),\n      inputEvent,\n      true\n    );\n  }\n  /**\n   * The dragStart event is triggered by an external event.\n   */\n  public triggerDragStart(e: any) {\n    this.onDragStart(e, false);\n  }\n  /**\n   * Set the event data while dragging.\n   */\n  public setEventData(data: IObject<any>) {\n    const currentData = this.data;\n\n    for (const name in data) {\n      currentData[name] = data[name];\n    }\n    return this;\n  }\n  /**\n   * Set the event data while dragging.\n   * Use `setEventData`\n   * @deprecated\n   */\n  public setEventDatas(data: IObject<any>) {\n    return this.setEventData(data);\n  }\n  /**\n   * Get the current event state while dragging.\n   */\n  public getCurrentEvent(inputEvent: any = this._prevInputEvent) {\n    return {\n      data: this.data,\n      datas: this.data,\n      ...this._getPosition(),\n      movement: this.getMovement(),\n      isDrag: this.isDrag,\n      isPinch: this.isPinch,\n      isScroll: false,\n      inputEvent,\n    };\n  }\n  /**\n   * Get & Set the event data while dragging.\n   */\n  public getEventData() {\n    return this.data;\n  }\n  /**\n   * Get & Set the event data while dragging.\n   * Use getEventData method\n   * @depreacated\n   */\n  public getEventDatas() {\n    return this.data;\n  }\n  /**\n   * Unset Gesto\n   */\n  public unset() {\n    const targets = this.targets;\n    const container = this.options.container!;\n\n    this.off();\n    removeEvent(this._window, \"blur\", this.onBlur);\n\n    if (this._useDrag) {\n      targets.forEach((el) => {\n        removeEvent(el, \"dragstart\", this.onDragStart);\n      });\n    }\n    if (this._useMouse) {\n      targets.forEach((target) => {\n        removeEvent(target, \"mousedown\", this.onDragStart);\n      });\n      removeEvent(container, \"contextmenu\", this._onContextMenu);\n    }\n    if (this._useTouch) {\n      targets.forEach((target) => {\n        removeEvent(target, \"touchstart\", this.onDragStart);\n      });\n      removeEvent(container, \"touchstart\", this.onDragStart);\n    }\n    this._prevInputEvent = null;\n    this._allowClickEvent();\n    this._dettachDragEvent();\n  }\n  public onDragStart = (e: any, isTrusted = true) => {\n    if (!this.flag && e.cancelable === false) {\n      return;\n    }\n    const isDragAPI = e.type.indexOf(\"drag\") >= -1;\n\n    if (this.flag && isDragAPI) {\n      return;\n    }\n\n    this._isDragAPI = true;\n    const {\n      container,\n      pinchOutside,\n      preventWheelClick,\n      preventRightClick,\n      preventDefault,\n      checkInput,\n      dragFocusedInput,\n      preventClickEventOnDragStart,\n      preventClickEventOnDrag,\n      preventClickEventByCondition,\n    } = this.options;\n    const useTouch = this._useTouch;\n    const isDragStart = !this.flag;\n\n    this._isSecondaryButton = e.which === 3 || e.button === 2;\n\n    if (\n      (preventWheelClick && (e.which === 2 || e.button === 1)) ||\n      (preventRightClick && (e.which === 3 || e.button === 2))\n    ) {\n      this.stop();\n      return false;\n    }\n\n    if (isDragStart) {\n      const activeElement = this._window.document.activeElement as HTMLElement;\n      const target = e.target as HTMLElement;\n\n      if (target) {\n        const tagName = target.tagName.toLowerCase();\n        const hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;\n        const hasContentEditable = target.isContentEditable;\n\n        if (hasInput || hasContentEditable) {\n          if (checkInput || (!dragFocusedInput && activeElement === target)) {\n            // force false or already focused.\n            return false;\n          }\n          // no focus\n          if (\n            activeElement &&\n            (activeElement === target ||\n              (hasContentEditable &&\n                activeElement.isContentEditable &&\n                activeElement.contains(target)))\n          ) {\n            if (dragFocusedInput) {\n              target.blur();\n            } else {\n              return false;\n            }\n          }\n        } else if (\n          (preventDefault || e.type === \"touchstart\") &&\n          activeElement\n        ) {\n          const activeTagName = activeElement.tagName.toLowerCase();\n\n          if (\n            activeElement.isContentEditable ||\n            INPUT_TAGNAMES.indexOf(activeTagName) > -1\n          ) {\n            activeElement.blur();\n          }\n        }\n\n        if (\n          preventClickEventOnDragStart ||\n          preventClickEventOnDrag ||\n          preventClickEventByCondition\n        ) {\n          addEvent(this._window, \"click\", this._onClick, true);\n        }\n      }\n      this.clientStores = [new ClientStore(getEventClients(e))];\n      this._isIdle = false;\n      this.flag = true;\n      this.isDrag = false;\n      this._isTrusted = isTrusted;\n      this._dragFlag = true;\n      this._prevInputEvent = e;\n      this.data = {};\n\n      this.doubleFlag = now() - this.prevTime < 200;\n      this._isMouseEvent = isMouseEvent(e);\n      if (!this._isMouseEvent && this._preventMouseEvent) {\n        this._allowMouseEvent();\n      }\n\n      const result =\n        this._preventMouseEvent ||\n        this.emit(\"dragStart\", {\n          data: this.data,\n          datas: this.data,\n          inputEvent: e,\n          isMouseEvent: this._isMouseEvent,\n          isSecondaryButton: this._isSecondaryButton,\n          isTrusted,\n          isDouble: this.doubleFlag,\n          ...this.getCurrentStore().getPosition(),\n          preventDefault() {\n            e.preventDefault();\n          },\n          preventDrag: () => {\n            this._dragFlag = false;\n          },\n        });\n      if (result === false) {\n        this.stop();\n      }\n      if (this._isMouseEvent && this.flag && preventDefault) {\n        e.preventDefault();\n      }\n    }\n    if (!this.flag) {\n      return false;\n    }\n    let timer = 0;\n\n    if (isDragStart) {\n      this._attchDragEvent();\n\n      // wait pinch\n      if (useTouch && pinchOutside) {\n        // @ts-ignore\n        timer = setTimeout(() => {\n          addEvent(container!, \"touchstart\", this.onDragStart, {\n            passive: false,\n          });\n        });\n      }\n    } else if (useTouch && pinchOutside) {\n      // pinch is occured\n      removeEvent(container!, \"touchstart\", this.onDragStart);\n    }\n    if (this.flag && isMultiTouch(e)) {\n      clearTimeout(timer);\n      if (isDragStart && e.touches.length !== e.changedTouches.length) {\n        return;\n      }\n      if (!this.pinchFlag) {\n        this.onPinchStart(e);\n      }\n    }\n  };\n  public onDrag = (e: any, isScroll?: boolean) => {\n    if (!this.flag) {\n      return;\n    }\n    const { preventDefault } = this.options;\n    if (!this._isMouseEvent && preventDefault) {\n      e.preventDefault();\n    }\n    this._prevInputEvent = e;\n    const clients = getEventClients(e);\n    const result = this.moveClients(clients, e, false);\n\n    if (this._dragFlag) {\n      if (this.pinchFlag || result.deltaX || result.deltaY) {\n        const dragResult =\n          this._preventMouseEvent ||\n          this.emit(\"drag\", {\n            ...result,\n            isScroll: !!isScroll,\n            inputEvent: e,\n          });\n\n        if (dragResult === false) {\n          this.stop();\n          return;\n        }\n      }\n      if (this.pinchFlag) {\n        this.onPinch(e, clients);\n      }\n    }\n\n    this.getCurrentStore().getPosition(clients, true);\n  };\n  public onDragEnd = (e?: any) => {\n    if (!this.flag) {\n      return;\n    }\n    const {\n      pinchOutside,\n      container,\n      preventClickEventOnDrag,\n      preventClickEventOnDragStart,\n      preventClickEventByCondition,\n    } = this.options;\n    const isDrag = this.isDrag;\n\n    if (\n      preventClickEventOnDrag ||\n      preventClickEventOnDragStart ||\n      preventClickEventByCondition\n    ) {\n      requestAnimationFrame(() => {\n        this._allowClickEvent();\n      });\n    }\n    if (\n      !preventClickEventByCondition &&\n      !preventClickEventOnDragStart &&\n      preventClickEventOnDrag &&\n      !isDrag\n    ) {\n      this._allowClickEvent();\n    }\n\n    if (this._useTouch && pinchOutside) {\n      removeEvent(container!, \"touchstart\", this.onDragStart);\n    }\n    if (this.pinchFlag) {\n      this.onPinchEnd(e);\n    }\n    const clients = e?.touches ? getEventClients(e) : [];\n    const clientsLength = clients.length;\n\n    if (clientsLength === 0 || !this.options.keepDragging) {\n      this.flag = false;\n    } else {\n      this._addStore(new ClientStore(clients));\n    }\n\n    const position = this._getPosition();\n    const currentTime = now();\n    const isDouble = !isDrag && this.doubleFlag;\n\n    this._prevInputEvent = null;\n    this.prevTime = isDrag || isDouble ? 0 : currentTime;\n\n    if (!this.flag) {\n      this._dettachDragEvent();\n\n      this._preventMouseEvent ||\n        this.emit(\"dragEnd\", {\n          data: this.data,\n          datas: this.data,\n          isDouble,\n          isDrag: isDrag,\n          isClick: !isDrag,\n          isMouseEvent: this._isMouseEvent,\n          isSecondaryButton: this._isSecondaryButton,\n          inputEvent: e,\n          isTrusted: this._isTrusted,\n          ...position,\n        });\n\n      this.clientStores = [];\n\n      if (!this._isMouseEvent) {\n        this._preventMouseEvent = true;\n\n        // Prevent the problem of touch event and mouse event occurring simultaneously\n        clearTimeout(this._preventMouseEventId);\n        // @ts-ignore\n        this._preventMouseEventId = setTimeout(() => {\n          this._preventMouseEvent = false;\n        }, 200);\n      }\n      this._isIdle = true;\n    }\n  };\n  public onPinchStart(e: TouchEvent) {\n    const { pinchThreshold } = this.options;\n\n    if (this.isDrag && this.getMovement() > pinchThreshold!) {\n      return;\n    }\n    const store = new ClientStore(getEventClients(e));\n\n    this.pinchFlag = true;\n    this._addStore(store);\n\n    const result = this.emit(\"pinchStart\", {\n      data: this.data,\n      datas: this.data,\n      angle: store.getAngle(),\n      touches: this.getCurrentStore().getPositions(),\n      ...store.getPosition(),\n      inputEvent: e,\n      isTrusted: this._isTrusted,\n      preventDefault() {\n        e.preventDefault();\n      },\n      preventDrag: () => {\n        this._dragFlag = false;\n      },\n    });\n\n    if (result === false) {\n      this.pinchFlag = false;\n    }\n  }\n  public onPinch(e: TouchEvent, clients: Client[]) {\n    if (!this.flag || !this.pinchFlag || clients.length < 2) {\n      return;\n    }\n\n    const store = this.getCurrentStore();\n    this.isPinch = true;\n\n    this.emit(\"pinch\", {\n      data: this.data,\n      datas: this.data,\n      movement: this.getMovement(clients),\n      angle: store.getAngle(clients),\n      rotation: store.getRotation(clients),\n      touches: store.getPositions(clients),\n      scale: store.getScale(clients),\n      distance: store.getDistance(clients),\n      ...store.getPosition(clients),\n      inputEvent: e,\n      isTrusted: this._isTrusted,\n    });\n  }\n  public onPinchEnd(e: TouchEvent) {\n    if (!this.pinchFlag) {\n      return;\n    }\n    const isPinch = this.isPinch;\n\n    this.isPinch = false;\n    this.pinchFlag = false;\n    const store = this.getCurrentStore();\n    this.emit(\"pinchEnd\", {\n      data: this.data,\n      datas: this.data,\n      isPinch,\n      touches: store.getPositions(),\n      ...store.getPosition(),\n      inputEvent: e,\n    });\n  }\n  private getCurrentStore() {\n    return this.clientStores[0];\n  }\n  private moveClients(\n    clients: Client[],\n    inputEvent: any,\n    isAdd: boolean\n  ): TargetParam<OnDrag> {\n    const position = this._getPosition(clients, isAdd);\n\n    const isPrevDrag = this.isDrag;\n\n    if (position.deltaX || position.deltaY) {\n      this.isDrag = true;\n    }\n    let isFirstDrag = false;\n\n    if (!isPrevDrag && this.isDrag) {\n      isFirstDrag = true;\n    }\n\n    return {\n      data: this.data,\n      datas: this.data,\n      ...position,\n      movement: this.getMovement(clients),\n      isDrag: this.isDrag,\n      isPinch: this.isPinch,\n      isScroll: false,\n      isMouseEvent: this._isMouseEvent,\n      isSecondaryButton: this._isSecondaryButton,\n      inputEvent,\n      isTrusted: this._isTrusted,\n      isFirstDrag,\n    };\n  }\n  private onBlur = () => {\n    this.onDragEnd();\n  };\n  private _addStore(store: ClientStore) {\n    this.clientStores.splice(0, 0, store);\n  }\n  private _getPosition(clients?: Client[], isAdd?: boolean) {\n    const store = this.getCurrentStore();\n    const position = store.getPosition(clients, isAdd);\n\n    const { distX, distY } = this.clientStores.slice(1).reduce((prev, cur) => {\n      const storePosition = cur.getPosition();\n\n      prev.distX += storePosition.distX;\n      prev.distY += storePosition.distY;\n      return prev;\n    }, position);\n\n    return {\n      ...position,\n      distX,\n      distY,\n    };\n  }\n  private _allowClickEvent = () => {\n    removeEvent(this._window, \"click\", this._onClick, true);\n  };\n  private _attchDragEvent() {\n    const win = this._window;\n    const container = this.options.container!;\n    const passive = {\n      passive: false,\n    };\n\n    if (this._isDragAPI) {\n      addEvent(container, \"dragover\", this.onDrag, passive);\n      addEvent(win, \"dragend\", this.onDragEnd);\n    }\n    if (this._useMouse) {\n      addEvent(container, \"mousemove\", this.onDrag);\n      addEvent(win, \"mouseup\", this.onDragEnd);\n    }\n\n    if (this._useTouch) {\n      addEvent(container, \"touchmove\", this.onDrag, passive);\n      addEvent(win, \"touchend\", this.onDragEnd, passive);\n      addEvent(win, \"touchcancel\", this.onDragEnd, passive);\n    }\n  }\n  private _dettachDragEvent() {\n    const win = this._window;\n    const container = this.options.container!;\n\n    if (this._isDragAPI) {\n      removeEvent(container, \"dragover\", this.onDrag);\n      removeEvent(win, \"dragend\", this.onDragEnd);\n    }\n    if (this._useMouse) {\n      removeEvent(container, \"mousemove\", this.onDrag);\n      removeEvent(win, \"mouseup\", this.onDragEnd);\n    }\n\n    if (this._useTouch) {\n      removeEvent(container, \"touchstart\", this.onDragStart);\n      removeEvent(container, \"touchmove\", this.onDrag);\n      removeEvent(win, \"touchend\", this.onDragEnd);\n      removeEvent(win, \"touchcancel\", this.onDragEnd);\n    }\n  }\n  private _onClick = (e: MouseEvent) => {\n    this._allowClickEvent();\n    this._allowMouseEvent();\n\n    const preventClickEventByCondition =\n      this.options.preventClickEventByCondition;\n    if (preventClickEventByCondition?.(e)) {\n      return;\n    }\n    e.stopPropagation();\n    e.preventDefault();\n  };\n  private _onContextMenu = (e: MouseEvent) => {\n    const options = this.options;\n    if (!options.preventRightClick) {\n      e.preventDefault();\n    } else {\n      this.onDragEnd(e);\n    }\n  };\n  private _allowMouseEvent() {\n    this._preventMouseEvent = false;\n    clearTimeout(this._preventMouseEventId);\n  }\n  private _passCallback = () => {};\n}\n\nexport default Gesto;\n","type Key = string | number;\ntype ChangedItem = [number, number];\ntype ChangedBeforeAdded = [number, number];\ntype List<ItemType> = ItemType[];\n\nclass PolyMap<K extends Key, V> {\n  private keys: K[] = [];\n  private values: V[] = [];\n\n  get(key: K): V | undefined {\n    const index = this.keys.indexOf(key);\n    return index !== -1 ? this.values[index] : undefined;\n  }\n\n  set(key: K, value: V): void {\n    const index = this.keys.indexOf(key);\n    if (index === -1) {\n      this.keys.push(key);\n      this.values.push(value);\n    } else {\n      this.values[index] = value;\n    }\n  }\n}\n\nclass HashMap<V> {\n  private object: Record<Key, V> = {};\n\n  get(key: Key): V | undefined {\n    return this.object[key];\n  }\n\n  set(key: Key, value: V): void {\n    this.object[key] = value;\n  }\n}\n\nconst SUPPORT_MAP = typeof Map === \"function\";\n\nclass Link {\n  prev?: Link;\n  next?: Link;\n\n  connect(prevLink?: Link, nextLink?: Link): void {\n    this.prev = prevLink;\n    this.next = nextLink;\n    if (prevLink) prevLink.next = this;\n    if (nextLink) nextLink.prev = this;\n  }\n\n  disconnect(): void {\n    const { prev, next } = this;\n    if (prev) prev.next = next;\n    if (next) next.prev = prev;\n  }\n\n  getIndex(): number {\n    let index = -1;\n    let link: Link | undefined = this;\n\n    while (link) {\n      link = link.prev;\n      ++index;\n    }\n    return index;\n  }\n}\n\nfunction orderChanged(\n  changed: ChangedBeforeAdded[],\n  fixed: boolean[]\n): ChangedItem[] {\n  const fromLinks: Link[] = [];\n  const toLinks: Link[] = [];\n\n  changed.forEach(([from, to]) => {\n    const link = new Link();\n    fromLinks[from] = link;\n    toLinks[to] = link;\n  });\n\n  fromLinks.forEach((link, i) => {\n    link.connect(fromLinks[i - 1]);\n  });\n\n  return changed\n    .filter((_, i) => !fixed[i])\n    .map(([from, to]) => {\n      if (from === to) {\n        return [0, 0];\n      }\n\n      const fromLink = fromLinks[from];\n      const toLink = toLinks[to - 1];\n      const fromIndex = fromLink.getIndex();\n\n      fromLink.disconnect();\n      fromLink.connect(toLink, toLink?.next);\n\n      const toIndex = fromLink.getIndex();\n      return [fromIndex, toIndex];\n    });\n}\n\nclass Result<ItemType> {\n  prevList: List<ItemType>;\n  list: List<ItemType>;\n  added: number[];\n  removed: number[];\n  changed: ChangedItem[];\n  maintained: ChangedItem[];\n  changedBeforeAdded: ChangedBeforeAdded[];\n  fixed: boolean[];\n\n  private cacheOrdered?: ChangedItem[];\n  private cachePureChanged?: ChangedItem[];\n\n  constructor(\n    prevList: List<ItemType>,\n    list: List<ItemType>,\n    added: number[],\n    removed: number[],\n    changed: ChangedItem[],\n    maintained: ChangedItem[],\n    changedBeforeAdded: ChangedBeforeAdded[],\n    fixed: boolean[]\n  ) {\n    this.prevList = prevList;\n    this.list = list;\n    this.added = added;\n    this.removed = removed;\n    this.changed = changed;\n    this.maintained = maintained;\n    this.changedBeforeAdded = changedBeforeAdded;\n    this.fixed = fixed;\n  }\n\n  get ordered(): ChangedItem[] {\n    if (!this.cacheOrdered) {\n      this.calculateOrdered();\n    }\n    return this.cacheOrdered!;\n  }\n\n  get pureChanged(): ChangedItem[] {\n    if (!this.cachePureChanged) {\n      this.calculateOrdered();\n    }\n    return this.cachePureChanged!;\n  }\n\n  private calculateOrdered(): void {\n    const ordered = orderChanged(this.changedBeforeAdded, this.fixed);\n    const pureChanged: ChangedItem[] = [];\n\n    this.cacheOrdered = ordered.filter(([_from, _to], i) => {\n      const [fromBefore, toBefore] = this.changed[i];\n      if (_from !== _to) {\n        pureChanged.push([fromBefore, toBefore]);\n        return true;\n      }\n      return false;\n    });\n\n    this.cachePureChanged = pureChanged;\n  }\n}\n\ntype MapConstructor<K, V> = new () => {\n  get(key: K): V | undefined;\n  set(key: K, value: V): void;\n};\n\nexport function diff<ItemType>(\n  prevList: List<ItemType>,\n  list: List<ItemType>,\n  findKeyCallback?: (e: ItemType) => Key\n): Result<ItemType> {\n  const mapClass: MapConstructor<unknown, number> = SUPPORT_MAP\n    ? Map\n    : findKeyCallback\n    ? HashMap\n    : PolyMap;\n  const callback = findKeyCallback || ((e: ItemType) => e as unknown as Key);\n\n  const added: number[] = [];\n  const removed: number[] = [];\n  const maintained: ChangedItem[] = [];\n  const prevKeys = prevList.map(callback);\n  const keys = list.map(callback);\n  const prevKeyMap = new mapClass();\n  const keyMap = new mapClass();\n  const changedBeforeAdded: ChangedBeforeAdded[] = [];\n  const fixed: boolean[] = [];\n  const removedMap: Record<number, number> = {};\n  const changed: ChangedItem[] = [];\n  let addedCount = 0;\n  let removedCount = 0;\n\n  prevKeys.forEach((key, prevListIndex) => {\n    prevKeyMap.set(key, prevListIndex);\n  });\n\n  keys.forEach((key, listIndex) => {\n    keyMap.set(key, listIndex);\n  });\n\n  prevKeys.forEach((key, prevListIndex) => {\n    const listIndex = keyMap.get(key);\n    if (listIndex === undefined) {\n      removed.push(prevListIndex);\n      ++removedCount;\n    } else {\n      removedMap[listIndex] = removedCount;\n    }\n  });\n\n  keys.forEach((key, listIndex) => {\n    const prevListIndex = prevKeyMap.get(key);\n    if (prevListIndex === undefined) {\n      added.push(listIndex);\n      ++addedCount;\n    } else {\n      maintained.push([prevListIndex, listIndex]);\n      removedCount = removedMap[listIndex] || 0;\n      changedBeforeAdded.push([\n        prevListIndex - removedCount,\n        listIndex - addedCount,\n      ]);\n      fixed.push(listIndex === prevListIndex);\n\n      if (prevListIndex !== listIndex) {\n        changed.push([prevListIndex, listIndex]);\n      }\n    }\n  });\n\n  removed.reverse();\n  return new Result(\n    prevList,\n    list,\n    added,\n    removed,\n    changed,\n    maintained,\n    changedBeforeAdded,\n    fixed\n  );\n}\n\nclass ListDiffer<ItemType> {\n  private findKeyCallback: ((e: ItemType) => Key) | undefined;\n  private list: List<ItemType>;\n\n  constructor(\n    list: List<ItemType> = [],\n    findKeyCallback?: (e: ItemType) => Key\n  ) {\n    this.findKeyCallback = findKeyCallback;\n    this.list = [...list];\n  }\n\n  update(list: List<ItemType>): Result<ItemType> {\n    const newData = [...list];\n    const result = diff(this.list, newData, this.findKeyCallback);\n    this.list = newData;\n    return result;\n  }\n\n  static diff = diff;\n}\n\nexport default ListDiffer;\n","export const findKeyCallback =\n  typeof Map === \"function\"\n    ? undefined\n    : (() => {\n        let childrenCount = 0;\n\n        return (el: Element) =>\n          (el as any).__DIFF_KEY__ ||\n          ((el as any).__DIFF_KEY__ = ++childrenCount);\n      })();\n\nexport const SUPPORT_MAP = typeof Map === \"function\";\n","import { diff as listdiff } from \"./list-differ\";\nimport { findKeyCallback } from \"./consts\";\nimport { IResult } from \"./types\";\n\nimport ListDiffer from \"./list-differ\";\n\n/**\n * A module that tracks changes in child elements including additions, removals, and reordering.\n * @extends eg.ListDiffer\n */\nclass ChildrenDiffer<T extends Element = Element> extends ListDiffer<T> {\n  /**\n   * @param - Initializing Children <ko> 초기 설정할 자식 노드들</ko>\n   */\n  constructor(list = []) {\n    super(list, findKeyCallback);\n  }\n}\nexport default ChildrenDiffer;\n\n/**\n * Computes the difference between two arrays of elements\n * @memberof eg.ChildrenDiffer\n * @static\n * @function\n * @param {T[]} prevList - Previous array of elements\n * @param {T[]} list - New array of elements to compare against\n * @return {IResult<T>} Object containing the following differences:\n * - prevList: Original list before updates\n * - list: New updated list\n * - added: Array of indices where new elements were added\n * - removed: Array of indices where elements were removed\n * - changed: Array of [prevIndex, newIndex] pairs showing position changes\n * - pureChanged: Array of direct position moves\n * - ordered: Array of moves needed to synchronize the lists\n * - maintained: Array of elements that were preserved between lists\n * @example\n * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1]);\n *\n * result.prevList;   // [1, 2, 3, 4, 5]\n * result.list;       // [4, 3, 6, 2, 1]\n * result.added;      // [0, 1, 5]\n * result.removed;    // [5]\n * result.changed;    // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * result.pureChanged; // [[4, 3], [3, 4], [2, 6]]\n * result.ordered;    // [[4, 1], [4, 2], [4, 3]]\n * result.maintained; // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n */\nexport function diff<T extends Element = Element>(\n  prevList: T[],\n  list: T[]\n): IResult<T> {\n  return listdiff<T>(prevList, list, findKeyCallback);\n}\n","import EventEmitter from \"../event-emitter\";\nimport { isFunction, isString, now } from \"../utility\";\nimport {\n  CheckScrollOptions,\n  DragScrollEvents,\n  DragScrollOptions,\n  Rect,\n} from \"./types\";\n\nfunction getDefaultScrollPosition(e: {\n  container: HTMLElement;\n  direction: number[];\n}) {\n  let container = e.container;\n\n  if (container === document.body) {\n    return [\n      container.scrollLeft || document.documentElement.scrollLeft,\n      container.scrollTop || document.documentElement.scrollTop,\n    ];\n  }\n  return [container.scrollLeft, container.scrollTop];\n}\n\nfunction checkDefaultScrollEvent(\n  container: HTMLElement | Window,\n  callback: () => void\n) {\n  container.addEventListener(\"scroll\", callback);\n\n  return () => {\n    container.removeEventListener(\"scroll\", callback);\n  };\n}\n\nfunction getContainerElement(\n  container: DragScrollOptions[\"container\"]\n): HTMLElement {\n  if (!container) {\n    return null;\n  } else if (isString(container)) {\n    return document.querySelector<HTMLElement>(container);\n  }\n  if (isFunction(container)) {\n    return container();\n  } else if (container instanceof Element) {\n    return container;\n  } else if (\"current\" in container) {\n    return container.current;\n  } else if (\"value\" in container) {\n    return container.value;\n  }\n}\n\n/**\n * @sort 1\n */\nclass DragScroll extends EventEmitter<DragScrollEvents> {\n  private _startRect: Rect | null = null;\n  private _startPos: number[] = [];\n  private _prevTime: number = 0;\n  private _timer: number = 0;\n  private _prevScrollPos: number[] = [0, 0];\n  private _isWait = false;\n  private _flag = false;\n  private _currentOptions: DragScrollOptions | null = null;\n  private _lock = false;\n  private _unregister: (() => void) | null = null;\n  /**\n   */\n  public dragStart(e: any, options: DragScrollOptions) {\n    const container = getContainerElement(options.container);\n\n    if (!container) {\n      this._flag = false;\n      return;\n    }\n    let top = 0;\n    let left = 0;\n    let width = 0;\n    let height = 0;\n\n    if (container === document.body) {\n      width = window.innerWidth;\n      height = window.innerHeight;\n    } else {\n      const rect = container.getBoundingClientRect();\n\n      top = rect.top;\n      left = rect.left;\n      width = rect.width;\n      height = rect.height;\n    }\n\n    this._flag = true;\n    this._startPos = [e.clientX, e.clientY];\n    this._startRect = { top, left, width, height };\n    this._prevScrollPos = this._getScrollPosition([0, 0], options);\n    this._currentOptions = options;\n    this._registerScrollEvent(options);\n  }\n  public drag(e: any, options: DragScrollOptions) {\n    clearTimeout(this._timer);\n    if (!this._flag) {\n      return;\n    }\n    const { clientX, clientY } = e;\n    const { threshold = 0 } = options;\n    const { _startRect, _startPos } = this;\n\n    this._currentOptions = options;\n    const direction = [0, 0];\n\n    if (_startRect.top > clientY - threshold) {\n      if (_startPos[1] > _startRect.top || clientY < _startPos[1]) {\n        direction[1] = -1;\n      }\n    } else if (_startRect.top + _startRect.height < clientY + threshold) {\n      if (\n        _startPos[1] < _startRect.top + _startRect.height ||\n        clientY > _startPos[1]\n      ) {\n        direction[1] = 1;\n      }\n    }\n    if (_startRect.left > clientX - threshold) {\n      if (_startPos[0] > _startRect.left || clientX < _startPos[0]) {\n        direction[0] = -1;\n      }\n    } else if (_startRect.left + _startRect.width < clientX + threshold) {\n      if (\n        _startPos[0] < _startRect.left + _startRect.width ||\n        clientX > _startPos[0]\n      ) {\n        direction[0] = 1;\n      }\n    }\n\n    if (!direction[0] && !direction[1]) {\n      return false;\n    }\n    return this._continueDrag({\n      ...options,\n      direction,\n      inputEvent: e,\n      isDrag: true,\n    });\n  }\n  /**\n   */\n  public checkScroll(options: CheckScrollOptions) {\n    if (this._isWait) {\n      return false;\n    }\n    const {\n      prevScrollPos = this._prevScrollPos,\n      direction,\n      throttleTime = 0,\n      inputEvent,\n      isDrag,\n    } = options;\n    const nextScrollPos = this._getScrollPosition(direction || [0, 0], options);\n    const offsetX = nextScrollPos[0] - prevScrollPos[0];\n    const offsetY = nextScrollPos[1] - prevScrollPos[1];\n\n    const nextDirection = direction || [\n      offsetX ? Math.abs(offsetX) / offsetX : 0,\n      offsetY ? Math.abs(offsetY) / offsetY : 0,\n    ];\n    this._prevScrollPos = nextScrollPos;\n    this._lock = false;\n\n    if (!offsetX && !offsetY) {\n      return false;\n    }\n    /**\n     * @event DragScroll#move\n     */\n    this.emit(\"move\", {\n      offsetX: nextDirection[0] ? offsetX : 0,\n      offsetY: nextDirection[1] ? offsetY : 0,\n      inputEvent,\n    });\n\n    if (throttleTime && isDrag) {\n      clearTimeout(this._timer);\n      this._timer = window.setTimeout(() => {\n        this._continueDrag(options);\n      }, throttleTime);\n    }\n    return true;\n  }\n  /**\n   *\n   */\n  public dragEnd() {\n    this._flag = false;\n    this._lock = false;\n    clearTimeout(this._timer);\n    this._unregisterScrollEvent();\n  }\n  private _getScrollPosition(direction: number[], options: DragScrollOptions) {\n    const { container, getScrollPosition = getDefaultScrollPosition } = options;\n    return getScrollPosition({\n      container: getContainerElement(container),\n      direction,\n    });\n  }\n  private _continueDrag(options: CheckScrollOptions) {\n    const {\n      container,\n      direction,\n      throttleTime,\n      useScroll,\n      isDrag,\n      inputEvent,\n    } = options;\n\n    if (!this._flag || (isDrag && this._isWait)) {\n      return;\n    }\n    const nowTime = now();\n    const distTime = Math.max(throttleTime + this._prevTime - nowTime, 0);\n\n    if (distTime > 0) {\n      clearTimeout(this._timer);\n      this._timer = window.setTimeout(() => {\n        this._continueDrag(options);\n      }, distTime);\n\n      return false;\n    }\n    this._prevTime = nowTime;\n    const prevScrollPos = this._getScrollPosition(direction, options);\n\n    this._prevScrollPos = prevScrollPos;\n\n    if (isDrag) {\n      this._isWait = true;\n    }\n\n    // unregister native scroll event\n    if (!useScroll) {\n      this._lock = true;\n    }\n    const param = {\n      container: getContainerElement(container),\n      direction,\n      inputEvent,\n    };\n    options.requestScroll?.(param);\n    /**\n     * @event DragScroll#scroll\n     */\n    this.emit(\"scroll\", param);\n\n    this._isWait = false;\n    return (\n      useScroll ||\n      this.checkScroll({\n        ...options,\n        prevScrollPos,\n        direction,\n        inputEvent,\n      })\n    );\n  }\n\n  private _registerScrollEvent(options: DragScrollOptions) {\n    this._unregisterScrollEvent();\n    const checkScrollEvent = options.checkScrollEvent;\n\n    if (!checkScrollEvent) {\n      return;\n    }\n    const callback =\n      checkScrollEvent === true ? checkDefaultScrollEvent : checkScrollEvent;\n    const container = getContainerElement(options.container);\n\n    if (\n      checkScrollEvent === true &&\n      (container === document.body || container === document.documentElement)\n    ) {\n      this._unregister = checkDefaultScrollEvent(window, this._onScroll);\n    } else {\n      this._unregister = callback(container, this._onScroll);\n    }\n  }\n  private _unregisterScrollEvent() {\n    this._unregister?.();\n    this._unregister = null;\n  }\n\n  private _onScroll = () => {\n    const options = this._currentOptions;\n    if (this._lock || !options) {\n      return;\n    }\n\n    this.emit(\"scrollDrag\", {\n      next: (inputEvent: any) => {\n        this.checkScroll({\n          container: options.container,\n          inputEvent,\n        });\n      },\n    });\n  };\n}\n\nexport default DragScroll;\n","import { throttle, TINY_NUM } from \"../utility\";\n\nexport function tinyThrottle(num: number) {\n  return throttle(num, TINY_NUM);\n}\nexport function isSameConstants(\n  linearConstants1: number[],\n  linearConstants2: number[]\n) {\n  return linearConstants1.every(\n    (v, i) => tinyThrottle(v - linearConstants2[i]) === 0\n  );\n}\n\nexport function isSamePoint(point1: number[], point2: number[]) {\n  return (\n    !tinyThrottle(point1[0] - point2[0]) && !tinyThrottle(point1[1] - point2[1])\n  );\n}\n\nexport function flat<Type extends any>(arr: Type[][]): Type[] {\n  return arr.reduce<Type[]>((prev, current) => {\n    prev.push(...current);\n    return prev;\n  }, []);\n}\n","import {\n  find,\n  findIndex,\n  getDist,\n  getShapeDirection,\n  TINY_NUM,\n} from \"../utility\";\nimport { OverlapPointInfo, Rect } from \"./types\";\nimport { isSameConstants, isSamePoint, tinyThrottle } from \"./utils\";\n\n/**\n * Gets the size of a shape (polygon) made of points.\n * @memberof OverlapArea\n */\nexport function getAreaSize(points: number[][]): number {\n  if (points.length < 3) {\n    return 0;\n  }\n  return (\n    Math.abs(\n      sum(\n        points.map((point, i) => {\n          const nextPoint = points[i + 1] || points[0];\n\n          return point[0] * nextPoint[1] - nextPoint[0] * point[1];\n        })\n      )\n    ) / 2\n  );\n}\n\n/**\n * Add all the numbers.\n * @function\n * @memberof Utils\n */\nexport function sum(nums: number[]): number {\n  const length = nums.length;\n  let total = 0;\n\n  for (let i = length - 1; i >= 0; --i) {\n    total += nums[i];\n  }\n  return total;\n}\n\n/**\n * Get the points of the overlapped part of two shapes.\n * @function\n * @memberof OverlapArea\n */\nexport function getOverlapPoints(\n  points1: number[][],\n  points2: number[][]\n): number[][] {\n  const infos = getOverlapPointInfos(points1, points2);\n\n  return infos.map(({ pos }) => pos);\n}\n\n/**\n * Convert two points into lines.\n * @function\n * @memberof OverlapArea\n */\nexport function convertLines(points: number[][]): number[][][] {\n  return [...points.slice(1), points[0]].map((point, i) => [points[i], point]);\n}\n\n/**\n * Get the coefficient of the linear function. [a, b, c] (ax + by + c = 0)\n * @return [a, b, c]\n * @memberof OverlapArea\n */\nexport function getLinearConstants(\n  point1: number[],\n  point2: number[]\n): [number, number, number] {\n  const [x1, y1] = point1;\n  const [x2, y2] = point2;\n  // ax + by + c = 0\n  // [a, b, c]\n  let dx = x2 - x1;\n  let dy = y2 - y1;\n\n  if (Math.abs(dx) < TINY_NUM) {\n    dx = 0;\n  }\n  if (Math.abs(dy) < TINY_NUM) {\n    dy = 0;\n  }\n\n  // b > 0\n  // ax + by + c = 0\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  if (!dx) {\n    if (dy) {\n      // -x + 1 = 0\n      a = -1;\n      c = x1;\n    }\n  } else if (!dy) {\n    // y - 1 = 0\n    b = 1;\n    c = -y1;\n  } else {\n    // y = -a(x - x1) + y1\n    // ax + y + a * x1 - y1 = 0\n    a = -dy / dx;\n    b = 1;\n    c = -a * x1 - y1;\n  }\n\n  return [a, b, c] as [number, number, number];\n}\n\nfunction getOverlapPointInfos(\n  points1: number[][],\n  points2: number[][]\n): OverlapPointInfo[] {\n  const targetPoints1 = points1.slice();\n  const targetPoints2 = points2.slice();\n\n  if (getShapeDirection(targetPoints1) === -1) {\n    targetPoints1.reverse();\n  }\n  if (getShapeDirection(targetPoints2) === -1) {\n    targetPoints2.reverse();\n  }\n  const lines1 = convertLines(targetPoints1);\n  const lines2 = convertLines(targetPoints2);\n  const linearConstantsList1 = lines1.map((line1) =>\n    getLinearConstants(line1[0], line1[1])\n  );\n  const linearConstantsList2 = lines2.map((line2) =>\n    getLinearConstants(line2[0], line2[1])\n  );\n\n  const overlapInfos: OverlapPointInfo[] = [];\n\n  linearConstantsList1.forEach((linearConstants1, i) => {\n    const line1 = lines1[i];\n    const linePointInfos: OverlapPointInfo[] = [];\n    linearConstantsList2.forEach((linearConstants2, j) => {\n      const intersectionPoints = getIntersectionPointsByConstants(\n        linearConstants1,\n        linearConstants2\n      );\n      const points = getPointsOnLines(intersectionPoints, [line1, lines2[j]]);\n\n      linePointInfos.push(\n        ...points.map((pos) => ({\n          index1: i,\n          index2: j,\n          pos,\n          type: \"intersection\" as const,\n        }))\n      );\n    });\n    linePointInfos.sort((a, b) => {\n      return getDist(line1[0], a.pos) - getDist(line1[0], b.pos);\n    });\n\n    overlapInfos.push(...linePointInfos);\n\n    if (isInside(line1[1], targetPoints2)) {\n      overlapInfos.push({\n        index1: i,\n        index2: -1,\n        pos: line1[1],\n        type: \"inside\" as const,\n      });\n    }\n  });\n\n  lines2.forEach((line2, i) => {\n    if (!isInside(line2[1], targetPoints1)) {\n      return;\n    }\n    let isNext = false;\n    let index = findIndex(overlapInfos, ({ index2 }) => {\n      if (index2 === i) {\n        isNext = true;\n        return false;\n      }\n\n      if (isNext) {\n        return true;\n      }\n      return false;\n    });\n    if (index === -1) {\n      isNext = false;\n      index = findIndex(overlapInfos, ({ index1, index2 }) => {\n        if (index1 === -1 && index2 + 1 === i) {\n          isNext = true;\n          return false;\n        }\n\n        if (isNext) {\n          return true;\n        }\n        return false;\n      });\n    }\n    if (index === -1) {\n      overlapInfos.push({\n        index1: -1,\n        index2: i,\n        pos: line2[1],\n        type: \"inside\" as const,\n      });\n    } else {\n      overlapInfos.splice(index, 0, {\n        index1: -1,\n        index2: i,\n        pos: line2[1],\n        type: \"inside\" as const,\n      });\n    }\n  });\n  const pointMap: Record<string, boolean> = {};\n\n  return overlapInfos.filter(({ pos }) => {\n    const key = `${pos[0]}x${pos[1]}`;\n\n    if (pointMap[key]) {\n      return false;\n    }\n    pointMap[key] = true;\n    return true;\n  });\n}\n\n/**\n * Get intersection points with linear functions.\n * @memberof OverlapArea\n */\nexport function getIntersectionPointsByConstants(\n  linearConstants1: number[],\n  linearConstants2: number[]\n): number[][] {\n  const [a1, b1, c1] = linearConstants1;\n  const [a2, b2, c2] = linearConstants2;\n\n  const isZeroA = a1 === 0 && a2 === 0;\n  const isZeroB = b1 === 0 && b2 === 0;\n  let results: number[][] = [];\n\n  if (isZeroA && isZeroB) {\n    return [];\n  } else if (isZeroA) {\n    // b1 * y + c1 = 0\n    // b2 * y + c2 = 0\n    const y1 = -c1 / b1;\n    const y2 = -c2 / b2;\n\n    if (y1 !== y2) {\n      return [];\n    } else {\n      return [\n        [-Infinity, y1],\n        [Infinity, y1],\n      ];\n    }\n  } else if (isZeroB) {\n    // a1 * x + c1 = 0\n    // a2 * x + c2 = 0\n    const x1 = -c1 / a1;\n    const x2 = -c2 / a2;\n\n    if (x1 !== x2) {\n      return [];\n    } else {\n      return [\n        [x1, -Infinity],\n        [x1, Infinity],\n      ];\n    }\n  } else if (a1 === 0) {\n    // b1 * y + c1 = 0\n    // y = - c1 / b1;\n    // a2 * x + b2 * y + c2 = 0\n    const y = -c1 / b1;\n    const x = -(b2 * y + c2) / a2;\n\n    results = [[x, y]];\n  } else if (a2 === 0) {\n    // b2 * y + c2 = 0\n    // y = - c2 / b2;\n    // a1 * x + b1 * y + c1 = 0\n    const y = -c2 / b2;\n    const x = -(b1 * y + c1) / a1;\n\n    results = [[x, y]];\n  } else if (b1 === 0) {\n    // a1 * x + c1 = 0\n    // x = - c1 / a1;\n    // a2 * x + b2 * y + c2 = 0\n    const x = -c1 / a1;\n    const y = -(a2 * x + c2) / b2;\n\n    results = [[x, y]];\n  } else if (b2 === 0) {\n    // a2 * x + c2 = 0\n    // x = - c2 / a2;\n    // a1 * x + b1 * y + c1 = 0\n    const x = -c2 / a2;\n    const y = -(a1 * x + c1) / b1;\n\n    results = [[x, y]];\n  } else {\n    // a1 * x + b1 * y + c1 = 0\n    // a2 * x + b2 * y + c2 = 0\n    // b2 * a1 * x + b2 * b1 * y + b2 * c1 = 0\n    // b1 * a2 * x + b1 * b2 * y + b1 * c2 = 0\n    // (b2 * a1 - b1 * a2)  * x = (b1 * c2 - b2 * c1)\n    const x = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);\n    const y = -(a1 * x + c1) / b1;\n\n    results = [[x, y]];\n  }\n\n  return results.map((result) => [result[0], result[1]]);\n}\n\n/**\n * Get the points on the lines (between two points).\n * @memberof OverlapArea\n */\nexport function getPointsOnLines(\n  points: number[][],\n  lines: number[][][]\n): number[][] {\n  const minMaxs = lines.map((line) =>\n    [0, 1].map((order) => [\n      Math.min(line[0][order], line[1][order]),\n      Math.max(line[0][order], line[1][order]),\n    ])\n  );\n  let results: number[][] = [];\n\n  if (points.length === 2) {\n    const [x, y] = points[0];\n    if (!tinyThrottle(x - points[1][0])) {\n      /// Math.max(minY1, minY2)\n      const top = Math.max(...minMaxs.map((minMax) => minMax[1][0]));\n      /// Math.min(maxY1, miax2)\n      const bottom = Math.min(...minMaxs.map((minMax) => minMax[1][1]));\n\n      if (tinyThrottle(top - bottom) > 0) {\n        return [];\n      }\n      results = [\n        [x, top],\n        [x, bottom],\n      ];\n    } else if (!tinyThrottle(y - points[1][1])) {\n      /// Math.max(minY1, minY2)\n      const left = Math.max(...minMaxs.map((minMax) => minMax[0][0]));\n      /// Math.min(maxY1, miax2)\n      const right = Math.min(...minMaxs.map((minMax) => minMax[0][1]));\n\n      if (tinyThrottle(left - right) > 0) {\n        return [];\n      }\n      results = [\n        [left, y],\n        [right, y],\n      ];\n    }\n  }\n\n  if (!results.length) {\n    results = points.filter((point) => {\n      const [pointX, pointY] = point;\n\n      return minMaxs.every((minMax) => {\n        return (\n          0 <= tinyThrottle(pointX - minMax[0][0]) &&\n          0 <= tinyThrottle(minMax[0][1] - pointX) &&\n          0 <= tinyThrottle(pointY - minMax[1][0]) &&\n          0 <= tinyThrottle(minMax[1][1] - pointY)\n        );\n      });\n    });\n  }\n\n  return results.map((result) => [\n    tinyThrottle(result[0]),\n    tinyThrottle(result[1]),\n  ]);\n}\n\n/**\n * Whether the point is in shape\n * @param - point pos\n * @param - shape points\n * @param - whether to check except line\n * @memberof OverlapArea\n */\nexport function isInside(\n  pos: number[],\n  points: number[][],\n  excludeLine?: boolean\n): boolean {\n  const [x, y] = pos;\n  const { minX, maxX } = getMinMaxs(points);\n\n  const xLine = [\n    [minX, y],\n    [maxX, y],\n  ];\n  const xLinearConstants = getLinearConstants(xLine[0], xLine[1]);\n  const lines = convertLines(points);\n\n  interface IntersectionPosInfo {\n    pos: number[];\n    line: number[][];\n    type: \"intersection\" | \"point\" | \"line\";\n  }\n  const intersectionPosInfos: IntersectionPosInfo[] = [];\n\n  lines.forEach((line) => {\n    const linearConstants = getLinearConstants(line[0], line[1]);\n    const standardPoint = line[0];\n\n    if (isSameConstants(xLinearConstants, linearConstants)) {\n      intersectionPosInfos.push({\n        pos: pos,\n        line,\n        type: \"line\",\n      });\n    } else {\n      const xPoints = getPointsOnLines(\n        getIntersectionPointsByConstants(xLinearConstants, linearConstants),\n        [xLine, line]\n      );\n\n      xPoints.forEach((point) => {\n        if (line.some((linePoint) => isSamePoint(linePoint, point))) {\n          intersectionPosInfos.push({\n            pos: point,\n            line,\n            type: \"point\",\n          });\n        } else if (tinyThrottle(standardPoint[1] - y) !== 0) {\n          intersectionPosInfos.push({\n            pos: point,\n            line,\n            type: \"intersection\",\n          });\n        }\n      });\n    }\n  });\n\n  if (!excludeLine) {\n    // on line\n    if (find(intersectionPosInfos, (p: any) => p[0] === x)) {\n      return true;\n    }\n  }\n  let intersectionCount = 0;\n  const xMap: any = {};\n\n  intersectionPosInfos.forEach(({ pos, type, line }) => {\n    if (pos[0] > x) {\n      return;\n    }\n    if (type === \"intersection\") {\n      ++intersectionCount;\n    } else if (type === \"line\") {\n      return;\n    } else if (type === \"point\") {\n      const point: any = find(line, (linePoint) => linePoint[1] !== y);\n      const prevValue = xMap[pos[0]];\n      const nextValue = point[1] > y ? 1 : -1;\n\n      if (!prevValue) {\n        xMap[pos[0]] = nextValue;\n      } else if (prevValue !== nextValue) {\n        ++intersectionCount;\n      }\n    }\n  });\n  return intersectionCount % 2 === 1;\n}\n\n/**\n * Get the minimum and maximum points of the points.\n * @memberof OverlapArea\n */\nexport function getMinMaxs(points: number[][]): {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n} {\n  const xs = points.map((point) => point[0]);\n  const ys = points.map((point) => point[1]);\n\n  return {\n    minX: Math.min(...xs),\n    minY: Math.min(...ys),\n    maxX: Math.max(...xs),\n    maxY: Math.max(...ys),\n  };\n}\n\n/**\n * Get points that fit the rect,\n * @memberof OverlapArea\n */\nexport function fitPoints(points: number[][], rect: Rect): number[][] {\n  const { width, height, left, top } = rect;\n  const { minX, minY, maxX, maxY } = getMinMaxs(points);\n  const ratioX = width / (maxX - minX);\n  const ratioY = height / (maxY - minY);\n\n  return points.map((point) => {\n    return [\n      left + (point[0] - minX) * ratioX,\n      top + (point[1] - minY) * ratioY,\n    ];\n  });\n}\n\n/**\n * Gets the size of the overlapped part of two shapes.\n * @function\n * @memberof OverlapArea\n */\nexport function getOverlapSize(\n  points1: number[][],\n  points2: number[][]\n): number {\n  const points = getOverlapPoints(points1, points2);\n\n  return getAreaSize(points);\n}\n","import { average, throttle, TINY_NUM } from \"../utility\";\n\nfunction add(\n  matrix: number[],\n  inverseMatrix: number[],\n  startIndex: number,\n  fromIndex: number,\n  n: number,\n  k: number\n) {\n  for (let i = 0; i < n; ++i) {\n    const x = startIndex + i * n;\n    const fromX = fromIndex + i * n;\n    matrix[x] += matrix[fromX] * k;\n    inverseMatrix[x] += inverseMatrix[fromX] * k;\n  }\n}\n\nfunction swap(\n  matrix: number[],\n  inverseMatrix: number[],\n  startIndex: number,\n  fromIndex: number,\n  n: number\n) {\n  for (let i = 0; i < n; ++i) {\n    const x = startIndex + i * n;\n    const fromX = fromIndex + i * n;\n    const v = matrix[x];\n    const iv = inverseMatrix[x];\n\n    matrix[x] = matrix[fromX];\n    matrix[fromX] = v;\n\n    inverseMatrix[x] = inverseMatrix[fromX];\n    inverseMatrix[fromX] = iv;\n  }\n}\n\nfunction divide(\n  matrix: number[],\n  inverseMatrix: number[],\n  startIndex: number,\n  n: number,\n  k: number\n) {\n  for (let i = 0; i < n; ++i) {\n    const x = startIndex + i * n;\n\n    matrix[x] /= k;\n    inverseMatrix[x] /= k;\n  }\n}\n\n/**\n *\n * @namespace Matrix\n */\n/**\n * @memberof Matrix\n */\nexport function ignoreDimension(\n  matrix: number[],\n  m: number,\n  n: number = Math.sqrt(matrix.length)\n) {\n  const newMatrix = matrix.slice();\n\n  for (let i = 0; i < n; ++i) {\n    newMatrix[i * n + m - 1] = 0;\n    newMatrix[(m - 1) * n + i] = 0;\n  }\n  newMatrix[(m - 1) * (n + 1)] = 1;\n\n  return newMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function invert(matrix: number[], n: number = Math.sqrt(matrix.length)) {\n  const newMatrix = matrix.slice();\n  const inverseMatrix = createIdentityMatrix(n);\n\n  for (let i = 0; i < n; ++i) {\n    // diagonal\n    const identityIndex = n * i + i;\n\n    if (!throttle(newMatrix[identityIndex], TINY_NUM)) {\n      // newMatrix[identityIndex] = 0;\n      for (let j = i + 1; j < n; ++j) {\n        if (newMatrix[n * i + j]) {\n          swap(newMatrix, inverseMatrix, i, j, n);\n          break;\n        }\n      }\n    }\n    if (!throttle(newMatrix[identityIndex], TINY_NUM)) {\n      // no inverse matrix\n      return [];\n    }\n    divide(newMatrix, inverseMatrix, i, n, newMatrix[identityIndex]);\n    for (let j = 0; j < n; ++j) {\n      const targetStartIndex = j;\n      const targetIndex = j + i * n;\n      const target = newMatrix[targetIndex];\n\n      if (!throttle(target, TINY_NUM) || i === j) {\n        continue;\n      }\n      add(newMatrix, inverseMatrix, targetStartIndex, i, n, -target);\n    }\n  }\n\n  return inverseMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function transpose(\n  matrix: number[],\n  n: number = Math.sqrt(matrix.length)\n) {\n  const newMatrix: number[] = [];\n\n  for (let i = 0; i < n; ++i) {\n    for (let j = 0; j < n; ++j) {\n      newMatrix[j * n + i] = matrix[n * i + j];\n    }\n  }\n  return newMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function getOrigin(\n  matrix: number[],\n  n: number = Math.sqrt(matrix.length)\n) {\n  const originMatrix: number[] = [];\n  const w = matrix[n * n - 1];\n  for (let i = 0; i < n - 1; ++i) {\n    originMatrix[i] = matrix[n * (n - 1) + i] / w;\n  }\n  originMatrix[n - 1] = 0;\n  return originMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function fromTranslation(pos: number[], n: number) {\n  const newMatrix = createIdentityMatrix(n);\n\n  for (let i = 0; i < n - 1; ++i) {\n    newMatrix[n * (n - 1) + i] = pos[i] || 0;\n  }\n  return newMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function convertPositionMatrix(matrix: number[], n: number) {\n  const newMatrix = matrix.slice();\n\n  for (let i = matrix.length; i < n - 1; ++i) {\n    newMatrix[i] = 0;\n  }\n  newMatrix[n - 1] = 1;\n  return newMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function convertDimension(\n  matrix: number[],\n  n: number = Math.sqrt(matrix.length),\n  m: number\n) {\n  // n < m\n  if (n === m) {\n    return matrix;\n  }\n  const newMatrix = createIdentityMatrix(m);\n\n  const length = Math.min(n, m);\n  for (let i = 0; i < length - 1; ++i) {\n    for (let j = 0; j < length - 1; ++j) {\n      newMatrix[i * m + j] = matrix[i * n + j];\n    }\n\n    newMatrix[(i + 1) * m - 1] = matrix[(i + 1) * n - 1];\n    newMatrix[(m - 1) * m + i] = matrix[(n - 1) * n + i];\n  }\n  newMatrix[m * m - 1] = matrix[n * n - 1];\n\n  return newMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function multiplies(n: number, ...matrixes: number[][]) {\n  let m: number[] = createIdentityMatrix(n);\n\n  matrixes.forEach((matrix) => {\n    m = multiply(m, matrix, n);\n  });\n  return m;\n}\n\n/**\n * @memberof Matrix\n */\nexport function multiply(\n  matrix: number[],\n  matrix2: number[],\n  n: number = Math.sqrt(matrix.length)\n) {\n  const newMatrix: number[] = [];\n  // 1 y: n\n  // 1 x: m\n  // 2 x: m\n  // 2 y: k\n  // n * m X m * k\n  const m = matrix.length / n;\n  const k = matrix2.length / m;\n\n  if (!m) {\n    return matrix2;\n  } else if (!k) {\n    return matrix;\n  }\n  for (let i = 0; i < n; ++i) {\n    for (let j = 0; j < k; ++j) {\n      newMatrix[j * n + i] = 0;\n      for (let l = 0; l < m; ++l) {\n        // m1 x: m(l), y: n(i)\n        // m2 x: k(j):  y: m(l)\n        // nw x: n(i), y: k(j)\n        newMatrix[j * n + i] += matrix[l * n + i] * matrix2[j * m + l];\n      }\n    }\n  }\n  // n * k\n  return newMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function plus(pos1: number[], pos2: number[]) {\n  const length = Math.min(pos1.length, pos2.length);\n  const nextPos = pos1.slice();\n\n  for (let i = 0; i < length; ++i) {\n    nextPos[i] = nextPos[i] + pos2[i];\n  }\n  return nextPos;\n}\n\n/**\n * @memberof Matrix\n */\nexport function minus(pos1: number[], pos2: number[]) {\n  const length = Math.min(pos1.length, pos2.length);\n  const nextPos = pos1.slice();\n\n  for (let i = 0; i < length; ++i) {\n    nextPos[i] = nextPos[i] - pos2[i];\n  }\n  return nextPos;\n}\n\n/**\n * @memberof Matrix\n */\nexport function convertCSStoMatrix(\n  a: number[],\n  is2d: boolean = a.length === 6\n) {\n  if (is2d) {\n    return [a[0], a[1], 0, a[2], a[3], 0, a[4], a[5], 1];\n  }\n  return a;\n}\n\n/**\n * @memberof Matrix\n */\nexport function convertMatrixtoCSS(\n  a: number[],\n  is2d: boolean = a.length === 9\n) {\n  if (is2d) {\n    return [a[0], a[1], a[3], a[4], a[6], a[7]];\n  }\n  return a;\n}\n\n/**\n * @memberof Matrix\n */\nexport function calculate(\n  matrix: number[],\n  matrix2: number[],\n  n: number = matrix2.length\n) {\n  const result = multiply(matrix, matrix2, n);\n  const k = result[n - 1];\n  return result.map((v) => v / k);\n}\n\n/**\n * @memberof Matrix\n */\nexport function rotateX3d(matrix: number[], rad: number) {\n  return multiply(\n    matrix,\n    [\n      1,\n      0,\n      0,\n      0,\n      0,\n      Math.cos(rad),\n      Math.sin(rad),\n      0,\n      0,\n      -Math.sin(rad),\n      Math.cos(rad),\n      0,\n      0,\n      0,\n      0,\n      1,\n    ],\n    4\n  );\n}\n\n/**\n * @memberof Matrix\n */\nexport function rotateY3d(matrix: number[], rad: number) {\n  return multiply(\n    matrix,\n    [\n      Math.cos(rad),\n      0,\n      -Math.sin(rad),\n      0,\n      0,\n      1,\n      0,\n      0,\n      Math.sin(rad),\n      0,\n      Math.cos(rad),\n      0,\n      0,\n      0,\n      0,\n      1,\n    ],\n    4\n  );\n}\n\n/**\n * @memberof Matrix\n */\nexport function rotateZ3d(matrix: number[], rad: number) {\n  return multiply(matrix, createRotateMatrix(rad, 4));\n}\n\n/**\n * @memberof Matrix\n */\nexport function scale3d(matrix: number[], [sx = 1, sy = 1, sz = 1]: number[]) {\n  return multiply(\n    matrix,\n    [sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1],\n    4\n  );\n}\n\n/**\n * @memberof Matrix\n */\nexport function rotate(pos: number[], rad: number) {\n  return calculate(createRotateMatrix(rad, 3), convertPositionMatrix(pos, 3));\n}\n\n/**\n * @memberof Matrix\n */\nexport function translate3d(\n  matrix: number[],\n  [tx = 0, ty = 0, tz = 0]: number[]\n) {\n  return multiply(\n    matrix,\n    [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1],\n    4\n  );\n}\n/**\n * @memberof Matrix\n */\nexport function matrix3d(matrix1: number[], matrix2: number[]) {\n  return multiply(matrix1, matrix2, 4);\n}\n\n/**\n * @memberof Matrix\n */\nexport function createRotateMatrix(rad: number, n: number) {\n  const cos = Math.cos(rad);\n  const sin = Math.sin(rad);\n  const m = createIdentityMatrix(n);\n\n  // cos -sin\n  // sin cos\n  m[0] = cos;\n  m[1] = sin;\n  m[n] = -sin;\n  m[n + 1] = cos;\n\n  return m;\n}\n\n/**\n * @memberof Matrix\n */\nexport function createIdentityMatrix(n: number) {\n  const length = n * n;\n  const matrix: number[] = [];\n\n  for (let i = 0; i < length; ++i) {\n    matrix[i] = i % (n + 1) ? 0 : 1;\n  }\n  return matrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function createScaleMatrix(scale: number[], n: number) {\n  const m = createIdentityMatrix(n);\n  const length = Math.min(scale.length, n - 1);\n\n  for (let i = 0; i < length; ++i) {\n    m[(n + 1) * i] = scale[i];\n  }\n  return m;\n}\n\n/**\n * @memberof Matrix\n */\nexport function createOriginMatrix(origin: number[], n: number) {\n  const m = createIdentityMatrix(n);\n  const length = Math.min(origin.length, n - 1);\n\n  for (let i = 0; i < length; ++i) {\n    m[n * (n - 1) + i] = origin[i];\n  }\n  return m;\n}\n\n/**\n * @memberof Matrix\n */\nexport function createWarpMatrix(\n  pos0: number[],\n  pos1: number[],\n  pos2: number[],\n  pos3: number[],\n  nextPos0: number[],\n  nextPos1: number[],\n  nextPos2: number[],\n  nextPos3: number[]\n) {\n  const [x0, y0] = pos0;\n  const [x1, y1] = pos1;\n  const [x2, y2] = pos2;\n  const [x3, y3] = pos3;\n\n  const [u0, v0] = nextPos0;\n  const [u1, v1] = nextPos1;\n  const [u2, v2] = nextPos2;\n  const [u3, v3] = nextPos3;\n\n  const matrix = [\n    x0,\n    0,\n    x1,\n    0,\n    x2,\n    0,\n    x3,\n    0,\n    y0,\n    0,\n    y1,\n    0,\n    y2,\n    0,\n    y3,\n    0,\n    1,\n    0,\n    1,\n    0,\n    1,\n    0,\n    1,\n    0,\n    0,\n    x0,\n    0,\n    x1,\n    0,\n    x2,\n    0,\n    x3,\n    0,\n    y0,\n    0,\n    y1,\n    0,\n    y2,\n    0,\n    y3,\n    0,\n    1,\n    0,\n    1,\n    0,\n    1,\n    0,\n    1,\n    -u0 * x0,\n    -v0 * x0,\n    -u1 * x1,\n    -v1 * x1,\n    -u2 * x2,\n    -v2 * x2,\n    -u3 * x3,\n    -v3 * x3,\n    -u0 * y0,\n    -v0 * y0,\n    -u1 * y1,\n    -v1 * y1,\n    -u2 * y2,\n    -v2 * y2,\n    -u3 * y3,\n    -v3 * y3,\n  ];\n  const inverseMatrix = invert(matrix, 8);\n\n  if (!inverseMatrix.length) {\n    return [];\n  }\n  const h = multiply(inverseMatrix, [u0, v0, u1, v1, u2, v2, u3, v3], 8);\n\n  h[8] = 1;\n  return convertDimension(transpose(h), 3, 4);\n}\n\n/**\n * @memberof Matrix\n */\nexport function getCenter(points: number[][]) {\n  return [0, 1].map((i) => average(points.map((pos) => pos[i])));\n}\n","import {\n  splitComma,\n  splitBracket,\n  splitUnit,\n  splitSpace,\n  isArray,\n  convertUnitSize,\n  isObject,\n} from \"../utility\";\nimport { MatrixInfo } from \"./types\";\nimport {\n  calculate,\n  invert,\n  matrix3d,\n  rotateX3d,\n  rotateY3d,\n  rotateZ3d,\n  scale3d,\n  translate3d,\n} from \"../matrix\";\n\nexport function createMatrix() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nexport function parseMat(\n  transform: string | string[],\n  size: number | Record<string, ((pos: number) => number) | number> = 0\n): number[] {\n  return toMat(parse(transform, size));\n}\nexport function getElementMatrix(el: HTMLElement) {\n  return parseMat(getComputedStyle(el).transform!);\n}\nexport function calculateMatrixDist(matrix: number[], pos: number[]) {\n  const res = calculate(matrix, [pos[0], pos[1] || 0, pos[2] || 0, 1], 4);\n  const w = res[3] || 1;\n\n  return [res[0] / w, res[1] / w, res[2] / w];\n}\nexport function getDistElementMatrix(\n  el: HTMLElement,\n  container = document.body\n): number[] {\n  let target: HTMLElement | null = el;\n  let matrix = createMatrix();\n\n  while (target) {\n    const transform = getComputedStyle(target).transform!;\n    matrix = matrix3d(parseMat(transform), matrix);\n\n    if (target === container) {\n      break;\n    }\n    target = target.parentElement;\n  }\n  matrix = invert(matrix, 4);\n\n  matrix[12] = 0;\n  matrix[13] = 0;\n  matrix[14] = 0;\n\n  return matrix;\n}\n\nexport function toMat(matrixInfos: MatrixInfo[]): number[] {\n  let target = createMatrix();\n\n  matrixInfos.forEach((info) => {\n    const { matrixFunction, functionValue } = info;\n\n    if (!matrixFunction) {\n      return;\n    }\n    target = matrixFunction(target, functionValue);\n  });\n  return target;\n}\nexport function parse(\n  transform: string | string[],\n  size: number | Record<string, ((pos: number) => number) | number> = 0\n): MatrixInfo[] {\n  const transforms = isArray(transform) ? transform : splitSpace(transform);\n\n  return transforms.map((t) => {\n    const { prefix: name, value } = splitBracket(t);\n\n    let matrixFunction = null;\n    let functionName: string = name;\n    let functionValue: any = \"\";\n\n    if (\n      name === \"translate\" ||\n      name === \"translateX\" ||\n      name === \"translate3d\"\n    ) {\n      const nextSize = isObject(size)\n        ? {\n            ...size,\n            \"o%\": size[\"%\"],\n          }\n        : {\n            \"%\": size,\n            \"o%\": size,\n          };\n      const [posX, posY = 0, posZ = 0] = splitComma(value!).map((v, i) => {\n        if (i === 0 && \"x%\" in nextSize) {\n          nextSize[\"%\"] = size[\"x%\"];\n        } else if (i === 1 && \"y%\" in nextSize) {\n          nextSize[\"%\"] = size[\"y%\"];\n        } else {\n          nextSize[\"%\"] = size[\"o%\"];\n        }\n        return convertUnitSize(v, nextSize);\n      });\n\n      matrixFunction = translate3d;\n      functionValue = [posX, posY, posZ];\n    } else if (name === \"translateY\") {\n      const nextSize = isObject(size)\n        ? {\n            \"%\": size[\"y%\"],\n            ...size,\n          }\n        : {\n            \"%\": size,\n          };\n      const posY = convertUnitSize(value!, nextSize);\n\n      matrixFunction = translate3d;\n      functionValue = [0, posY, 0];\n    } else if (name === \"translateZ\") {\n      const posZ = parseFloat(value!);\n\n      matrixFunction = translate3d;\n      functionValue = [0, 0, posZ];\n    } else if (name === \"scale\" || name === \"scale3d\") {\n      const [sx, sy = sx, sz = 1] = splitComma(value!).map((v) =>\n        parseFloat(v)\n      ) as number[];\n\n      matrixFunction = scale3d;\n      functionValue = [sx, sy, sz];\n    } else if (name === \"scaleX\") {\n      const sx = parseFloat(value!);\n\n      matrixFunction = scale3d;\n      functionValue = [sx, 1, 1];\n    } else if (name === \"scaleY\") {\n      const sy = parseFloat(value!);\n\n      matrixFunction = scale3d;\n      functionValue = [1, sy, 1];\n    } else if (name === \"scaleZ\") {\n      const sz = parseFloat(value!);\n\n      matrixFunction = scale3d;\n      functionValue = [1, 1, sz];\n    } else if (\n      name === \"rotate\" ||\n      name === \"rotateZ\" ||\n      name === \"rotateX\" ||\n      name === \"rotateY\"\n    ) {\n      const { unit, value: unitValue } = splitUnit(value!);\n      const rad = unit === \"rad\" ? unitValue : (unitValue * Math.PI) / 180;\n\n      if (name === \"rotate\" || name === \"rotateZ\") {\n        functionName = \"rotateZ\";\n        matrixFunction = rotateZ3d;\n      } else if (name === \"rotateX\") {\n        matrixFunction = rotateX3d;\n      } else if (name === \"rotateY\") {\n        matrixFunction = rotateY3d;\n      }\n      functionValue = rad;\n    } else if (name === \"matrix3d\") {\n      matrixFunction = matrix3d;\n      functionValue = splitComma(value!).map((v) => parseFloat(v));\n    } else if (name === \"matrix\") {\n      const m = splitComma(value!).map((v) => parseFloat(v));\n      matrixFunction = matrix3d;\n      functionValue = [\n        m[0],\n        m[1],\n        0,\n        0,\n        m[2],\n        m[3],\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        m[4],\n        m[5],\n        0,\n        1,\n      ];\n    } else {\n      functionName = \"\";\n    }\n    return {\n      name: name!,\n      functionName,\n      value: value!,\n      matrixFunction,\n      functionValue,\n    };\n  });\n}\n","import type { ElementType, Hypertext, Point, Rect } from \"./types\";\nimport {\n  IObject,\n  addClass,\n  hasClass,\n  calculateBoundSize,\n  getDist,\n  getDocument,\n} from \"../utility\";\nimport { diff } from \"../differ\";\nimport { getMinMaxs } from \"../overlap-area/overlap-area\";\n\nexport function getClient(e: MouseEvent | TouchEvent) {\n  if (\"touches\" in e) {\n    const touch = e.touches[0] || e.changedTouches[0];\n\n    return {\n      clientX: touch.clientX,\n      clientY: touch.clientY,\n    };\n  } else {\n    return {\n      clientX: e.clientX,\n      clientY: e.clientY,\n    };\n  }\n}\nexport function filterDuplicated<T>(arr: T[]): T[] {\n  if (typeof Map === \"undefined\") {\n    return arr.filter((value, index) => {\n      return arr.indexOf(value) === index;\n    });\n  }\n  const map = new Map<T, true>();\n  return arr.filter((value) => {\n    if (map.has(value)) {\n      return false;\n    }\n    map.set(value, true);\n    return true;\n  });\n}\n\nexport function elementFromPoint(\n  baseNode: Node,\n  clientX: number,\n  clientY: number\n): ElementType | null {\n  const doc = getDocument(baseNode);\n\n  return (\n    ((doc.elementFromPoint && doc.elementFromPoint(clientX, clientY)) as any) ||\n    null\n  );\n}\n\nfunction jsxToObject(jsxElement: any) {\n  return {\n    tag: jsxElement.type,\n    className: jsxElement.props.className,\n    style: jsxElement.props.style || {},\n    children: jsxElement.props.children || [],\n    attributes: jsxElement.props,\n  };\n}\n\nexport function createElement(\n  jsxBack: Hypertext,\n  prevTarget?: ElementType,\n  container?: ElementType\n) {\n  const jsx = jsxToObject(jsxBack);\n  const { tag, children, attributes, className, style } = jsx;\n\n  const el =\n    prevTarget || (getDocument(container).createElement(tag) as ElementType);\n\n  for (const name in attributes) {\n    el.setAttribute(name, attributes[name]);\n  }\n  const elChildren = el.children;\n  children.forEach((child: Hypertext, i: number) => {\n    createElement(child, elChildren[i] as ElementType, el);\n  });\n  if (className) {\n    className.split(/\\s+/g).forEach((name: string) => {\n      if (name && !hasClass(el, name)) {\n        addClass(el, name);\n      }\n    });\n  }\n  if (style) {\n    const elStyle = el.style;\n    for (const name in Object.keys(style)) {\n      elStyle[name as any] = style[name];\n    }\n  }\n  if (!prevTarget && container) {\n    container.appendChild(el);\n  }\n  return el;\n}\nexport function h(\n  tag: string,\n  attrs: IObject<any>,\n  ...children: Hypertext[]\n): Hypertext {\n  const { className = \"\", style = {}, ...attributes } = attrs || {};\n  return {\n    tag,\n    className,\n    style,\n    attributes,\n    children,\n  };\n}\n\nexport function diffValue<T>(prev: T, cur: T, func: (prev: T, cur: T) => void) {\n  if (prev !== cur) {\n    func(prev, cur);\n  }\n}\nexport function isFastInside(point: number[], points: number[][]) {\n  const { minX, minY, maxX, maxY } = getMinMaxs(points);\n  const [x, y] = point;\n\n  return minX <= x && x <= maxX && minY <= y && y <= maxY;\n}\nexport function getFastOverlapPoints(points1: number[][], points2: number[][]) {\n  const {\n    minX: minX1,\n    minY: minY1,\n    maxX: maxX1,\n    maxY: maxY1,\n  } = getMinMaxs(points1);\n  const {\n    minX: minX2,\n    minY: minY2,\n    maxX: maxX2,\n    maxY: maxY2,\n  } = getMinMaxs(points2);\n\n  if (maxX2 < minX1 || maxX1 < minX2 || maxY2 < minY1 || maxY1 < minY2) {\n    return [];\n  }\n  const width = Math.min(maxX2 - minX1, maxX1 - minX2);\n  const height = Math.min(maxY2 - minY1, maxY1 - minY2);\n\n  return [\n    [0, 0],\n    [width, 0],\n    [width, height],\n    [0, height],\n  ];\n}\nexport function getRect(\n  e: any,\n  ratio: number,\n  boundArea = e.data.boundArea\n): Rect {\n  let { distX = 0, distY = 0 } = e;\n  const { startX, startY } = e.data;\n\n  if (ratio > 0) {\n    const nextHeight = Math.sqrt(\n      (distX * distX + distY * distY) / (1 + ratio * ratio)\n    );\n    const nextWidth = ratio * nextHeight;\n\n    distX = (distX >= 0 ? 1 : -1) * nextWidth;\n    distY = (distY >= 0 ? 1 : -1) * nextHeight;\n  }\n  let width = Math.abs(distX);\n  let height = Math.abs(distY);\n\n  const maxWidth =\n    distX < 0 ? startX - boundArea.left : boundArea.right - startX;\n  const maxHeight =\n    distY < 0 ? startY - boundArea.top : boundArea.bottom - startY;\n\n  [width, height] = calculateBoundSize(\n    [width, height],\n    [0, 0],\n    [maxWidth, maxHeight],\n    !!ratio\n  );\n  distX = (distX >= 0 ? 1 : -1) * width;\n  distY = (distY >= 0 ? 1 : -1) * height;\n\n  const tx = Math.min(0, distX);\n  const ty = Math.min(0, distY);\n  const left = startX + tx;\n  const top = startY + ty;\n\n  return {\n    left,\n    top,\n    right: left + width,\n    bottom: top + height,\n    width,\n    height,\n  };\n}\n\nexport function getDefaultElementRect(el: ElementType): Point {\n  const rect = el.getBoundingClientRect();\n  const { left, top, width, height } = rect;\n\n  return {\n    pos1: [left, top],\n    pos2: [left + width, top],\n    pos3: [left, top + height],\n    pos4: [left + width, top + height],\n  };\n}\n\nexport function passTargets(\n  beforeTargets: ElementType[],\n  afterTargets: ElementType[],\n  continueSelectWithoutDeselect: boolean\n) {\n  const { list, prevList, added, removed, maintained } = diff(\n    beforeTargets,\n    afterTargets\n  );\n\n  return [\n    ...added.map((index) => list[index]),\n    ...removed.map((index) => prevList[index]),\n    ...(continueSelectWithoutDeselect\n      ? maintained.map(([, nextIndex]) => list[nextIndex])\n      : []),\n  ];\n}\n\nexport function getLineSize(points: number[][]) {\n  let size = 0;\n  const length = points.length;\n\n  for (let i = 1; i < length; ++i) {\n    size = Math.max(getDist(points[i], points[i - 1]), size);\n  }\n\n  return size;\n}\n\nexport function stringHash(str: string) {\n  let hash = 5381,\n    i = str.length;\n\n  while (i) {\n    hash = (hash * 33) ^ str.charCodeAt(--i);\n  }\n\n  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */\n  return hash >>> 0;\n}\n","import { stringHash } from \"../selecto/utils\";\nimport { getDocument, splitComma } from \"../utility\";\nimport { InjectOptions } from \"./types\";\n\nexport function getHash(str: string) {\n  return stringHash(str).toString(36);\n}\nexport function getShadowRoot(parentElement: HTMLElement | SVGElement) {\n  if (parentElement && parentElement.getRootNode) {\n    const rootNode = parentElement.getRootNode();\n\n    if (rootNode.nodeType === 11) {\n      return rootNode as ShadowRoot;\n    }\n  }\n  return;\n}\nexport function replaceStyle(\n  className: string,\n  css: string,\n  options: Partial<InjectOptions>\n) {\n  if (options.original) {\n    return css;\n  }\n  return css.replace(/([^};{\\s}][^};{]*|^\\s*){/gm, (_, selector) => {\n    const trimmedSelector = selector.trim();\n    return (\n      (trimmedSelector ? splitComma(trimmedSelector) : [\"\"])\n        .map((subSelector) => {\n          const trimmedSubSelector = subSelector.trim();\n          if (trimmedSubSelector.indexOf(\"@\") === 0) {\n            return trimmedSubSelector;\n          } else if (trimmedSubSelector.indexOf(\":global\") > -1) {\n            return trimmedSubSelector.replace(/\\:global/g, \"\");\n          } else if (trimmedSubSelector.indexOf(\":host\") > -1) {\n            return `${trimmedSubSelector.replace(/\\:host/g, `.${className}`)}`;\n          } else if (trimmedSubSelector) {\n            return `.${className} ${trimmedSubSelector}`;\n          } else {\n            return `.${className}`;\n          }\n        })\n        .join(\", \") + \" {\"\n    );\n  });\n}\nexport function injectStyle(\n  className: string,\n  css: string,\n  options: Partial<InjectOptions>,\n  el: Node,\n  shadowRoot?: Node\n) {\n  const doc = getDocument(el);\n  const style = doc.createElement(\"style\");\n\n  style.setAttribute(\"type\", \"text/css\");\n  style.setAttribute(\"data-styled-id\", className);\n  style.setAttribute(\"data-styled-count\", \"1\");\n\n  if (options.nonce) {\n    style.setAttribute(\"nonce\", options.nonce);\n  }\n  style.innerHTML = replaceStyle(className, css, options);\n\n  (shadowRoot || doc.head || doc.body).appendChild(style);\n  return style;\n}\n","import { getHash, injectStyle, getShadowRoot } from \"./utils\";\nimport { StyledInjector, InjectOptions } from \"./types\";\n\n/**\n * Create an styled object that can be defined and inserted into the css.\n * @param - css styles\n */\nfunction styled(css: string): StyledInjector {\n  const injectClassName = \"rCS\" + getHash(css);\n\n  return {\n    className: injectClassName,\n    inject(el: HTMLElement | SVGElement, options: Partial<InjectOptions> = {}) {\n      const shadowRoot = getShadowRoot(el);\n      let styleElement = (\n        shadowRoot ||\n        el.ownerDocument ||\n        document\n      ).querySelector<HTMLStyleElement>(\n        `style[data-styled-id=\"${injectClassName}\"]`\n      );\n\n      if (!styleElement) {\n        styleElement = injectStyle(\n          injectClassName,\n          css,\n          options,\n          el,\n          shadowRoot\n        );\n      } else {\n        const count =\n          parseFloat(styleElement.getAttribute(\"data-styled-count\")) || 0;\n        styleElement.setAttribute(\"data-styled-count\", `${count + 1}`);\n      }\n      return {\n        destroy() {\n          const injectCount =\n            parseFloat(styleElement.getAttribute(\"data-styled-count\")) || 0;\n\n          if (injectCount <= 1) {\n            if (styleElement.remove) {\n              styleElement.remove();\n            } else {\n              styleElement.parentNode?.removeChild(styleElement);\n            }\n            styleElement = null;\n          } else {\n            styleElement.setAttribute(\n              \"data-styled-count\",\n              `${injectCount - 1}`\n            );\n          }\n        },\n      };\n    },\n  };\n}\n\nexport * from \"./types\";\nexport default styled;\n","import styled from \"../css-styled\";\nimport { SelectoOptions } from \"./types\";\n\nexport const injector = styled(`\n:host {\n    position: fixed;\n    display: none;\n    border: 1px solid rgba(16, 172, 132,1.0);\n    background: rgba(16, 172, 132,0.25);\n    pointer-events: none;\n    will-change: transform;\n    z-index: 100;\n}\n`);\n\n/**\n * @memberof Selecto\n */\nexport const CLASS_NAME = `selecto-selection ${injector.className}`;\n\nexport const PROPERTIES = [\n  \"className\",\n  \"boundContainer\",\n  \"selectableTargets\",\n  \"selectByClick\",\n  \"selectFromInside\",\n  \"continueSelect\",\n  \"continueSelectWithoutDeselect\",\n  \"toggleContinueSelect\",\n  \"toggleContinueSelectWithoutDeselect\",\n  \"keyContainer\",\n  \"hitRate\",\n  \"scrollOptions\",\n  \"checkInput\",\n  \"preventDefault\",\n  \"ratio\",\n  \"getElementRect\",\n  \"preventDragFromInside\",\n  \"rootContainer\",\n  \"dragCondition\",\n  \"clickBySelectEnd\",\n  \"checkOverflow\",\n  \"innerScrollOptions\",\n] as const;\n/**\n * @memberof Selecto\n */\nexport const OPTIONS = [\n  // ignore target, container,\n  \"dragContainer\",\n  \"cspNonce\",\n  \"preventClickEventOnDrag\",\n  \"preventClickEventOnDragStart\",\n  \"preventRightClick\",\n  ...PROPERTIES,\n] as const;\n\nexport const OPTION_TYPES: { [key in keyof SelectoOptions]: any } = {\n  className: String,\n  boundContainer: null,\n  portalContainer: null,\n  container: null,\n  dragContainer: null,\n  selectableTargets: Array,\n  selectByClick: Boolean,\n  selectFromInside: Boolean,\n  continueSelect: Boolean,\n  toggleContinueSelect: Array,\n  toggleContinueSelectWithoutDeselect: Array,\n  keyContainer: null,\n  hitRate: Number,\n  scrollOptions: Object,\n  checkInput: Boolean,\n  preventDefault: Boolean,\n  cspNonce: String,\n  ratio: Number,\n  getElementRect: Function,\n  preventDragFromInside: Boolean,\n  rootContainer: Object,\n  dragCondition: Function,\n  clickBySelectEnd: Boolean,\n  continueSelectWithoutDeselect: Boolean,\n  preventClickEventOnDragStart: Boolean,\n  preventClickEventOnDrag: Boolean,\n  checkOverflow: Boolean,\n  innerScrollOptions: Object,\n};\n\n/**\n * @memberof Selecto\n */\nexport const EVENTS = [\n  \"dragStart\",\n  \"drag\",\n  \"dragEnd\",\n  \"selectStart\",\n  \"select\",\n  \"selectEnd\",\n  \"keydown\",\n  \"keyup\",\n  \"scroll\",\n  \"innerScroll\",\n] as const;\n\n/**\n * @memberof Selecto\n */\nexport const METHODS = [\n  \"clickTarget\",\n  \"getSelectableElements\",\n  \"setSelectedTargets\",\n  \"getElementPoints\",\n  \"getSelectedTargets\",\n  \"findSelectableTargets\",\n  \"triggerDragStart\",\n  \"checkScroll\",\n  \"selectTargetsByPoints\",\n  \"setSelectedTargetsByPoints\",\n] as const;\n","import EventEmitter from \"../event-emitter\";\nimport Gesto, { OnDrag } from \"../gesto\";\nimport { InjectResult } from \"../css-styled\";\nimport {\n  isObject,\n  camelize,\n  IObject,\n  addEvent,\n  removeEvent,\n  isString,\n  between,\n  splitUnit,\n  isFunction,\n  getWindow,\n  getDocument,\n  isNode,\n} from \"../utility\";\nimport { diff } from \"../differ\";\nimport DragScroll from \"../drag-scroll\";\nimport {\n  getAreaSize,\n  getOverlapPoints,\n  isInside,\n  fitPoints,\n} from \"../overlap-area/overlap-area\";\nimport {\n  getDistElementMatrix,\n  calculateMatrixDist,\n  createMatrix,\n} from \"../css-to-mat\";\nimport {\n  createElement,\n  getClient,\n  diffValue,\n  getRect,\n  getDefaultElementRect,\n  passTargets,\n  elementFromPoint,\n  filterDuplicated,\n  getLineSize,\n} from \"./utils\";\nimport {\n  SelectoOptions,\n  SelectoProperties,\n  OnDragEvent,\n  SelectoEvents,\n  Rect,\n  BoundContainer,\n  SelectedTargets,\n  SelectedTargetsWithRect,\n  InnerParentInfo,\n  ElementType,\n  OnDragStart,\n} from \"./types\";\nimport { PROPERTIES, injector, CLASS_NAME } from \"./consts\";\n\nfunction setupProperties(component: any) {\n  const prototype = Object.getPrototypeOf(component);\n\n  PROPERTIES.forEach((property) => {\n    const attributes: IObject<any> = {\n      enumerable: true,\n      configurable: true,\n      get() {\n        return this.options[property];\n      },\n    };\n\n    const getter = camelize(`get ${property}`);\n    if (prototype[getter]) {\n      attributes.get = function () {\n        return this[getter]();\n      };\n    } else {\n      attributes.get = function () {\n        return this.options[property];\n      };\n    }\n\n    const setter = camelize(`set ${property}`);\n    if (prototype[setter]) {\n      attributes.set = function (value: any) {\n        this[setter](value);\n      };\n    } else {\n      attributes.set = function (value: any) {\n        this.options[property] = value;\n      };\n    }\n    Object.defineProperty(prototype, property, attributes);\n  });\n}\n\nclass Selecto extends EventEmitter<SelectoEvents> {\n  public options: SelectoOptions;\n  private target: ElementType;\n  private dragContainer!: Element | Window | Element[];\n  private container!: HTMLElement;\n  private gesto!: Gesto;\n  private injectResult!: InjectResult;\n  private selectedTargets: ElementType[] = [];\n  private dragScroll: DragScroll = new DragScroll();\n  private _keydownContinueSelect: boolean = false;\n  private _keydownContinueSelectWithoutDeselection: boolean = false;\n\n  /**\n   *\n   */\n  constructor(options: Partial<SelectoOptions> = {}) {\n    super();\n    this.target = options.portalContainer!;\n    let container = options.container;\n    this.options = {\n      className: \"\",\n      portalContainer: null,\n      container: null,\n      dragContainer: null,\n      selectableTargets: [],\n      selectByClick: true,\n      selectFromInside: true,\n      clickBySelectEnd: false,\n      hitRate: 100,\n      continueSelect: false,\n      continueSelectWithoutDeselect: false,\n      toggleContinueSelect: null,\n      toggleContinueSelectWithoutDeselect: null,\n      keyContainer: null,\n      scrollOptions: null,\n      checkInput: false,\n      preventDefault: false,\n      boundContainer: false,\n      preventDragFromInside: true,\n      dragCondition: null,\n      rootContainer: null,\n      checkOverflow: false,\n      innerScrollOptions: false,\n      getElementRect: getDefaultElementRect,\n      cspNonce: \"\",\n      ratio: 0,\n      ...options,\n    };\n\n    setupProperties(this);\n\n    const portalContainer = this.options.portalContainer;\n\n    if (portalContainer) {\n      container = portalContainer.parentElement;\n    }\n    this.container = container || document.body;\n    this.initElement();\n    this.initDragScroll();\n    this.setKeyController();\n  }\n  /**\n   * You can set the currently selected targets.\n   * selectByClick, continueSelect, and continueSelectWithoutDeselect are not applied.\n   */\n  public setSelectedTargets(selectedTargets: ElementType[]): SelectedTargets {\n    const beforeSelected = this.selectedTargets;\n    const { added, removed, prevList, list } = diff(\n      beforeSelected,\n      selectedTargets\n    );\n    this.selectedTargets = selectedTargets;\n\n    return {\n      added: added.map((index) => list[index]),\n      removed: removed.map((index) => prevList[index]),\n      beforeSelected,\n      selected: selectedTargets,\n    };\n  }\n  /**\n   * You can set the currently selected targets by points\n   * selectByClick, continueSelect, and continueSelectWithoutDeselect are not applied.\n   */\n  public setSelectedTargetsByPoints(\n    point1: number[],\n    point2: number[]\n  ): SelectedTargetsWithRect {\n    const left = Math.min(point1[0], point2[0]);\n    const top = Math.min(point1[1], point2[1]);\n    const right = Math.max(point1[0], point2[0]);\n    const bottom = Math.max(point1[1], point2[1]);\n    const rect: Rect = {\n      left,\n      top,\n      right,\n      bottom,\n      width: right - left,\n      height: bottom - top,\n    };\n    const data = { ignoreClick: true };\n\n    this.findSelectableTargets(data);\n    const selectedElements = this.hitTest(rect, data, true, null);\n    const result = this.setSelectedTargets(selectedElements);\n\n    return {\n      ...result,\n      rect,\n    };\n  }\n  /**\n   * Select target by virtual drag from startPoint to endPoint.\n   * The target of inputEvent is null.\n   */\n  public selectTargetsByPoints(startPoint: number[], endPoint: number[]) {\n    const mousedown = new MouseEvent(\"mousedown\", {\n      clientX: startPoint[0],\n      clientY: startPoint[1],\n      cancelable: true,\n      bubbles: true,\n    });\n    const mousemove = new MouseEvent(\"mousemove\", {\n      clientX: endPoint[0],\n      clientY: endPoint[1],\n      cancelable: true,\n      bubbles: true,\n    });\n    const mouseup = new MouseEvent(\"mousemove\", {\n      clientX: endPoint[0],\n      clientY: endPoint[1],\n      cancelable: true,\n      bubbles: true,\n    });\n    const gesto = this.gesto;\n    const result = gesto.onDragStart(mousedown);\n\n    if (result !== false) {\n      gesto.onDrag(mousemove);\n      gesto.onDragEnd(mouseup);\n    }\n  }\n  /**\n   * You can get the currently selected targets.\n   */\n  public getSelectedTargets(): ElementType[] {\n    return this.selectedTargets;\n  }\n  /**\n   * `OnDragStart` is triggered by an external event.\n   * @param - external event\n   * @example\n   * import Selecto from \"selecto\";\n   *\n   * const selecto = new Selecto();\n   *\n   * window.addEventListener(\"mousedown\", e => {\n   *   selecto.triggerDragStart(e);\n   * });\n   */\n  public triggerDragStart(e: MouseEvent | TouchEvent) {\n    this.gesto.triggerDragStart(e);\n    return this;\n  }\n  /**\n   * Destroy elements, properties, and events.\n   */\n  public destroy() {\n    this.off();\n    this.gesto.unset();\n    this.injectResult.destroy();\n    this.dragScroll.dragEnd();\n    removeEvent(document, \"selectstart\", this._onDocumentSelectStart);\n\n    if (!this.options.portalContainer) {\n      this.target.parentElement?.removeChild(this.target);\n    }\n\n    window.removeEventListener(\"keydown\", this._handleKeyDown);\n    window.removeEventListener(\"keyup\", this._handleKeyUp);\n    window.removeEventListener(\"blur\", this._handleBlur);\n\n    (this.gesto as any) = null;\n    (this.injectResult as any) = null;\n    (this.target as any) = null;\n    (this.container as any) = null;\n    (this.options as any) = null;\n  }\n  public getElementPoints(target: ElementType) {\n    const getElementRect = this.getElementRect || getDefaultElementRect;\n    const info = getElementRect(target);\n    const points = [info.pos1, info.pos2, info.pos4, info.pos3];\n\n    if (getElementRect !== getDefaultElementRect) {\n      const rect = target.getBoundingClientRect();\n\n      return fitPoints(points, rect);\n    }\n    return points;\n  }\n  /**\n   * Get all elements set in `selectableTargets`.\n   */\n  public getSelectableElements() {\n    const container = this.container;\n    const selectableElements: ElementType[] = [];\n\n    this.options.selectableTargets.forEach((target) => {\n      if (isFunction(target)) {\n        const result = target();\n\n        if (result) {\n          selectableElements.push(...[].slice.call(result));\n        }\n      } else if (isNode(target)) {\n        selectableElements.push(target);\n      } else if (isObject(target)) {\n        const element = target.value || target.current;\n        if (element) {\n          selectableElements.push(element);\n        }\n      } else {\n        const elements = [].slice.call(\n          getDocument(container).querySelectorAll(target)\n        );\n\n        selectableElements.push(...elements);\n      }\n    });\n\n    return selectableElements;\n  }\n  /**\n   * If scroll occurs during dragging, you can manually call this method to check the position again.\n   */\n  public checkScroll() {\n    if (!this.gesto.isFlag()) {\n      return;\n    }\n    const scrollOptions = this.scrollOptions;\n    const innerScrollOptions = this.gesto.getEventData().innerScrollOptions;\n    const hasScrollOptions = innerScrollOptions || scrollOptions?.container;\n\n    // If it is a scrolling position, pass drag\n    if (hasScrollOptions) {\n      this.dragScroll.checkScroll({\n        inputEvent: this.gesto.getCurrentEvent(),\n        ...(innerScrollOptions || scrollOptions),\n      });\n    }\n  }\n  /**\n   * Find for selectableTargets again during drag event\n   * You can update selectable targets during an event.\n   */\n  public findSelectableTargets(data: IObject<any> = this.gesto.getEventData()) {\n    const selectableTargets = this.getSelectableElements();\n    const selectablePoints = selectableTargets.map((target) =>\n      this.getElementPoints(target)\n    );\n\n    data.selectableTargets = selectableTargets;\n    data.selectablePoints = selectablePoints;\n    data.selectableParentMap = null;\n\n    const options = this.options;\n    const hasIndexesMap = options.checkOverflow || options.innerScrollOptions;\n    const doc = getDocument(this.container);\n\n    if (hasIndexesMap) {\n      const parentMap = new Map<Element, InnerParentInfo>();\n\n      data.selectableInnerScrollParentMap = parentMap;\n      data.selectableInnerScrollPathsList = selectableTargets.map(\n        (target, index) => {\n          let parentElement = target.parentElement;\n\n          let parents: Element[] = [];\n          const paths: Element[] = [];\n\n          while (parentElement && parentElement !== doc.body) {\n            let info = parentMap.get(parentElement);\n\n            if (!info) {\n              const overflow =\n                getComputedStyle(parentElement).overflow !== \"visible\";\n\n              if (overflow) {\n                const rect = getDefaultElementRect(parentElement);\n\n                info = {\n                  parentElement,\n                  indexes: [],\n                  points: [rect.pos1, rect.pos2, rect.pos4, rect.pos3],\n                  paths: [...paths],\n                };\n\n                parents.push(parentElement);\n                parents.forEach((prevParentElement) => {\n                  parentMap.set(prevParentElement, info as InnerParentInfo);\n                });\n                parents = [];\n              }\n            }\n            if (info) {\n              parentElement = info.parentElement;\n\n              parentMap.get(parentElement)?.indexes.push(index);\n              paths.push(parentElement);\n            } else {\n              parents.push(parentElement);\n            }\n            parentElement = parentElement.parentElement;\n          }\n\n          return paths;\n        }\n      );\n    }\n\n    if (!options.checkOverflow) {\n      data.selectableInners = selectableTargets.map(() => true);\n    }\n\n    this._refreshGroups(data);\n\n    return selectableTargets;\n  }\n  /**\n   * External click or mouse events can be applied to the selecto.\n   * @params - Extenal click or mouse event\n   * @params - Specify the clicked target directly.\n   */\n  public clickTarget(\n    e: MouseEvent | TouchEvent,\n    clickedTarget?: Element\n  ): this {\n    const { clientX, clientY } = getClient(e);\n    const dragEvent = {\n      data: {\n        selectFlag: false,\n      },\n      clientX,\n      clientY,\n      inputEvent: e,\n      isClick: true,\n      isTrusted: false,\n      stop: () => {\n        return false;\n      },\n    } as any;\n    if (this._onDragStart(dragEvent, clickedTarget)) {\n      this._onDragEnd(dragEvent);\n    }\n    return this;\n  }\n  private setKeyController() {\n    window.addEventListener(\"keydown\", this._handleKeyDown);\n    window.addEventListener(\"keyup\", this._handleKeyUp);\n    window.addEventListener(\"blur\", this._handleBlur);\n  }\n\n  private _handleKeyDown = (e: KeyboardEvent) => {\n    if (e.key === \"Shift\" && !this._keydownContinueSelect) {\n      this._keydownContinueSelect = true;\n      this.emit(\"keydown\", {\n        keydownContinueSelect: true,\n        keydownContinueSelectWithoutDeselection: false,\n      });\n    }\n  };\n\n  private _handleKeyUp = (e: KeyboardEvent) => {\n    if (e.key === \"Shift\" && this._keydownContinueSelect) {\n      this._keydownContinueSelect = false;\n      this.emit(\"keyup\", {\n        keydownContinueSelect: false,\n        keydownContinueSelectWithoutDeselection: false,\n      });\n    }\n  };\n\n  private _handleBlur = () => {\n    if (this._keydownContinueSelect) {\n      this._keydownContinueSelect = false;\n      this.emit(\"keyup\", {\n        keydownContinueSelect: false,\n        keydownContinueSelectWithoutDeselection: false,\n      });\n    }\n  };\n\n  private setClassName(nextClassName: string) {\n    this.options.className = nextClassName;\n    this.target.setAttribute(`class`, `${CLASS_NAME} ${nextClassName || \"\"}`);\n  }\n  private setKeyEvent() {\n    this.setKeyController();\n  }\n  // with getter, setter property\n  private setKeyContainer(keyContainer: HTMLElement | Document | Window) {\n    const options = this.options;\n\n    diffValue(options.keyContainer, keyContainer, () => {\n      options.keyContainer = keyContainer;\n\n      this.setKeyController();\n    });\n  }\n  private getContinueSelect() {\n    return this._keydownContinueSelect;\n  }\n\n  private getContinueSelectWithoutDeselect() {\n    const {\n      continueSelectWithoutDeselect,\n      toggleContinueSelectWithoutDeselect,\n    } = this.options;\n\n    if (\n      !toggleContinueSelectWithoutDeselect ||\n      !this._keydownContinueSelectWithoutDeselection\n    ) {\n      return continueSelectWithoutDeselect;\n    }\n    return !continueSelectWithoutDeselect;\n  }\n\n  private setToggleContinueSelect(\n    toggleContinueSelect: string[][] | string[] | string\n  ) {\n    const options = this.options;\n\n    diffValue(options.toggleContinueSelect, toggleContinueSelect, () => {\n      options.toggleContinueSelect = toggleContinueSelect;\n\n      this.setKeyEvent();\n    });\n  }\n  private setToggleContinueSelectWithoutDeselect(\n    toggleContinueSelectWithoutDeselect: string[][] | string[] | string\n  ) {\n    const options = this.options;\n\n    diffValue(\n      options.toggleContinueSelectWithoutDeselect,\n      toggleContinueSelectWithoutDeselect,\n      () => {\n        options.toggleContinueSelectWithoutDeselect =\n          toggleContinueSelectWithoutDeselect;\n\n        this.setKeyEvent();\n      }\n    );\n  }\n  private setPreventDefault(value: boolean) {\n    this.gesto.options.preventDefault = value;\n  }\n  private setCheckInput(value: boolean) {\n    this.gesto.options.checkInput = value;\n  }\n  private initElement() {\n    const {\n      dragContainer,\n      checkInput,\n      preventDefault,\n      preventClickEventOnDragStart,\n      preventClickEventOnDrag,\n      preventClickEventByCondition,\n      preventRightClick = true,\n      className,\n    } = this.options;\n    const container = this.container;\n    console.log({\n      jsx: <div className={`${CLASS_NAME} ${className || \"\"}`}></div>,\n    });\n    this.target = createElement(\n      (<div className={`${CLASS_NAME} ${className || \"\"}`}></div>) as any,\n      this.target,\n      container\n    );\n\n    console.log(this.target);\n\n    const target = this.target;\n\n    this.dragContainer =\n      typeof dragContainer === \"string\"\n        ? [].slice.call(getDocument(container).querySelectorAll(dragContainer))\n        : dragContainer || (this.target.parentNode as any);\n    this.gesto = new Gesto(this.dragContainer, {\n      checkWindowBlur: true,\n      container: getWindow(container),\n      checkInput,\n      preventDefault,\n      preventClickEventOnDragStart,\n      preventClickEventOnDrag,\n      preventClickEventByCondition,\n      preventRightClick,\n    })\n      .on(\"dragStart\" as any, this._onDragStart)\n      .on(\"drag\" as any, this._onDrag)\n      .on(\"dragEnd\" as any, this._onDragEnd);\n    addEvent(document, \"selectstart\", this._onDocumentSelectStart);\n\n    this.injectResult = injector.inject(target, {\n      nonce: this.options.cspNonce,\n    });\n  }\n  private hitTest(\n    selectRect: Rect,\n    data: any,\n    isDrag: boolean,\n    gestoEvent: any\n  ) {\n    const { hitRate, selectByClick } = this.options;\n    const { left, top, right, bottom } = selectRect;\n    const innerGroups: Record<\n      string | number,\n      Record<string | number, number[]>\n    > = data.innerGroups;\n    const innerWidth = data.innerWidth;\n    const innerHeight = data.innerHeight;\n    const clientX = gestoEvent?.clientX;\n    const clientY = gestoEvent?.clientY;\n    const ignoreClick = data.ignoreClick;\n    const rectPoints = [\n      [left, top],\n      [right, top],\n      [right, bottom],\n      [left, bottom],\n    ];\n    const isHit = (points: number[][], el: Element) => {\n      const hitRateValue =\n        typeof hitRate === \"function\"\n          ? splitUnit(`${hitRate(el)}`)\n          : splitUnit(`${hitRate}`);\n\n      const inArea = ignoreClick ? false : isInside([clientX, clientY], points);\n\n      if (!isDrag && selectByClick && inArea) {\n        return true;\n      }\n      const overlapPoints = getOverlapPoints(rectPoints, points);\n\n      if (!overlapPoints.length) {\n        return false;\n      }\n      let overlapSize = getAreaSize(overlapPoints);\n\n      // Line\n      let targetSize = 0;\n\n      if (overlapSize === 0 && getAreaSize(points) === 0) {\n        targetSize = getLineSize(points);\n        overlapSize = getLineSize(overlapPoints);\n      } else {\n        targetSize = getAreaSize(points);\n      }\n\n      if (hitRateValue.unit === \"px\") {\n        return overlapSize >= hitRateValue.value;\n      } else {\n        const rate = between(\n          Math.round((overlapSize / targetSize) * 100),\n          0,\n          100\n        );\n\n        return rate >= Math.min(100, hitRateValue.value);\n      }\n    };\n    const selectableTargets: ElementType[] = data.selectableTargets;\n    const selectablePoints: number[][][] = data.selectablePoints;\n    const selectableInners: boolean[] = data.selectableInners;\n\n    if (!innerGroups) {\n      return selectableTargets.filter((_, i) => {\n        if (!selectableInners[i]) {\n          return false;\n        }\n        return isHit(selectablePoints[i], selectableTargets[i]);\n      });\n    }\n    const selectedTargets: ElementType[] = [];\n    const minX = Math.floor(left / innerWidth);\n    const maxX = Math.floor(right / innerWidth);\n    const minY = Math.floor(top / innerHeight);\n    const maxY = Math.floor(bottom / innerHeight);\n\n    for (let x = minX; x <= maxX; ++x) {\n      const yGroups = innerGroups[x];\n\n      if (!yGroups) {\n        continue;\n      }\n      for (let y = minY; y <= maxY; ++y) {\n        const group = yGroups[y];\n\n        if (!group) {\n          continue;\n        }\n        group.forEach((index) => {\n          const points = selectablePoints[index];\n          const inner = selectableInners[index];\n          const target = selectableTargets[index];\n\n          if (inner && isHit(points, target)) {\n            selectedTargets.push(target);\n          }\n        });\n      }\n    }\n    return filterDuplicated(selectedTargets);\n  }\n  private initDragScroll() {\n    this.dragScroll\n      .on(\"scrollDrag\", ({ next }) => {\n        next(this.gesto.getCurrentEvent());\n      })\n      .on(\"scroll\", ({ container, direction }) => {\n        const innerScrollOptions = this.gesto.getEventData().innerScrollOptions;\n\n        if (innerScrollOptions) {\n          this.emit(\"innerScroll\", {\n            container,\n            direction,\n          });\n        } else {\n          this.emit(\"scroll\", {\n            container,\n            direction,\n          });\n        }\n      })\n      .on(\"move\", ({ offsetX, offsetY, inputEvent }) => {\n        const gesto = this.gesto;\n\n        if (!gesto || !gesto.isFlag()) {\n          return;\n        }\n\n        const data = this.gesto.getEventData();\n        const boundArea = data.boundArea;\n\n        data.startX -= offsetX;\n        data.startY -= offsetY;\n\n        const innerScrollOptions = this.gesto.getEventData().innerScrollOptions;\n        const container = innerScrollOptions?.container;\n        let isMoveInnerScroll = false;\n\n        if (container) {\n          const parentMap: Map<Element, InnerParentInfo> =\n            data.selectableInnerScrollParentMap;\n          const parentInfo = parentMap.get(container);\n\n          if (parentInfo) {\n            parentInfo.paths.forEach((scrollContainer) => {\n              const containerInfo = parentMap.get(scrollContainer);\n\n              containerInfo?.points.forEach((pos) => {\n                pos[0] -= offsetX;\n                pos[1] -= offsetY;\n              });\n            });\n            parentInfo.indexes.forEach((index) => {\n              data.selectablePoints[index].forEach((pos: number[]) => {\n                pos[0] -= offsetX;\n                pos[1] -= offsetY;\n              });\n            });\n            isMoveInnerScroll = true;\n          }\n        }\n        if (!isMoveInnerScroll) {\n          data.selectablePoints.forEach((points: number[][]) => {\n            points.forEach((pos) => {\n              pos[0] -= offsetX;\n              pos[1] -= offsetY;\n            });\n          });\n        }\n        this._refreshGroups(data);\n\n        boundArea.left -= offsetX;\n        boundArea.right -= offsetX;\n        boundArea.top -= offsetY;\n        boundArea.bottom -= offsetY;\n\n        this.gesto.scrollBy(\n          offsetX,\n          offsetY,\n          inputEvent.inputEvent\n          // false\n        );\n        this._checkSelected(this.gesto.getCurrentEvent());\n      });\n  }\n  private _select(\n    selectedTargets: ElementType[],\n    rect: Rect,\n    e: OnDragEvent,\n    isStart?: boolean,\n    isDragStartEnd = false\n  ) {\n    const inputEvent = e.inputEvent;\n    const data = e.data;\n    const result = this.setSelectedTargets(selectedTargets);\n    const { added, removed, prevList, list } = diff(\n      data.startSelectedTargets,\n      selectedTargets\n    );\n\n    const startResult = {\n      startSelected: prevList,\n      startAdded: added.map((i) => list[i]),\n      startRemoved: removed.map((i) => prevList[i]),\n    };\n\n    if (isStart) {\n      /**\n       * When the select(drag) starts, the selectStart event is called.\n       * @memberof Selecto\n       * @event selectStart\n       * @param {Selecto.OnSelect} - Parameters for the selectStart event\n       * @example\n       * import Selecto from \"selecto\";\n       *\n       * const selecto = new Selecto({\n       *   container: document.body,\n       *   selectByClick: true,\n       *   selectFromInside: false,\n       * });\n       *\n       * selecto.on(\"selectStart\", e => {\n       *   e.added.forEach(el => {\n       *     el.classList.add(\"selected\");\n       *   });\n       *   e.removed.forEach(el => {\n       *     el.classList.remove(\"selected\");\n       *   });\n       * }).on(\"selectEnd\", e => {\n       *   e.afterAdded.forEach(el => {\n       *     el.classList.add(\"selected\");\n       *   });\n       *   e.afterRemoved.forEach(el => {\n       *     el.classList.remove(\"selected\");\n       *   });\n       * });\n       */\n      this.emit(\"selectStart\", {\n        ...result,\n        ...startResult,\n        rect,\n        inputEvent,\n        data: data.data,\n        isTrusted: e.isTrusted,\n        isDragStartEnd,\n      });\n    }\n    if (result.added.length || result.removed.length) {\n      /**\n       * When the select in real time, the select event is called.\n       * @memberof Selecto\n       * @event select\n       * @param {Selecto.OnSelect} - Parameters for the select event\n       * @example\n       * import Selecto from \"selecto\";\n       *\n       * const selecto = new Selecto({\n       *   container: document.body,\n       *   selectByClick: true,\n       *   selectFromInside: false,\n       * });\n       *\n       * selecto.on(\"select\", e => {\n       *   e.added.forEach(el => {\n       *     el.classList.add(\"selected\");\n       *   });\n       *   e.removed.forEach(el => {\n       *     el.classList.remove(\"selected\");\n       *   });\n       * });\n       */\n      this.emit(\"select\", {\n        ...result,\n        ...startResult,\n        rect,\n        inputEvent,\n        data: data.data,\n        isTrusted: e.isTrusted,\n        isDragStartEnd,\n      });\n    }\n  }\n  private _selectEnd(\n    startSelectedTargets: ElementType[],\n    startPassedTargets: ElementType[],\n    rect: Rect,\n    e: OnDragEvent,\n    isDragStartEnd: boolean = false\n  ) {\n    const { inputEvent, isDouble, data } = e;\n    const type = inputEvent && inputEvent.type;\n    const isDragStart = type === \"mousedown\" || type === \"touchstart\";\n\n    const { added, removed, prevList, list } = diff(\n      startSelectedTargets,\n      this.selectedTargets\n    );\n    const {\n      added: afterAdded,\n      removed: afterRemoved,\n      prevList: afterPrevList,\n      list: afterList,\n    } = diff(startPassedTargets, this.selectedTargets);\n\n    /**\n     * When the select(dragEnd or click) ends, the selectEnd event is called.\n     * @memberof Selecto\n     * @event selectEnd\n     * @param {Selecto.OnSelectEnd} - Parameters for the selectEnd event\n     * @example\n     * import Selecto from \"selecto\";\n     *\n     * const selecto = new Selecto({\n     *   container: document.body,\n     *   selectByClick: true,\n     *   selectFromInside: false,\n     * });\n     *\n     * selecto.on(\"selectStart\", e => {\n     *   e.added.forEach(el => {\n     *     el.classList.add(\"selected\");\n     *   });\n     *   e.removed.forEach(el => {\n     *     el.classList.remove(\"selected\");\n     *   });\n     * }).on(\"selectEnd\", e => {\n     *   e.afterAdded.forEach(el => {\n     *     el.classList.add(\"selected\");\n     *   });\n     *   e.afterRemoved.forEach(el => {\n     *     el.classList.remove(\"selected\");\n     *   });\n     * });\n     */\n    this.emit(\"selectEnd\", {\n      startSelected: startSelectedTargets,\n      beforeSelected: startPassedTargets,\n      selected: this.selectedTargets,\n      added: added.map((index) => list[index]),\n      removed: removed.map((index) => prevList[index]),\n      afterAdded: afterAdded.map((index) => afterList[index]),\n      afterRemoved: afterRemoved.map((index) => afterPrevList[index]),\n      isDragStart: isDragStart && isDragStartEnd,\n      isDragStartEnd: isDragStart && isDragStartEnd,\n      isClick: !!e.isClick,\n      isDouble: !!isDouble,\n      rect,\n      inputEvent,\n      data: data.data,\n      isTrusted: e.isTrusted,\n    });\n  }\n  private _onDragStart = (e: OnDragStart<Gesto>, clickedTarget?: Element) => {\n    const { data, clientX, clientY, inputEvent } = e;\n    const {\n      selectFromInside,\n      selectByClick,\n      rootContainer,\n      boundContainer,\n      preventDragFromInside = true,\n      clickBySelectEnd,\n      dragCondition,\n    } = this.options;\n\n    if (dragCondition && !dragCondition(e)) {\n      e.stop();\n      return;\n    }\n    data.data = {};\n    const win = getWindow(this.container);\n    data.innerWidth = win.innerWidth;\n    data.innerHeight = win.innerHeight;\n    this.findSelectableTargets(data);\n    data.startSelectedTargets = this.selectedTargets;\n    data.scaleMatrix = createMatrix();\n    data.containerX = 0;\n    data.containerY = 0;\n\n    const container = this.container;\n    let boundArea = {\n      left: -Infinity,\n      top: -Infinity,\n      right: Infinity,\n      bottom: Infinity,\n    };\n    if (rootContainer) {\n      const containerRect = this.container.getBoundingClientRect();\n\n      data.containerX = containerRect.left;\n      data.containerY = containerRect.top;\n      data.scaleMatrix = getDistElementMatrix(this.container, rootContainer);\n    }\n\n    if (boundContainer) {\n      const boundInfo: Required<BoundContainer> =\n        isObject(boundContainer) && \"element\" in boundContainer\n          ? {\n              left: true,\n              top: true,\n              bottom: true,\n              right: true,\n              ...boundContainer,\n            }\n          : {\n              element: boundContainer,\n              left: true,\n              top: true,\n              bottom: true,\n              right: true,\n            };\n      const boundElement = boundInfo.element;\n      let rectElement: HTMLElement;\n\n      if (boundElement) {\n        if (isString(boundElement)) {\n          rectElement = getDocument(container).querySelector(boundElement)!;\n        } else if (boundElement === true) {\n          rectElement = this.container;\n        } else {\n          rectElement = boundElement;\n        }\n        const rect = rectElement.getBoundingClientRect();\n\n        if (boundInfo.left) {\n          boundArea.left = rect.left;\n        }\n        if (boundInfo.top) {\n          boundArea.top = rect.top;\n        }\n        if (boundInfo.right) {\n          boundArea.right = rect.right;\n        }\n        if (boundInfo.bottom) {\n          boundArea.bottom = rect.bottom;\n        }\n      }\n    }\n\n    data.boundArea = boundArea;\n\n    const hitRect = {\n      left: clientX,\n      top: clientY,\n      right: clientX,\n      bottom: clientY,\n      width: 0,\n      height: 0,\n    };\n    let firstPassedTargets: ElementType[] = [];\n\n    // allow click on select\n    const allowClickBySelectEnd = selectByClick && !clickBySelectEnd;\n    let hasInsideTargets = false;\n\n    if (!selectFromInside || allowClickBySelectEnd) {\n      const pointTarget = this._findElement(\n        clickedTarget || inputEvent.target, // elementFromPoint(clientX, clientY),\n        data.selectableTargets\n      );\n\n      hasInsideTargets = !!pointTarget;\n      if (allowClickBySelectEnd) {\n        firstPassedTargets = pointTarget ? [pointTarget] : [];\n      }\n    }\n    const isPreventSelect = !selectFromInside && hasInsideTargets;\n\n    // prevent drag from inside when selectByClick is false\n    if (isPreventSelect && !selectByClick) {\n      e.stop();\n      return false;\n    }\n\n    const type = inputEvent.type;\n    const isTrusted = type === \"mousedown\" || type === \"touchstart\";\n    /**\n     * When the drag starts (triggers on mousedown or touchstart), the dragStart event is called.\n     * Call the stop () function if you have a specific element or don't want to raise a select\n     * @memberof Selecto\n     * @event dragStart\n     * @param {OnDragStart} - Parameters for the dragStart event\n     * @example\n     * import Selecto from \"selecto\";\n     *\n     * const selecto = new Selecto({\n     *   container: document.body,\n     *   selectByClick: true,\n     *   selectFromInside: false,\n     * });\n     *\n     * selecto.on(\"dragStart\", e => {\n     *   if (e.inputEvent.target.tagName === \"SPAN\") {\n     *     e.stop();\n     *   }\n     * }).on(\"select\", e => {\n     *   e.added.forEach(el => {\n     *     el.classList.add(\"selected\");\n     *   });\n     *   e.removed.forEach(el => {\n     *     el.classList.remove(\"selected\");\n     *   });\n     * });\n     */\n    const result =\n      !e.isClick && isTrusted\n        ? this.emit(\"dragStart\", { ...e, data: data.data })\n        : true;\n\n    if (!result) {\n      e.stop();\n      return false;\n    }\n\n    if (this.continueSelect) {\n      firstPassedTargets = passTargets(\n        this.selectedTargets,\n        firstPassedTargets,\n        this.continueSelectWithoutDeselect\n      );\n      data.startPassedTargets = this.selectedTargets;\n    } else {\n      data.startPassedTargets = [];\n    }\n\n    this._select(\n      firstPassedTargets,\n      hitRect,\n      e,\n      true,\n      isPreventSelect &&\n        selectByClick &&\n        !clickBySelectEnd &&\n        preventDragFromInside\n    );\n    data.startX = clientX;\n    data.startY = clientY;\n    data.selectFlag = false;\n    data.preventDragFromInside = false;\n\n    if (inputEvent.target) {\n      const offsetPos = calculateMatrixDist(data.scaleMatrix, [\n        clientX - data.containerX,\n        clientY - data.containerY,\n      ]);\n      this.target.style.cssText +=\n        `position: ${rootContainer ? \"absolute\" : \"fixed\"};` +\n        `left:0px;top:0px;` +\n        `transform: translate(${offsetPos[0]}px, ${offsetPos[1]}px)`;\n    }\n\n    if (isPreventSelect && selectByClick && !clickBySelectEnd) {\n      inputEvent.preventDefault();\n\n      // prevent drag from inside when selectByClick is true and force call `selectEnd`\n      if (preventDragFromInside) {\n        this._selectEnd(\n          data.startSelectedTargets,\n          data.startPassedTargets,\n          hitRect,\n          e,\n          true\n        );\n        data.preventDragFromInside = true;\n      }\n    } else {\n      data.selectFlag = true;\n      // why?\n      // if (type === \"touchstart\") {\n      //     inputEvent.preventDefault();\n      // }\n      const { scrollOptions, innerScrollOptions } = this.options;\n\n      let isInnerScroll = false;\n\n      if (innerScrollOptions) {\n        const inputEvent = e.inputEvent;\n        const target = inputEvent.target;\n\n        let innerScrollElement: HTMLElement | null = null;\n        let parentElement = target;\n\n        while (parentElement && parentElement !== getDocument(container).body) {\n          const overflow =\n            getComputedStyle(parentElement).overflow !== \"visible\";\n\n          if (overflow) {\n            innerScrollElement = parentElement;\n            break;\n          }\n          parentElement = parentElement.parentElement;\n        }\n        if (innerScrollElement) {\n          data.innerScrollOptions = {\n            container: innerScrollElement,\n            checkScrollEvent: true,\n            ...(innerScrollOptions === true ? {} : innerScrollOptions),\n          };\n          this.dragScroll.dragStart(e, data.innerScrollOptions);\n\n          isInnerScroll = true;\n        }\n      }\n      if (!isInnerScroll && scrollOptions && scrollOptions.container) {\n        this.dragScroll.dragStart(e, scrollOptions);\n      }\n\n      if (isPreventSelect && selectByClick && clickBySelectEnd) {\n        data.selectFlag = false;\n        e.preventDrag();\n      }\n    }\n    return true;\n  };\n  private _checkSelected(e: any, rect = getRect(e, this.options.ratio)) {\n    const { data } = e;\n    const { top, left, width, height } = rect;\n    const selectFlag = data.selectFlag;\n    const { containerX, containerY, scaleMatrix } = data;\n    const offsetPos = calculateMatrixDist(scaleMatrix, [\n      left - containerX,\n      top - containerY,\n    ]);\n    const offsetSize = calculateMatrixDist(scaleMatrix, [width, height]);\n    let selectedTargets: ElementType[] = [];\n    if (selectFlag) {\n      this.target.style.cssText +=\n        `display: block;` +\n        `left:0px;top:0px;` +\n        `transform: translate(${offsetPos[0]}px, ${offsetPos[1]}px);` +\n        `width:${offsetSize[0]}px;height:${offsetSize[1]}px;`;\n\n      const passedTargets = this.hitTest(rect, data, true, e);\n      selectedTargets = passTargets(\n        data.startPassedTargets,\n        passedTargets,\n        this.continueSelect && this.continueSelectWithoutDeselect\n      );\n    }\n    /**\n     * When the drag, the drag event is called.\n     * Call the stop () function if you have a specific element or don't want to raise a select\n     * @memberof Selecto\n     * @event drag\n     * @param {OnDrag} - Parameters for the drag event\n     * @example\n     * import Selecto from \"selecto\";\n     *\n     * const selecto = new Selecto({\n     *   container: document.body,\n     *   selectByClick: true,\n     *   selectFromInside: false,\n     * });\n     *\n     * selecto.on(\"drag\", e => {\n     *   e.stop();\n     * }).on(\"select\", e => {\n     *   e.added.forEach(el => {\n     *     el.classList.add(\"selected\");\n     *   });\n     *   e.removed.forEach(el => {\n     *     el.classList.remove(\"selected\");\n     *   });\n     * });\n     */\n    const result = this.emit(\"drag\", {\n      ...e,\n      data: data.data,\n      isSelect: selectFlag,\n      rect,\n    });\n    if (result === false) {\n      this.target.style.cssText += \"display: none;\";\n      e.stop();\n      return;\n    }\n\n    if (selectFlag) {\n      this._select(selectedTargets, rect, e);\n    }\n  }\n  private _onDrag = (e: OnDrag) => {\n    if (e.data.selectFlag) {\n      const scrollOptions = this.scrollOptions;\n      const innerScrollOptions = e.data.innerScrollOptions;\n      const hasScrollOptions = innerScrollOptions || scrollOptions?.container;\n\n      // If it is a scrolling position, pass drag\n      if (\n        hasScrollOptions &&\n        !e.isScroll &&\n        this.dragScroll.drag(e, innerScrollOptions || scrollOptions)\n      ) {\n        return;\n      }\n    }\n    this._checkSelected(e);\n  };\n  private _onDragEnd = (e: OnDragEvent) => {\n    const { data, inputEvent } = e;\n    const rect = getRect(e, this.options.ratio);\n    const selectFlag = data.selectFlag;\n    const container = this.container;\n\n    /**\n     * When the drag ends (triggers on mouseup or touchend after drag), the dragEnd event is called.\n     * @memberof Selecto\n     * @event dragEnd\n     * @param {OnDragEnd} - Parameters for the dragEnd event\n     */\n    if (inputEvent) {\n      this.emit(\"dragEnd\", {\n        isDouble: !!e.isDouble,\n        isClick: !!e.isClick,\n        isDrag: false,\n        isSelect: selectFlag,\n        ...e,\n        data: data.data,\n        rect,\n      });\n    }\n    this.target.style.cssText += \"display: none;\";\n\n    if (selectFlag) {\n      data.selectFlag = false;\n      this.dragScroll.dragEnd();\n    } else if (this.selectByClick && this.clickBySelectEnd) {\n      // only clickBySelectEnd\n      const pointTarget = this._findElement(\n        inputEvent?.target || elementFromPoint(container, e.clientX, e.clientY),\n        data.selectableTargets\n      );\n      this._select(pointTarget ? [pointTarget] : [], rect, e);\n    }\n    if (!data.preventDragFromInside) {\n      this._selectEnd(\n        data.startSelectedTargets,\n        data.startPassedTargets,\n        rect,\n        e\n      );\n    }\n  };\n\n  private _onDocumentSelectStart = (e: any) => {\n    const doc = getDocument(this.container);\n\n    if (!this.gesto.isFlag()) {\n      return;\n    }\n    let dragContainer = this.dragContainer;\n\n    if (dragContainer === getWindow(this.container)) {\n      dragContainer = doc.documentElement;\n    }\n    const containers = isNode(dragContainer)\n      ? [dragContainer]\n      : ([].slice.call(dragContainer) as Element[]);\n    const target = e.target;\n\n    containers.some((container) => {\n      if (container === target || container.contains(target)) {\n        e.preventDefault();\n        return true;\n      }\n    });\n  };\n  private _findElement(\n    clickedTarget: ElementType,\n    selectableTargets: Element[]\n  ) {\n    let pointTarget = clickedTarget;\n\n    while (pointTarget) {\n      if (selectableTargets.indexOf(pointTarget) > -1) {\n        break;\n      }\n      pointTarget = pointTarget.parentElement!;\n    }\n    return pointTarget;\n  }\n  private _refreshGroups(data: IObject<any>) {\n    const innerWidth = data.innerWidth;\n    const innerHeight = data.innerHeight;\n    const selectablePoints: number[][][] = data.selectablePoints;\n\n    if (this.options.checkOverflow) {\n      const innerScrollContainer =\n        this.gesto.getEventData().innerScrollOptions?.container;\n      const parentMap: Map<Element, InnerParentInfo> =\n        data.selectableInnerScrollParentMap;\n      const innerScrollPathsList: Element[][] =\n        data.selectableInnerScrollPathsList;\n\n      data.selectableInners = innerScrollPathsList.map(\n        (innerScrollPaths, i) => {\n          let isAlwaysTrue = false;\n          return innerScrollPaths.every((target) => {\n            if (isAlwaysTrue) {\n              return true;\n            }\n            if (target === innerScrollContainer) {\n              isAlwaysTrue = true;\n              return true;\n            }\n\n            const rect = parentMap.get(target);\n\n            if (rect) {\n              const points1 = selectablePoints[i];\n              const points2 = rect.points;\n              const overlapPoints = getOverlapPoints(points1, points2);\n\n              if (!overlapPoints.length) {\n                return false;\n              }\n            }\n            return true;\n          });\n        }\n      );\n    }\n    if (!innerWidth || !innerHeight) {\n      data.innerGroups = null;\n    } else {\n      const selectablePoints: number[][][] = data.selectablePoints;\n\n      const groups: Record<\n        string | number,\n        Record<string | number, number[]>\n      > = {};\n\n      selectablePoints.forEach((points, i) => {\n        let minX = Infinity;\n        let maxX = -Infinity;\n        let minY = Infinity;\n        let maxY = -Infinity;\n\n        points.forEach((pos) => {\n          const x = Math.floor(pos[0] / innerWidth);\n          const y = Math.floor(pos[1] / innerHeight);\n\n          minX = Math.min(x, minX);\n          maxX = Math.max(x, maxX);\n          minY = Math.min(y, minY);\n          maxY = Math.max(y, maxY);\n        });\n\n        for (let x = minX; x <= maxX; ++x) {\n          for (let y = minY; y <= maxY; ++y) {\n            groups[x] = groups[x] || {};\n            groups[x][y] = groups[x][y] || [];\n\n            groups[x][y].push(i);\n          }\n        }\n      });\n\n      data.innerGroups = groups;\n    }\n  }\n}\n\ninterface Selecto extends SelectoProperties {}\n\nexport default Selecto;\n","import { Able } from \"../types\";\n\nexport function makeAble<\n  Name extends string,\n  AbleObject extends Partial<Able<any, any>>\n>(name: Name, able: AbleObject) {\n  return {\n    events: [] as AbleObject[\"events\"] extends readonly any[]\n      ? AbleObject[\"events\"]\n      : readonly [],\n    props: [] as AbleObject[\"props\"] extends readonly any[]\n      ? AbleObject[\"props\"]\n      : readonly [],\n    name,\n    ...able,\n  } as const;\n}\n","/*\nCopyright (c) 2015 NAVER Corp.\nname: @egjs/agent\nlicense: MIT\nauthor: NAVER Corp.\nrepository: git+https://github.com/naver/egjs-agent.git\nversion: 2.4.4\n*/\nfunction some(arr, callback) {\n  var length = arr.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (callback(arr[i], i)) {\n      return true;\n    }\n  }\n\n  return false;\n}\nfunction find(arr, callback) {\n  var length = arr.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (callback(arr[i], i)) {\n      return arr[i];\n    }\n  }\n\n  return null;\n}\nfunction getUserAgentString(agent) {\n  var userAgent = agent;\n\n  if (typeof userAgent === \"undefined\") {\n    if (typeof navigator === \"undefined\" || !navigator) {\n      return \"\";\n    }\n\n    userAgent = navigator.userAgent || \"\";\n  }\n\n  return userAgent.toLowerCase();\n}\nfunction execRegExp(pattern, text) {\n  try {\n    return new RegExp(pattern, \"g\").exec(text);\n  } catch (e) {\n    return null;\n  }\n}\nfunction hasUserAgentData() {\n  if (typeof navigator === \"undefined\" || !navigator || !navigator.userAgentData) {\n    return false;\n  }\n\n  var userAgentData = navigator.userAgentData;\n  var brands = userAgentData.brands || userAgentData.uaList;\n  return !!(brands && brands.length);\n}\nfunction findVersion(versionTest, userAgent) {\n  var result = execRegExp(\"(\" + versionTest + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))\", userAgent);\n  return result ? result[3] : \"\";\n}\nfunction convertVersion(text) {\n  return text.replace(/_/g, \".\");\n}\nfunction findPreset(presets, userAgent) {\n  var userPreset = null;\n  var version = \"-1\";\n  some(presets, function (preset) {\n    var result = execRegExp(\"(\" + preset.test + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))?\", userAgent);\n\n    if (!result || preset.brand) {\n      return false;\n    }\n\n    userPreset = preset;\n    version = result[3] || \"-1\";\n\n    if (preset.versionAlias) {\n      version = preset.versionAlias;\n    } else if (preset.versionTest) {\n      version = findVersion(preset.versionTest.toLowerCase(), userAgent) || version;\n    }\n\n    version = convertVersion(version);\n    return true;\n  });\n  return {\n    preset: userPreset,\n    version: version\n  };\n}\nfunction findPresetBrand(presets, brands) {\n  var brandInfo = {\n    brand: \"\",\n    version: \"-1\"\n  };\n  some(presets, function (preset) {\n    var result = findBrand(brands, preset);\n\n    if (!result) {\n      return false;\n    }\n\n    brandInfo.brand = preset.id;\n    brandInfo.version = preset.versionAlias || result.version;\n    return brandInfo.version !== \"-1\";\n  });\n  return brandInfo;\n}\nfunction findBrand(brands, preset) {\n  return find(brands, function (_a) {\n    var brand = _a.brand;\n    return execRegExp(\"\" + preset.test, brand.toLowerCase());\n  });\n}\n\nvar BROWSER_PRESETS = [{\n  test: \"phantomjs\",\n  id: \"phantomjs\"\n}, {\n  test: \"whale\",\n  id: \"whale\"\n}, {\n  test: \"edgios|edge|edg\",\n  id: \"edge\"\n}, {\n  test: \"msie|trident|windows phone\",\n  id: \"ie\",\n  versionTest: \"iemobile|msie|rv\"\n}, {\n  test: \"miuibrowser\",\n  id: \"miui browser\"\n}, {\n  test: \"samsungbrowser\",\n  id: \"samsung internet\"\n}, {\n  test: \"samsung\",\n  id: \"samsung internet\",\n  versionTest: \"version\"\n}, {\n  test: \"chrome|crios\",\n  id: \"chrome\"\n}, {\n  test: \"firefox|fxios\",\n  id: \"firefox\"\n}, {\n  test: \"android\",\n  id: \"android browser\",\n  versionTest: \"version\"\n}, {\n  test: \"safari|iphone|ipad|ipod\",\n  id: \"safari\",\n  versionTest: \"version\"\n}]; // chromium's engine(blink) is based on applewebkit 537.36.\n\nvar CHROMIUM_PRESETS = [{\n  test: \"(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\\\schrome)\",\n  id: \"chrome\",\n  versionTest: \"chrome\"\n}, {\n  test: \"chromium\",\n  id: \"chrome\"\n}, {\n  test: \"whale\",\n  id: \"chrome\",\n  versionAlias: \"-1\",\n  brand: true\n}];\nvar WEBKIT_PRESETS = [{\n  test: \"applewebkit\",\n  id: \"webkit\",\n  versionTest: \"applewebkit|safari\"\n}];\nvar WEBVIEW_PRESETS = [{\n  test: \"(?=(iphone|ipad))(?!(.*version))\",\n  id: \"webview\"\n}, {\n  test: \"(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))\",\n  id: \"webview\"\n}, {\n  // test webview\n  test: \"webview\",\n  id: \"webview\"\n}];\nvar OS_PRESETS = [{\n  test: \"windows phone\",\n  id: \"windows phone\"\n}, {\n  test: \"windows 2000\",\n  id: \"window\",\n  versionAlias: \"5.0\"\n}, {\n  test: \"windows nt\",\n  id: \"window\"\n}, {\n  test: \"win32|windows\",\n  id: \"window\"\n}, {\n  test: \"iphone|ipad|ipod\",\n  id: \"ios\",\n  versionTest: \"iphone os|cpu os\"\n}, {\n  test: \"macos|macintel|mac os x\",\n  id: \"mac\"\n}, {\n  test: \"android|linux armv81\",\n  id: \"android\"\n}, {\n  test: \"tizen\",\n  id: \"tizen\"\n}, {\n  test: \"webos|web0s\",\n  id: \"webos\"\n}];\n\nfunction isWebView(userAgent) {\n  return !!findPreset(WEBVIEW_PRESETS, userAgent).preset;\n}\nfunction getLegacyAgent(userAgent) {\n  var nextAgent = getUserAgentString(userAgent);\n  var isMobile = !!/mobi/g.exec(nextAgent);\n  var browser = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1,\n    webview: isWebView(nextAgent),\n    chromium: false,\n    chromiumVersion: \"-1\",\n    webkit: false,\n    webkitVersion: \"-1\"\n  };\n  var os = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  };\n\n  var _a = findPreset(BROWSER_PRESETS, nextAgent),\n      browserPreset = _a.preset,\n      browserVersion = _a.version;\n\n  var _b = findPreset(OS_PRESETS, nextAgent),\n      osPreset = _b.preset,\n      osVersion = _b.version;\n\n  var chromiumPreset = findPreset(CHROMIUM_PRESETS, nextAgent);\n  browser.chromium = !!chromiumPreset.preset;\n  browser.chromiumVersion = chromiumPreset.version;\n\n  if (!browser.chromium) {\n    var webkitPreset = findPreset(WEBKIT_PRESETS, nextAgent);\n    browser.webkit = !!webkitPreset.preset;\n    browser.webkitVersion = webkitPreset.version;\n  }\n\n  if (osPreset) {\n    os.name = osPreset.id;\n    os.version = osVersion;\n    os.majorVersion = parseInt(osVersion, 10);\n  }\n\n  if (browserPreset) {\n    browser.name = browserPreset.id;\n    browser.version = browserVersion; // Early whale bugs\n\n    if (browser.webview && os.name === \"ios\" && browser.name !== \"safari\") {\n      browser.webview = false;\n    }\n  }\n\n  browser.majorVersion = parseInt(browser.version, 10);\n  return {\n    browser: browser,\n    os: os,\n    isMobile: isMobile,\n    isHints: false\n  };\n}\n\nfunction getClientHintsAgent(osData) {\n  var userAgentData = navigator.userAgentData;\n  var brands = (userAgentData.uaList || userAgentData.brands).slice();\n  var fullVersionList = osData && osData.fullVersionList;\n  var isMobile = userAgentData.mobile || false;\n  var firstBrand = brands[0];\n  var platform = (osData && osData.platform || userAgentData.platform || navigator.platform).toLowerCase();\n  var browser = {\n    name: firstBrand.brand,\n    version: firstBrand.version,\n    majorVersion: -1,\n    webkit: false,\n    webkitVersion: \"-1\",\n    chromium: false,\n    chromiumVersion: \"-1\",\n    webview: !!findPresetBrand(WEBVIEW_PRESETS, brands).brand || isWebView(getUserAgentString())\n  };\n  var os = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  };\n  browser.webkit = !browser.chromium && some(WEBKIT_PRESETS, function (preset) {\n    return findBrand(brands, preset);\n  });\n  var chromiumBrand = findPresetBrand(CHROMIUM_PRESETS, brands);\n  browser.chromium = !!chromiumBrand.brand;\n  browser.chromiumVersion = chromiumBrand.version || \"-1\";\n\n  if (!browser.chromium) {\n    var webkitBrand = findPresetBrand(WEBKIT_PRESETS, brands);\n    browser.webkit = !!webkitBrand.brand;\n    browser.webkitVersion = webkitBrand.version || \"-1\";\n  }\n\n  var platfomResult = find(OS_PRESETS, function (preset) {\n    return new RegExp(\"\" + preset.test, \"g\").exec(platform);\n  });\n  os.name = platfomResult ? platfomResult.id : \"\";\n\n  if (osData) {\n    os.version = osData.platformVersion || \"-1\";\n  }\n\n  if (fullVersionList && fullVersionList.length) {\n    var browserBrandByFullVersionList = findPresetBrand(BROWSER_PRESETS, fullVersionList);\n    browser.name = browserBrandByFullVersionList.brand || browser.name;\n    browser.version = browserBrandByFullVersionList.version || browser.version;\n  } else {\n    var browserBrand = findPresetBrand(BROWSER_PRESETS, brands);\n    browser.name = browserBrand.brand || browser.name;\n    browser.version = browserBrand.brand && osData ? osData.uaFullVersion : browserBrand.version;\n  }\n\n  if (browser.webkit) {\n    os.name = isMobile ? \"ios\" : \"mac\";\n  }\n\n  if (os.name === \"ios\" && browser.webview) {\n    browser.version = \"-1\";\n  }\n\n  os.version = convertVersion(os.version);\n  browser.version = convertVersion(browser.version);\n  os.majorVersion = parseInt(os.version, 10);\n  browser.majorVersion = parseInt(browser.version, 10);\n  return {\n    browser: browser,\n    os: os,\n    isMobile: isMobile,\n    isHints: true\n  };\n}\n\n/**\n * @namespace eg.agent\n */\n\n/**\n* Extracts accuate browser and operating system information from the user agent string or client hints.\n* @ko 유저 에이전트 문자열 또는 client hints에서 정확한 브라우저와 운영체제 정보를 추출한다.\n* @function eg.agent#getAccurateAgent\n* @param - Callback function to get the accuate agent <ko>정확한 에이전트를 가져오기 위한 callback 함수</ko>\n* @return - get the accuate agent promise. If Promise are not supported, null is returned. <ko> 정확한 에이전트 promise를 가져온다. Promise를 지원 하지 않는 경우, null을 반환한다. </ko>\n* @example\nimport { getAccurateAgent } from \"@egjs/agent\";\n// eg.agent.getAccurateAgent()\ngetAccurateAgent().then(agent => {\n   const { os, browser, isMobile } = agent;\n});\ngetAccurateAgent(agent => {\n    const { os, browser, isMobile } = agent;\n});\n*/\n\nfunction getAccurateAgent(callback) {\n  if (hasUserAgentData()) {\n    return navigator.userAgentData.getHighEntropyValues([\"architecture\", \"model\", \"platform\", \"platformVersion\", \"uaFullVersion\", \"fullVersionList\"]).then(function (info) {\n      var agentInfo = getClientHintsAgent(info);\n      callback && callback(agentInfo);\n      return agentInfo;\n    });\n  }\n\n  callback && callback(agent());\n\n  if (typeof Promise === \"undefined\" || !Promise) {\n    return null;\n  }\n\n  return Promise.resolve(agent());\n}\n/**\n * Extracts browser and operating system information from the user agent string.\n * @ko 유저 에이전트 문자열에서 브라우저와 운영체제 정보를 추출한다.\n * @function eg.agent#agent\n * @param - user agent string to parse <ko>파싱할 유저에이전트 문자열</ko>\n * @return - agent Info <ko> 에이전트 정보 </ko>\n * @example\nimport agent from \"@egjs/agent\";\n// eg.agent();\nconst { os, browser, isMobile } = agent();\n */\n\nfunction agent(userAgent) {\n  if (typeof userAgent === \"undefined\" && hasUserAgentData()) {\n    return getClientHintsAgent();\n  } else {\n    return getLegacyAgent(userAgent);\n  }\n}\n\nexport default agent;\nexport { getAccurateAgent, getLegacyAgent };\n//# sourceMappingURL=agent.esm.js.map\n","import getAgent from \"@egjs/agent\";\nimport { IObject } from \"../utility\";\nimport { MoveableInterface } from \"./types\";\n\nexport const DIRECTIONS4 = [\"n\", \"w\", \"s\", \"e\"];\nexport const DIRECTIONS = [\"n\", \"w\", \"s\", \"e\", \"nw\", \"ne\", \"sw\", \"se\"];\n\nfunction getSVGCursor(scale: number, degree: number) {\n  return `data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${\n    32 * scale\n  }px\" height=\"${\n    32 * scale\n  }px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(${degree}deg);transform-origin: 16px 16px\"></path></svg>`;\n}\nfunction getCursorCSS(degree: number) {\n  const x1 = getSVGCursor(1, degree);\n  // const x2 = getSVGCursor(2, degree);\n  const degree45 = (Math.round(degree / 45) * 45) % 180;\n  let defaultCursor = \"ns-resize\";\n\n  if (degree45 === 135) {\n    defaultCursor = \"nwse-resize\";\n  } else if (degree45 === 45) {\n    defaultCursor = \"nesw-resize\";\n  } else if (degree45 === 90) {\n    defaultCursor = \"ew-resize\";\n  }\n\n  // tslint:disable-next-line: max-line-length\n  return `cursor:${defaultCursor};cursor: url('${x1}') 16 16, ${defaultCursor};`;\n}\n\nexport const agent = getAgent();\nexport const IS_WEBKIT = agent.browser.webkit;\nexport const IS_WEBKIT605 =\n  IS_WEBKIT &&\n  (() => {\n    const navi =\n      typeof window === \"undefined\" ? { userAgent: \"\" } : window.navigator;\n    const res = /applewebkit\\/([^\\s]+)/g.exec(navi.userAgent.toLowerCase());\n\n    return res ? parseFloat(res[1]) < 605 : false;\n  })();\n\nconst browserName = agent.browser.name;\nconst browserVersion = parseInt(agent.browser.version, 10);\nconst IS_CHROME = browserName === \"chrome\";\nconst IS_CHROMIUM = agent.browser.chromium;\nconst chromiumVersion = parseInt(agent.browser.chromiumVersion, 10) || 0;\n\nexport const IS_CHROMIUM109 =\n  (IS_CHROME && browserVersion >= 109) ||\n  (IS_CHROMIUM && chromiumVersion >= 109);\nexport const IS_FIREFOX = browserName === \"firefox\";\nexport const IS_SAFARI_ABOVE15 =\n  parseInt(agent.browser.webkitVersion, 10) >= 612 || browserVersion >= 15;\n\nexport const PREFIX = \"moveable-\";\n\nconst directionCSS = DIRECTIONS.map((dir) => {\n  let top = \"\";\n  let left = \"\";\n  let originX = \"center\";\n  let originY = \"center\";\n  const offset = `calc(var(--moveable-control-padding, 20) * -1px)`;\n\n  if (dir.indexOf(\"n\") > -1) {\n    top = `top: ${offset};`;\n    originY = `bottom`;\n  }\n  if (dir.indexOf(`s`) > -1) {\n    top = `top: 0px;`;\n    originY = `top`;\n  }\n  if (dir.indexOf(`w`) > -1) {\n    left = `left: ${offset};`;\n    originX = `right`;\n  }\n  if (dir.indexOf(`e`) > -1) {\n    left = `left: 0px;`;\n    originX = `left`;\n  }\n  return `.around-control[data-direction*=\"${dir}\"] {\n        ${left}${top}\n        transform-origin: ${originX} ${originY};\n    }`;\n}).join(\"\\n\");\n\nexport const MOVEABLE_CSS = `\n{\nposition: absolute;\nwidth: 1px;\nheight: 1px;\nleft: 0;\ntop: 0;\nz-index: 3000;\n--moveable-color: #4af;\n--zoom: 1;\n--zoompx: 1px;\n--moveable-line-padding: 0;\n--moveable-control-padding: 0;\nwill-change: transform;\noutline: 1px solid transparent;\n}\n.control-box {\nz-index: 0;\n}\n.line, .control {\nposition: absolute;\nleft: 0;\ntop: 0;\nwill-change: transform;\n}\n.control {\nwidth: 14px;\nheight: 14px;\nborder-radius: 50%;\nborder: 2px solid #fff;\nbox-sizing: border-box;\nbackground: #4af;\nbackground: var(--moveable-color);\nmargin-top: -7px;\nmargin-left: -7px;\nborder: 2px solid #fff;\nz-index: 10;\n}\n.around-control {\nposition: absolute;\nwill-change: transform;\nwidth: calc(var(--moveable-control-padding, 20) * 1px);\nheight: calc(var(--moveable-control-padding, 20) * 1px);\nleft: calc(var(--moveable-control-padding, 20) * -0.5px);\ntop: calc(var(--moveable-control-padding, 20) * -0.5px);\nbox-sizing: border-box;\nbackground: transparent;\nz-index: 8;\ncursor: alias;\ntransform-origin: center center;\n}\n${directionCSS}\n.padding {\nposition: absolute;\ntop: 0px;\nleft: 0px;\nwidth: 100px;\nheight: 100px;\ntransform-origin: 0 0;\n}\n.line {\nwidth: 1px;\nheight: 1px;\nbackground: #4af;\nbackground: var(--moveable-color);\ntransform-origin: 0px 50%;\n}\n.line.edge {\nz-index: 1;\nbackground: transparent;\n}\n.line.dashed {\nbox-sizing: border-box;\nbackground: transparent;\n}\n.line.dashed.horizontal {\nborder-top: 1px dashed #4af;\nborder-top-color: #4af;\nborder-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\nborder-left: 1px dashed #4af;\nborder-left-color: #4af;\nborder-left-color: var(--moveable-color);\n}\n.line.vertical {\ntransform: translateX(-50%);\n}\n.line.horizontal {\ntransform: translateY(-50%);\n}\n.line.vertical.bold {\nwidth: 2px;\n}\n.line.horizontal.bold {\nheight: 2px;\n}\n\n.control.origin {\nborder-color: #f55;\nbackground: #fff;\nwidth: 12px;\nheight: 12px;\nmargin-top: -6px;\nmargin-left: -6px;\npointer-events: none;\n}\n${[0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165]\n  .map(\n    (degree) => `\n.direction[data-rotation=\"${degree}\"], :global .view-control-rotation${degree} {\n${getCursorCSS(degree)}\n}\n`\n  )\n  .join(\"\\n\")}\n\n.line.direction:before {\ncontent: \"\";\nposition: absolute;\nwidth: 100%;\nheight: calc(var(--moveable-line-padding, 0) * 1px);\nbottom: 0;\nleft: 0;\n}\n.group {\nz-index: -1;\n}\n.area {\nposition: absolute;\n}\n.area-pieces {\nposition: absolute;\ntop: 0;\nleft: 0;\ndisplay: none;\n}\n.area.avoid, .area.pass {\npointer-events: none;\n}\n.area.avoid+.area-pieces {\ndisplay: block;\n}\n.area-piece {\nposition: absolute;\n}\n\n${\n  IS_WEBKIT605\n    ? `:global svg *:before {\ncontent:\"\";\ntransform-origin: inherit;\n}`\n    : \"\"\n}\n`;\n\nexport const NEARBY_POS = [\n  [0, 1, 2],\n  [1, 0, 3],\n  [2, 0, 3],\n  [3, 1, 2],\n];\n\nexport const FLOAT_POINT_NUM = 0.0001;\nexport const TINY_NUM = 0.0000001;\nexport const MIN_SCALE = 0.000000001;\nexport const MAX_NUM = Math.pow(10, 10);\nexport const MIN_NUM = -MAX_NUM;\n\nexport const DIRECTION_REGION_TO_DIRECTION: Record<string, number[]> = {\n  n: [0, -1],\n  e: [1, 0],\n  s: [0, 1],\n  w: [-1, 0],\n  nw: [-1, -1],\n  ne: [1, -1],\n  sw: [-1, 1],\n  se: [1, 1],\n};\n\nexport const DIRECTION_INDEXES: IObject<number[]> = {\n  n: [0, 1],\n  e: [1, 3],\n  s: [3, 2],\n  w: [2, 0],\n  nw: [0],\n  ne: [1],\n  sw: [2],\n  se: [3],\n};\nexport const DIRECTION_ROTATIONS: IObject<number> = {\n  n: 0,\n  s: 180,\n  w: 270,\n  e: 90,\n  nw: 315,\n  ne: 45,\n  sw: 225,\n  se: 135,\n};\n\nexport const MOVEABLE_METHODS: Array<keyof MoveableInterface> = [\n  \"isMoveableElement\",\n  \"updateRect\",\n  \"updateTarget\",\n  \"destroy\",\n  \"dragStart\",\n  \"isInside\",\n  \"hitTest\",\n  \"setState\",\n  \"getRect\",\n  \"request\",\n  \"isDragging\",\n  \"getManager\",\n  \"forceUpdate\",\n  \"waitToChangeTarget\",\n  \"updateSelectors\",\n  \"getTargets\",\n  \"stopDrag\",\n  \"getControlBoxElement\",\n  \"getMoveables\",\n  \"getDragElement\",\n];\n","export function prefixNames(prefix: string, ...classNames: string[]) {\n  return classNames\n    .map((className) =>\n      className\n        .split(\" \")\n        .map((name) => (name ? `${prefix}${name}` : \"\"))\n        .join(\" \")\n    )\n    .join(\" \");\n}\n\n/* react */\nexport function ref(target: any, name: string) {\n  return (e: any) => {\n    e && (target[name] = e);\n  };\n}\nexport function refs(target: any, name: string, i: number) {\n  return (e: any) => {\n    e && (target[name][i] = e);\n  };\n}\n\nexport function prefixCSS(prefix: string, css: string) {\n  return css.replace(/([^}{]*){/gm, (_, selector) => {\n    return `${selector.replace(/\\.([^{,\\s\\d.]+)/g, `.${prefix}$1`)}{`;\n  });\n}\n\nexport type ParametersType<Func, Return> = Func extends (\n  ...params: infer Params\n) => any\n  ? (...params: Params) => Return\n  : never;\n\nexport type ExcludeInterface<Obj1, Obj2> = {\n  [key in Exclude<keyof Obj1, keyof Obj2>]: Obj1[key];\n};\n\nexport type UniqueMethodInterface<\n  Methods,\n  Target extends Methods,\n  ReturnTarget extends any,\n  Duplicate extends { [key: string]: any }\n> = {\n  [key in keyof ExcludeInterface<Methods, Duplicate>]: Methods[key] extends (\n    ...params: any[]\n  ) => Target\n    ? ParametersType<Methods[key], ReturnTarget>\n    : Methods[key];\n};\n\nexport type Entries<\n  Obj extends { [key: string]: any },\n  Key = keyof Obj\n> = Key extends string ? [Key, Obj[Key]] : never;\n\nexport type ReverseKey<\n  Key extends string,\n  Obj extends { [key: string]: any },\n  E = Entries<Obj>\n> = E extends [infer Value, Key] ? Value : never;\n\nexport type ChangedMethodInterface<\n  Methods,\n  Target extends Methods,\n  ReturnTarget extends any,\n  Duplicate extends { [key: string]: any }\n> = {\n  [key in Duplicate[keyof Duplicate]]: Methods[ReverseKey<key, Duplicate> &\n    keyof Methods] extends (...params: any[]) => Target\n    ? ParametersType<\n        Methods[ReverseKey<key, Duplicate> & keyof Methods],\n        ReturnTarget\n      >\n    : Methods[ReverseKey<key, Duplicate> & keyof Methods];\n};\n\nexport type MethodInterface<\n  Methods,\n  Target extends Methods,\n  ReturnTarget extends any,\n  Duplicate extends { [key: string]: any } = {}\n> = UniqueMethodInterface<Methods, Target, ReturnTarget, Duplicate> &\n  ChangedMethodInterface<Methods, Target, ReturnTarget, Duplicate>;\n","import { MoveableManagerState, OnCustomDrag } from \"../types\";\nimport { convertDragDist } from \"../utils\";\n\nexport function setCustomDrag(\n  e: any,\n  state: MoveableManagerState<any>,\n  delta: number[],\n  isPinch: boolean,\n  isConvert: boolean,\n  ableName = \"draggable\"\n) {\n  const result = state.gestos[ableName]?.move(delta, e.inputEvent) ?? {};\n  const datas = result.originalDatas || result.datas;\n  const ableDatas = datas[ableName] || (datas[ableName] = {});\n\n  return {\n    ...(isConvert ? convertDragDist(state, result) : result),\n    isPinch: !!isPinch,\n    parentEvent: true,\n    datas: ableDatas,\n    originalDatas: e.originalDatas,\n  };\n}\n\nexport default class CustomGesto {\n  private prevX = 0;\n  private prevY = 0;\n  private startX = 0;\n  private startY = 0;\n  private isDrag = false;\n  private isFlag = false;\n  private datas: any = {\n    draggable: {},\n  };\n  constructor(private ableName = \"draggable\") {\n    this.datas = {\n      [ableName]: {},\n    };\n  }\n\n  public dragStart(client: number[], e: any) {\n    this.isDrag = false;\n    this.isFlag = false;\n    const originalDatas = e.originalDatas;\n\n    this.datas = originalDatas;\n    if (!originalDatas[this.ableName]) {\n      originalDatas[this.ableName] = {};\n    }\n    return {\n      ...this.move(client, e.inputEvent),\n      type: \"dragstart\",\n    };\n  }\n  public drag(client: number[], inputEvent: any) {\n    return this.move(\n      [client[0] - this.prevX, client[1] - this.prevY],\n      inputEvent\n    );\n  }\n  public move(delta: number[], inputEvent: any): OnCustomDrag {\n    let clientX!: number;\n    let clientY!: number;\n    let isFirstDrag = false;\n\n    if (!this.isFlag) {\n      this.prevX = delta[0];\n      this.prevY = delta[1];\n      this.startX = delta[0];\n      this.startY = delta[1];\n\n      clientX = delta[0];\n      clientY = delta[1];\n\n      this.isFlag = true;\n    } else {\n      const isPrevDrag = this.isDrag;\n\n      clientX = this.prevX + delta[0];\n      clientY = this.prevY + delta[1];\n\n      if (delta[0] || delta[1]) {\n        this.isDrag = true;\n      }\n\n      if (!isPrevDrag && this.isDrag) {\n        isFirstDrag = true;\n      }\n    }\n\n    this.prevX = clientX;\n    this.prevY = clientY;\n\n    return {\n      type: \"drag\",\n      clientX,\n      clientY,\n      inputEvent,\n      isFirstDrag,\n      isDrag: this.isDrag,\n      distX: clientX - this.startX,\n      distY: clientY - this.startY,\n      deltaX: delta[0],\n      deltaY: delta[1],\n      datas: this.datas[this.ableName],\n      originalDatas: this.datas,\n      parentEvent: true,\n      parentGesto: this,\n    };\n  }\n}\n","import { MoveablePosition } from \"../types\";\nimport { calculatePoses, calculatePosition, sign } from \"../utils\";\n\nexport function calculateElementPosition(\n  matrix: number[],\n  origin: number[],\n  width: number,\n  height: number\n): MoveablePosition {\n  const is3d = matrix.length === 16;\n  const n = is3d ? 4 : 3;\n  const poses = calculatePoses(matrix, width, height, n);\n  let [[x1, y1], [x2, y2], [x3, y3], [x4, y4]] = poses;\n  let [originX, originY] = calculatePosition(matrix, origin, n);\n\n  const left = Math.min(x1, x2, x3, x4);\n  const top = Math.min(y1, y2, y3, y4);\n  const right = Math.max(x1, x2, x3, x4);\n  const bottom = Math.max(y1, y2, y3, y4);\n\n  x1 = x1 - left || 0;\n  x2 = x2 - left || 0;\n  x3 = x3 - left || 0;\n  x4 = x4 - left || 0;\n\n  y1 = y1 - top || 0;\n  y2 = y2 - top || 0;\n  y3 = y3 - top || 0;\n  y4 = y4 - top || 0;\n\n  originX = originX - left || 0;\n  originY = originY - top || 0;\n\n  const sx = matrix[0];\n  const sy = matrix[n + 1];\n  const direction = sign(sx * sy);\n\n  return {\n    left,\n    top,\n    right,\n    bottom,\n    origin: [originX, originY],\n    pos1: [x1, y1],\n    pos2: [x2, y2],\n    pos3: [x3, y3],\n    pos4: [x4, y4],\n    direction,\n  };\n}\n","import {\n  invert,\n  calculate,\n  minus,\n  plus,\n  convertPositionMatrix,\n  createScaleMatrix,\n  multiply,\n  fromTranslation,\n  convertDimension,\n} from \"../../matrix\";\nimport {\n  calculatePoses,\n  getAbsoluteMatrix,\n  getAbsolutePosesByState,\n  calculatePosition,\n  calculateInversePosition,\n  convertTransformInfo,\n  fillCSSObject,\n} from \"../utils\";\nimport {\n  splitUnit,\n  isArray,\n  splitSpace,\n  findIndex,\n  dot,\n  find,\n  isString,\n} from \"../../utility\";\nimport {\n  MoveableManagerState,\n  ResizableProps,\n  MoveableManagerInterface,\n  OnTransformEvent,\n  OnTransformStartEvent,\n  DraggableProps,\n  OnDrag,\n} from \"../types\";\nimport { setCustomDrag } from \"./custom-gesto\";\nimport { parse, parseMat } from \"../../css-to-mat\";\nimport { Draggable } from \"../index\";\nimport { calculateElementPosition } from \"../utils/calculate-element-position\";\n\nexport function calculatePointerDist(\n  moveable: MoveableManagerInterface,\n  e: any\n) {\n  const { clientX, clientY, datas } = e;\n  const { moveableClientRect, rootMatrix, is3d, pos1 } = moveable.state;\n  const { left, top } = moveableClientRect;\n  const n = is3d ? 4 : 3;\n  const [posX, posY] = minus(\n    calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n),\n    pos1\n  );\n  const [distX, distY] = getDragDist({ datas, distX: posX, distY: posY });\n\n  return [distX, distY];\n}\n\nexport function setDragStart(\n  moveable: MoveableManagerInterface<any>,\n  { datas }: any\n) {\n  const {\n    allMatrix,\n    beforeMatrix,\n    is3d,\n    left,\n    top,\n    origin,\n    offsetMatrix,\n    targetMatrix,\n    transformOrigin,\n  } = moveable.state;\n  const n = is3d ? 4 : 3;\n\n  datas.is3d = is3d;\n  datas.matrix = allMatrix;\n  datas.targetMatrix = targetMatrix;\n  datas.beforeMatrix = beforeMatrix;\n  datas.offsetMatrix = offsetMatrix;\n  datas.transformOrigin = transformOrigin;\n  datas.inverseMatrix = invert(allMatrix, n);\n  datas.inverseBeforeMatrix = invert(beforeMatrix, n);\n  datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);\n  datas.startDragBeforeDist = calculate(\n    datas.inverseBeforeMatrix,\n    datas.absoluteOrigin,\n    n\n  );\n  datas.startDragDist = calculate(datas.inverseMatrix, datas.absoluteOrigin, n);\n}\n\nexport function getTransformDirection(e: any) {\n  return calculateElementPosition(e.datas.beforeTransform, [50, 50], 100, 100)\n    .direction;\n}\n\nexport interface OriginalDataTransformInfos {\n  startTransforms: string[];\n  nextTransforms: string[];\n  nextTransformAppendedIndexes: number[];\n}\n\nexport function resolveTransformEvent(\n  moveable: MoveableManagerInterface,\n  event: any,\n  functionName: string\n) {\n  const {\n    datas,\n    originalDatas: { beforeRenderable: originalDatas },\n  } = event;\n\n  const index = datas.transformIndex;\n\n  const nextTransforms = originalDatas.nextTransforms as string[];\n  const length = nextTransforms.length;\n  const nextTransformAppendedIndexes: any[] =\n    originalDatas.nextTransformAppendedIndexes;\n  let nextIndex = -1;\n\n  if (index === -1) {\n    // translate => rotate => scale\n    if (functionName === \"translate\") {\n      nextIndex = 0;\n    } else if (functionName === \"rotate\") {\n      nextIndex = findIndex(nextTransforms, (text) => text.match(/scale\\(/g));\n    }\n    if (nextIndex === -1) {\n      nextIndex = nextTransforms.length;\n    }\n    datas.transformIndex = nextIndex;\n  } else if (\n    find(\n      nextTransformAppendedIndexes,\n      (info) => info.index === index && info.functionName === functionName\n    )\n  ) {\n    nextIndex = index;\n  } else {\n    nextIndex =\n      index +\n      nextTransformAppendedIndexes.filter((info) => info.index < index).length;\n  }\n\n  const result = convertTransformInfo(\n    nextTransforms,\n    moveable.state,\n    nextIndex\n  );\n  const targetFunction = result.targetFunction;\n  const matFunctionName = functionName === \"rotate\" ? \"rotateZ\" : functionName;\n\n  datas.beforeFunctionTexts = result.beforeFunctionTexts;\n  datas.afterFunctionTexts = result.afterFunctionTexts;\n  datas.beforeTransform = result.beforeFunctionMatrix;\n  datas.beforeTransform2 = result.beforeFunctionMatrix2;\n  datas.targetTansform = result.targetFunctionMatrix;\n  datas.afterTransform = result.afterFunctionMatrix;\n  datas.afterTransform2 = result.afterFunctionMatrix2;\n  datas.targetAllTransform = result.allFunctionMatrix;\n\n  if (targetFunction.functionName === matFunctionName) {\n    datas.afterFunctionTexts.splice(0, 1);\n    datas.isAppendTransform = false;\n  } else if (length > nextIndex) {\n    datas.isAppendTransform = true;\n\n    originalDatas.nextTransformAppendedIndexes = [\n      ...nextTransformAppendedIndexes,\n      {\n        functionName,\n        index: nextIndex,\n        isAppend: true,\n      },\n    ];\n  }\n}\n\nexport function convertTransformFormat(datas: any, value: any, dist: any) {\n  return `${datas.beforeFunctionTexts.join(\" \")} ${\n    datas.isAppendTransform ? dist : value\n  } ${datas.afterFunctionTexts.join(\" \")}`;\n}\nexport function getTransformDist({ datas, distX, distY }: any) {\n  const [bx, by] = getBeforeDragDist({ datas, distX, distY });\n  // B * [tx, ty] * A = [bx, by] * targetMatrix;\n  // [tx, ty] = B-1 * [bx, by] * targetMatrix * A-1 * [0, 0];\n\n  const res = getTransfromMatrix(datas, fromTranslation([bx, by], 4));\n\n  return calculate(res, convertPositionMatrix([0, 0, 0], 4), 4);\n}\nexport function getTransfromMatrix(\n  datas: any,\n  targetMatrix: number[],\n  isAfter?: boolean\n) {\n  const {\n    beforeTransform,\n    afterTransform,\n    beforeTransform2,\n    afterTransform2,\n    targetAllTransform,\n  } = datas;\n\n  // B * afterTargetMatrix * A = (targetMatrix * targetAllTransform)\n  // afterTargetMatrix = B-1 * targetMatrix * targetAllTransform * A-1\n  // nextTargetMatrix = (targetMatrix * targetAllTransform)\n  const nextTargetMatrix = isAfter\n    ? multiply(targetAllTransform, targetMatrix, 4)\n    : multiply(targetMatrix, targetAllTransform, 4);\n\n  // res1 = B-1 * nextTargetMatrix\n  const res1 = multiply(\n    invert(isAfter ? beforeTransform2 : beforeTransform, 4),\n    nextTargetMatrix,\n    4\n  );\n\n  // res3 = res2 * A-1\n  const afterTargetMatrix = multiply(\n    res1,\n    invert(isAfter ? afterTransform2 : afterTransform, 4),\n    4\n  );\n\n  return afterTargetMatrix;\n}\nexport function getBeforeDragDist({ datas, distX, distY }: any) {\n  // TT = BT\n  const { inverseBeforeMatrix, is3d, startDragBeforeDist, absoluteOrigin } =\n    datas;\n  const n = is3d ? 4 : 3;\n\n  // ABS_ORIGIN * [distX, distY] = BM * (ORIGIN + [tx, ty])\n  // BM -1 * ABS_ORIGIN * [distX, distY] - ORIGIN = [tx, ty]\n  return minus(\n    calculate(inverseBeforeMatrix, plus(absoluteOrigin, [distX, distY]), n),\n    startDragBeforeDist\n  );\n}\nexport function getDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n  const {\n    inverseBeforeMatrix,\n    inverseMatrix,\n    is3d,\n    startDragBeforeDist,\n    startDragDist,\n    absoluteOrigin,\n  } = datas;\n  const n = is3d ? 4 : 3;\n\n  return minus(\n    calculate(\n      isBefore ? inverseBeforeMatrix : inverseMatrix,\n      plus(absoluteOrigin, [distX, distY]),\n      n\n    ),\n    isBefore ? startDragBeforeDist : startDragDist\n  );\n}\nexport function getInverseDragDist(\n  { datas, distX, distY }: any,\n  isBefore?: boolean\n) {\n  const {\n    beforeMatrix,\n    matrix,\n    is3d,\n    startDragBeforeDist,\n    startDragDist,\n    absoluteOrigin,\n  } = datas;\n  const n = is3d ? 4 : 3;\n\n  return minus(\n    calculate(\n      isBefore ? beforeMatrix : matrix,\n      plus(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]),\n      n\n    ),\n    absoluteOrigin\n  );\n}\n\nexport function calculateTransformOrigin(\n  transformOrigin: string[],\n  width: number,\n  height: number,\n  prevWidth: number = width,\n  prevHeight: number = height,\n  prevOrigin: number[] = [0, 0]\n) {\n  if (!transformOrigin) {\n    return prevOrigin;\n  }\n  return transformOrigin.map((pos, i) => {\n    const { value, unit } = splitUnit(pos);\n\n    const prevSize = i ? prevHeight : prevWidth;\n    const size = i ? height : width;\n    if (pos === \"%\" || isNaN(value)) {\n      // no value but %\n\n      const measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;\n\n      return size * measureRatio;\n    } else if (unit !== \"%\") {\n      return value;\n    }\n    return (size * value) / 100;\n  });\n}\n\nexport function getPosIndexesByDirection(direction: number[]) {\n  const indexes: number[] = [];\n\n  if (direction[1] >= 0) {\n    if (direction[0] >= 0) {\n      indexes.push(3);\n    }\n    if (direction[0] <= 0) {\n      indexes.push(2);\n    }\n  }\n  if (direction[1] <= 0) {\n    if (direction[0] >= 0) {\n      indexes.push(1);\n    }\n    if (direction[0] <= 0) {\n      indexes.push(0);\n    }\n  }\n  return indexes;\n}\nexport function getPosesByDirection(poses: number[][], direction: number[]) {\n  /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n  return getPosIndexesByDirection(direction).map((index) => poses[index]);\n}\n\nexport function getPosBySingleDirection(poses: number[][], direction: number) {\n  const ratio = (direction + 1) / 2;\n  return [\n    dot(poses[0][0], poses[1][0], ratio, 1 - ratio),\n    dot(poses[0][1], poses[1][1], ratio, 1 - ratio),\n  ];\n}\n\nexport function getPosByDirection(poses: number[][], direction: number[]) {\n  const top = getPosBySingleDirection([poses[0], poses[1]], direction[0]);\n  const bottom = getPosBySingleDirection([poses[2], poses[3]], direction[0]);\n\n  return getPosBySingleDirection([top, bottom], direction[1]);\n}\n\nfunction getDist(\n  startPos: number[],\n  matrix: number[],\n  width: number,\n  height: number,\n  n: number,\n  fixedDirection: number[]\n) {\n  const poses = calculatePoses(matrix, width, height, n);\n  const fixedPos = getPosByDirection(poses, fixedDirection);\n  const distX = startPos[0] - fixedPos[0];\n  const distY = startPos[1] - fixedPos[1];\n\n  return [distX, distY];\n}\nexport function getNextMatrix(\n  offsetMatrix: number[],\n  targetMatrix: number[],\n  origin: number[],\n  n: number\n) {\n  return multiply(offsetMatrix, getAbsoluteMatrix(targetMatrix, n, origin), n);\n}\nexport function getNextTransformMatrix(\n  state: MoveableManagerState<any>,\n  datas: any,\n  transform: string | number[],\n  isAllTransform?: boolean\n) {\n  const { transformOrigin, offsetMatrix, is3d } = state;\n  const n = is3d ? 4 : 3;\n  let targetTransform!: number[];\n\n  if (isString(transform)) {\n    const { beforeTransform, afterTransform } = datas;\n\n    if (isAllTransform) {\n      targetTransform = convertDimension(parseMat(transform), 4, n);\n    } else {\n      targetTransform = convertDimension(\n        multiply(\n          multiply(beforeTransform, parseMat([transform]), 4),\n          afterTransform,\n          4\n        ),\n        4,\n        n\n      );\n    }\n  } else {\n    targetTransform = transform;\n  }\n\n  return getNextMatrix(offsetMatrix, targetTransform, transformOrigin, n);\n}\nexport function scaleMatrix(state: any, scale: number[]) {\n  const {\n    transformOrigin,\n    offsetMatrix,\n    is3d,\n    targetMatrix,\n    targetAllTransform,\n  } = state;\n  const n = is3d ? 4 : 3;\n\n  return getNextMatrix(\n    offsetMatrix,\n    multiply(\n      targetAllTransform || targetMatrix,\n      createScaleMatrix(scale, n),\n      n\n    ),\n    transformOrigin,\n    n\n  );\n}\n\nexport function fillTransformStartEvent(\n  moveable: MoveableManagerInterface,\n  e: any\n): OnTransformStartEvent {\n  const originalDatas = getBeforeRenderableDatas(e);\n  return {\n    setTransform: (transform: string | string[], index = -1) => {\n      originalDatas.startTransforms = isArray(transform)\n        ? transform\n        : splitSpace(transform);\n      setTransformIndex(moveable, e, index);\n    },\n    setTransformIndex: (index: number) => {\n      setTransformIndex(moveable, e, index);\n    },\n  };\n}\nexport function setDefaultTransformIndex(\n  moveable: MoveableManagerInterface,\n  e: any,\n  property: string\n) {\n  const originalDatas = getBeforeRenderableDatas(e);\n  const startTransforms = originalDatas.startTransforms;\n\n  setTransformIndex(\n    moveable,\n    e,\n    findIndex<string>(\n      startTransforms,\n      (func) => func.indexOf(`${property}(`) === 0\n    )\n  );\n}\nexport function setTransformIndex(\n  moveable: MoveableManagerInterface,\n  e: any,\n  index: number\n) {\n  const originalDatas = getBeforeRenderableDatas(e);\n  const datas = e.datas;\n\n  datas.transformIndex = index;\n  if (index === -1) {\n    return;\n  }\n  const transform = originalDatas.startTransforms[index];\n\n  if (!transform) {\n    return;\n  }\n  const state = moveable.state;\n  const info = parse([transform], {\n    \"x%\": (v) => (v / 100) * state.offsetWidth,\n    \"y%\": (v) => (v / 100) * state.offsetHeight,\n  });\n\n  datas.startValue = info[0].functionValue;\n}\nexport function fillOriginalTransform(e: any, transform: string) {\n  const originalDatas = getBeforeRenderableDatas(e);\n\n  originalDatas.nextTransforms = splitSpace(transform);\n  // originalDatas.nextTargetMatrix = parseMat(transform);\n}\nexport function getBeforeRenderableDatas(e: any) {\n  return e.originalDatas.beforeRenderable;\n}\nexport function getNextTransforms(e: any) {\n  const {\n    originalDatas: { beforeRenderable: originalDatas },\n  } = e;\n\n  return originalDatas.nextTransforms as string[];\n}\nexport function getNextTransformText(e: any) {\n  return (getNextTransforms(e) || []).join(\" \");\n}\n\nexport function getNextStyle(e: any) {\n  return getBeforeRenderableDatas(e).nextStyle;\n}\n\nexport function fillTransformEvent(\n  moveable: MoveableManagerInterface<DraggableProps>,\n  nextTransform: string,\n  delta: number[],\n  isPinch: boolean,\n  e: any\n): OnTransformEvent {\n  fillOriginalTransform(e, nextTransform);\n\n  const drag = Draggable.drag!(\n    moveable,\n    setCustomDrag(e, moveable.state, delta, isPinch, false)\n  ) as OnDrag;\n  const afterTransform = drag ? drag.transform : nextTransform;\n  return {\n    transform: nextTransform,\n    drag: drag as OnDrag,\n    ...fillCSSObject(\n      {\n        transform: afterTransform,\n      },\n      e\n    ),\n    afterTransform,\n  };\n}\n\nexport function getTranslateFixedPosition(\n  moveable: MoveableManagerInterface<any>,\n  transform: string | number[],\n  fixedDirection: number[],\n  fixedOffset: number[],\n  datas: any,\n  isAllTransform?: boolean\n) {\n  const nextMatrix = getNextTransformMatrix(\n    moveable.state,\n    datas,\n    transform,\n    isAllTransform\n  );\n  const nextFixedPosition = getDirectionOffset(\n    moveable,\n    fixedDirection,\n    fixedOffset,\n    nextMatrix\n  );\n\n  return nextFixedPosition;\n}\n\nexport function getTranslateDist(\n  moveable: MoveableManagerInterface<any>,\n  transform: string,\n  fixedDirection: number[],\n  fixedPosition: number[],\n  fixedOffset: number[],\n  datas: any,\n  isAllTransform?: boolean\n) {\n  const nextFixedPosition = getTranslateFixedPosition(\n    moveable,\n    transform,\n    fixedDirection,\n    fixedOffset,\n    datas,\n    isAllTransform\n  );\n  const state = moveable.state;\n  const { left, top } = state;\n\n  const groupable = moveable.props.groupable;\n  const groupLeft = groupable ? left : 0;\n  const groupTop = groupable ? top : 0;\n  const dist = minus(fixedPosition, nextFixedPosition);\n\n  return minus(dist, [groupLeft, groupTop]);\n}\nexport function getScaleDist(\n  moveable: MoveableManagerInterface<any>,\n  transform: string,\n  fixedDirection: number[],\n  fixedPosition: number[],\n  fixedOffset: number[],\n  datas: any,\n  isAllTransform?: boolean\n) {\n  const dist = getTranslateDist(\n    moveable,\n    transform,\n    fixedDirection,\n    fixedPosition,\n    fixedOffset,\n    datas,\n    isAllTransform\n  );\n\n  return dist;\n}\nexport function getOriginDirection(moveable: MoveableManagerInterface<any>) {\n  const { width, height, transformOrigin } = moveable.state;\n  return [\n    -1 + transformOrigin[0] / (width / 2),\n    -1 + transformOrigin[1] / (height / 2),\n  ];\n}\nexport function getDirectionByPos(\n  pos: number[],\n  width: number,\n  height: number\n) {\n  return [\n    width ? -1 + pos[0] / (width / 2) : 0,\n    height ? -1 + pos[1] / (height / 2) : 0,\n  ];\n}\nexport function getDirectionOffset(\n  moveable: MoveableManagerInterface,\n  fixedDirection: number[],\n  fixedOffset: number[],\n  nextMatrix: number[] = moveable.state.allMatrix\n) {\n  const { width, height, is3d } = moveable.state;\n  const n = is3d ? 4 : 3;\n  const fixedOffsetPosition = [\n    (width / 2) * (1 + fixedDirection[0]) + fixedOffset[0],\n    (height / 2) * (1 + fixedDirection[1]) + fixedOffset[1],\n  ];\n  return calculatePosition(nextMatrix, fixedOffsetPosition, n);\n}\nexport function getRotateDist(\n  moveable: MoveableManagerInterface<any>,\n  rotateDist: number,\n  datas: any\n) {\n  const fixedDirection = datas.fixedDirection;\n  const fixedPosition = datas.fixedPosition;\n  const fixedOffset = datas.fixedOffset;\n\n  return getTranslateDist(\n    moveable,\n    `rotate(${rotateDist}deg)`,\n    fixedDirection,\n    fixedPosition,\n    fixedOffset,\n    datas\n  );\n}\nexport function getResizeDist(\n  moveable: MoveableManagerInterface<any>,\n  width: number,\n  height: number,\n  fixedPosition: number[],\n  transformOrigin: string[],\n  datas: any\n) {\n  const { groupable } = moveable.props;\n  const state = moveable.state;\n  const {\n    transformOrigin: prevOrigin,\n    offsetMatrix,\n    is3d,\n    width: prevWidth,\n    height: prevHeight,\n    left,\n    top,\n  } = state;\n  const fixedDirection = datas.fixedDirection;\n  const targetMatrix = datas.nextTargetMatrix || state.targetMatrix;\n  const n = is3d ? 4 : 3;\n  const nextOrigin = calculateTransformOrigin(\n    transformOrigin!,\n    width,\n    height,\n    prevWidth,\n    prevHeight,\n    prevOrigin\n  );\n  const groupLeft = groupable ? left : 0;\n  const groupTop = groupable ? top : 0;\n  const nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\n  const dist = getDist(\n    fixedPosition,\n    nextMatrix,\n    width,\n    height,\n    n,\n    fixedDirection\n  );\n\n  return minus(dist, [groupLeft, groupTop]);\n}\nexport function getAbsolutePosition(\n  moveable: MoveableManagerInterface<ResizableProps>,\n  direction: number[]\n) {\n  return getPosByDirection(getAbsolutePosesByState(moveable.state), direction);\n}\n","import { MoveableManagerInterface } from \"../types\";\n\nexport function getGestoData(\n  moveable: MoveableManagerInterface,\n  ableName: string\n) {\n  const targetGesto = moveable.targetGesto;\n  const controlGesto = moveable.controlGesto;\n  let data!: Record<string, any>;\n\n  if (targetGesto?.isFlag()) {\n    data = targetGesto.getEventData()[ableName];\n  }\n\n  if (!data && controlGesto?.isFlag()) {\n    data = controlGesto.getEventData()[ableName];\n  }\n\n  return data || {};\n}\n","import {\n  convertCSStoMatrix,\n  convertDimension,\n  createIdentityMatrix,\n  createOriginMatrix,\n  createScaleMatrix,\n} from \"../../matrix\";\nimport { getCachedStyle } from \"../store/store\";\nimport {\n  IS_WEBKIT,\n  IS_SAFARI_ABOVE15,\n  IS_FIREFOX,\n  IS_CHROMIUM109,\n} from \"../consts\";\nimport { MatrixInfo } from \"../types\";\nimport {\n  getOffsetInfo,\n  getElementTransform,\n  getTransformMatrix,\n  getPositionFixedInfo,\n  convert3DMatrixes,\n  getOffsetPosInfo,\n  getSVGMatrix,\n  getBodyOffset,\n  getAbsoluteMatrix,\n} from \"../utils\";\nimport { getDocumentBody, getDocumentElement } from \"../../utility\";\nimport { parseMat } from \"../../css-to-mat\";\n\nexport function getShadowRoot(parentElement: HTMLElement | SVGElement) {\n  if (parentElement && parentElement.getRootNode) {\n    const rootNode = parentElement.getRootNode();\n\n    if (rootNode.nodeType === 11) {\n      return rootNode;\n    }\n  }\n  return;\n}\n\nfunction getIndividualTransforms(getStyle: (property: string) => any) {\n  const scale = getStyle(\"scale\") as string;\n  const rotate = getStyle(\"rotate\") as string;\n  const translate = getStyle(\"translate\") as string;\n  const individualTransforms: string[] = [];\n\n  if (translate && translate !== \"0px\" && translate !== \"none\") {\n    individualTransforms.push(`translate(${translate.split(/\\s+/).join(\",\")})`);\n  }\n  if (rotate && rotate !== \"1\" && rotate !== \"none\") {\n    individualTransforms.push(`rotate(${rotate})`);\n  }\n  if (scale && scale !== \"1\" && scale !== \"none\") {\n    individualTransforms.push(`scale(${scale.split(/\\s+/).join(\",\")})`);\n  }\n  return individualTransforms;\n}\n\nexport interface MatrixStackInfo {\n  zoom: number;\n  offsetContainer: HTMLElement;\n  matrixes: MatrixInfo[];\n  targetMatrix: number[];\n  transformOrigin: number[];\n  targetOrigin: number[];\n  is3d: boolean;\n  hasFixed: boolean;\n}\nexport function getMatrixStackInfo(\n  target: SVGElement | HTMLElement,\n  container?: SVGElement | HTMLElement | null,\n  checkContainer?: boolean\n): MatrixStackInfo {\n  let el: SVGElement | HTMLElement | null = target;\n  const matrixes: MatrixInfo[] = [];\n  const documentElement = getDocumentElement(target) || getDocumentBody(target);\n  let requestEnd =\n    (!checkContainer && target === container) || target === documentElement;\n  let isEnd = requestEnd;\n  let is3d = false;\n  let n = 3;\n  let transformOrigin!: number[];\n  let targetTransformOrigin!: number[];\n  let targetMatrix!: number[];\n\n  let hasFixed = false;\n  let offsetContainer = getOffsetInfo(container, container, true).offsetParent;\n  let zoom = 1;\n\n  while (el && !isEnd) {\n    isEnd = requestEnd;\n    const getStyle = getCachedStyle(el);\n    const position = getStyle(\"position\");\n    const transform = getElementTransform(el);\n    const isFixed = position === \"fixed\";\n    const individualTransforms = getIndividualTransforms(getStyle);\n    let matrix: number[] = convertCSStoMatrix(getTransformMatrix(transform));\n    let offsetParent: HTMLElement;\n    let isOffsetEnd = false;\n    let isStatic = false;\n    let parentClientLeft = 0;\n    let parentClientTop = 0;\n    let fixedClientLeft = 0;\n    let fixedClientTop = 0;\n    let fixedInfo: {\n      hasTransform: boolean;\n      fixedContainer: HTMLElement | null;\n    } = {\n      hasTransform: false,\n      fixedContainer: null,\n    };\n\n    if (isFixed) {\n      hasFixed = true;\n      fixedInfo = getPositionFixedInfo(el);\n      offsetContainer = fixedInfo.fixedContainer!;\n    }\n\n    // convert 3 to 4\n    const length = matrix.length;\n\n    if (!is3d && (length === 16 || individualTransforms.length)) {\n      is3d = true;\n      n = 4;\n\n      convert3DMatrixes(matrixes);\n      if (targetMatrix) {\n        targetMatrix = convertDimension(targetMatrix, 3, 4);\n      }\n    }\n    if (is3d && length === 9) {\n      matrix = convertDimension(matrix, 3, 4);\n    }\n    const {\n      tagName,\n      hasOffset,\n      isSVG,\n      origin,\n      targetOrigin,\n      offset: offsetPos,\n    } = getOffsetPosInfo(el, target);\n    let [offsetLeft, offsetTop] = offsetPos;\n\n    // no target with svg\n    if (\n      tagName === \"svg\" &&\n      !(el as SVGSVGElement).ownerSVGElement &&\n      targetMatrix\n    ) {\n      // scale matrix for svg's SVGElements.\n      matrixes.push({\n        type: \"target\",\n        target: el,\n        matrix: getSVGMatrix(el as SVGSVGElement, n),\n      });\n      matrixes.push({\n        type: \"offset\",\n        target: el,\n        matrix: createIdentityMatrix(n),\n      });\n    }\n\n    const targetZoom = parseFloat(getStyle(\"zoom\")) || 1;\n\n    if (isFixed) {\n      offsetParent = fixedInfo.fixedContainer!;\n      isOffsetEnd = true;\n    } else {\n      const offsetInfo = getOffsetInfo(el, container, false, true, getStyle);\n      const offsetZoom = offsetInfo.offsetZoom;\n\n      offsetParent = offsetInfo.offsetParent;\n      isOffsetEnd = offsetInfo.isEnd;\n      isStatic = offsetInfo.isStatic;\n      zoom *= offsetZoom;\n\n      if ((offsetInfo.isCustomElement || offsetZoom !== 1) && isStatic) {\n        offsetLeft -= offsetParent.offsetLeft;\n        offsetTop -= offsetParent.offsetTop;\n      } else if (IS_FIREFOX || IS_CHROMIUM109) {\n        const parentSlotElement = offsetInfo.parentSlotElement;\n\n        if (parentSlotElement) {\n          let customOffsetParent: HTMLElement | null = offsetParent;\n          let customOffsetLeft = 0;\n          let customOffsetTop = 0;\n\n          while (customOffsetParent) {\n            if (!getShadowRoot(customOffsetParent)) {\n              break;\n            }\n            customOffsetLeft += customOffsetParent.offsetLeft;\n            customOffsetTop += customOffsetParent.offsetTop;\n            customOffsetParent = customOffsetParent.offsetParent as HTMLElement;\n          }\n          offsetLeft -= customOffsetLeft;\n          offsetTop -= customOffsetTop;\n        }\n      }\n    }\n\n    if (\n      IS_WEBKIT &&\n      !IS_SAFARI_ABOVE15 &&\n      hasOffset &&\n      !isSVG &&\n      isStatic &&\n      (position === \"relative\" || position === \"static\")\n    ) {\n      offsetLeft -= offsetParent.offsetLeft;\n      offsetTop -= offsetParent.offsetTop;\n      requestEnd = requestEnd || isOffsetEnd;\n    }\n\n    if (isFixed) {\n      if (hasOffset && fixedInfo.hasTransform) {\n        // border\n        fixedClientLeft = offsetParent.clientLeft;\n        fixedClientTop = offsetParent.clientTop;\n      }\n    } else {\n      if (hasOffset && offsetContainer !== offsetParent) {\n        // border\n        parentClientLeft = offsetParent.clientLeft;\n        parentClientTop = offsetParent.clientTop;\n      }\n      if (hasOffset && offsetParent === documentElement) {\n        const margin = getBodyOffset(el, false);\n\n        offsetLeft += margin[0];\n        offsetTop += margin[1];\n      }\n    }\n\n    matrixes.push({\n      type: \"target\",\n      target: el,\n      matrix: getAbsoluteMatrix(matrix, n, origin),\n    });\n\n    if (individualTransforms.length) {\n      matrixes.push({\n        type: \"offset\",\n        target: el,\n        matrix: createIdentityMatrix(n),\n      });\n\n      matrixes.push({\n        type: \"target\",\n        target: el,\n        matrix: getAbsoluteMatrix(parseMat(individualTransforms), n, origin),\n      });\n    }\n    if (hasOffset) {\n      const isElementTarget = el === target;\n      const scrollLeft = isElementTarget ? 0 : el.scrollLeft;\n      const scrollTop = isElementTarget ? 0 : el.scrollTop;\n\n      matrixes.push({\n        type: \"offset\",\n        target: el,\n        matrix: createOriginMatrix(\n          [\n            offsetLeft - scrollLeft + parentClientLeft - fixedClientLeft,\n            offsetTop - scrollTop + parentClientTop - fixedClientTop,\n          ],\n          n\n        ),\n      });\n    } else {\n      // svg\n      matrixes.push({\n        type: \"offset\",\n        target: el,\n        origin,\n      });\n    }\n    // transform으로 계산되지 않는 zoom을 위한 (0, 0) 을 기준 matrix 추가.\n    if (targetZoom !== 1) {\n      matrixes.push({\n        type: \"zoom\",\n        target: el,\n        matrix: getAbsoluteMatrix(\n          createScaleMatrix([targetZoom, targetZoom], n),\n          n,\n          [0, 0]\n        ),\n      });\n    }\n    if (!targetMatrix) {\n      targetMatrix = matrix;\n    }\n    if (!transformOrigin) {\n      transformOrigin = origin;\n    }\n    if (!targetTransformOrigin) {\n      targetTransformOrigin = targetOrigin;\n    }\n\n    if (isEnd || isFixed) {\n      break;\n    } else {\n      el = offsetParent;\n      requestEnd = isOffsetEnd;\n    }\n    if (!checkContainer || el === documentElement) {\n      isEnd = requestEnd;\n    }\n  }\n  if (!targetMatrix) {\n    targetMatrix = createIdentityMatrix(n);\n  }\n  if (!transformOrigin) {\n    transformOrigin = [0, 0];\n  }\n  if (!targetTransformOrigin) {\n    targetTransformOrigin = [0, 0];\n  }\n\n  return {\n    zoom,\n    offsetContainer,\n    matrixes,\n    targetMatrix,\n    transformOrigin,\n    targetOrigin: targetTransformOrigin,\n    is3d,\n    hasFixed,\n  };\n}\n","import { find, getWindow } from \"../../utility\";\nimport { getClientRect } from \"../utils\";\nimport { MoveableClientRect } from \"../types\";\nimport {\n  getMatrixStackInfo,\n  MatrixStackInfo,\n} from \"../utils/get-matrix-stack-info\";\n\nlet cacheStyleMap: Map<\n  Element,\n  {\n    style: CSSStyleDeclaration;\n    cached: Record<string, any>;\n  }\n> | null = null;\nlet clientRectStyleMap: Map<Element, MoveableClientRect> | null = null;\n\nlet matrixContainerInfos: Array<\n  [\n    [SVGElement | HTMLElement, SVGElement | HTMLElement | null | undefined],\n    MatrixStackInfo\n  ]\n> | null = null;\n\nexport type GetStyle = (propertyName: string) => any;\nexport function setStoreCache(useCache?: boolean) {\n  if (useCache) {\n    if (window.Map) {\n      cacheStyleMap = new Map();\n      clientRectStyleMap = new Map();\n    }\n    matrixContainerInfos = [];\n  } else {\n    cacheStyleMap = null;\n    matrixContainerInfos = null;\n    clientRectStyleMap = null;\n  }\n}\n\nexport function getCachedClientRect(\n  el: HTMLElement | SVGElement\n): MoveableClientRect {\n  const clientRect = clientRectStyleMap?.get(el);\n\n  if (clientRect) {\n    return clientRect;\n  }\n  const nextClientRect = getClientRect(el, true);\n\n  if (clientRectStyleMap) {\n    clientRectStyleMap.set(el, nextClientRect);\n  }\n  return nextClientRect;\n}\n\nexport function getCachedMatrixContainerInfo(\n  target: SVGElement | HTMLElement,\n  container?: SVGElement | HTMLElement | null\n) {\n  if (matrixContainerInfos) {\n    const result = find(\n      matrixContainerInfos,\n      (info) => info[0][0] == target && info[0][1] == container\n    );\n\n    if (result) {\n      return result[1];\n    }\n  }\n  const result = getMatrixStackInfo(target, container, true);\n\n  if (matrixContainerInfos) {\n    matrixContainerInfos.push([[target, container], result]);\n  }\n  return result;\n}\nexport function getCachedStyle(element: Element): GetStyle {\n  let cache = cacheStyleMap?.get(element);\n\n  if (!cache) {\n    const nextStyle = getWindow(element).getComputedStyle(element);\n\n    if (!cacheStyleMap) {\n      return (property: string) => {\n        return (nextStyle as any)[property];\n      };\n    }\n    cache = {\n      style: nextStyle,\n      cached: {},\n    };\n    cacheStyleMap.set(element, cache);\n  }\n  const cached = cache.cached;\n  const style = cache.style;\n\n  return (property: string) => {\n    if (!(property in cached)) {\n      cached[property] = (style as any)[property];\n    }\n    return cached[property];\n  };\n}\n","import {\n  Able,\n  MoveableGroupInterface,\n  MoveableManagerInterface,\n  MoveableManagerState,\n} from \"./types\";\nimport CustomGesto, { setCustomDrag } from \"./gesto/custom-gesto\";\nimport { getAbsolutePosesByState } from \"./utils\";\nimport { calculate, createRotateMatrix } from \"../matrix\";\nimport { getPosByDirection } from \"./gesto/gesto-utils\";\n\nexport function fillChildEvents(\n  moveable: MoveableGroupInterface<any, any>,\n  name: string,\n  e: any\n): any[] {\n  const datas = e.originalDatas;\n\n  datas.groupable = datas.groupable || {};\n\n  const groupableDatas = datas.groupable;\n\n  groupableDatas.childDatas = groupableDatas.childDatas || [];\n\n  const childDatas = groupableDatas.childDatas;\n\n  return moveable.moveables.map((_, i) => {\n    childDatas[i] = childDatas[i] || {};\n    childDatas[i][name] = childDatas[i][name] || {};\n\n    return {\n      ...e,\n      isRequestChild: true,\n      datas: childDatas[i][name],\n      originalDatas: childDatas[i],\n    };\n  });\n}\nexport function triggerChildGesto(\n  moveable: MoveableGroupInterface<any, any>,\n  able: Able,\n  type: string,\n  delta: number[],\n  e: any,\n  isConvert: boolean,\n  ableName: string\n) {\n  const isStart = !!type.match(/Start$/g);\n  const isEnd = !!type.match(/End$/g);\n  const isPinch = e.isPinch;\n  const datas = e.datas;\n  const events = fillChildEvents(moveable, able.name, e);\n  const moveables = moveable.moveables;\n\n  const childEvents: any[] = [];\n  const eventParams = events.map((ev, i) => {\n    const childMoveable = moveables[i];\n    const state = childMoveable.state as MoveableManagerState<any>;\n    const gestos = state.gestos;\n    let childEvent: any = ev;\n\n    if (isStart) {\n      childEvent = new CustomGesto(ableName).dragStart(delta, ev);\n      childEvents.push(childEvent);\n    } else {\n      if (!gestos[ableName]) {\n        gestos[ableName] = datas.childGestos[i];\n      }\n      if (!gestos[ableName]) {\n        return;\n      }\n      childEvent = setCustomDrag(\n        ev,\n        state,\n        delta,\n        isPinch,\n        isConvert,\n        ableName\n      );\n      childEvents.push(childEvent);\n    }\n    const result = (able as any)[type]!(childMoveable, {\n      ...childEvent,\n      parentFlag: true,\n    });\n\n    if (isEnd) {\n      gestos[ableName] = null;\n    }\n    return result;\n  });\n  if (isStart) {\n    datas.childGestos = moveables.map((child) => child.state.gestos[ableName]);\n  }\n  return {\n    eventParams,\n    childEvents,\n  };\n}\nexport function triggerChildAbles<T extends Able>(\n  moveable: MoveableGroupInterface<any, any>,\n  able: T,\n  type: keyof T & string,\n  e: any,\n  eachEvent: (movebale: MoveableManagerInterface<any, any>, ev: any) => any = (\n    _,\n    ev\n  ) => ev,\n  callback?: (\n    moveable: MoveableManagerInterface<any, any>,\n    ev: any,\n    result: any,\n    index: number\n  ) => any\n) {\n  const isEnd = !!type.match(/End$/g);\n  const events = fillChildEvents(moveable, able.name, e);\n  const moveables = moveable.moveables;\n  const childs = events.map((ev, i) => {\n    const childMoveable = moveables[i];\n    let childEvent = ev;\n\n    childEvent = eachEvent(childMoveable, ev);\n\n    const result = (able as any)[type]!(childMoveable, {\n      ...childEvent,\n      parentFlag: true,\n    });\n\n    result && callback && callback(childMoveable, ev, result, i);\n\n    if (isEnd) {\n      childMoveable.state.gestos = {};\n    }\n    return result;\n  });\n\n  return childs;\n}\n\nexport function startChildDist(\n  moveable: MoveableGroupInterface,\n  child: MoveableManagerInterface,\n  parentDatas: any,\n  childEvent: any\n) {\n  const fixedDirection = parentDatas.fixedDirection;\n  const fixedPosition = parentDatas.fixedPosition;\n\n  const startPositions =\n    childEvent.datas.startPositions || getAbsolutePosesByState(child.state);\n  const pos = getPosByDirection(startPositions, fixedDirection);\n  const [originalX, originalY] = calculate(\n    createRotateMatrix((-moveable.rotation / 180) * Math.PI, 3),\n    [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1],\n    3\n  );\n  childEvent.datas.originalX = originalX;\n  childEvent.datas.originalY = originalY;\n\n  return childEvent;\n}\n","import {\n  prefix,\n  getControlTransform,\n  getLineStyle,\n  getProps,\n  sign,\n} from \"./utils\";\nimport { Renderer, MoveableManagerInterface, RenderDirections } from \"./types\";\nimport {\n  DIRECTION_INDEXES,\n  DIRECTION_ROTATIONS,\n  DIRECTIONS,\n  DIRECTIONS4,\n} from \"./consts\";\nimport { IObject, throttle, getRad, getKeys } from \"../utility\";\nimport { absDegree } from \"./ables/snappable\";\n\nexport interface DirectionControlInfo {\n  data: Record<string, any>;\n  classNames: string[];\n  dir: string;\n}\n\nexport function renderDirectionControlsByInfos(\n  moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n  ableName: string,\n  renderDirections: DirectionControlInfo[],\n  React: Renderer\n): any[] {\n  const { renderPoses, rotation: rotationRad, direction } = moveable.getState();\n\n  const { zoom } = getProps(moveable.props, ableName as any);\n\n  const degRotation = absDegree((rotationRad / Math.PI) * 180);\n  const directionMap: IObject<boolean> = {};\n  const renderState = moveable.renderState;\n  if (!renderState.renderDirectionMap) {\n    renderState.renderDirectionMap = {};\n  }\n  const renderDirectionMap = renderState.renderDirectionMap;\n\n  renderDirections.forEach(({ dir }) => {\n    directionMap[dir] = true;\n  });\n\n  const directionSign = sign(direction);\n  return renderDirections.map(({ data, classNames, dir }) => {\n    const indexes = DIRECTION_INDEXES[dir];\n\n    if (!indexes || !directionMap[dir]) {\n      return null;\n    }\n    renderDirectionMap[dir] = true;\n    const directionRotation =\n      (throttle(degRotation, 15) +\n        directionSign * DIRECTION_ROTATIONS[dir] +\n        720) %\n      180;\n\n    const dataAttrs: Record<string, string> = {};\n\n    getKeys(data).forEach((name) => {\n      dataAttrs[`data-${name}`] = data[name];\n    });\n    return (\n      <div\n        className={prefix(\"control\", \"direction\", dir, ableName, ...classNames)}\n        data-rotation={directionRotation}\n        data-direction={dir}\n        {...dataAttrs}\n        key={`direction-${dir}`}\n        style={getControlTransform(\n          rotationRad,\n          zoom!,\n          ...indexes.map((index) => renderPoses[index])\n        )}\n      ></div>\n    );\n  });\n}\nexport function renderDirectionControls(\n  moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n  defaultDirections: string[],\n  ableName: string,\n  React: Renderer\n): any[] {\n  const {\n    renderDirections: directions = defaultDirections,\n    displayAroundControls,\n  } = getProps(moveable.props, ableName as any);\n\n  if (!directions) {\n    return [];\n  }\n  const renderDirections = directions === true ? DIRECTIONS : directions;\n\n  return [\n    ...(displayAroundControls\n      ? renderAroundControls(moveable, React, ableName, renderDirections)\n      : []),\n    ...renderDirectionControlsByInfos(\n      moveable,\n      ableName,\n      renderDirections.map((dir) => {\n        return {\n          data: {},\n          classNames: [],\n          dir,\n        };\n      }),\n      React\n    ),\n  ];\n}\n\nexport function renderLine(\n  React: Renderer,\n  direction: string,\n  pos1: number[],\n  pos2: number[],\n  zoom: number,\n  key: number | string,\n  ...classNames: string[]\n): any {\n  const rad = getRad(pos1, pos2);\n  const rotation = direction ? throttle((rad / Math.PI) * 180, 15) % 180 : -1;\n\n  return (\n    <div\n      key={`line-${key}`}\n      className={prefix(\n        \"line\",\n        \"direction\",\n        direction ? \"edge\" : \"\",\n        direction,\n        ...classNames\n      )}\n      data-rotation={rotation}\n      data-line-key={key}\n      data-direction={direction}\n      style={getLineStyle(pos1, pos2, zoom, rad)}\n    ></div>\n  );\n}\n\nexport function renderEdgeLines(\n  React: Renderer,\n  ableName: string,\n  edge: true | string[],\n  poses: number[][],\n  zoom: number\n): any[] {\n  const directions = edge === true ? DIRECTIONS4 : edge;\n\n  return directions\n    .map((direction, i) => {\n      const [index1, index2] = DIRECTION_INDEXES[direction];\n\n      if (index2 == null) {\n        return;\n      }\n      return renderLine(\n        React,\n        direction,\n        poses[index1],\n        poses[index2],\n        zoom,\n        `${ableName}Edge${i}`,\n        ableName\n      );\n    })\n    .filter(Boolean);\n}\n\nexport function getRenderDirections(ableName: string) {\n  return (\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    React: Renderer\n  ) => {\n    const edge = getProps(moveable.props, ableName as any).edge;\n\n    if (edge && (edge === true || edge.length)) {\n      return [\n        ...renderEdgeLines(\n          React,\n          ableName,\n          edge,\n          moveable.getState().renderPoses,\n          moveable.props.zoom!\n        ),\n        ...renderDiagonalDirections(moveable, ableName, React),\n      ];\n    }\n    return renderAllDirections(moveable, ableName, React);\n  };\n}\n\nexport function renderAllDirections(\n  moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n  ableName: string,\n  React: Renderer\n) {\n  return renderDirectionControls(moveable, DIRECTIONS, ableName, React);\n}\n\nexport function renderDiagonalDirections(\n  moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n  ableName: string,\n  React: Renderer\n): any[] {\n  return renderDirectionControls(\n    moveable,\n    [\"nw\", \"ne\", \"sw\", \"se\"],\n    ableName,\n    React\n  );\n}\n\nexport function renderAroundControls(\n  moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n  React: Renderer,\n  ableName?: string,\n  renderDirections?: string[]\n): any[] {\n  const renderState = moveable.renderState;\n  if (!renderState.renderDirectionMap) {\n    renderState.renderDirectionMap = {};\n  }\n  const { renderPoses, rotation: rotationRad, direction } = moveable.getState();\n\n  const renderDirectionMap = renderState.renderDirectionMap;\n\n  const { zoom } = moveable.props;\n  const directionSign = sign(direction);\n  const degRotation = (rotationRad / Math.PI) * 180;\n\n  return (renderDirections || getKeys(renderDirectionMap)).map((dir) => {\n    const indexes = DIRECTION_INDEXES[dir];\n\n    if (!indexes) {\n      return null;\n    }\n    const directionRotation =\n      (throttle(degRotation, 15) +\n        directionSign * DIRECTION_ROTATIONS[dir] +\n        720) %\n      180;\n\n    const classNames: string[] = [\"around-control\"];\n\n    if (ableName) {\n      classNames.push(\"direction\", ableName);\n    }\n    return (\n      <div\n        className={prefix(...classNames)}\n        data-rotation={directionRotation}\n        data-direction={dir}\n        key={`direction-around-${dir}`}\n        style={getControlTransform(\n          rotationRad,\n          zoom!,\n          ...indexes.map((index) => renderPoses[index])\n        )}\n      ></div>\n    );\n  });\n}\n","import { getRad, throttle } from \"../../../utility\";\nimport {\n  BoundInfo,\n  SnappableProps,\n  BoundType,\n  RotatableProps,\n  MoveableManagerInterface,\n  SnappableState,\n} from \"../../types\";\nimport { rotate, minus } from \"../../../matrix\";\nimport { abs, getDistSize } from \"../../utils\";\nimport { TINY_NUM } from \"../../consts\";\n\nexport function checkBoundPoses(\n  bounds: BoundType | false | undefined,\n  verticalPoses: number[],\n  horizontalPoses: number[]\n) {\n  const {\n    position = \"client\",\n    left = -Infinity,\n    top = -Infinity,\n    right = Infinity,\n    bottom = Infinity,\n  } = bounds || {};\n  const nextBounds = {\n    position,\n    left,\n    top,\n    right,\n    bottom,\n  };\n\n  return {\n    vertical: checkBounds(nextBounds, verticalPoses, true),\n    horizontal: checkBounds(nextBounds, horizontalPoses, false),\n  };\n}\nexport function getBounds(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n  externalBounds?: BoundType | false | null\n) {\n  const {\n    containerClientRect: {\n      clientHeight: containerHeight,\n      clientWidth: containerWidth,\n      clientLeft,\n      clientTop,\n    },\n    snapOffset: {\n      left: snapOffsetLeft,\n      top: snapOffsetTop,\n      right: snapOffsetRight,\n      bottom: snapOffsetBottom,\n    },\n  } = moveable.state;\n  const bounds = externalBounds || moveable.props.bounds || ({} as BoundType);\n  const position = bounds.position || \"client\";\n  const isCSS = position === \"css\";\n  const { left = -Infinity, top = -Infinity } = bounds;\n  let {\n    right = isCSS ? -Infinity : Infinity,\n    bottom = isCSS ? -Infinity : Infinity,\n  } = bounds;\n\n  if (isCSS) {\n    right = containerWidth! + snapOffsetRight - snapOffsetLeft - right;\n    bottom = containerHeight! + snapOffsetBottom - snapOffsetTop - bottom;\n  }\n\n  return {\n    left: left + snapOffsetLeft - clientLeft!,\n    right: right + snapOffsetLeft - clientLeft!,\n    top: top + snapOffsetTop - clientTop!,\n    bottom: bottom + snapOffsetTop - clientTop!,\n  };\n}\nexport function checkBoundKeepRatio(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n  startPos: number[],\n  endPos: number[]\n) {\n  const { left, top, right, bottom } = getBounds(moveable);\n\n  const [endX, endY] = endPos;\n  let [dx, dy] = minus(endPos, startPos);\n\n  if (abs(dx) < TINY_NUM) {\n    dx = 0;\n  }\n  if (abs(dy) < TINY_NUM) {\n    dy = 0;\n  }\n  const isBottom = dy > 0;\n  const isRight = dx > 0;\n\n  const verticalInfo = {\n    isBound: false,\n    offset: 0,\n    pos: 0,\n  };\n  const horizontalInfo = {\n    isBound: false,\n    offset: 0,\n    pos: 0,\n  };\n  if (dx === 0 && dy === 0) {\n    return {\n      vertical: verticalInfo,\n      horizontal: horizontalInfo,\n    };\n  } else if (dx === 0) {\n    if (isBottom) {\n      if (bottom < endY) {\n        horizontalInfo.pos = bottom;\n        horizontalInfo.offset = endY - bottom;\n      }\n    } else {\n      if (top > endY) {\n        horizontalInfo.pos = top;\n        horizontalInfo.offset = endY - top;\n      }\n    }\n  } else if (dy === 0) {\n    if (isRight) {\n      if (right < endX) {\n        verticalInfo.pos = right;\n        verticalInfo.offset = endX - right;\n      }\n    } else {\n      if (left > endX) {\n        verticalInfo.pos = left;\n        verticalInfo.offset = endX - left;\n      }\n    }\n  } else {\n    // y - y1 = a * (x - x1)\n    const a = dy / dx;\n    const b = endPos[1] - a * endX;\n    let y = 0;\n    let x = 0;\n    let isBound = false;\n\n    if (isRight && right <= endX) {\n      y = a * right + b;\n      x = right;\n      isBound = true;\n    } else if (!isRight && endX <= left) {\n      y = a * left + b;\n      x = left;\n      isBound = true;\n    }\n    if (isBound) {\n      if (y < top || y > bottom) {\n        isBound = false;\n      }\n    }\n    if (!isBound) {\n      if (isBottom && bottom <= endY) {\n        y = bottom;\n        x = (y - b) / a;\n        isBound = true;\n      } else if (!isBottom && endY <= top) {\n        y = top;\n        x = (y - b) / a;\n        isBound = true;\n      }\n    }\n    if (isBound) {\n      verticalInfo.isBound = true;\n      verticalInfo.pos = x;\n      verticalInfo.offset = endX - x;\n\n      horizontalInfo.isBound = true;\n      horizontalInfo.pos = y;\n      horizontalInfo.offset = endY - y;\n    }\n  }\n\n  return {\n    vertical: verticalInfo,\n    horizontal: horizontalInfo,\n  };\n}\nfunction checkBounds(\n  bounds: Required<BoundType>,\n  poses: number[],\n  isVertical: boolean\n): BoundInfo[] {\n  // 0   [100 - 200]  300\n  const startBoundPos = bounds[isVertical ? \"left\" : \"top\"];\n  const endBoundPos = bounds[isVertical ? \"right\" : \"bottom\"];\n\n  // 450\n  const minPos = Math.min(...poses);\n  const maxPos = Math.max(...poses);\n  const boundInfos: BoundInfo[] = [];\n\n  if (startBoundPos + 1 > minPos) {\n    boundInfos.push({\n      direction: \"start\",\n      isBound: true,\n      offset: minPos - startBoundPos,\n      pos: startBoundPos,\n    });\n  }\n  if (endBoundPos - 1 < maxPos) {\n    boundInfos.push({\n      direction: \"end\",\n      isBound: true,\n      offset: maxPos - endBoundPos,\n      pos: endBoundPos,\n    });\n  }\n\n  if (!boundInfos.length) {\n    boundInfos.push({\n      isBound: false,\n      offset: 0,\n      pos: 0,\n    });\n  }\n\n  return boundInfos.sort((a, b) => abs(b.offset) - abs(a.offset));\n}\nexport function isBoundRotate(\n  relativePoses: number[][],\n  boundRect: { left: number; top: number; right: number; bottom: number },\n  rad: number\n) {\n  const nextPoses = rad\n    ? relativePoses.map((pos) => rotate(pos, rad))\n    : relativePoses;\n\n  return nextPoses.some((pos) => {\n    return (\n      (pos[0] < boundRect.left && abs(pos[0] - boundRect.left) > 0.1) ||\n      (pos[0] > boundRect.right && abs(pos[0] - boundRect.right) > 0.1) ||\n      (pos[1] < boundRect.top && abs(pos[1] - boundRect.top) > 0.1) ||\n      (pos[1] > boundRect.bottom && abs(pos[1] - boundRect.bottom) > 0.1)\n    );\n  });\n}\nexport function boundRotate(vec: number[], boundPos: number, index: number) {\n  const r = getDistSize(vec);\n  const nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;\n\n  return [nextPos, -nextPos]\n    .sort((a, b) => {\n      return abs(a - vec[index ? 0 : 1]) - abs(b - vec[index ? 0 : 1]);\n    })\n    .map((pos) => {\n      return getRad([0, 0], index ? [pos, boundPos] : [boundPos, pos]);\n    });\n}\n\nexport function checkRotateBounds(\n  moveable: MoveableManagerInterface<\n    SnappableProps & RotatableProps,\n    SnappableState\n  >,\n  prevPoses: number[][],\n  nextPoses: number[][],\n  origin: number[],\n  rotation: number\n) {\n  if (!moveable.props.bounds) {\n    return [];\n  }\n  const rad = (rotation * Math.PI) / 180;\n\n  const { left, top, right, bottom } = getBounds(moveable);\n\n  const relativeLeft = left - origin[0];\n  const relativeRight = right - origin[0];\n  const relativeTop = top - origin[1];\n  const relativeBottom = bottom - origin[1];\n  const boundRect = {\n    left: relativeLeft,\n    top: relativeTop,\n    right: relativeRight,\n    bottom: relativeBottom,\n  };\n\n  if (!isBoundRotate(nextPoses, boundRect, 0)) {\n    return [];\n  }\n  const result: number[] = [];\n  [\n    [relativeLeft, 0],\n    [relativeRight, 0],\n    [relativeTop, 1],\n    [relativeBottom, 1],\n  ].forEach(([boundPos, index]) => {\n    nextPoses.forEach((nextPos) => {\n      const relativeRad1 = getRad([0, 0], nextPos);\n\n      result.push(\n        ...boundRotate(nextPos, boundPos, index)\n          .map((relativeRad2) => rad + relativeRad2 - relativeRad1)\n          .filter((nextRad) => !isBoundRotate(prevPoses, boundRect, nextRad))\n          .map((nextRad) => throttle((nextRad * 180) / Math.PI, TINY_NUM))\n      );\n    });\n  });\n\n  return result;\n}\n","import { throttle, TINY_NUM } from \"../../../utility\";\nimport {\n  MoveableClientRect,\n  MoveableManagerInterface,\n  SnapDirectionPoses,\n  SnapDirections,\n  SnappableProps,\n  SnappableState,\n} from \"../../types\";\nimport { calculatePosition } from \"../../utils\";\nexport const VERTICAL_NAMES = [\"left\", \"right\", \"center\"] as const;\nexport const HORIZONTAL_NAMES = [\"top\", \"bottom\", \"middle\"] as const;\nexport const SNAP_SKIP_NAMES_MAP = {\n  left: \"start\",\n  right: \"end\",\n  center: \"center\",\n  top: \"start\",\n  bottom: \"end\",\n  middle: \"center\",\n};\n\nexport const VERTICAL_NAMES_MAP = {\n  start: \"left\",\n  end: \"right\",\n  center: \"center\",\n} as const;\nexport const HORIZONTAL_NAMES_MAP = {\n  start: \"top\",\n  end: \"bottom\",\n  center: \"middle\",\n} as const;\n\nexport function getInitialBounds() {\n  return {\n    left: false,\n    top: false,\n    right: false,\n    bottom: false,\n  };\n}\n\nexport function hasGuidelines(\n  moveable: MoveableManagerInterface<any, any>,\n  ableName: string\n): moveable is MoveableManagerInterface<SnappableProps, SnappableState> {\n  const {\n    props: {\n      snappable,\n      bounds,\n      innerBounds,\n      verticalGuidelines,\n      horizontalGuidelines,\n      snapGridWidth,\n      snapGridHeight,\n    },\n    state: { guidelines, enableSnap },\n  } = moveable;\n\n  if (\n    !snappable ||\n    !enableSnap ||\n    (ableName && snappable !== true && snappable.indexOf(ableName) < 0)\n  ) {\n    return false;\n  }\n  if (\n    snapGridWidth ||\n    snapGridHeight ||\n    bounds ||\n    innerBounds ||\n    (guidelines && guidelines.length) ||\n    (verticalGuidelines && verticalGuidelines.length) ||\n    (horizontalGuidelines && horizontalGuidelines.length)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function getSnapDirections(\n  snapDirections: SnapDirections | boolean | undefined\n): SnapDirections {\n  if (snapDirections === false) {\n    return {};\n  } else if (snapDirections === true || !snapDirections) {\n    return { left: true, right: true, top: true, bottom: true };\n  }\n  return snapDirections;\n}\n\nexport function mapSnapDirectionPoses(\n  snapDirections: SnapDirections | boolean | undefined,\n  snapPoses: SnapDirectionPoses\n) {\n  const nextSnapDirections = getSnapDirections(snapDirections);\n  const nextSnapPoses: SnapDirectionPoses = {};\n\n  for (const name in nextSnapDirections) {\n    if (name in snapPoses && (nextSnapDirections as any)[name]) {\n      (nextSnapPoses as any)[name] = (snapPoses as any)[name];\n    }\n  }\n  return nextSnapPoses;\n}\n\nexport function splitSnapDirectionPoses(\n  snapDirections: SnapDirections | boolean | undefined,\n  snapPoses: SnapDirectionPoses\n) {\n  const nextSnapPoses = mapSnapDirectionPoses(snapDirections, snapPoses);\n  const horizontalNames = HORIZONTAL_NAMES.filter(\n    (name) => name in nextSnapPoses\n  );\n  const verticalNames = VERTICAL_NAMES.filter((name) => name in nextSnapPoses);\n\n  return {\n    horizontalNames,\n    verticalNames,\n    horizontal: horizontalNames.map((name) => nextSnapPoses[name]!),\n    vertical: verticalNames.map((name) => nextSnapPoses[name]!),\n  };\n}\n\nexport function calculateContainerPos(\n  rootMatrix: number[],\n  containerRect: MoveableClientRect,\n  n: number\n) {\n  const clientPos = calculatePosition(\n    rootMatrix,\n    [containerRect.clientLeft!, containerRect.clientTop!],\n    n\n  );\n\n  return [containerRect.left + clientPos[0], containerRect.top + clientPos[1]];\n}\n\nexport function solveLineConstants([point1, point2]: number[][]): [\n  number,\n  number,\n  number\n] {\n  let dx = point2[0] - point1[0];\n  let dy = point2[1] - point1[1];\n\n  if (Math.abs(dx) < TINY_NUM) {\n    dx = 0;\n  }\n  if (Math.abs(dy) < TINY_NUM) {\n    dy = 0;\n  }\n\n  // b > 0\n  // ax + by + c = 0\n  let a = 0;\n  let b = 0;\n  let c = 0;\n\n  if (!dx) {\n    // -x + 1 = 0\n    a = -1;\n    c = point1[0];\n  } else if (!dy) {\n    // y - 1 = 0\n    b = 1;\n    c = -point1[1];\n  } else {\n    // y = -a(x - x1) + y1\n    // ax + y + a * x1 - y1 = 0\n    a = -dy / dx;\n    b = 1;\n    c = a * point1[0] - point1[1];\n  }\n\n  return [a, b, c].map((v) => throttle(v, TINY_NUM)) as [\n    number,\n    number,\n    number\n  ];\n}\n","export const NAME_snapRotationThreshold = \"snapRotationThreshold\";\nexport const NAME_snapRotationDegrees = \"snapRotationDegrees\";\nexport const NAME_snapHorizontalThreshold = \"snapHorizontalThreshold\";\nexport const NAME_snapVerticalThreshold = \"snapVerticalThreshold\";\n","import {\n  SnapInfo,\n  SnappableProps,\n  SnappableState,\n  SnapGuideline,\n  ResizableProps,\n  ScalableProps,\n  SnapOffsetInfo,\n  MoveableManagerInterface,\n  SnapDirectionPoses,\n  SnapDirectionInfo,\n} from \"../../types\";\nimport { selectValue, getTinyDist, abs } from \"../../utils\";\nimport {\n  getPosByDirection,\n  getPosesByDirection,\n} from \"../../gesto/gesto-utils\";\nimport { TINY_NUM } from \"../../consts\";\nimport { minus } from \"../../../matrix\";\nimport { splitSnapDirectionPoses } from \"./utils\";\nimport {\n  NAME_snapHorizontalThreshold,\n  NAME_snapVerticalThreshold,\n} from \"./names\";\n\nexport function checkMoveableSnapPoses(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n  posesX: number[],\n  posesY: number[],\n  dirXs: string[] = [],\n  dirYs: string[] = [],\n  customSnapVerticalThreshold: number | undefined,\n  customSnapHorizontalThreshold: number | undefined\n) {\n  const props = moveable.props;\n  const snapThresholdMultiples = moveable.state.snapThresholdInfo\n    ?.multiples || [1, 1];\n  const snapHorizontalThreshold = selectValue<number>(\n    customSnapHorizontalThreshold,\n    props[NAME_snapHorizontalThreshold],\n    5\n  );\n  const snapVerticalThreshold = selectValue<number>(\n    customSnapVerticalThreshold,\n    props[NAME_snapVerticalThreshold],\n    5\n  );\n\n  return checkSnapPoses(\n    moveable.state.guidelines,\n    posesX,\n    posesY,\n    dirXs,\n    dirYs,\n    snapHorizontalThreshold,\n    snapVerticalThreshold,\n    snapThresholdMultiples\n  );\n}\n\nexport function checkSnapPoses(\n  guidelines: SnapGuideline[],\n  posesX: number[],\n  posesY: number[],\n  dirXs: string[],\n  dirYs: string[],\n  snapHorizontalThreshold: number,\n  snapVerticalThreshold: number,\n  multiples: number[]\n) {\n  return {\n    vertical: checkSnap(\n      guidelines,\n      \"vertical\",\n      posesX,\n      snapVerticalThreshold * multiples[0],\n      dirXs\n    ),\n    horizontal: checkSnap(\n      guidelines,\n      \"horizontal\",\n      posesY,\n      snapHorizontalThreshold * multiples[1],\n      dirYs\n    ),\n  };\n}\nexport function checkSnapKeepRatio(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n  startPos: number[],\n  endPos: number[]\n): { vertical: SnapOffsetInfo; horizontal: SnapOffsetInfo } {\n  const [endX, endY] = endPos;\n  const [startX, startY] = startPos;\n  let [dx, dy] = minus(endPos, startPos);\n  const isBottom = dy > 0;\n  const isRight = dx > 0;\n\n  dx = getTinyDist(dx);\n  dy = getTinyDist(dy);\n\n  const verticalInfo: SnapOffsetInfo = {\n    isSnap: false,\n    offset: 0,\n    pos: 0,\n  };\n  const horizontalInfo: SnapOffsetInfo = {\n    isSnap: false,\n    offset: 0,\n    pos: 0,\n  };\n\n  if (dx === 0 && dy === 0) {\n    return {\n      vertical: verticalInfo,\n      horizontal: horizontalInfo,\n    };\n  }\n  const { vertical: verticalSnapInfo, horizontal: horizontalSnapInfo } =\n    checkMoveableSnapPoses(\n      moveable,\n      dx ? [endX] : [],\n      dy ? [endY] : [],\n      [],\n      [],\n      undefined,\n      undefined\n    );\n\n  verticalSnapInfo.posInfos.filter(({ pos }) => {\n    return isRight ? pos >= startX : pos <= startX;\n  });\n  horizontalSnapInfo.posInfos.filter(({ pos }) => {\n    return isBottom ? pos >= startY : pos <= startY;\n  });\n  verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;\n  horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;\n\n  const { isSnap: isVerticalSnap, guideline: verticalGuideline } =\n    getNearestSnapGuidelineInfo(verticalSnapInfo);\n  const { isSnap: isHorizontalSnap, guideline: horizontalGuideline } =\n    getNearestSnapGuidelineInfo(horizontalSnapInfo);\n  const horizontalPos = isHorizontalSnap ? horizontalGuideline!.pos[1] : 0;\n  const verticalPos = isVerticalSnap ? verticalGuideline!.pos[0] : 0;\n\n  if (dx === 0) {\n    if (isHorizontalSnap) {\n      horizontalInfo.isSnap = true;\n      horizontalInfo.pos = horizontalGuideline!.pos[1];\n      horizontalInfo.offset = endY - horizontalInfo.pos;\n    }\n  } else if (dy === 0) {\n    if (isVerticalSnap) {\n      verticalInfo.isSnap = true;\n      verticalInfo.pos = verticalPos;\n      verticalInfo.offset = endX - verticalPos;\n    }\n  } else {\n    // y - y1 = a * (x - x1)\n    const a = dy / dx;\n    const b = endPos[1] - a * endX;\n    let y = 0;\n    let x = 0;\n    let isSnap = false;\n\n    if (isVerticalSnap) {\n      x = verticalPos;\n      y = a * x + b;\n      isSnap = true;\n    } else if (isHorizontalSnap) {\n      y = horizontalPos;\n      x = (y - b) / a;\n      isSnap = true;\n    }\n    if (isSnap) {\n      verticalInfo.isSnap = true;\n      verticalInfo.pos = x;\n      verticalInfo.offset = endX - x;\n\n      horizontalInfo.isSnap = true;\n      horizontalInfo.pos = y;\n      horizontalInfo.offset = endY - y;\n    }\n  }\n  return {\n    vertical: verticalInfo,\n    horizontal: horizontalInfo,\n  };\n}\n\nfunction getStringDirection(dir: number | string) {\n  let stringDirection = \"\";\n\n  if (dir === -1 || dir === \"top\" || dir === \"left\") {\n    stringDirection = \"start\";\n  } else if (dir === 0 || dir === \"center\" || dir === \"middle\") {\n    stringDirection = \"center\";\n  } else if (dir === 1 || dir === \"right\" || dir === \"bottom\") {\n    stringDirection = \"end\";\n  }\n  return stringDirection;\n}\n\nexport function checkSnaps(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n  rect: SnapDirectionPoses,\n  customSnapVerticalThreshold: number | undefined,\n  customSnapHorizontalThreshold: number | undefined\n): { vertical: SnapDirectionInfo; horizontal: SnapDirectionInfo } {\n  const poses = splitSnapDirectionPoses(moveable.props.snapDirections, rect);\n\n  const result = checkMoveableSnapPoses(\n    moveable,\n    poses.vertical,\n    poses.horizontal,\n    poses.verticalNames.map((name) => getStringDirection(name)),\n    poses.horizontalNames.map((name) => getStringDirection(name)),\n    customSnapVerticalThreshold,\n    customSnapHorizontalThreshold\n  );\n  const horizontalDirection = getStringDirection(\n    poses.horizontalNames[result.horizontal.index]\n  );\n  const verticalDirection = getStringDirection(\n    poses.verticalNames[result.vertical.index]\n  );\n\n  return {\n    vertical: {\n      ...result.vertical,\n      direction: verticalDirection,\n    },\n    horizontal: {\n      ...result.horizontal,\n      direction: horizontalDirection,\n    },\n  };\n}\n\nexport function getNearestSnapGuidelineInfo(snapInfo: SnapInfo) {\n  const isSnap = snapInfo.isSnap;\n\n  if (!isSnap) {\n    return {\n      isSnap: false,\n      offset: 0,\n      dist: -1,\n      pos: 0,\n      guideline: null,\n    };\n  }\n  const posInfo = snapInfo.posInfos[0];\n  const guidelineInfo = posInfo!.guidelineInfos[0];\n  const offset = guidelineInfo!.offset;\n  const dist = guidelineInfo!.dist;\n  const guideline = guidelineInfo!.guideline;\n\n  return {\n    isSnap,\n    offset,\n    dist,\n    pos: posInfo!.pos,\n    guideline,\n  };\n}\n\nfunction checkSnap(\n  guidelines: SnapGuideline[],\n  targetType: \"horizontal\" | \"vertical\",\n  targetPoses: number[],\n  snapThreshold: number,\n  dirs: string[] = []\n): SnapInfo {\n  if (!guidelines || !guidelines.length) {\n    return {\n      isSnap: false,\n      index: -1,\n      direction: \"\",\n      posInfos: [],\n    };\n  }\n  const isVertical = targetType === \"vertical\";\n  const posType = isVertical ? 0 : 1;\n\n  const snapPosInfos = targetPoses\n    .map((targetPos, index) => {\n      const direction = dirs[index] || \"\";\n\n      const guidelineInfos = guidelines\n        .map((guideline) => {\n          const { pos } = guideline;\n          const offset = targetPos - pos[posType];\n\n          return {\n            offset,\n            dist: abs(offset),\n            guideline,\n            direction,\n          };\n        })\n        .filter(({ guideline, dist }) => {\n          const { type } = guideline;\n          if (type !== targetType || dist > snapThreshold) {\n            return false;\n          }\n          return true;\n        })\n        .sort((a, b) => a.dist - b.dist);\n\n      return {\n        pos: targetPos,\n        index,\n        guidelineInfos,\n        direction,\n      };\n    })\n    .filter((snapPosInfo) => {\n      return snapPosInfo.guidelineInfos.length > 0;\n    })\n    .sort((a, b) => {\n      return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;\n    });\n\n  const isSnap = snapPosInfos.length > 0;\n  return {\n    isSnap,\n    index: isSnap ? snapPosInfos[0].index : -1,\n    direction: snapPosInfos[0]?.direction ?? \"\",\n    posInfos: snapPosInfos,\n  };\n}\n\nexport function getSnapInfosByDirection(\n  moveable: MoveableManagerInterface<\n    SnappableProps & (ResizableProps | ScalableProps),\n    SnappableState\n  >,\n  // pos1 pos2 pos3 pos4\n  poses: number[][],\n  snapDirection: number[],\n  customSnapVerticalThreshold: number | undefined,\n  customSnapHorizontalThreshold: number | undefined\n): { vertical: SnapDirectionInfo; horizontal: SnapDirectionInfo } {\n  let dirs: number[][] = [];\n\n  if (snapDirection[0] && snapDirection[1]) {\n    dirs = [\n      snapDirection,\n      [-snapDirection[0], snapDirection[1]],\n      [snapDirection[0], -snapDirection[1]],\n    ];\n  } else if (!snapDirection[0] && !snapDirection[1]) {\n    [\n      [-1, -1],\n      [1, -1],\n      [1, 1],\n      [-1, 1],\n    ].forEach((dir, i, arr) => {\n      const nextDir = arr[i + 1] || arr[0];\n      dirs.push(dir);\n      dirs.push([(dir[0] + nextDir[0]) / 2, (dir[1] + nextDir[1]) / 2]);\n    });\n  } else {\n    if (moveable.props.keepRatio) {\n      dirs.push([-1, -1], [-1, 1], [1, -1], [1, 1], snapDirection);\n    } else {\n      dirs.push(\n        ...getPosesByDirection(\n          [\n            [-1, -1],\n            [1, -1],\n            [-1, -1],\n            [1, 1],\n          ],\n          snapDirection\n        )\n      );\n\n      if (dirs.length > 1) {\n        dirs.push([\n          (dirs[0][0] + dirs[1][0]) / 2,\n          (dirs[0][1] + dirs[1][1]) / 2,\n        ]);\n      }\n    }\n  }\n  const nextPoses = dirs.map((dir) => getPosByDirection(poses, dir));\n  const xs = nextPoses.map((pos) => pos[0]);\n  const ys = nextPoses.map((pos) => pos[1]);\n  const result = checkMoveableSnapPoses(\n    moveable,\n    xs,\n    ys,\n    dirs.map((dir) => getStringDirection(dir[0])),\n    dirs.map((dir) => getStringDirection(dir[1])),\n    customSnapVerticalThreshold,\n    customSnapHorizontalThreshold\n  );\n  const verticalDirection = getStringDirection(\n    dirs.map((dir) => dir[0])[result.vertical.index]\n  );\n  const horizontalDirection = getStringDirection(\n    dirs.map((dir) => dir[1])[result.horizontal.index]\n  );\n\n  return {\n    vertical: {\n      ...result.vertical,\n      direction: verticalDirection,\n    },\n    horizontal: {\n      ...result.horizontal,\n      direction: horizontalDirection,\n    },\n  };\n}\n\nexport function checkSnapBoundPriority(\n  a: { isBound: boolean; isSnap: boolean; offset: number },\n  b: { isBound: boolean; isSnap: boolean; offset: number }\n) {\n  const aDist = abs(a.offset);\n  const bDist = abs(b.offset);\n\n  if (a.isBound && b.isBound) {\n    return bDist - aDist;\n  } else if (a.isBound) {\n    return -1;\n  } else if (b.isBound) {\n    return 1;\n  } else if (a.isSnap && b.isSnap) {\n    return bDist - aDist;\n  } else if (a.isSnap) {\n    return -1;\n  } else if (b.isSnap) {\n    return 1;\n  } else if (aDist < TINY_NUM) {\n    return 1;\n  } else if (bDist < TINY_NUM) {\n    return -1;\n  }\n  return aDist - bDist;\n}\nexport function getNearOffsetInfo<\n  T extends {\n    offset: number[];\n    isBound: boolean;\n    isSnap: boolean;\n    sign: number[];\n  }\n>(offsets: T[], index: number) {\n  return offsets.slice().sort((a, b) => {\n    const aSign = a.sign[index];\n    const bSign = b.sign[index];\n    const aOffset = a.offset[index];\n    const bOffset = b.offset[index];\n    // -1 The positions of a and b do not change.\n    // 1 The positions of a and b are reversed.\n    if (!aSign) {\n      return 1;\n    } else if (!bSign) {\n      return -1;\n    }\n    return checkSnapBoundPriority(\n      { isBound: a.isBound, isSnap: a.isSnap, offset: aOffset },\n      { isBound: b.isBound, isSnap: b.isSnap, offset: bOffset }\n    );\n  })[0];\n}\n\nexport function getCheckSnapDirections(\n  direction: number[],\n  fixedDirection: number[],\n  keepRatio: boolean\n) {\n  const directions: number[][][] = [];\n  // const fixedDirection = [-direction[0], -direction[1]];\n\n  if (keepRatio) {\n    if (abs(fixedDirection[0]) !== 1 || abs(fixedDirection[1]) !== 1) {\n      directions.push(\n        [fixedDirection, [-1, -1]],\n        [fixedDirection, [-1, 1]],\n        [fixedDirection, [1, -1]],\n        [fixedDirection, [1, 1]]\n      );\n    } else {\n      directions.push(\n        [fixedDirection, [direction[0], -direction[1]]],\n        [fixedDirection, [-direction[0], direction[1]]]\n      );\n    }\n    directions.push([fixedDirection, direction]);\n  } else {\n    if ((direction[0] && direction[1]) || (!direction[0] && !direction[1])) {\n      const endDirection = direction[0] ? direction : [1, 1];\n\n      [1, -1].forEach((signX) => {\n        [1, -1].forEach((signY) => {\n          const nextDirection = [\n            signX * endDirection[0],\n            signY * endDirection[1],\n          ];\n\n          if (\n            fixedDirection[0] === nextDirection[0] &&\n            fixedDirection[1] === nextDirection[1]\n          ) {\n            return;\n          }\n          directions.push([fixedDirection, nextDirection]);\n        });\n      });\n    } else if (direction[0]) {\n      const signs = abs(fixedDirection[0]) === 1 ? [1] : [1, -1];\n\n      signs.forEach((sign) => {\n        directions.push(\n          [\n            [fixedDirection[0], -1],\n            [sign * direction[0], -1],\n          ],\n          [\n            [fixedDirection[0], 0],\n            [sign * direction[0], 0],\n          ],\n          [\n            [fixedDirection[0], 1],\n            [sign * direction[0], 1],\n          ]\n        );\n      });\n    } else if (direction[1]) {\n      const signs = abs(fixedDirection[1]) === 1 ? [1] : [1, -1];\n\n      signs.forEach((sign) => {\n        directions.push(\n          [\n            [-1, fixedDirection[1]],\n            [-1, sign * direction[1]],\n          ],\n          [\n            [0, fixedDirection[1]],\n            [0, sign * direction[1]],\n          ],\n          [\n            [1, fixedDirection[1]],\n            [1, sign * direction[1]],\n          ]\n        );\n      });\n    }\n  }\n  return directions;\n}\n","import { average, getRad, throttle } from \"../../../utility\";\nimport { rotate } from \"../../../matrix\";\nimport {\n  maxOffset,\n  getDistSize,\n  getTinyDist,\n  calculatePoses,\n  abs,\n} from \"../../utils\";\n\nimport {\n  SnappableProps,\n  DraggableProps,\n  RotatableProps,\n  MoveableManagerInterface,\n} from \"../../types\";\nimport {\n  getDragDist,\n  getPosByDirection,\n  getInverseDragDist,\n} from \"../../gesto/gesto-utils\";\nimport { getNearOffsetInfo } from \"./snap\";\nimport { TINY_NUM } from \"../../consts\";\nimport { getInitialBounds, solveLineConstants } from \"./utils\";\n\nfunction isStartLine(dot: number[], line: number[][]) {\n  // l    o     => true\n  // o    l    => false\n  const cx = average([line[0][0], line[1][0]]);\n  const cy = average([line[0][1], line[1][1]]);\n\n  return {\n    vertical: cx <= dot[0],\n    horizontal: cy <= dot[1],\n  };\n}\nfunction hitTestLine(dot: number[], [pos1, pos2]: number[][]) {\n  let dx = pos2[0] - pos1[0];\n  let dy = pos2[1] - pos1[1];\n\n  if (abs(dx) < TINY_NUM) {\n    dx = 0;\n  }\n  if (abs(dy) < TINY_NUM) {\n    dy = 0;\n  }\n  let test1: number;\n  let test2: number;\n  if (!dx) {\n    test1 = pos1[0];\n    test2 = dot[0];\n  } else if (!dy) {\n    test1 = pos1[1];\n    test2 = dot[1];\n  } else {\n    const a = dy / dx;\n\n    // y = a * (x - pos1) + pos1\n    test1 = a * (dot[0] - pos1[0]) + pos1[1];\n    test2 = dot[1];\n  }\n  return test1 - test2;\n}\nfunction isSameStartLine(\n  dots: number[][],\n  line: number[][],\n  centerSign: boolean,\n  error: number = TINY_NUM\n) {\n  return dots.every((dot) => {\n    const value = hitTestLine(dot, line);\n    const sign = value <= 0;\n    return sign === centerSign || abs(value) <= error;\n  });\n}\nfunction checkInnerBoundDot(\n  pos: number,\n  start: number,\n  end: number,\n  isStart: boolean,\n  threshold = 0\n) {\n  if (\n    (isStart && start - threshold <= pos) ||\n    (!isStart && pos <= end + threshold)\n  ) {\n    // false 402 565 602 => 37 ([0, 37])\n    // true 400 524.9712603540036 600 => 124 ([124, 0])\n    // true 400 410 600 => 10 ([10, 0])\n    return {\n      isBound: true,\n      offset: isStart ? start - pos : end - pos,\n    };\n  }\n  return {\n    isBound: false,\n    offset: 0,\n  };\n}\n\nfunction checkInnerBound(\n  moveable: MoveableManagerInterface<SnappableProps>,\n  {\n    line,\n    centerSign,\n    verticalSign,\n    horizontalSign,\n    lineConstants,\n  }: InnerBoundLineInfo\n) {\n  const bounds = moveable.props.innerBounds;\n\n  if (!bounds) {\n    return {\n      isAllBound: false,\n      isBound: false,\n      isVerticalBound: false,\n      isHorizontalBound: false,\n      offset: [0, 0],\n    };\n  }\n  const { left, top, width, height } = bounds;\n  const leftLine = [\n    [left, top],\n    [left, top + height],\n  ];\n  const topLine = [\n    [left, top],\n    [left + width, top],\n  ];\n  const rightLine = [\n    [left + width, top],\n    [left + width, top + height],\n  ];\n  const bottomLine = [\n    [left, top + height],\n    [left + width, top + height],\n  ];\n\n  if (\n    isSameStartLine(\n      [\n        [left, top],\n        [left + width, top],\n        [left, top + height],\n        [left + width, top + height],\n      ],\n      line,\n      centerSign\n    )\n  ) {\n    return {\n      isAllBound: false,\n      isBound: false,\n      isVerticalBound: false,\n      isHorizontalBound: false,\n      offset: [0, 0],\n    };\n  }\n  // test vertical\n\n  const topBoundInfo = checkLineBoundCollision(\n    line,\n    lineConstants,\n    topLine,\n    verticalSign\n  );\n  const bottomBoundInfo = checkLineBoundCollision(\n    line,\n    lineConstants,\n    bottomLine,\n    verticalSign\n  );\n\n  // test horizontal\n  const leftBoundInfo = checkLineBoundCollision(\n    line,\n    lineConstants,\n    leftLine,\n    horizontalSign\n  );\n  const rightBoundInfo = checkLineBoundCollision(\n    line,\n    lineConstants,\n    rightLine,\n    horizontalSign\n  );\n\n  const isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;\n  const isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;\n  const isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;\n  const isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;\n  const verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);\n  const horizontalOffset = maxOffset(\n    leftBoundInfo.offset,\n    rightBoundInfo.offset\n  );\n  let offset = [0, 0];\n  let isBound = false;\n  let isAllBound = false;\n\n  if (abs(horizontalOffset) < abs(verticalOffset)) {\n    offset = [verticalOffset, 0];\n    isBound = isVerticalBound;\n    isAllBound = isAllVerticalBound;\n  } else {\n    offset = [0, horizontalOffset];\n    isBound = isHorizontalBound;\n    isAllBound = isAllHorizontalBound;\n  }\n  return {\n    isAllBound,\n    isVerticalBound,\n    isHorizontalBound,\n    isBound,\n    offset,\n  };\n}\n\nfunction checkLineBoundCollision(\n  line: number[][],\n  [a, b]: [number, number, number],\n  boundLine: number[][],\n  isStart: boolean,\n  threshold?: number,\n  isRender?: boolean\n) {\n  const dot1 = line[0];\n  // const dot2 = line[1];\n  const boundDot1 = boundLine[0];\n  const boundDot2 = boundLine[1];\n\n  // const dy1 = getTinyDist(dot2[1] - dot1[1]);\n  // const dx1 = getTinyDist(dot2[0] - dot1[0]);\n  const dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);\n  const dx2 = getTinyDist(boundDot2[0] - boundDot1[0]);\n\n  const hasDx = b;\n  const hasDy = a;\n  const slope = -a / b;\n  // lineConstants\n  // ax + by + c = 0\n  // dx2 or dy2 is zero\n  if (!dx2) {\n    // vertical\n    // by + c = 0\n    if (isRender && !hasDy) {\n      // 90deg\n      return {\n        isBound: false,\n        offset: 0,\n      };\n    } else if (hasDx) {\n      // ax + by + c = 0\n      // const y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1];\n      const y = slope * (boundDot1[0] - dot1[0]) + dot1[1];\n\n      // boundDot1[1] <= y  <= boundDot2[1]\n      return checkInnerBoundDot(\n        y,\n        boundDot1[1],\n        boundDot2[1],\n        isStart,\n        threshold\n      );\n    } else {\n      // ax + c = 0\n      const offset = boundDot1[0] - dot1[0];\n\n      const isBound = abs(offset) <= (threshold || 0);\n\n      return {\n        isBound,\n        offset: isBound ? offset : 0,\n      };\n    }\n  } else if (!dy2) {\n    // horizontal\n    if (isRender && !hasDx) {\n      // 90deg\n      return {\n        isBound: false,\n        offset: 0,\n      };\n    } else if (hasDy) {\n      // y = a * (x - x1) + y1\n      // x = (y - y1) / a + x1\n      // const a = dy1 / dx1;\n      // const x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0];\n      const x = (boundDot1[1] - dot1[1]) / slope + dot1[0];\n\n      // boundDot1[0] <= x && x <= boundDot2[0]\n      return checkInnerBoundDot(\n        x,\n        boundDot1[0],\n        boundDot2[0],\n        isStart,\n        threshold\n      );\n    } else {\n      const offset = boundDot1[1] - dot1[1];\n\n      const isBound = abs(offset) <= (threshold || 0);\n\n      return {\n        isBound,\n        offset: isBound ? offset : 0,\n      };\n    }\n  }\n  return {\n    isBound: false,\n    offset: 0,\n  };\n}\nexport function getInnerBoundInfo(\n  moveable: MoveableManagerInterface<SnappableProps>,\n  lineInfos: InnerBoundLineInfo[],\n  datas: any\n) {\n  return lineInfos.map((info) => {\n    const { isBound, offset, isVerticalBound, isHorizontalBound } =\n      checkInnerBound(moveable, info);\n\n    const multiple = info.multiple;\n\n    const sizeOffset = getDragDist({\n      datas,\n      distX: offset[0],\n      distY: offset[1],\n    }).map((size, i) => size * (multiple[i] ? 2 / multiple[i] : 0));\n\n    return {\n      sign: multiple,\n      isBound,\n      isVerticalBound,\n      isHorizontalBound,\n      isSnap: false,\n      offset: sizeOffset,\n    };\n  });\n}\n\nexport function getInnerBoundDragInfo(\n  moveable: MoveableManagerInterface<SnappableProps & DraggableProps, any>,\n  poses: number[][],\n  datas: any\n) {\n  const lines = getCheckInnerBoundLineInfos(moveable, poses, [0, 0], false).map(\n    (info) => {\n      return {\n        ...info,\n        multiple: info.multiple.map((dir) => abs(dir) * 2),\n      };\n    }\n  );\n  const innerBoundInfo = getInnerBoundInfo(moveable, lines, datas);\n  const widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);\n  const heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);\n  let verticalOffset = 0;\n  let horizontalOffset = 0;\n  const isVerticalBound =\n    widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;\n  const isHorizontalBound =\n    widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;\n\n  if (isVerticalBound || isHorizontalBound) {\n    [verticalOffset, horizontalOffset] = getInverseDragDist({\n      datas,\n      distX: -widthOffsetInfo.offset[0],\n      distY: -heightOffsetInfo.offset[1],\n    });\n  }\n\n  return {\n    vertical: {\n      isBound: isVerticalBound,\n      offset: verticalOffset,\n    },\n    horizontal: {\n      isBound: isHorizontalBound,\n      offset: horizontalOffset,\n    },\n  };\n}\nexport function getCheckSnapLineDirections(\n  direction: number[],\n  keepRatio: boolean\n) {\n  const lineDirections: number[][][] = [];\n  const x = direction[0];\n  const y = direction[1];\n  if (x && y) {\n    lineDirections.push(\n      [[0, y * 2], direction, [-x, y]],\n      [[x * 2, 0], direction, [x, -y]]\n    );\n  } else if (x) {\n    // vertcal\n    lineDirections.push([\n      [x * 2, 0],\n      [x, 1],\n      [x, -1],\n    ]);\n    if (keepRatio) {\n      lineDirections.push(\n        [\n          [0, -1],\n          [x, -1],\n          [-x, -1],\n        ],\n        [\n          [0, 1],\n          [x, 1],\n          [-x, 1],\n        ]\n      );\n    }\n  } else if (y) {\n    // horizontal\n    lineDirections.push([\n      [0, y * 2],\n      [1, y],\n      [-1, y],\n    ]);\n    if (keepRatio) {\n      lineDirections.push(\n        [\n          [-1, 0],\n          [-1, y],\n          [-1, -y],\n        ],\n        [\n          [1, 0],\n          [1, y],\n          [1, -y],\n        ]\n      );\n    }\n  } else {\n    // [0, 0] to all direction\n    lineDirections.push(\n      [\n        [-1, 0],\n        [-1, -1],\n        [-1, 1],\n      ],\n      [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n      ],\n      [\n        [0, -1],\n        [-1, -1],\n        [1, -1],\n      ],\n      [\n        [0, 1],\n        [-1, 1],\n        [1, 1],\n      ]\n    );\n  }\n\n  return lineDirections;\n}\nexport interface InnerBoundLineInfo {\n  line: number[][];\n  multiple: number[];\n  horizontalSign: boolean;\n  verticalSign: boolean;\n  centerSign: boolean;\n  lineConstants: [number, number, number];\n}\nexport function getCheckInnerBoundLineInfos(\n  moveable: MoveableManagerInterface<SnappableProps>,\n  poses: number[][],\n  direction: number[],\n  keepRatio: boolean\n): InnerBoundLineInfo[] {\n  const { allMatrix, is3d } = moveable.state;\n  const virtualPoses = calculatePoses(allMatrix, 100, 100, is3d ? 4 : 3);\n  const center = getPosByDirection(virtualPoses, [0, 0]);\n\n  return getCheckSnapLineDirections(direction, keepRatio).map(\n    ([multiple, dir1, dir2]) => {\n      const virtualLine = [\n        getPosByDirection(virtualPoses, dir1),\n        getPosByDirection(virtualPoses, dir2),\n      ];\n      const lineConstants = solveLineConstants(virtualLine);\n      const { vertical: verticalSign, horizontal: horizontalSign } =\n        isStartLine(center, virtualLine);\n      const centerSign = hitTestLine(center, virtualLine) <= 0;\n\n      return {\n        multiple,\n        centerSign,\n        verticalSign,\n        horizontalSign,\n        lineConstants,\n        line: [getPosByDirection(poses, dir1), getPosByDirection(poses, dir2)],\n      };\n    }\n  );\n}\n\nfunction isBoundRotate(\n  relativePoses: number[][],\n  boundDots: number[][],\n  center: number[],\n  rad: number\n) {\n  const nextPoses = rad\n    ? relativePoses.map((pos) => rotate(pos, rad))\n    : relativePoses;\n  return [\n    [nextPoses[0], nextPoses[1]],\n    [nextPoses[1], nextPoses[3]],\n    [nextPoses[3], nextPoses[2]],\n    [nextPoses[2], nextPoses[0]],\n  ].some((line) => {\n    const centerSign = hitTestLine(center, line) <= 0;\n\n    return !isSameStartLine(boundDots, line, centerSign);\n  });\n}\nfunction getDistPointLine([pos1, pos2]: number[][]) {\n  // x = 0, y = 0\n  // d = (ax + by + c) / root(a2 + b2)\n\n  const dx = pos2[0] - pos1[0];\n  const dy = pos2[1] - pos1[1];\n\n  if (!dx) {\n    return abs(pos1[0]);\n  }\n  if (!dy) {\n    return abs(pos1[1]);\n  }\n  // y - y1 = a(x - x1)\n  // 0 = ax -y + -a * x1 + y1\n\n  const a = dy / dx;\n\n  return abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));\n}\nfunction solveReverseLine([pos1, pos2]: number[][]) {\n  const dx = pos2[0] - pos1[0];\n  const dy = pos2[1] - pos1[1];\n\n  if (!dx) {\n    return [pos1[0], 0];\n  }\n  if (!dy) {\n    return [0, pos1[1]];\n  }\n  const a = dy / dx;\n  // y - y1 = a (x  - x1)\n  // y = ax - a * x1 + y1\n  const b = -a * pos1[0] + pos1[1];\n  // y = ax + b = -1/a x\n  // x = -b / (a + 1 / a)\n  // y = b / (1 + 1 / a^2)\n\n  return [-b / (a + 1 / a), b / (a * a + 1)];\n}\nexport function checkRotateInnerBounds(\n  moveable: MoveableManagerInterface<SnappableProps & RotatableProps, any>,\n  prevPoses: number[][],\n  nextPoses: number[][],\n  origin: number[],\n  rotation: number\n) {\n  const bounds = moveable.props.innerBounds;\n  const rad = (rotation * Math.PI) / 180;\n\n  if (!bounds) {\n    return [];\n  }\n  const { left, top, width, height } = bounds;\n\n  const relativeLeft = left - origin[0];\n  const relativeRight = left + width - origin[0];\n  const relativeTop = top - origin[1];\n  const relativeBottom = top + height - origin[1];\n  const dots = [\n    [relativeLeft, relativeTop],\n    [relativeRight, relativeTop],\n    [relativeLeft, relativeBottom],\n    [relativeRight, relativeBottom],\n  ];\n  const center = getPosByDirection(nextPoses, [0, 0]);\n\n  if (!isBoundRotate(nextPoses, dots, center, 0)) {\n    return [];\n  }\n  const result: number[] = [];\n  const dotInfos = dots.map((dot) => [getDistSize(dot), getRad([0, 0], dot)]);\n  [\n    [nextPoses[0], nextPoses[1]],\n    [nextPoses[1], nextPoses[3]],\n    [nextPoses[3], nextPoses[2]],\n    [nextPoses[2], nextPoses[0]],\n  ].forEach((line) => {\n    const lineRad = getRad([0, 0], solveReverseLine(line));\n    const lineDist = getDistPointLine(line);\n\n    result.push(\n      ...dotInfos\n        .filter(([dotDist]) => {\n          return dotDist && lineDist <= dotDist;\n        })\n        .map(([dotDist, dotRad]) => {\n          const distRad = Math.acos(dotDist ? lineDist / dotDist : 0);\n          const nextRad1 = dotRad + distRad;\n          const nextRad2 = dotRad - distRad;\n\n          return [rad + nextRad1 - lineRad, rad + nextRad2 - lineRad];\n        })\n        .reduce((prev, cur) => {\n          prev.push(...cur);\n          return prev;\n        }, [])\n        .filter((nextRad) => !isBoundRotate(prevPoses, dots, center, nextRad))\n        .map((nextRad) => throttle((nextRad * 180) / Math.PI, TINY_NUM))\n    );\n  });\n  return result;\n}\n\nexport function checkInnerBoundPoses(\n  moveable: MoveableManagerInterface<SnappableProps>\n) {\n  const innerBounds = moveable.props.innerBounds;\n  const boundMap = getInitialBounds();\n\n  if (!innerBounds) {\n    return {\n      boundMap,\n      vertical: [],\n      horizontal: [],\n    };\n  }\n  const { pos1, pos2, pos3, pos4 } = moveable.getRect();\n  const poses = [pos1, pos2, pos3, pos4];\n  const center = getPosByDirection(poses, [0, 0]);\n  const { left, top, width, height } = innerBounds;\n  const leftLine = [\n    [left, top],\n    [left, top + height],\n  ];\n  const topLine = [\n    [left, top],\n    [left + width, top],\n  ];\n  const rightLine = [\n    [left + width, top],\n    [left + width, top + height],\n  ];\n  const bottomLine = [\n    [left, top + height],\n    [left + width, top + height],\n  ];\n  const lineInfos = getCheckInnerBoundLineInfos(moveable, poses, [0, 0], false);\n\n  const horizontalPoses: number[] = [];\n  const verticalPoses: number[] = [];\n\n  lineInfos.forEach((lineInfo) => {\n    const { line, lineConstants } = lineInfo;\n    const { horizontal: isHorizontalStart, vertical: isVerticalStart } =\n      isStartLine(center, line);\n\n    // test vertical\n    const topBoundInfo = checkLineBoundCollision(\n      line,\n      lineConstants,\n      topLine,\n      isVerticalStart,\n      1,\n      true\n    );\n    const bottomBoundInfo = checkLineBoundCollision(\n      line,\n      lineConstants,\n      bottomLine,\n      isVerticalStart,\n      1,\n      true\n    );\n\n    // test horizontal\n    const leftBoundInfo = checkLineBoundCollision(\n      line,\n      lineConstants,\n      leftLine,\n      isHorizontalStart,\n      1,\n      true\n    );\n    const rightBoundInfo = checkLineBoundCollision(\n      line,\n      lineConstants,\n      rightLine,\n      isHorizontalStart,\n      1,\n      true\n    );\n\n    if (topBoundInfo.isBound && !boundMap.top) {\n      horizontalPoses.push(top);\n      boundMap.top = true;\n    }\n    if (bottomBoundInfo.isBound && !boundMap.bottom) {\n      horizontalPoses.push(top + height);\n      boundMap.bottom = true;\n    }\n    if (leftBoundInfo.isBound && !boundMap.left) {\n      verticalPoses.push(left);\n      boundMap.left = true;\n    }\n    if (rightBoundInfo.isBound && !boundMap.right) {\n      verticalPoses.push(left + width);\n      boundMap.right = true;\n    }\n  });\n\n  return {\n    boundMap,\n    horizontal: horizontalPoses,\n    vertical: verticalPoses,\n  };\n}\n","import { getDist, getRad, IObject, TINY_NUM } from \"../../../utility\";\nimport { minus } from \"../../../matrix\";\nimport {\n  abs,\n  getAbsolutePoses,\n  getDistSize,\n  getRect,\n  maxOffset,\n} from \"../../utils\";\nimport { getDragDist, getPosByDirection } from \"../../gesto/gesto-utils\";\nimport {\n  BoundInfo,\n  SnapInfo,\n  MoveableManagerInterface,\n  SnappableProps,\n  SnappableState,\n  SnapBoundInfo,\n  SnapGuideline,\n  BoundType,\n  SnapOffsetInfo,\n  DraggableProps,\n} from \"../../types\";\nimport { checkBoundKeepRatio, checkBoundPoses, getBounds } from \"./bounds\";\nimport { getInnerBoundDragInfo } from \"./inner-bounds\";\nimport {\n  getNearestSnapGuidelineInfo,\n  checkMoveableSnapPoses,\n  checkSnapPoses,\n  checkSnapKeepRatio,\n} from \"./snap\";\nimport {\n  hasGuidelines,\n  getSnapDirections,\n  splitSnapDirectionPoses,\n} from \"./utils\";\n\ninterface DirectionSnapType<T> {\n  vertical: T;\n  horizontal: T;\n}\n\nexport function solveEquation(\n  pos1: number[],\n  pos2: number[],\n  snapOffset: number,\n  isVertical: boolean\n) {\n  let dx = pos2[0] - pos1[0];\n  let dy = pos2[1] - pos1[1];\n\n  if (abs(dx) < TINY_NUM) {\n    dx = 0;\n  }\n  if (abs(dy) < TINY_NUM) {\n    dy = 0;\n  }\n  if (!dx) {\n    // y = 0 * x + b\n    // only horizontal\n    if (!isVertical) {\n      return [0, snapOffset];\n    }\n    return [0, 0];\n  }\n  if (!dy) {\n    // only vertical\n    if (isVertical) {\n      return [snapOffset, 0];\n    }\n    return [0, 0];\n  }\n  // y = ax + b\n  const a = dy / dx;\n  const b = pos1[1] - a * pos1[0];\n\n  if (isVertical) {\n    // y = a * x + b\n    const y = a * (pos2[0] + snapOffset) + b;\n\n    return [snapOffset, y - pos2[1]];\n  } else {\n    // x = (y - b) / a\n    const x = (pos2[1] + snapOffset - b) / a;\n\n    return [x - pos2[0], snapOffset];\n  }\n}\n\nfunction solveNextOffset(\n  pos1: number[],\n  pos2: number[],\n  offset: number,\n  isVertical: boolean,\n  datas: IObject<any>\n) {\n  const sizeOffset = solveEquation(pos1, pos2, offset, isVertical);\n\n  if (!sizeOffset) {\n    return {\n      isOutside: false,\n      offset: [0, 0],\n    };\n  }\n  const size = getDist(pos1, pos2);\n  const dist1 = getDist(sizeOffset, pos1);\n  const dist2 = getDist(sizeOffset, pos2);\n\n  const isOutside = dist1 > size || dist2 > size;\n  const [widthOffset, heightOffset] = getDragDist({\n    datas,\n    distX: sizeOffset[0],\n    distY: sizeOffset[1],\n  });\n\n  return {\n    offset: [widthOffset, heightOffset],\n    isOutside,\n  };\n}\n\nfunction getSnapBound(boundInfo: BoundInfo, snapInfo: SnapInfo) {\n  if (boundInfo.isBound) {\n    return boundInfo.offset;\n  } else if (snapInfo.isSnap) {\n    return getNearestSnapGuidelineInfo(snapInfo).offset;\n  }\n  return 0;\n}\n\nexport function checkThrottleDragRotate(\n  throttleDragRotate: number,\n  [distX, distY]: number[],\n  [isVerticalBound, isHorizontalBound]: boolean[],\n  [isVerticalSnap, isHorizontalSnap]: boolean[],\n  [verticalOffset, horizontalOffset]: number[]\n) {\n  let offsetX = -verticalOffset;\n  let offsetY = -horizontalOffset;\n\n  if (throttleDragRotate && distX && distY) {\n    offsetX = 0;\n    offsetY = 0;\n    const adjustPoses: number[][] = [];\n    if (isVerticalBound && isHorizontalBound) {\n      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n    } else if (isVerticalBound) {\n      adjustPoses.push([verticalOffset, 0]);\n    } else if (isHorizontalBound) {\n      adjustPoses.push([0, horizontalOffset]);\n    } else if (isVerticalSnap && isHorizontalSnap) {\n      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n    } else if (isVerticalSnap) {\n      adjustPoses.push([verticalOffset, 0]);\n    } else if (isHorizontalSnap) {\n      adjustPoses.push([0, horizontalOffset]);\n    }\n    if (adjustPoses.length) {\n      adjustPoses.sort((a, b) => {\n        return (\n          getDistSize(minus([distX, distY], a)) -\n          getDistSize(minus([distX, distY], b))\n        );\n      });\n      const adjustPos = adjustPoses[0];\n\n      if (adjustPos[0] && abs(distX) > TINY_NUM) {\n        offsetX = -adjustPos[0];\n        offsetY = (distY * abs(distX + offsetX)) / abs(distX) - distY;\n      } else if (adjustPos[1] && abs(distY) > TINY_NUM) {\n        const prevDistY = distY;\n        offsetY = -adjustPos[1];\n        offsetX = (distX * abs(distY + offsetY)) / abs(prevDistY) - distX;\n      }\n      if (throttleDragRotate && isHorizontalBound && isVerticalBound) {\n        if (abs(offsetX) > TINY_NUM && abs(offsetX) < abs(verticalOffset)) {\n          const scale = abs(verticalOffset) / abs(offsetX);\n\n          offsetX *= scale;\n          offsetY *= scale;\n        } else if (\n          abs(offsetY) > TINY_NUM &&\n          abs(offsetY) < abs(horizontalOffset)\n        ) {\n          const scale = abs(horizontalOffset) / abs(offsetY);\n\n          offsetX *= scale;\n          offsetY *= scale;\n        } else {\n          offsetX = maxOffset(-verticalOffset, offsetX);\n          offsetY = maxOffset(-horizontalOffset, offsetY);\n        }\n      }\n    }\n  } else {\n    offsetX = distX || isVerticalBound ? -verticalOffset : 0;\n    offsetY = distY || isHorizontalBound ? -horizontalOffset : 0;\n  }\n  return [offsetX, offsetY];\n}\n\nexport function checkSnapBoundsDrag(\n  moveable: MoveableManagerInterface<SnappableProps & DraggableProps, any>,\n  distX: number,\n  distY: number,\n  throttleDragRotate: number,\n  ignoreSnap: boolean,\n  datas: any\n) {\n  if (!hasGuidelines(moveable, \"draggable\")) {\n    return [\n      {\n        isSnap: false,\n        isBound: false,\n        offset: 0,\n      },\n      {\n        isSnap: false,\n        isBound: false,\n        offset: 0,\n      },\n    ];\n  }\n  const poses = getAbsolutePoses(datas.absolutePoses, [distX, distY]);\n  const { left, right, top, bottom } = getRect(poses);\n  const boundPoses = {\n    horizontal: poses.map((pos) => pos[1]),\n    vertical: poses.map((pos) => pos[0]),\n  };\n  const snapDirections = getSnapDirections(moveable.props.snapDirections);\n  const snapPoses = splitSnapDirectionPoses(snapDirections, {\n    left,\n    right,\n    top,\n    bottom,\n    center: (left + right) / 2,\n    middle: (top + bottom) / 2,\n  });\n  const {\n    vertical: verticalSnapBoundInfo,\n    horizontal: horizontalSnapBoundInfo,\n  } = checkMoveableSnapBounds(moveable, ignoreSnap, snapPoses, boundPoses);\n  const {\n    vertical: verticalInnerBoundInfo,\n    horizontal: horizontalInnerBoundInfo,\n  } = getInnerBoundDragInfo(moveable, poses, datas);\n\n  const isVerticalSnap = verticalSnapBoundInfo.isSnap;\n  const isHorizontalSnap = horizontalSnapBoundInfo.isSnap;\n  const isVerticalBound =\n    verticalSnapBoundInfo.isBound || verticalInnerBoundInfo.isBound;\n  const isHorizontalBound =\n    horizontalSnapBoundInfo.isBound || horizontalInnerBoundInfo.isBound;\n  const verticalOffset = maxOffset(\n    verticalSnapBoundInfo.offset,\n    verticalInnerBoundInfo.offset\n  );\n  const horizontalOffset = maxOffset(\n    horizontalSnapBoundInfo.offset,\n    horizontalInnerBoundInfo.offset\n  );\n\n  const [offsetX, offsetY] = checkThrottleDragRotate(\n    throttleDragRotate,\n    [distX, distY],\n    [isVerticalBound, isHorizontalBound],\n    [isVerticalSnap, isHorizontalSnap],\n    [verticalOffset, horizontalOffset]\n  );\n\n  return [\n    {\n      isBound: isVerticalBound,\n      isSnap: isVerticalSnap,\n      offset: offsetX,\n    },\n    {\n      isBound: isHorizontalBound,\n      isSnap: isHorizontalSnap,\n      offset: offsetY,\n    },\n  ];\n}\n\nexport function checkMoveableSnapBounds(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n  ignoreSnap: boolean,\n  poses: { vertical: number[]; horizontal: number[] },\n  boundPoses: { vertical: number[]; horizontal: number[] } = poses\n): DirectionSnapType<Required<SnapBoundInfo>> {\n  const { horizontal: horizontalBoundInfos, vertical: verticalBoundInfos } =\n    checkBoundPoses(\n      getBounds(moveable),\n      boundPoses.vertical,\n      boundPoses.horizontal\n    );\n  const { horizontal: horizontalSnapInfo, vertical: verticalSnapInfo } =\n    ignoreSnap\n      ? {\n          horizontal: { isSnap: false, index: -1 } as SnapInfo,\n          vertical: { isSnap: false, index: -1 } as SnapInfo,\n        }\n      : checkMoveableSnapPoses(\n          moveable,\n          poses.vertical,\n          poses.horizontal,\n          undefined,\n          undefined,\n          undefined,\n          undefined\n        );\n  const horizontalOffset = getSnapBound(\n    horizontalBoundInfos[0],\n    horizontalSnapInfo\n  );\n  const verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);\n\n  const horizontalDist = abs(horizontalOffset);\n  const verticalDist = abs(verticalOffset);\n\n  return {\n    horizontal: {\n      isBound: horizontalBoundInfos[0].isBound,\n      isSnap: horizontalSnapInfo.isSnap,\n      snapIndex: horizontalSnapInfo.index,\n      offset: horizontalOffset,\n      dist: horizontalDist,\n      bounds: horizontalBoundInfos,\n      snap: horizontalSnapInfo,\n    },\n    vertical: {\n      isBound: verticalBoundInfos[0].isBound,\n      isSnap: verticalSnapInfo.isSnap,\n      snapIndex: verticalSnapInfo.index,\n      offset: verticalOffset,\n      dist: verticalDist,\n      bounds: verticalBoundInfos,\n      snap: verticalSnapInfo,\n    },\n  };\n}\nexport function checkSnapBounds(\n  guideines: SnapGuideline[],\n  bounds: BoundType | undefined | false,\n  posesX: number[],\n  posesY: number[],\n  snapHorizontalThreshold: number,\n  snapVerticalThreshold: number,\n  multiples = [1, 1]\n): DirectionSnapType<Required<SnapBoundInfo>> {\n  const { horizontal: horizontalBoundInfos, vertical: verticalBoundInfos } =\n    checkBoundPoses(bounds, posesX, posesY);\n\n  // options.isRequest ? {\n  //     horizontal: { isSnap: false, index: -1 } as SnapInfo,\n  //     vertical: { isSnap: false, index: -1 } as SnapInfo,\n  // } :\n  const { horizontal: horizontalSnapInfo, vertical: verticalSnapInfo } =\n    checkSnapPoses(\n      guideines,\n      posesX,\n      posesY,\n      [],\n      [],\n      snapHorizontalThreshold,\n      snapVerticalThreshold,\n      multiples\n    );\n\n  const horizontalOffset = getSnapBound(\n    horizontalBoundInfos[0],\n    horizontalSnapInfo\n  );\n  const verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);\n\n  const horizontalDist = abs(horizontalOffset);\n  const verticalDist = abs(verticalOffset);\n\n  return {\n    horizontal: {\n      isBound: horizontalBoundInfos[0].isBound,\n      isSnap: horizontalSnapInfo.isSnap,\n      snapIndex: horizontalSnapInfo.index,\n      offset: horizontalOffset,\n      dist: horizontalDist,\n      bounds: horizontalBoundInfos,\n      snap: horizontalSnapInfo,\n    },\n    vertical: {\n      isBound: verticalBoundInfos[0].isBound,\n      isSnap: verticalSnapInfo.isSnap,\n      snapIndex: verticalSnapInfo.index,\n      offset: verticalOffset,\n      dist: verticalDist,\n      bounds: verticalBoundInfos,\n      snap: verticalSnapInfo,\n    },\n  };\n}\n\nfunction checkSnapRightLine(\n  startPos: number[],\n  endPos: number[],\n  snapBoundInfo: { vertical: SnapBoundInfo; horizontal: SnapBoundInfo },\n  keepRatio: boolean\n) {\n  const rad = (getRad(startPos, endPos) / Math.PI) * 180;\n  const {\n    vertical: {\n      isBound: isVerticalBound,\n      isSnap: isVerticalSnap,\n      dist: verticalDist,\n    },\n    horizontal: {\n      isBound: isHorizontalBound,\n      isSnap: isHorizontalSnap,\n      dist: horizontalDist,\n    },\n  } = snapBoundInfo;\n\n  const rad180 = rad % 180;\n  const isHorizontalLine = rad180 < 3 || rad180 > 177;\n  const isVerticalLine = rad180 > 87 && rad180 < 93;\n\n  if (horizontalDist < verticalDist) {\n    if (\n      isVerticalBound ||\n      (isVerticalSnap && !isVerticalLine && (!keepRatio || !isHorizontalLine))\n    ) {\n      return \"vertical\";\n    }\n  }\n  if (\n    isHorizontalBound ||\n    (isHorizontalSnap && !isHorizontalLine && (!keepRatio || !isVerticalLine))\n  ) {\n    return \"horizontal\";\n  }\n  return \"\";\n}\n\nexport function getSnapBoundInfo(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n  poses: number[][],\n  directions: number[][][],\n  keepRatio: boolean,\n  isRequest: boolean,\n  datas: any\n) {\n  return directions.map(([startDirection, endDirection]) => {\n    const otherStartPos = getPosByDirection(poses, startDirection);\n    const otherEndPos = getPosByDirection(poses, endDirection);\n    const snapBoundInfo = keepRatio\n      ? checkSnapBoundsKeepRatio(\n          moveable,\n          otherStartPos,\n          otherEndPos,\n          isRequest\n        )\n      : checkMoveableSnapBounds(moveable, isRequest, {\n          vertical: [otherEndPos[0]],\n          horizontal: [otherEndPos[1]],\n        });\n\n    const {\n      horizontal: {\n        // dist: otherHorizontalDist,\n        offset: otherHorizontalOffset,\n        isBound: isOtherHorizontalBound,\n        isSnap: isOtherHorizontalSnap,\n      },\n      vertical: {\n        // dist: otherVerticalDist,\n        offset: otherVerticalOffset,\n        isBound: isOtherVerticalBound,\n        isSnap: isOtherVerticalSnap,\n      },\n    } = snapBoundInfo;\n\n    const multiple = minus(endDirection, startDirection);\n\n    if (!otherVerticalOffset && !otherHorizontalOffset) {\n      return {\n        isBound: isOtherVerticalBound || isOtherHorizontalBound,\n        isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,\n        sign: multiple,\n        offset: [0, 0],\n      };\n    }\n    const snapLine = checkSnapRightLine(\n      otherStartPos,\n      otherEndPos,\n      snapBoundInfo,\n      keepRatio\n    );\n\n    if (!snapLine) {\n      return {\n        sign: multiple,\n        isBound: false,\n        isSnap: false,\n        offset: [0, 0],\n      };\n    }\n\n    const isVertical = snapLine === \"vertical\";\n    let sizeOffset = [0, 0];\n\n    if (\n      !keepRatio &&\n      abs(endDirection[0]) === 1 &&\n      abs(endDirection[1]) === 1 &&\n      startDirection[0] !== endDirection[0] &&\n      startDirection[1] !== endDirection[1]\n    ) {\n      sizeOffset = getDragDist({\n        datas,\n        distX: -otherVerticalOffset,\n        distY: -otherHorizontalOffset,\n      });\n    } else {\n      sizeOffset = solveNextOffset(\n        otherStartPos,\n        otherEndPos,\n        -(isVertical ? otherVerticalOffset : otherHorizontalOffset),\n        isVertical,\n        datas\n      ).offset;\n    }\n    sizeOffset = sizeOffset.map(\n      (size, i) => size * (multiple[i] ? 2 / multiple[i] : 0)\n    );\n\n    return {\n      sign: multiple,\n      isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,\n      isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,\n      offset: sizeOffset,\n    };\n  });\n}\n\nfunction getSnapBoundOffset(boundInfo: BoundInfo, snapInfo: SnapOffsetInfo) {\n  if (boundInfo.isBound) {\n    return boundInfo.offset;\n  } else if (snapInfo.isSnap) {\n    return snapInfo.offset;\n  }\n  return 0;\n}\n\nexport function checkSnapBoundsKeepRatio(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n  startPos: number[],\n  endPos: number[],\n  isRequest: boolean\n): DirectionSnapType<SnapBoundInfo> {\n  const { horizontal: horizontalBoundInfo, vertical: verticalBoundInfo } =\n    checkBoundKeepRatio(moveable, startPos, endPos);\n  const { horizontal: horizontalSnapInfo, vertical: verticalSnapInfo } =\n    isRequest\n      ? ({\n          horizontal: { isSnap: false },\n          vertical: { isSnap: false },\n        } as any)\n      : checkSnapKeepRatio(moveable, startPos, endPos);\n\n  const horizontalOffset = getSnapBoundOffset(\n    horizontalBoundInfo,\n    horizontalSnapInfo\n  );\n  const verticalOffset = getSnapBoundOffset(\n    verticalBoundInfo,\n    verticalSnapInfo\n  );\n\n  const horizontalDist = abs(horizontalOffset);\n  const verticalDist = abs(verticalOffset);\n\n  return {\n    horizontal: {\n      isBound: horizontalBoundInfo.isBound,\n      isSnap: horizontalSnapInfo.isSnap,\n      offset: horizontalOffset,\n      dist: horizontalDist,\n    },\n    vertical: {\n      isBound: verticalBoundInfo.isBound,\n      isSnap: verticalSnapInfo.isSnap,\n      offset: verticalOffset,\n      dist: verticalDist,\n    },\n  };\n}\n\nexport function checkMaxBounds(\n  moveable: MoveableManagerInterface<SnappableProps>,\n  poses: number[][],\n  direction: number[],\n  fixedPosition: number[],\n  datas: any\n) {\n  const fixedDirection = [-direction[0], -direction[1]];\n  const { width, height } = moveable.state;\n  const bounds = moveable.props.bounds;\n  let maxWidth = Infinity;\n  let maxHeight = Infinity;\n\n  if (bounds) {\n    const directions = [\n      [direction[0], -direction[1]],\n      [-direction[0], direction[1]],\n    ];\n    const {\n      left = -Infinity,\n      top = -Infinity,\n      right = Infinity,\n      bottom = Infinity,\n    } = bounds;\n\n    directions.forEach((otherDirection) => {\n      const isCheckVertical = otherDirection[0] !== fixedDirection[0];\n      const isCheckHorizontal = otherDirection[1] !== fixedDirection[1];\n      const otherPos = getPosByDirection(poses, otherDirection);\n      const deg = (getRad(fixedPosition, otherPos) * 360) / Math.PI;\n\n      if (isCheckHorizontal) {\n        const nextOtherPos = otherPos.slice();\n\n        if (abs(deg - 360) < 2 || abs(deg - 180) < 2) {\n          nextOtherPos[1] = fixedPosition[1];\n        }\n        const {\n          offset: [, heightOffset],\n          isOutside: isHeightOutside,\n        } = solveNextOffset(\n          fixedPosition,\n          nextOtherPos,\n          (fixedPosition[1] < otherPos[1] ? bottom : top) - otherPos[1],\n          false,\n          datas\n        );\n        if (!isNaN(heightOffset)) {\n          maxHeight = height + (isHeightOutside ? 1 : -1) * abs(heightOffset);\n        }\n      }\n      if (isCheckVertical) {\n        const nextOtherPos = otherPos.slice();\n\n        if (abs(deg - 90) < 2 || abs(deg - 270) < 2) {\n          nextOtherPos[0] = fixedPosition[0];\n        }\n        const {\n          offset: [widthOffset],\n          isOutside: isWidthOutside,\n        } = solveNextOffset(\n          fixedPosition,\n          nextOtherPos,\n          (fixedPosition[0] < otherPos[0] ? right : left) - otherPos[0],\n          true,\n          datas\n        );\n        if (!isNaN(widthOffset)) {\n          maxWidth = width + (isWidthOutside ? 1 : -1) * abs(widthOffset);\n        }\n      }\n    });\n  }\n  return {\n    maxWidth,\n    maxHeight,\n  };\n}\n","import {\n  setDragStart,\n  getBeforeDragDist,\n  getTransformDist,\n  convertTransformFormat,\n  resolveTransformEvent,\n  fillTransformStartEvent,\n  setDefaultTransformIndex,\n  fillOriginalTransform,\n} from \"../gesto/gesto-utils\";\nimport {\n  triggerEvent,\n  fillParams,\n  getDistSize,\n  prefix,\n  fillEndParams,\n  fillCSSObject,\n} from \"../utils\";\nimport { minus, plus } from \"../../matrix\";\nimport {\n  DraggableProps,\n  OnDrag,\n  OnDragGroup,\n  OnDragGroupStart,\n  OnDragStart,\n  OnDragEnd,\n  DraggableState,\n  Renderer,\n  OnDragGroupEnd,\n  MoveableManagerInterface,\n  MoveableGroupInterface,\n} from \"../types\";\nimport { triggerChildGesto } from \"../group-utils\";\nimport { startCheckSnapDrag } from \"./snappable\";\nimport { getRad, throttle, throttleArray } from \"../../utility\";\nimport { checkSnapBoundsDrag } from \"./snappable/snap-bounds\";\nimport { TINY_NUM } from \"../consts\";\n\n/**\n * @namespace Draggable\n * @memberof Moveable\n * @description Draggable refers to the ability to drag and move targets.\n */\nexport default {\n  name: \"draggable\",\n  props: [\n    \"draggable\",\n    \"throttleDrag\",\n    \"throttleDragRotate\",\n    \"hideThrottleDragRotateLine\",\n    \"startDragRotate\",\n    \"edgeDraggable\",\n  ] as const,\n  events: [\n    \"dragStart\",\n    \"drag\",\n    \"dragEnd\",\n    \"dragGroupStart\",\n    \"dragGroup\",\n    \"dragGroupEnd\",\n  ] as const,\n  requestStyle(): string[] {\n    return [\"left\", \"top\", \"right\", \"bottom\"];\n  },\n  requestChildStyle(): string[] {\n    return [\"left\", \"top\", \"right\", \"bottom\"];\n  },\n  render(\n    moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n    React: Renderer\n  ): any[] {\n    const { hideThrottleDragRotateLine, throttleDragRotate, zoom } =\n      moveable.props;\n    const { dragInfo, beforeOrigin } = moveable.getState();\n\n    if (hideThrottleDragRotateLine || !throttleDragRotate || !dragInfo) {\n      return [];\n    }\n    const dist = dragInfo.dist;\n\n    if (!dist[0] && !dist[1]) {\n      return [];\n    }\n\n    const width = getDistSize(dist);\n    const rad = getRad(dist, [0, 0]);\n\n    return [\n      <div\n        className={prefix(\"line\", \"horizontal\", \"dragline\", \"dashed\")}\n        key={`dragRotateGuideline`}\n        style={{\n          width: `${width}px`,\n          transform: `translate(${beforeOrigin[0]}px, ${beforeOrigin[1]}px) rotate(${rad}rad) scaleY(${zoom})`,\n        }}\n      />,\n    ];\n  },\n  dragStart(moveable: MoveableManagerInterface<DraggableProps, any>, e: any) {\n    const { datas, parentEvent, parentGesto } = e;\n    const state = moveable.state;\n    const { gestos, style } = state;\n\n    if (gestos.draggable) {\n      return false;\n    }\n    gestos.draggable = parentGesto || moveable.targetGesto;\n\n    datas.datas = {};\n    datas.left = parseFloat(style.left || \"\") || 0;\n    datas.top = parseFloat(style.top || \"\") || 0;\n    datas.bottom = parseFloat(style.bottom || \"\") || 0;\n    datas.right = parseFloat(style.right || \"\") || 0;\n    datas.startValue = [0, 0];\n\n    setDragStart(moveable, e);\n    setDefaultTransformIndex(moveable, e, \"translate\");\n    startCheckSnapDrag(moveable, datas);\n\n    datas.prevDist = [0, 0];\n    datas.prevBeforeDist = [0, 0];\n    datas.isDrag = false;\n    datas.deltaOffset = [0, 0];\n\n    const params = fillParams<OnDragStart>(moveable, e, {\n      set: (translate: number[]) => {\n        datas.startValue = translate;\n      },\n      ...fillTransformStartEvent(moveable, e),\n    });\n    const result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\n\n    if (result !== false) {\n      datas.isDrag = true;\n      moveable.state.dragInfo = {\n        startRect: moveable.getRect(),\n        dist: [0, 0],\n      };\n    } else {\n      gestos.draggable = null;\n      datas.isPinch = false;\n    }\n    return datas.isDrag ? params : false;\n  },\n  drag(\n    moveable: MoveableManagerInterface<DraggableProps, any>,\n    e: any\n  ): OnDrag | undefined {\n    if (!e) {\n      return;\n    }\n    resolveTransformEvent(moveable, e, \"translate\");\n\n    const {\n      datas,\n      parentEvent,\n      parentFlag,\n      isPinch,\n      deltaOffset,\n      useSnap,\n      isRequest,\n      isGroup,\n      parentThrottleDrag,\n    } = e;\n    let { distX, distY } = e;\n    const { isDrag, prevDist, prevBeforeDist, startValue } = datas;\n\n    if (!isDrag) {\n      return;\n    }\n\n    if (deltaOffset) {\n      distX += deltaOffset[0];\n      distY += deltaOffset[1];\n    }\n    const props = moveable.props;\n\n    const parentMoveable = props.parentMoveable;\n    const throttleDrag = isGroup\n      ? 0\n      : props.throttleDrag || parentThrottleDrag || 0;\n    const throttleDragRotate = parentEvent ? 0 : props.throttleDragRotate || 0;\n\n    let dragRotateRad = 0;\n    let isVerticalSnap = false;\n    let isVerticalBound = false;\n    let isHorizontalSnap = false;\n    let isHorizontalBound = false;\n\n    if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {\n      const startDragRotate = props.startDragRotate || 0;\n      const deg =\n        throttle(\n          startDragRotate + (getRad([0, 0], [distX, distY]) * 180) / Math.PI,\n          throttleDragRotate\n        ) - startDragRotate;\n      const ry = distY * Math.abs(Math.cos(((deg - 90) / 180) * Math.PI));\n      const rx = distX * Math.abs(Math.cos((deg / 180) * Math.PI));\n      const r = getDistSize([rx, ry]);\n      dragRotateRad = (deg * Math.PI) / 180;\n\n      distX = r * Math.cos(dragRotateRad);\n      distY = r * Math.sin(dragRotateRad);\n    }\n\n    if (!isPinch && !parentEvent && !parentFlag) {\n      const [verticalInfo, horizontalInfo] = checkSnapBoundsDrag(\n        moveable,\n        distX,\n        distY,\n        throttleDragRotate,\n        (!useSnap && isRequest) || deltaOffset,\n        datas\n      );\n      isVerticalSnap = verticalInfo.isSnap;\n      isVerticalBound = verticalInfo.isBound;\n      isHorizontalSnap = horizontalInfo.isSnap;\n      isHorizontalBound = horizontalInfo.isBound;\n\n      const verticalOffset = verticalInfo.offset;\n      const horizontalOffset = horizontalInfo.offset;\n\n      distX += verticalOffset;\n      distY += horizontalOffset;\n    }\n\n    const beforeTranslate = plus(\n      getBeforeDragDist({ datas, distX, distY }),\n      startValue\n    );\n    const translate = plus(\n      getTransformDist({ datas, distX, distY }),\n      startValue\n    );\n\n    throttleArray(translate, TINY_NUM);\n    throttleArray(beforeTranslate, TINY_NUM);\n\n    if (!throttleDragRotate) {\n      if (!isVerticalSnap && !isVerticalBound) {\n        translate[0] = throttle(translate[0], throttleDrag);\n        beforeTranslate[0] = throttle(beforeTranslate[0], throttleDrag);\n      }\n      if (!isHorizontalSnap && !isHorizontalBound) {\n        translate[1] = throttle(translate[1], throttleDrag);\n        beforeTranslate[1] = throttle(beforeTranslate[1], throttleDrag);\n      }\n    }\n\n    const beforeDist = minus(beforeTranslate, startValue);\n    const dist = minus(translate, startValue);\n    const delta = minus(dist, prevDist);\n    const beforeDelta = minus(beforeDist, prevBeforeDist);\n\n    datas.prevDist = dist;\n    datas.prevBeforeDist = beforeDist;\n\n    datas.passDelta = delta; //distX - (datas.passDistX || 0);\n    // datas.passDeltaY = distY - (datas.passDistY || 0);\n    datas.passDist = dist; //distX;\n    // datas.passDistY = distY;\n\n    const left = datas.left + beforeDist[0];\n    const top = datas.top + beforeDist[1];\n    const right = datas.right - beforeDist[0];\n    const bottom = datas.bottom - beforeDist[1];\n    const nextTransform = convertTransformFormat(\n      datas,\n      `translate(${translate[0]}px, ${translate[1]}px)`,\n      `translate(${dist[0]}px, ${dist[1]}px)`\n    );\n\n    fillOriginalTransform(e, nextTransform);\n\n    moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;\n    if (\n      !parentEvent &&\n      !parentMoveable &&\n      delta.every((num) => !num) &&\n      beforeDelta.some((num) => !num)\n    ) {\n      return;\n    }\n\n    const { width, height } = moveable.state;\n    const params = fillParams<OnDrag>(moveable, e, {\n      transform: nextTransform,\n      dist,\n      delta,\n      translate,\n      beforeDist,\n      beforeDelta,\n      beforeTranslate,\n      left,\n      top,\n      right,\n      bottom,\n      width,\n      height,\n      isPinch,\n      ...fillCSSObject(\n        {\n          transform: nextTransform,\n        },\n        e\n      ),\n    });\n\n    !parentEvent && triggerEvent(moveable, \"onDrag\", params);\n    return params;\n  },\n  dragAfter(\n    moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n    e: any\n  ) {\n    const datas = e.datas;\n    const { deltaOffset } = datas;\n\n    if (deltaOffset[0] || deltaOffset[1]) {\n      datas.deltaOffset = [0, 0];\n      return this.drag(moveable, { ...e, deltaOffset });\n    }\n    return false;\n  },\n  dragEnd(\n    moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n    e: any\n  ) {\n    const { parentEvent, datas } = e;\n\n    moveable.state.dragInfo = null;\n    if (!datas.isDrag) {\n      return;\n    }\n    datas.isDrag = false;\n    const param = fillEndParams<OnDragEnd>(moveable, e, {});\n    !parentEvent && triggerEvent(moveable, \"onDragEnd\", param);\n    return param;\n  },\n  dragGroupStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { datas, clientX, clientY } = e;\n\n    const params = this.dragStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n    const { childEvents, eventParams } = triggerChildGesto(\n      moveable,\n      this,\n      \"dragStart\",\n      [clientX || 0, clientY || 0],\n      e,\n      false,\n      \"draggable\"\n    );\n\n    const nextParams: OnDragGroupStart = {\n      ...params,\n      targets: moveable.props.targets!,\n      events: eventParams,\n    };\n    const result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\n\n    datas.isDrag = result !== false;\n\n    // find data.startValue and based on first child moveable\n    const startValue = childEvents[0]?.datas.startValue ?? [0, 0];\n\n    datas.throttleOffset = [startValue[0] % 1, startValue[1] % 1];\n\n    return datas.isDrag ? params : false;\n  },\n  dragGroup(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { datas } = e;\n\n    if (!datas.isDrag) {\n      return;\n    }\n    const params = this.drag(moveable, {\n      ...e,\n      parentThrottleDrag: moveable.props.throttleDrag,\n    });\n    const { passDelta } = e.datas;\n    const { eventParams } = triggerChildGesto(\n      moveable,\n      this,\n      \"drag\",\n      passDelta,\n      e,\n      false,\n      \"draggable\"\n    );\n\n    if (!params) {\n      return;\n    }\n\n    const nextParams: OnDragGroup = {\n      targets: moveable.props.targets!,\n      events: eventParams,\n      ...params,\n    };\n\n    triggerEvent(moveable, \"onDragGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { isDrag, datas } = e;\n\n    if (!datas.isDrag) {\n      return;\n    }\n    this.dragEnd(moveable, e);\n    const { eventParams } = triggerChildGesto(\n      moveable,\n      this,\n      \"dragEnd\",\n      [0, 0],\n      e,\n      false,\n      \"draggable\"\n    );\n    triggerEvent(\n      moveable,\n      \"onDragGroupEnd\",\n      fillEndParams<OnDragGroupEnd>(moveable, e, {\n        targets: moveable.props.targets!,\n        events: eventParams,\n      })\n    );\n\n    return isDrag;\n  },\n  /**\n     * @method Moveable.Draggable#request\n     * @param {object} [e] - the draggable's request parameter\n     * @param {number} [e.x] - x position\n     * @param {number} [e.y] - y position\n     * @param {number} [e.deltaX] - X number to move\n     * @param {number} [e.deltaY] - Y number to move\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"draggable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100 });\n     * moveable.request(\"draggable\", { x: 220, y: 100 });\n     * moveable.request(\"draggable\", { x: 240, y: 100 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n  request(moveable: MoveableManagerInterface<any, any>) {\n    const datas = {};\n    const rect = moveable.getRect();\n    let distX = 0;\n    let distY = 0;\n    let useSnap = false;\n\n    return {\n      isControl: false,\n      requestStart(e: Record<string, any>) {\n        useSnap = e.useSnap;\n        return { datas, useSnap };\n      },\n      request(e: Record<string, any>) {\n        if (\"x\" in e) {\n          distX = e.x - rect.left;\n        } else if (\"deltaX\" in e) {\n          distX += e.deltaX;\n        }\n        if (\"y\" in e) {\n          distY = e.y - rect.top;\n        } else if (\"deltaY\" in e) {\n          distY += e.deltaY;\n        }\n\n        return { datas, distX, distY, useSnap };\n      },\n      requestEnd() {\n        return { datas, isDrag: true, useSnap };\n      },\n    };\n  },\n  unset(moveable: MoveableManagerInterface<any, Record<string, any>>) {\n    moveable.state.gestos.draggable = null;\n    moveable.state.dragInfo = null;\n  },\n};\n\n/**\n * Whether or not target can be dragged. (default: false)\n * @name Moveable.Draggable#draggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.draggable = true;\n */\n\n/**\n * throttle of x, y when drag.\n * @name Moveable.Draggable#throttleDrag\n * @default 0\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleDrag = 1;\n */\n\n/**\n * throttle of angle of x, y when drag.\n * @name Moveable.Draggable#throttleDragRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleDragRotate = 45;\n */\n\n/**\n * start angle of throttleDragRotate of x, y when drag.\n * @name Moveable.Draggable#startDragRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * // 45, 135, 225, 315\n * moveable.throttleDragRotate = 90;\n * moveable.startDragRotate = 45;\n */\n\n/**\n * When the drag starts, the dragStart event is called.\n * @memberof Moveable.Draggable\n * @event dragStart\n * @param {Moveable.Draggable.OnDragStart} - Parameters for the dragStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When dragging, the drag event is called.\n * @memberof Moveable.Draggable\n * @event drag\n * @param {Moveable.Draggable.OnDrag} - Parameters for the drag event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"drag\", ({ target, transform }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the drag finishes, the dragEnd event is called.\n * @memberof Moveable.Draggable\n * @event dragEnd\n * @param {Moveable.Draggable.OnDragEnd} - Parameters for the dragEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n * When the group drag starts, the `dragGroupStart` event is called.\n * @memberof Moveable.Draggable\n * @event dragGroupStart\n * @param {Moveable.Draggable.OnDragGroupStart} - Parameters for the `dragGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroupStart\", ({ targets }) => {\n *     console.log(\"onDragGroupStart\", targets);\n * });\n */\n\n/**\n * When the group drag, the `dragGroup` event is called.\n * @memberof Moveable.Draggable\n * @event dragGroup\n * @param {Moveable.Draggable.OnDragGroup} - Parameters for the `dragGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroup\", ({ targets, events }) => {\n *     console.log(\"onDragGroup\", targets);\n *     events.forEach(ev => {\n *          // drag event\n *          console.log(\"onDrag left, top\", ev.left, ev.top);\n *          // ev.target!.style.left = `${ev.left}px`;\n *          // ev.target!.style.top = `${ev.top}px`;\n *          console.log(\"onDrag translate\", ev.dist);\n *          ev.target!.style.transform = ev.transform;)\n *     });\n * });\n */\n\n/**\n * When the group drag finishes, the `dragGroupEnd` event is called.\n * @memberof Moveable.Draggable\n * @event dragGroupEnd\n * @param {Moveable.Draggable.OnDragGroupEnd} - Parameters for the `dragGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onDragGroupEnd\", targets, isDrag);\n * });\n */\n","import { calculatePosition } from \"../utils\";\nimport { getDirectionByPos, getPosByDirection } from \"../gesto/gesto-utils\";\n\nexport function getFixedDirectionInfo(\n  startPositions: number[][],\n  fixedDirection: number[]\n) {\n  const fixedPosition = getPosByDirection(startPositions, fixedDirection);\n  const fixedOffset = [0, 0];\n\n  return {\n    fixedPosition,\n    fixedDirection,\n    fixedOffset,\n  };\n}\n\nexport function getOffsetFixedDirectionInfo(\n  state: {\n    allMatrix: number[];\n    is3d: boolean;\n    width: number;\n    height: number;\n  },\n  fixedDirection: number[]\n) {\n  // for start\n  const { allMatrix, is3d, width, height } = state;\n  const n = is3d ? 4 : 3;\n  const nextFixedOffset = [\n    (width / 2) * (1 + fixedDirection[0]),\n    (height / 2) * (1 + fixedDirection[1]),\n  ];\n  const fixedPosition = calculatePosition(allMatrix, nextFixedOffset, n);\n  const fixedOffset = [0, 0];\n\n  return {\n    fixedPosition,\n    fixedDirection,\n    fixedOffset,\n  };\n}\n\nexport function getOffsetFixedPositionInfo(\n  state: {\n    allMatrix: number[];\n    is3d: boolean;\n    width: number;\n    height: number;\n  },\n  offsetFixedPosition: number[]\n) {\n  // for start\n  const { allMatrix, is3d, width, height } = state;\n  const n = is3d ? 4 : 3;\n  const fixedDirection = getDirectionByPos(offsetFixedPosition, width, height);\n  const nextFixedPosition = calculatePosition(\n    allMatrix,\n    offsetFixedPosition,\n    n\n  );\n  const fixedOffset = [\n    width ? 0 : offsetFixedPosition[0],\n    height ? 0 : offsetFixedPosition[1],\n  ];\n\n  return {\n    fixedPosition: nextFixedPosition,\n    fixedDirection,\n    fixedOffset,\n  };\n}\n","import {\n  triggerEvent,\n  fillParams,\n  fillEndParams,\n  getAbsolutePosesByState,\n  catchEvent,\n  getOffsetSizeDist,\n  getProps,\n  getDirectionCondition,\n  calculatePoses,\n  fillAfterTransform,\n  getDirectionViewClassName,\n  getTotalDirection,\n  abs,\n} from \"../utils\";\nimport {\n  setDragStart,\n  getResizeDist,\n  getAbsolutePosition,\n  getNextMatrix,\n  getNextTransforms,\n} from \"../gesto/gesto-utils\";\nimport {\n  ResizableProps,\n  OnResizeGroup,\n  OnResizeGroupEnd,\n  OnResizeGroupStart,\n  DraggableProps,\n  OnDrag,\n  OnResizeStart,\n  SnappableState,\n  OnResize,\n  OnResizeEnd,\n  MoveableManagerInterface,\n  MoveableGroupInterface,\n  SnappableProps,\n  OnBeforeResize,\n  OnBeforeResizeGroup,\n  ResizableRequestParam,\n} from \"../types\";\nimport { getRenderDirections } from \"../render-directions\";\nimport {\n  fillChildEvents,\n  startChildDist,\n  triggerChildAbles,\n} from \"../group-utils\";\nimport Draggable from \"./draggable\";\nimport {\n  calculate,\n  convertDimension,\n  createRotateMatrix,\n  plus,\n} from \"../../matrix\";\nimport CustomGesto, { setCustomDrag } from \"../gesto/custom-gesto\";\nimport { checkSnapResize } from \"./snappable\";\nimport {\n  calculateBoundSize,\n  isString,\n  convertUnitSize,\n  throttle,\n  isNumber,\n} from \"../../utility\";\nimport { TINY_NUM } from \"../consts\";\nimport { parseMat } from \"../../css-to-mat\";\nimport {\n  getFixedDirectionInfo,\n  getOffsetFixedPositionInfo,\n} from \"../utils/get-fixed-direction\";\n\n/**\n * @namespace Resizable\n * @memberof Moveable\n * @description Resizable indicates whether the target's width and height can be increased or decreased.\n */\n\nconst directionCondition = getDirectionCondition(\"resizable\");\n\nexport default {\n  name: \"resizable\",\n  ableGroup: \"size\",\n  canPinch: true,\n  props: [\n    \"resizable\",\n    \"throttleResize\",\n    \"renderDirections\",\n    \"displayAroundControls\",\n    \"keepRatio\",\n    \"resizeFormat\",\n    \"keepRatioFinally\",\n    \"edge\",\n    \"checkResizableError\",\n  ] as const,\n  events: [\n    \"resizeStart\",\n    \"beforeResize\",\n    \"resize\",\n    \"resizeEnd\",\n    \"resizeGroupStart\",\n    \"beforeResizeGroup\",\n    \"resizeGroup\",\n    \"resizeGroupEnd\",\n  ] as const,\n  render: getRenderDirections(\"resizable\"),\n  dragControlCondition: directionCondition,\n  viewClassName: getDirectionViewClassName(\"resizable\"),\n  dragControlStart(\n    moveable: MoveableManagerInterface<\n      ResizableProps & DraggableProps,\n      SnappableState\n    >,\n    e: any\n  ) {\n    const {\n      inputEvent,\n      isPinch,\n      isGroup,\n      parentDirection,\n      parentGesto,\n      datas,\n      parentFixedDirection,\n      parentEvent,\n    } = e;\n\n    const direction = getTotalDirection(\n      parentDirection,\n      isPinch,\n      inputEvent,\n      datas\n    );\n\n    const state = moveable.state;\n    const { target, width, height, gestos } = state;\n\n    if (!direction || !target) {\n      return false;\n    }\n    if (gestos.resizable) {\n      return false;\n    }\n    gestos.resizable = parentGesto || moveable.controlGesto;\n    !isPinch && setDragStart(moveable, e);\n\n    datas.datas = {};\n    datas.direction = direction;\n    datas.startOffsetWidth = width;\n    datas.startOffsetHeight = height;\n    datas.prevWidth = 0;\n    datas.prevHeight = 0;\n\n    datas.minSize = [0, 0];\n\n    datas.startWidth = state.inlineCSSWidth || state.cssWidth;\n    datas.startHeight = state.inlineCSSHeight || state.cssHeight;\n    datas.maxSize = [Infinity, Infinity];\n\n    if (!isGroup) {\n      datas.minSize = [state.minOffsetWidth, state.minOffsetHeight];\n      datas.maxSize = [state.maxOffsetWidth, state.maxOffsetHeight];\n    }\n    const transformOrigin = moveable.props.transformOrigin || \"% %\";\n\n    datas.transformOrigin =\n      transformOrigin && isString(transformOrigin)\n        ? transformOrigin.split(\" \")\n        : transformOrigin;\n\n    datas.startOffsetMatrix = state.offsetMatrix;\n    datas.startTransformOrigin = state.transformOrigin;\n\n    datas.isWidth =\n      e?.parentIsWidth ??\n      ((!direction[0] && !direction[1]) || direction[0] || !direction[1]);\n\n    function setRatio(ratio: number) {\n      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\n    }\n\n    datas.startPositions = getAbsolutePosesByState(moveable.state);\n\n    function setFixedDirection(fixedDirection: number[]) {\n      const result = getFixedDirectionInfo(\n        datas.startPositions,\n        fixedDirection\n      );\n\n      datas.fixedDirection = result.fixedDirection;\n      datas.fixedPosition = result.fixedPosition;\n      datas.fixedOffset = result.fixedOffset;\n    }\n    function setFixedPosition(fixedPosition: number[]) {\n      const result = getOffsetFixedPositionInfo(moveable.state, fixedPosition);\n\n      datas.fixedDirection = result.fixedDirection;\n      datas.fixedPosition = result.fixedPosition;\n      datas.fixedOffset = result.fixedOffset;\n    }\n    function setMin(minSize: Array<string | number>) {\n      datas.minSize = [\n        convertUnitSize(`${minSize[0]}`, 0) || 0,\n        convertUnitSize(`${minSize[1]}`, 0) || 0,\n      ];\n    }\n    function setMax(maxSize: Array<string | number>) {\n      const nextMaxSize = [maxSize[0] || Infinity, maxSize[1] || Infinity];\n      if (!isNumber(nextMaxSize[0]) || isFinite(nextMaxSize[0])) {\n        nextMaxSize[0] = convertUnitSize(`${nextMaxSize[0]}`, 0) || Infinity;\n      }\n      if (!isNumber(nextMaxSize[1]) || isFinite(nextMaxSize[1])) {\n        nextMaxSize[1] = convertUnitSize(`${nextMaxSize[1]}`, 0) || Infinity;\n      }\n      datas.maxSize = nextMaxSize;\n    }\n\n    setRatio(width / height);\n    setFixedDirection(parentFixedDirection || [-direction[0], -direction[1]]);\n\n    datas.setFixedDirection = setFixedDirection;\n    datas.setFixedPosition = setFixedPosition;\n    datas.setMin = setMin;\n    datas.setMax = setMax;\n    const params = fillParams<OnResizeStart>(moveable, e, {\n      direction,\n      startRatio: datas.ratio,\n      set: ([startWidth, startHeight]: number[]) => {\n        datas.startWidth = startWidth;\n        datas.startHeight = startHeight;\n      },\n      setMin,\n      setMax,\n      setRatio,\n      setFixedDirection,\n      setFixedPosition,\n      setOrigin: (origin: Array<string | number>) => {\n        datas.transformOrigin = origin;\n      },\n      dragStart: Draggable.dragStart(\n        moveable,\n        new CustomGesto().dragStart([0, 0], e)\n      ),\n    });\n    const result =\n      parentEvent || triggerEvent(moveable, \"onResizeStart\", params);\n\n    datas.startFixedDirection = datas.fixedDirection;\n    datas.startFixedPosition = datas.fixedPosition;\n    if (result !== false) {\n      datas.isResize = true;\n      moveable.state.snapRenderInfo = {\n        request: e.isRequest,\n        direction,\n      };\n    }\n    return datas.isResize ? params : false;\n  },\n  dragControl(\n    moveable: MoveableManagerInterface<\n      ResizableProps & DraggableProps & SnappableProps\n    >,\n    e: any\n  ) {\n    const {\n      datas,\n      parentFlag,\n      isPinch,\n      parentKeepRatio,\n      dragClient,\n      parentDist,\n      useSnap,\n      isRequest,\n      isGroup,\n      parentEvent,\n      resolveMatrix,\n    } = e;\n\n    const {\n      isResize,\n      transformOrigin,\n      startWidth,\n      startHeight,\n      prevWidth,\n      prevHeight,\n      minSize,\n      maxSize,\n      ratio,\n      startOffsetWidth,\n      startOffsetHeight,\n      isWidth,\n    } = datas;\n\n    if (!isResize) {\n      return;\n    }\n    if (resolveMatrix) {\n      const { is3d } = moveable.state;\n      const { startOffsetMatrix, startTransformOrigin } = datas;\n      const n = is3d ? 4 : 3;\n      let targetMatrix = parseMat(getNextTransforms(e));\n      const targetN = Math.sqrt(targetMatrix.length);\n\n      if (n !== targetN) {\n        targetMatrix = convertDimension(targetMatrix, targetN, n);\n      }\n\n      const nextAllMatrix = getNextMatrix(\n        startOffsetMatrix,\n        targetMatrix,\n        startTransformOrigin,\n        n\n      );\n      const poses = calculatePoses(\n        nextAllMatrix,\n        startOffsetWidth,\n        startOffsetHeight,\n        n\n      );\n\n      datas.startPositions = poses;\n      datas.nextTargetMatrix = targetMatrix;\n      datas.nextAllMatrix = nextAllMatrix;\n    }\n    const props = getProps(moveable.props, \"resizable\");\n    const {\n      resizeFormat,\n      throttleResize = parentFlag ? 0 : 1,\n      parentMoveable,\n      keepRatioFinally,\n    } = props;\n    const direction = datas.direction;\n    let sizeDirection = direction;\n    let distWidth = 0;\n    let distHeight = 0;\n\n    if (!direction[0] && !direction[1]) {\n      sizeDirection = [1, 1];\n    }\n    const keepRatio =\n      (ratio &&\n        (parentKeepRatio != null ? parentKeepRatio : props.keepRatio)) ||\n      false;\n\n    function getNextBoundingSize() {\n      const fixedDirection = datas.fixedDirection;\n      const nextSize = getOffsetSizeDist(sizeDirection, keepRatio, datas, e);\n\n      distWidth = nextSize.distWidth;\n      distHeight = nextSize.distHeight;\n\n      let nextWidth =\n        sizeDirection[0] - fixedDirection[0] || keepRatio\n          ? Math.max(startOffsetWidth + distWidth, TINY_NUM)\n          : startOffsetWidth;\n      let nextHeight =\n        sizeDirection[1] - fixedDirection[1] || keepRatio\n          ? Math.max(startOffsetHeight + distHeight, TINY_NUM)\n          : startOffsetHeight;\n\n      if (keepRatio && startOffsetWidth && startOffsetHeight) {\n        // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight\n        if (isWidth) {\n          nextHeight = nextWidth / ratio;\n        } else {\n          nextWidth = nextHeight * ratio;\n        }\n      }\n      return [nextWidth, nextHeight];\n    }\n\n    let [boundingWidth, boundingHeight] = getNextBoundingSize();\n\n    if (!parentEvent) {\n      datas.setFixedDirection(datas.fixedDirection);\n\n      triggerEvent(\n        moveable,\n        \"onBeforeResize\",\n        fillParams<OnBeforeResize>(\n          moveable,\n          e,\n          {\n            startFixedDirection: datas.startFixedDirection,\n            startFixedPosition: datas.startFixedPosition,\n            setFixedDirection(nextFixedDirection: number[]) {\n              datas.setFixedDirection(nextFixedDirection);\n\n              [boundingWidth, boundingHeight] = getNextBoundingSize();\n\n              return [boundingWidth, boundingHeight];\n            },\n            setFixedPosition(nextFixedPosition: number[]) {\n              datas.setFixedPosition(nextFixedPosition);\n\n              [boundingWidth, boundingHeight] = getNextBoundingSize();\n\n              return [boundingWidth, boundingHeight];\n            },\n            boundingWidth,\n            boundingHeight,\n            setSize(size: number[]) {\n              [boundingWidth, boundingHeight] = size;\n            },\n          },\n          true\n        )\n      );\n    }\n\n    let fixedPosition = dragClient;\n\n    if (!dragClient) {\n      if (!parentFlag && isPinch) {\n        fixedPosition = getAbsolutePosition(moveable, [0, 0]);\n      } else {\n        fixedPosition = datas.fixedPosition;\n      }\n    }\n\n    let snapDist = [0, 0];\n\n    if (!isPinch) {\n      snapDist = checkSnapResize(\n        moveable,\n        boundingWidth,\n        boundingHeight,\n        direction,\n        fixedPosition,\n        !useSnap && isRequest,\n        datas\n      );\n    }\n    if (parentDist) {\n      !parentDist[0] && (snapDist[0] = 0);\n      !parentDist[1] && (snapDist[1] = 0);\n    }\n\n    function computeSize() {\n      if (resizeFormat) {\n        [boundingWidth, boundingHeight] = resizeFormat([\n          boundingWidth,\n          boundingHeight,\n        ]);\n      }\n      boundingWidth = throttle(boundingWidth, throttleResize!);\n      boundingHeight = throttle(boundingHeight, throttleResize!);\n    }\n    if (keepRatio) {\n      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n        if (abs(snapDist[0]) > abs(snapDist[1])) {\n          snapDist[1] = 0;\n        } else {\n          snapDist[0] = 0;\n        }\n      }\n      const isNoSnap = !snapDist[0] && !snapDist[1];\n\n      if (isNoSnap) {\n        // pre-compute before maintaining the ratio\n        computeSize();\n      }\n      if (\n        (sizeDirection[0] && !sizeDirection[1]) ||\n        (snapDist[0] && !snapDist[1]) ||\n        (isNoSnap && isWidth)\n      ) {\n        boundingWidth += snapDist[0];\n        boundingHeight = boundingWidth / ratio;\n      } else if (\n        (!sizeDirection[0] && sizeDirection[1]) ||\n        (!snapDist[0] && snapDist[1]) ||\n        (isNoSnap && !isWidth)\n      ) {\n        boundingHeight += snapDist[1];\n        boundingWidth = boundingHeight * ratio;\n      }\n    } else {\n      boundingWidth += snapDist[0];\n      boundingHeight += snapDist[1];\n\n      boundingWidth = Math.max(0, boundingWidth);\n      boundingHeight = Math.max(0, boundingHeight);\n    }\n\n    [boundingWidth, boundingHeight] = calculateBoundSize(\n      [boundingWidth, boundingHeight],\n      minSize,\n      maxSize,\n      keepRatio ? ratio : false\n    );\n    computeSize();\n\n    if (keepRatio && (isGroup || keepRatioFinally)) {\n      if (isWidth) {\n        boundingHeight = boundingWidth / ratio;\n      } else {\n        boundingWidth = boundingHeight * ratio;\n      }\n    }\n    distWidth = boundingWidth - startOffsetWidth;\n    distHeight = boundingHeight - startOffsetHeight;\n\n    const delta = [distWidth - prevWidth, distHeight - prevHeight];\n\n    datas.prevWidth = distWidth;\n    datas.prevHeight = distHeight;\n\n    const inverseDelta = getResizeDist(\n      moveable,\n      boundingWidth,\n      boundingHeight,\n      fixedPosition,\n      transformOrigin,\n      datas\n    );\n\n    if (\n      !parentMoveable &&\n      delta.every((num) => !num) &&\n      inverseDelta.every((num) => !num)\n    ) {\n      return;\n    }\n    const drag = Draggable.drag(\n      moveable,\n      setCustomDrag(\n        e,\n        moveable.state,\n        inverseDelta,\n        !!isPinch,\n        false,\n        \"draggable\"\n      )\n    ) as OnDrag;\n    const transform = drag.transform;\n\n    const nextWidth = startWidth + distWidth;\n    const nextHeight = startHeight + distHeight;\n\n    const params = fillParams<OnResize>(moveable, e, {\n      width: nextWidth,\n      height: nextHeight,\n      offsetWidth: Math.round(boundingWidth),\n      offsetHeight: Math.round(boundingHeight),\n      startRatio: ratio,\n      boundingWidth,\n      boundingHeight,\n      direction,\n      dist: [distWidth, distHeight],\n      delta,\n      isPinch: !!isPinch,\n      drag,\n      ...fillAfterTransform(\n        {\n          style: {\n            width: `${nextWidth}px`,\n            height: `${nextHeight}px`,\n          },\n          transform,\n        },\n        drag,\n        e\n      ),\n    });\n    !parentEvent && triggerEvent(moveable, \"onResize\", params);\n    return params;\n  },\n  dragControlAfter(\n    moveable: MoveableManagerInterface<ResizableProps & DraggableProps>,\n    e: any\n  ) {\n    const datas = e.datas;\n    const {\n      isResize,\n      startOffsetWidth,\n      startOffsetHeight,\n      prevWidth,\n      prevHeight,\n    } = datas;\n\n    if (!isResize || moveable.props.checkResizableError === false) {\n      return;\n    }\n    const { width, height } = moveable.state;\n    const errorWidth = width - (startOffsetWidth + prevWidth);\n    const errorHeight = height - (startOffsetHeight + prevHeight);\n    const isErrorWidth = abs(errorWidth) > 3;\n    const isErrorHeight = abs(errorHeight) > 3;\n\n    if (isErrorWidth) {\n      datas.startWidth += errorWidth;\n      datas.startOffsetWidth += errorWidth;\n      datas.prevWidth += errorWidth;\n    }\n    if (isErrorHeight) {\n      datas.startHeight += errorHeight;\n      datas.startOffsetHeight += errorHeight;\n      datas.prevHeight += errorHeight;\n    }\n    if (isErrorWidth || isErrorHeight) {\n      return this.dragControl(moveable, e);\n    }\n  },\n  dragControlEnd(\n    moveable: MoveableManagerInterface<ResizableProps & DraggableProps>,\n    e: any\n  ) {\n    const { datas, parentEvent } = e;\n    if (!datas.isResize) {\n      return;\n    }\n    datas.isResize = false;\n\n    const params = fillEndParams<OnResizeEnd>(moveable, e, {});\n    !parentEvent && triggerEvent(moveable, \"onResizeEnd\", params);\n    return params;\n  },\n  dragGroupControlCondition: directionCondition,\n  dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { datas } = e;\n    const params = this.dragControlStart(moveable, { ...e, isGroup: true });\n\n    if (!params) {\n      return false;\n    }\n    const originalEvents = fillChildEvents(moveable, \"resizable\", e);\n    const {\n      startOffsetWidth: parentStartOffsetWidth,\n      startOffsetHeight: parentStartOffsetHeight,\n    } = datas;\n\n    function updateGroupMin() {\n      const originalMinSize = datas.minSize;\n      originalEvents.forEach((ev) => {\n        const {\n          minSize: childMinSize,\n          startOffsetWidth: childStartOffsetWidth,\n          startOffsetHeight: childStartOffsetHeight,\n        } = ev.datas;\n\n        const parentMinWidth =\n          parentStartOffsetWidth *\n          (childStartOffsetWidth ? childMinSize[0] / childStartOffsetWidth : 0);\n        const parentMinHeight =\n          parentStartOffsetHeight *\n          (childStartOffsetHeight\n            ? childMinSize[1] / childStartOffsetHeight\n            : 0);\n\n        originalMinSize[0] = Math.max(originalMinSize[0], parentMinWidth);\n        originalMinSize[1] = Math.max(originalMinSize[1], parentMinHeight);\n      });\n    }\n\n    function updateGroupMax() {\n      const originalMaxSize = datas.maxSize;\n      originalEvents.forEach((ev) => {\n        const {\n          maxSize: childMaxSize,\n          startOffsetWidth: childStartOffsetWidth,\n          startOffsetHeight: childStartOffsetHeight,\n        } = ev.datas;\n\n        const parentMaxWidth =\n          parentStartOffsetWidth *\n          (childStartOffsetWidth ? childMaxSize[0] / childStartOffsetWidth : 0);\n        const parentMaxHeight =\n          parentStartOffsetHeight *\n          (childStartOffsetHeight\n            ? childMaxSize[1] / childStartOffsetHeight\n            : 0);\n\n        originalMaxSize[0] = Math.min(originalMaxSize[0], parentMaxWidth);\n        originalMaxSize[1] = Math.min(originalMaxSize[1], parentMaxHeight);\n      });\n    }\n    const events = triggerChildAbles(\n      moveable,\n      this,\n      \"dragControlStart\",\n      e,\n      (child, ev) => {\n        return startChildDist(moveable, child, datas, ev);\n      }\n    );\n\n    updateGroupMin();\n    updateGroupMax();\n\n    const setFixedDirection = (fixedDirection: number[]) => {\n      params.setFixedDirection(fixedDirection);\n      events.forEach((ev, i) => {\n        ev.setFixedDirection(fixedDirection);\n        startChildDist(moveable, ev.moveable, datas, originalEvents[i]);\n      });\n    };\n\n    datas.setFixedDirection = setFixedDirection;\n\n    const nextParams: OnResizeGroupStart = {\n      ...params,\n      targets: moveable.props.targets!,\n      events: events.map((ev) => {\n        return {\n          ...ev,\n          setMin: (minSize: Array<number | string>) => {\n            ev.setMin(minSize);\n            updateGroupMin();\n          },\n          setMax: (maxSize: Array<number | string>) => {\n            ev.setMax(maxSize);\n            updateGroupMax();\n          },\n        };\n      }),\n      setFixedDirection,\n      setMin: (minSize: Array<number | string>) => {\n        params.setMin(minSize);\n        updateGroupMin();\n      },\n      setMax: (maxSize: Array<number | string>) => {\n        params.setMax(maxSize);\n        updateGroupMax();\n      },\n    };\n    const result = triggerEvent(moveable, \"onResizeGroupStart\", nextParams);\n\n    datas.isResize = result !== false;\n    return datas.isResize ? params : false;\n  },\n  dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { datas } = e;\n    if (!datas.isResize) {\n      return;\n    }\n    const props = getProps(moveable.props, \"resizable\");\n\n    catchEvent(moveable, \"onBeforeResize\", (parentEvent) => {\n      triggerEvent(\n        moveable,\n        \"onBeforeResizeGroup\",\n        fillParams<OnBeforeResizeGroup>(\n          moveable,\n          e,\n          {\n            ...parentEvent,\n            targets: props.targets!,\n          },\n          true\n        )\n      );\n    });\n\n    const params = this.dragControl(moveable, { ...e, isGroup: true });\n\n    if (!params) {\n      return;\n    }\n    const { boundingWidth, boundingHeight, dist } = params;\n\n    const keepRatio = props.keepRatio;\n\n    const parentScale = [\n      boundingWidth / (boundingWidth - dist[0]),\n      boundingHeight / (boundingHeight - dist[1]),\n    ];\n    const fixedPosition = datas.fixedPosition;\n\n    const events = triggerChildAbles(\n      moveable,\n      this,\n      \"dragControl\",\n      e,\n      (_, ev) => {\n        const [clientX, clientY] = calculate(\n          createRotateMatrix((moveable.rotation / 180) * Math.PI, 3),\n          [\n            ev.datas.originalX * parentScale[0],\n            ev.datas.originalY * parentScale[1],\n            1,\n          ],\n          3\n        );\n\n        return {\n          ...ev,\n          parentDist: null,\n          parentScale,\n          dragClient: plus(fixedPosition, [clientX, clientY]),\n          parentKeepRatio: keepRatio,\n        };\n      }\n    );\n    const nextParams: OnResizeGroup = {\n      targets: props.targets!,\n      events,\n      ...params,\n    };\n\n    triggerEvent(moveable, \"onResizeGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { isDrag, datas } = e;\n\n    if (!datas.isResize) {\n      return;\n    }\n\n    this.dragControlEnd(moveable, e);\n    const events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n\n    const nextParams: OnResizeGroupEnd = fillEndParams<OnResizeGroupEnd>(\n      moveable,\n      e,\n      {\n        targets: moveable.props.targets!,\n        events,\n      }\n    );\n\n    triggerEvent(moveable, \"onResizeGroupEnd\", nextParams);\n    return isDrag;\n  },\n  /**\n     * @method Moveable.Resizable#request\n     * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"resizable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"resizable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 });\n     * moveable.request(\"resizable\", { offsetWidth: 110, offsetHeight: 100 });\n     * moveable.request(\"resizable\", { offsetWidth: 120, offsetHeight: 100 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n  request(moveable: MoveableManagerInterface<any>) {\n    const datas: Record<string, any> = {};\n    let distWidth = 0;\n    let distHeight = 0;\n    let useSnap = false;\n    const rect = moveable.getRect();\n\n    return {\n      isControl: true,\n      requestStart(e: ResizableRequestParam) {\n        useSnap = e.useSnap!;\n\n        return {\n          datas,\n          parentDirection: e.direction || [1, 1],\n          parentIsWidth: e?.horizontal ?? true,\n          useSnap,\n        };\n      },\n      request(e: ResizableRequestParam) {\n        if (\"offsetWidth\" in e) {\n          distWidth = e.offsetWidth! - rect.offsetWidth;\n        } else if (\"deltaWidth\" in e) {\n          distWidth += e.deltaWidth!;\n        }\n        if (\"offsetHeight\" in e) {\n          distHeight = e.offsetHeight! - rect.offsetHeight;\n        } else if (\"deltaHeight\" in e) {\n          distHeight += e.deltaHeight!;\n        }\n\n        return {\n          datas,\n          parentDist: [distWidth, distHeight],\n          parentKeepRatio: e.keepRatio,\n          useSnap,\n        };\n      },\n      requestEnd() {\n        return { datas, isDrag: true, useSnap };\n      },\n    };\n  },\n  unset(moveable: MoveableManagerInterface<any, {}>) {\n    moveable.state.gestos.resizable = null;\n  },\n};\n\n/**\n * Whether or not target can be resized.\n * @name Moveable.Resizable#resizable\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     resizable: false,\n * });\n *\n * moveable.resizable = true;\n */\n\n/**\n * throttle of width, height when resize. If throttleResize is set to less than 1, the target may shake.\n * @name Moveable.Resizable#throttleResize\n * @default 1\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   throttleResize: 1,\n * });\n *\n * moveable.throttleResize = 0;\n */\n/**\n * When resize or scale, keeps a ratio of the width, height.\n * @name Moveable.Resizable#keepRatio\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n/**\n * Set directions to show the control box.\n * @name Moveable.Resizable#renderDirections\n * @default [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"]\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n\n/**\n * Function to convert size for resize\n * @name Moveable.Resizable#resizeFormat\n * @default oneself\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   resizeFormat: v => v,\n * });\n *\n * moveable.resizeFormat = (size: number[]) => ([Math.trunc(size[0]), Math.trunc(size[1])];\n */\n\n/**\n * When the resize starts, the resizeStart event is called.\n * @memberof Moveable.Resizable\n * @event resizeStart\n * @param {Moveable.Resizable.OnResizeStart} - Parameters for the resizeStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When resizing, `beforeResize` is called before `resize` occurs. In `beforeResize`, you can get and set the pre-value before resizing.\n * @memberof Moveable.Resizable\n * @event beforeResize\n * @param {Moveable.Resizable.OnBeforeResize} - Parameters for the `beforeResize` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"beforeResize\", ({ setFixedDirection }) => {\n *     if (shiftKey) {\n *        setFixedDirection([0, 0]);\n *     }\n * });\n * moveable.on(\"resize\", ({ target, width, height, drag }) => {\n *     target.style.width = `${width}px`;\n *     target.style.height = `${height}px`;\n *     target.style.transform = drag.transform;\n * });\n */\n\n/**\n * When resizing, the resize event is called.\n * @memberof Moveable.Resizable\n * @event resize\n * @param {Moveable.Resizable.OnResize} - Parameters for the resize event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resize\", ({ target, width, height }) => {\n *     target.style.width = `${e.width}px`;\n *     target.style.height = `${e.height}px`;\n * });\n */\n/**\n * When the resize finishes, the resizeEnd event is called.\n * @memberof Moveable.Resizable\n * @event resizeEnd\n * @param {Moveable.Resizable.OnResizeEnd} - Parameters for the resizeEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n * When the group resize starts, the `resizeGroupStart` event is called.\n * @memberof Moveable.Resizable\n * @event resizeGroupStart\n * @param {Moveable.Resizable.OnResizeGroupStart} - Parameters for the `resizeGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroupStart\", ({ targets }) => {\n *     console.log(\"onResizeGroupStart\", targets);\n * });\n */\n\n/**\n * When the group resize, the `resizeGroup` event is called.\n * @memberof Moveable.Resizable\n * @event resizeGroup\n * @param {Moveable.Resizable.onResizeGroup} - Parameters for the `resizeGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroup\", ({ targets, events }) => {\n *     console.log(\"onResizeGroup\", targets);\n *     events.forEach(ev => {\n *         const offset = [\n *             direction[0] < 0 ? -ev.delta[0] : 0,\n *             direction[1] < 0 ? -ev.delta[1] : 0,\n *         ];\n *         // ev.drag is a drag event that occurs when the group resize.\n *         const left = offset[0] + ev.drag.beforeDist[0];\n *         const top = offset[1] + ev.drag.beforeDist[1];\n *         const width = ev.width;\n *         const top = ev.top;\n *     });\n * });\n */\n\n/**\n * When the group resize finishes, the `resizeGroupEnd` event is called.\n * @memberof Moveable.Resizable\n * @event resizeGroupEnd\n * @param {Moveable.Resizable.OnResizeGroupEnd} - Parameters for the `resizeGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onResizeGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n  prefix,\n  triggerEvent,\n  fillParams,\n  calculatePosition,\n  fillEndParams,\n  getRotationRad,\n  getRefTargets,\n  catchEvent,\n  getProps,\n  calculateMoveableClientPositions,\n  fillAfterTransform,\n  getTotalOrigin,\n} from \"../utils\";\nimport {\n  IObject,\n  hasClass,\n  getRad,\n  throttle,\n  getDist,\n  getKeys,\n  isArray,\n} from \"../../utility\";\nimport {\n  RotatableProps,\n  OnRotateGroup,\n  OnRotateGroupEnd,\n  Renderer,\n  OnRotateGroupStart,\n  OnRotateStart,\n  OnRotate,\n  OnRotateEnd,\n  MoveableClientRect,\n  SnappableProps,\n  SnappableState,\n  MoveableManagerInterface,\n  MoveableGroupInterface,\n  DraggableProps,\n  OnBeforeRotate,\n  OnBeforeRotateGroup,\n  OnResizeStart,\n  OnResize,\n  TransformObject,\n  OnDragStart,\n} from \"../types\";\nimport { triggerChildAbles } from \"../group-utils\";\nimport {\n  calculate,\n  convertPositionMatrix,\n  getOrigin,\n  minus,\n  plus,\n  rotate as rotateMatrix,\n} from \"../../matrix\";\nimport CustomGesto, { setCustomDrag } from \"../gesto/custom-gesto\";\nimport { checkSnapRotate } from \"./snappable\";\nimport {\n  fillTransformStartEvent,\n  convertTransformFormat,\n  getRotateDist,\n  fillTransformEvent,\n  setDefaultTransformIndex,\n  resolveTransformEvent,\n  getTransformDirection,\n  getPosByDirection,\n  getTranslateFixedPosition,\n} from \"../gesto/gesto-utils\";\nimport {\n  DirectionControlInfo,\n  renderAroundControls,\n  renderDirectionControlsByInfos,\n} from \"../render-directions\";\nimport { DIRECTION_REGION_TO_DIRECTION } from \"../consts\";\nimport Resizable from \"./resizable\";\nimport Draggable from \"./draggable\";\nimport {\n  getOffsetFixedDirectionInfo,\n  getOffsetFixedPositionInfo,\n} from \"../utils/get-fixed-direction\";\n\n/**\n * @namespace Rotatable\n * @memberof Moveable\n * @description Rotatable indicates whether the target can be rotated.\n */\n\nfunction setRotateStartInfo(\n  moveable: MoveableManagerInterface<any, any>,\n  datas: IObject<any>,\n  clientX: number,\n  clientY: number,\n  rect: MoveableClientRect\n) {\n  const groupable = moveable.props.groupable;\n  const state = moveable.state;\n  const n = state.is3d ? 4 : 3;\n  const origin = datas.origin;\n  const nextOrigin = calculatePosition(\n    moveable.state.rootMatrix,\n    // TO-DO #710\n    minus([origin[0], origin[1]], groupable ? [0, 0] : [state.left, state.top]),\n    n\n  );\n  const startAbsoluteOrigin = plus([rect.left, rect.top], nextOrigin);\n\n  datas.startAbsoluteOrigin = startAbsoluteOrigin;\n  datas.prevDeg =\n    (getRad(startAbsoluteOrigin, [clientX, clientY]) / Math.PI) * 180;\n  datas.defaultDeg = datas.prevDeg;\n  datas.prevSnapDeg = 0;\n  datas.loop = 0;\n  datas.startDist = getDist(startAbsoluteOrigin, [clientX, clientY]);\n}\n\nfunction getAbsoluteDist(deg: number, direction: number, datas: IObject<any>) {\n  const { defaultDeg, prevDeg } = datas;\n\n  let normalizedPrevDeg = prevDeg % 360;\n  let loop = Math.floor(prevDeg / 360);\n\n  if (normalizedPrevDeg < 0) {\n    normalizedPrevDeg += 360;\n  }\n\n  if (normalizedPrevDeg > deg && normalizedPrevDeg > 270 && deg < 90) {\n    // 360 => 0\n    ++loop;\n  } else if (normalizedPrevDeg < deg && normalizedPrevDeg < 90 && deg > 270) {\n    // 0 => 360\n    --loop;\n  }\n  const dist = direction * (loop * 360 + deg - defaultDeg);\n\n  datas.prevDeg = defaultDeg + dist;\n\n  return dist;\n}\nfunction getAbsoluteDistByClient(\n  clientX: number,\n  clientY: number,\n  direction: number,\n  datas: IObject<any>\n) {\n  return getAbsoluteDist(\n    (getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI) * 180,\n    direction,\n    datas\n  );\n}\nfunction getRotateInfo(\n  moveable: MoveableManagerInterface<any, any>,\n  moveableRect: any,\n  datas: IObject<any>,\n  dist: number,\n  startValue: number,\n  checkSnap?: boolean\n) {\n  const { throttleRotate = 0 } = moveable.props;\n  const prevSnapDeg = datas.prevSnapDeg;\n  let snapRotation = 0;\n  let isSnap = false;\n\n  if (checkSnap) {\n    const result = checkSnapRotate(\n      moveable,\n      moveableRect,\n      dist,\n      startValue + dist\n    );\n\n    isSnap = result.isSnap;\n    snapRotation = startValue + result.dist;\n  }\n\n  if (!isSnap) {\n    snapRotation = throttle(startValue + dist, throttleRotate);\n  }\n  const snapDeg = snapRotation - startValue;\n\n  datas.prevSnapDeg = snapDeg;\n\n  return [snapDeg - prevSnapDeg, snapDeg, snapRotation];\n}\n\nexport function getReversePositionX(dir: string) {\n  if (dir === \"left\") {\n    return \"right\";\n  } else if (dir === \"right\") {\n    return \"left\";\n  }\n  return dir;\n}\nexport function getReversePositionY(dir: string) {\n  if (dir === \"top\") {\n    return \"bottom\";\n  } else if (dir === \"bottom\") {\n    return \"top\";\n  }\n  return dir;\n}\nexport function getRotationPositions(\n  rotationPosition: RotatableProps[\"rotationPosition\"],\n  [pos1, pos2, pos3, pos4]: number[][],\n  direction: number\n): [number[], number][] {\n  if (rotationPosition === \"none\") {\n    return [];\n  }\n  if (isArray(rotationPosition)) {\n    return rotationPosition.map(\n      (child) =>\n        getRotationPositions(child, [pos1, pos2, pos3, pos4], direction)[0]\n    );\n  }\n  const [dir1, dir2] = (rotationPosition || \"top\").split(\"-\");\n  let radPoses = [pos1, pos2];\n\n  if (dir1 === \"left\") {\n    radPoses = [pos3, pos1];\n  } else if (dir1 === \"right\") {\n    radPoses = [pos2, pos4];\n  } else if (dir1 === \"bottom\") {\n    radPoses = [pos4, pos3];\n  }\n  let pos = [\n    (radPoses[0][0] + radPoses[1][0]) / 2,\n    (radPoses[0][1] + radPoses[1][1]) / 2,\n  ];\n  const rad = getRotationRad(radPoses, direction);\n  if (dir2) {\n    const isStart = dir2 === \"top\" || dir2 === \"left\";\n    const isReverse = dir1 === \"bottom\" || dir1 === \"left\";\n\n    pos = radPoses[(isStart && !isReverse) || (!isStart && isReverse) ? 0 : 1];\n  }\n  return [[pos, rad]];\n}\n\nexport function dragControlCondition(\n  moveable: MoveableManagerInterface<RotatableProps>,\n  e: any\n) {\n  if (e.isRequest) {\n    return e.requestAble === \"rotatable\";\n  }\n  const target = e.inputEvent.target as HTMLElement;\n  if (\n    hasClass(target, prefix(\"rotation-control\")) ||\n    (moveable.props.rotateAroundControls &&\n      hasClass(target, prefix(\"around-control\"))) ||\n    (hasClass(target, prefix(\"control\")) &&\n      hasClass(target, prefix(\"rotatable\")))\n  ) {\n    return true;\n  }\n  const rotationTarget = moveable.props.rotationTarget;\n\n  if (rotationTarget) {\n    return getRefTargets(rotationTarget, true).some((element) => {\n      if (!element) {\n        return false;\n      }\n      return target === element || target.contains(element);\n    });\n  }\n  return false;\n}\n\nconst css = `.rotation {\nposition: absolute;\nheight: 40px;\nwidth: 1px;\ntransform-origin: 50% 100%;\nheight: calc(40px * var(--zoom));\ntop: auto;\nleft: 0;\nbottom: 100%;\nwill-change: transform;\n}\n.rotation .rotation-line {\ndisplay: block;\nwidth: 100%;\nheight: 100%;\ntransform-origin: 50% 50%;\n}\n.rotation .rotation-control {\nborder-color: #4af;\nborder-color: var(--moveable-color);\nbackground:#fff;\ncursor: alias;\n}\n:global .view-rotation-dragging, .rotatable.direction.control {\ncursor: alias;\n}\n.rotatable.direction.control.move {\ncursor: move;\n}\n`;\nexport default {\n  name: \"rotatable\",\n  canPinch: true,\n  props: [\n    \"rotatable\",\n    \"rotationPosition\",\n    \"throttleRotate\",\n    \"renderDirections\",\n    \"rotationTarget\",\n    \"rotateAroundControls\",\n    \"edge\",\n    \"resolveAblesWithRotatable\",\n    \"displayAroundControls\",\n  ] as const,\n  events: [\n    \"rotateStart\",\n    \"beforeRotate\",\n    \"rotate\",\n    \"rotateEnd\",\n    \"rotateGroupStart\",\n    \"beforeRotateGroup\",\n    \"rotateGroup\",\n    \"rotateGroupEnd\",\n  ] as const,\n  css: [css],\n  viewClassName(moveable: MoveableManagerInterface<RotatableProps>) {\n    if (!moveable.isDragging(\"rotatable\")) {\n      return \"\";\n    }\n    return prefix(\"view-rotation-dragging\");\n  },\n  render(\n    moveable: MoveableManagerInterface<RotatableProps>,\n    React: Renderer\n  ): any {\n    const {\n      rotatable,\n      rotationPosition,\n      zoom,\n      renderDirections,\n      rotateAroundControls,\n      resolveAblesWithRotatable,\n    } = getProps(moveable.props, \"rotatable\");\n    const { renderPoses, direction } = moveable.getState();\n    if (!rotatable) {\n      return null;\n    }\n    const positions = getRotationPositions(\n      rotationPosition!,\n      renderPoses,\n      direction\n    );\n    const jsxs: any[] = [];\n\n    positions.forEach(([pos, rad], i) => {\n      jsxs.push(\n        <div\n          key={`rotation${i}`}\n          className={prefix(\"rotation\")}\n          style={{\n            // tslint:disable-next-line: max-line-length\n            transform: `translate(-50%) translate(${pos[0]}px, ${pos[1]}px) rotate(${rad}rad)`,\n          }}\n        >\n          <div\n            className={prefix(\"line rotation-line\")}\n            style={{\n              transform: `scaleX(${zoom})`,\n            }}\n          ></div>\n          <div\n            className={prefix(\"control rotation-control\")}\n            style={{\n              transform: `translate(0.5px) scale(${zoom})`,\n            }}\n          ></div>\n        </div>\n      );\n    });\n    if (renderDirections) {\n      const ables = getKeys(resolveAblesWithRotatable || {});\n      const resolveMap: Record<string, string> = {};\n\n      ables.forEach((name) => {\n        resolveAblesWithRotatable![name]!.forEach((direction) => {\n          resolveMap[direction] = name;\n        });\n      });\n\n      let directionControlInfos: DirectionControlInfo[] = [];\n\n      if (isArray(renderDirections)) {\n        directionControlInfos = renderDirections.map((dir) => {\n          const able = resolveMap[dir];\n\n          return {\n            data: able ? { resolve: able } : {},\n            classNames: able ? [`move`] : [],\n            dir,\n          };\n        });\n      }\n\n      jsxs.push(\n        ...renderDirectionControlsByInfos(\n          moveable,\n          \"rotatable\",\n          directionControlInfos,\n          React\n        )\n      );\n    }\n    if (rotateAroundControls) {\n      jsxs.push(...renderAroundControls(moveable, React));\n    }\n\n    return jsxs;\n  },\n  dragControlCondition: dragControlCondition as (\n    moveable: any,\n    e: any\n  ) => boolean,\n  dragControlStart(\n    moveable: MoveableManagerInterface<\n      RotatableProps & SnappableProps & DraggableProps,\n      SnappableState\n    >,\n    e: any\n  ) {\n    const {\n      datas,\n      clientX,\n      clientY,\n      parentRotate,\n      parentFlag,\n      isPinch,\n      isRequest,\n    } = e;\n    const state = moveable.state;\n    const {\n      target,\n      left,\n      top,\n      direction,\n      beforeDirection,\n      targetTransform,\n      moveableClientRect,\n      offsetMatrix,\n      targetMatrix,\n      allMatrix,\n      width,\n      height,\n    } = state;\n\n    if (!isRequest && !target) {\n      return false;\n    }\n\n    const rect = moveable.getRect();\n    datas.rect = rect;\n    datas.transform = targetTransform;\n    datas.left = left;\n    datas.top = top;\n    let setFixedPosition = (fixedPosition: number[]) => {\n      const result = getOffsetFixedPositionInfo(moveable.state, fixedPosition);\n\n      datas.fixedDirection = result.fixedDirection;\n      datas.fixedOffset = result.fixedOffset;\n      datas.fixedPosition = result.fixedPosition;\n\n      if (resizeStart) {\n        resizeStart.setFixedPosition(fixedPosition);\n      }\n    };\n    let setFixedDirection: OnRotateStart[\"setFixedDirection\"] = (\n      fixedDirection: number[]\n    ) => {\n      const result = getOffsetFixedDirectionInfo(\n        moveable.state,\n        fixedDirection\n      );\n\n      datas.fixedDirection = result.fixedDirection;\n      datas.fixedOffset = result.fixedOffset;\n      datas.fixedPosition = result.fixedPosition;\n\n      if (resizeStart) {\n        resizeStart.setFixedDirection(fixedDirection);\n      }\n    };\n    let startClientX = clientX;\n    let startClientY = clientY;\n\n    if (isRequest || isPinch || parentFlag) {\n      const externalRotate = parentRotate || 0;\n\n      datas.beforeInfo = {\n        origin: rect.beforeOrigin,\n        prevDeg: externalRotate,\n        defaultDeg: externalRotate,\n        prevSnapDeg: 0,\n        startDist: 0,\n      };\n      datas.afterInfo = {\n        ...datas.beforeInfo,\n        origin: rect.origin,\n      };\n      datas.absoluteInfo = {\n        ...datas.beforeInfo,\n        origin: rect.origin,\n        startValue: externalRotate,\n      };\n    } else {\n      const inputTarget = e.inputEvent?.target;\n\n      if (inputTarget) {\n        const regionDirection =\n          inputTarget.getAttribute(\"data-direction\") || \"\";\n        const controlDirection = DIRECTION_REGION_TO_DIRECTION[regionDirection];\n\n        if (controlDirection) {\n          datas.isControl = true;\n          datas.isAroundControl = hasClass(\n            inputTarget,\n            prefix(\"around-control\")\n          );\n          datas.controlDirection = controlDirection;\n          const resolve = inputTarget.getAttribute(\"data-resolve\");\n\n          if (resolve) {\n            datas.resolveAble = resolve;\n          }\n\n          const clientPoses = calculateMoveableClientPositions(\n            state.rootMatrix,\n            state.renderPoses,\n            moveableClientRect\n          );\n\n          [startClientX, startClientY] = getPosByDirection(\n            clientPoses,\n            controlDirection\n          );\n        }\n      }\n      datas.beforeInfo = { origin: rect.beforeOrigin };\n      datas.afterInfo = { origin: rect.origin };\n      datas.absoluteInfo = {\n        origin: rect.origin,\n        startValue: rect.rotation,\n      };\n\n      const originalFixedPosition = setFixedPosition;\n\n      setFixedPosition = (fixedPosition: number[]) => {\n        const n = state.is3d ? 4 : 3;\n        const [originX, originY] = plus(\n          getOrigin(targetMatrix, n),\n          fixedPosition\n        );\n        const fixedBeforeOrigin = calculate(\n          offsetMatrix,\n          convertPositionMatrix([originX, originY], n)\n        );\n        const fixedAfterOrigin = calculate(\n          allMatrix,\n          convertPositionMatrix([fixedPosition[0], fixedPosition[1]], n)\n        );\n        originalFixedPosition(fixedPosition);\n        const posDelta = state.posDelta;\n\n        datas.beforeInfo.origin = minus(fixedBeforeOrigin, posDelta);\n        datas.afterInfo.origin = minus(fixedAfterOrigin, posDelta);\n        datas.absoluteInfo.origin = minus(fixedAfterOrigin, posDelta);\n\n        setRotateStartInfo(\n          moveable,\n          datas.beforeInfo,\n          startClientX,\n          startClientY,\n          moveableClientRect\n        );\n        setRotateStartInfo(\n          moveable,\n          datas.afterInfo,\n          startClientX,\n          startClientY,\n          moveableClientRect\n        );\n        setRotateStartInfo(\n          moveable,\n          datas.absoluteInfo,\n          startClientX,\n          startClientY,\n          moveableClientRect\n        );\n      };\n      setFixedDirection = (fixedDirection: number[]) => {\n        const fixedPosition = getPosByDirection(\n          [\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n          ],\n          fixedDirection\n        );\n\n        setFixedPosition(fixedPosition);\n      };\n    }\n\n    datas.startClientX = startClientX;\n    datas.startClientY = startClientY;\n    datas.direction = direction;\n    datas.beforeDirection = beforeDirection;\n    datas.startValue = 0;\n    datas.datas = {};\n\n    setDefaultTransformIndex(moveable, e, \"rotate\");\n\n    let dragStart: OnDragStart | false = false;\n    let resizeStart: OnResizeStart | false = false;\n\n    if (datas.isControl && datas.resolveAble) {\n      const resolveAble = datas.resolveAble;\n\n      if (resolveAble === \"resizable\") {\n        resizeStart = Resizable.dragControlStart(moveable, {\n          ...new CustomGesto(\"resizable\").dragStart([0, 0], e),\n          parentPosition: datas.controlPosition,\n          parentFixedPosition: datas.fixedPosition,\n        });\n      }\n    }\n\n    if (!resizeStart) {\n      dragStart = Draggable.dragStart!(\n        moveable,\n        new CustomGesto().dragStart([0, 0], e)\n      );\n    }\n\n    setFixedPosition(getTotalOrigin(moveable));\n    const params = fillParams<OnRotateStart>(moveable, e, {\n      set: (rotatation: number) => {\n        datas.startValue = (rotatation * Math.PI) / 180;\n      },\n      setFixedDirection,\n      setFixedPosition,\n      ...fillTransformStartEvent(moveable, e),\n      dragStart,\n      resizeStart,\n    });\n    const result = triggerEvent(moveable, \"onRotateStart\", params);\n    datas.isRotate = result !== false;\n    state.snapRenderInfo = {\n      request: e.isRequest,\n    };\n\n    return datas.isRotate ? params : false;\n  },\n  dragControl(\n    moveable: MoveableManagerInterface<RotatableProps & DraggableProps>,\n    e: any\n  ) {\n    const {\n      datas,\n      clientDistX,\n      clientDistY,\n      parentRotate,\n      parentFlag,\n      isPinch,\n      groupDelta,\n      resolveMatrix,\n    } = e;\n    const {\n      beforeDirection,\n      beforeInfo,\n      afterInfo,\n      absoluteInfo,\n      isRotate,\n      startValue,\n      rect,\n      startClientX,\n      startClientY,\n    } = datas;\n\n    if (!isRotate) {\n      return;\n    }\n\n    resolveTransformEvent(moveable, e, \"rotate\");\n\n    const targetDirection = getTransformDirection(e);\n    const direction = beforeDirection * targetDirection;\n    const { parentMoveable } = moveable.props;\n\n    let beforeDelta = 0;\n    let beforeDist: number;\n    let beforeRotation: number;\n\n    let delta = 0;\n    let dist: number;\n    let rotation: number;\n\n    let absoluteDelta = 0;\n    let absoluteDist: number;\n    let absoluteRotation: number;\n\n    const startRotation = (180 / Math.PI) * startValue;\n    const absoluteStartRotation = absoluteInfo.startValue;\n    let isSnap = false;\n    const nextClientX = startClientX + clientDistX;\n    const nextClientY = startClientY + clientDistY;\n\n    if (!parentFlag && \"parentDist\" in e) {\n      const parentDist = e.parentDist;\n\n      beforeDist = parentDist;\n      dist = parentDist;\n      absoluteDist = parentDist;\n    } else if (isPinch || parentFlag) {\n      beforeDist = getAbsoluteDist(parentRotate, beforeDirection, beforeInfo);\n      dist = getAbsoluteDist(parentRotate, direction, afterInfo);\n      absoluteDist = getAbsoluteDist(parentRotate, direction, absoluteInfo);\n    } else {\n      beforeDist = getAbsoluteDistByClient(\n        nextClientX,\n        nextClientY,\n        beforeDirection,\n        beforeInfo\n      );\n      dist = getAbsoluteDistByClient(\n        nextClientX,\n        nextClientY,\n        direction,\n        afterInfo\n      );\n      absoluteDist = getAbsoluteDistByClient(\n        nextClientX,\n        nextClientY,\n        direction,\n        absoluteInfo\n      );\n      isSnap = true;\n    }\n    beforeRotation = startRotation + beforeDist;\n    rotation = startRotation + dist;\n    absoluteRotation = absoluteStartRotation + absoluteDist;\n\n    triggerEvent(\n      moveable,\n      \"onBeforeRotate\",\n      fillParams<OnBeforeRotate>(\n        moveable,\n        e,\n        {\n          beforeRotation,\n          rotation,\n          absoluteRotation,\n          setRotation(nextRotation: number) {\n            dist = nextRotation - startRotation;\n            beforeDist = dist;\n            absoluteDist = dist;\n          },\n        },\n        true\n      )\n    );\n\n    [beforeDelta, beforeDist, beforeRotation] = getRotateInfo(\n      moveable,\n      rect,\n      beforeInfo,\n      beforeDist,\n      startRotation,\n      isSnap\n    );\n\n    [delta, dist, rotation] = getRotateInfo(\n      moveable,\n      rect,\n      afterInfo,\n      dist,\n      startRotation,\n      isSnap\n    );\n\n    [absoluteDelta, absoluteDist, absoluteRotation] = getRotateInfo(\n      moveable,\n      rect,\n      absoluteInfo,\n      absoluteDist,\n      absoluteStartRotation,\n      isSnap\n    );\n\n    if (\n      !absoluteDelta &&\n      !delta &&\n      !beforeDelta &&\n      !parentMoveable &&\n      !resolveMatrix\n    ) {\n      return;\n    }\n\n    const nextTransform = convertTransformFormat(\n      datas,\n      `rotate(${rotation}deg)`,\n      `rotate(${dist}deg)`\n    );\n    if (resolveMatrix) {\n      datas.fixedPosition = getTranslateFixedPosition(\n        moveable,\n        datas.targetAllTransform,\n        datas.fixedDirection,\n        datas.fixedOffset,\n        datas\n      );\n    }\n\n    const inverseDist = getRotateDist(moveable, dist, datas);\n    const inverseDelta = minus(\n      plus(groupDelta || [0, 0], inverseDist),\n      datas.prevInverseDist || [0, 0]\n    );\n    datas.prevInverseDist = inverseDist;\n    datas.requestValue = null;\n\n    const dragEvent = fillTransformEvent(\n      moveable,\n      nextTransform,\n      inverseDelta,\n      isPinch,\n      e\n    );\n\n    let transformEvent: TransformObject = dragEvent;\n    const parentDistance =\n      getDist([nextClientX, nextClientY], absoluteInfo.startAbsoluteOrigin) -\n      absoluteInfo.startDist;\n\n    let resize: OnResize | undefined = undefined;\n\n    if (datas.resolveAble === \"resizable\") {\n      const resizeEvent = Resizable.dragControl(moveable, {\n        ...setCustomDrag(\n          e,\n          moveable.state,\n          [e.deltaX, e.deltaY],\n          !!isPinch,\n          false,\n          \"resizable\"\n        ),\n        resolveMatrix: true,\n        parentDistance,\n      });\n\n      if (resizeEvent) {\n        resize = resizeEvent;\n        transformEvent = fillAfterTransform(transformEvent, resizeEvent, e);\n      }\n    }\n\n    const params = fillParams<OnRotate>(moveable, e, {\n      delta,\n      dist,\n      rotate: rotation,\n      rotation,\n\n      beforeDist,\n      beforeDelta,\n      beforeRotate: beforeRotation,\n      beforeRotation,\n\n      absoluteDist,\n      absoluteDelta,\n      absoluteRotate: absoluteRotation,\n      absoluteRotation,\n\n      isPinch: !!isPinch,\n      resize,\n      ...dragEvent,\n      ...transformEvent,\n    });\n    triggerEvent(moveable, \"onRotate\", params);\n\n    return params;\n  },\n  dragControlEnd(moveable: MoveableManagerInterface<RotatableProps>, e: any) {\n    const { datas } = e;\n\n    if (!datas.isRotate) {\n      return;\n    }\n    datas.isRotate = false;\n\n    const params = fillEndParams<OnRotateEnd>(moveable, e, {});\n\n    triggerEvent(moveable, \"onRotateEnd\", params);\n    return params;\n  },\n  dragGroupControlCondition: dragControlCondition as (\n    moveable: any,\n    e: any\n  ) => boolean,\n  dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { datas } = e;\n    const {\n      left: parentLeft,\n      top: parentTop,\n      beforeOrigin: parentBeforeOrigin,\n    } = moveable.state;\n\n    const params = this.dragControlStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    params.set(datas.beforeDirection * moveable.rotation);\n\n    const events = triggerChildAbles(\n      moveable,\n      this,\n      \"dragControlStart\",\n      e,\n      (child, ev) => {\n        const { left, top, beforeOrigin } = child.state;\n        const childClient = plus(\n          minus([left, top], [parentLeft, parentTop]),\n          minus(beforeOrigin, parentBeforeOrigin)\n        );\n\n        ev.datas.startGroupClient = childClient;\n        ev.datas.groupClient = childClient;\n        return { ...ev, parentRotate: 0 };\n      }\n    );\n\n    const nextParams: OnRotateGroupStart = {\n      ...params,\n      targets: moveable.props.targets!,\n      events,\n    };\n    const result = triggerEvent(moveable, \"onRotateGroupStart\", nextParams);\n\n    datas.isRotate = result !== false;\n\n    return datas.isRotate ? params : false;\n  },\n  dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { datas } = e;\n\n    if (!datas.isRotate) {\n      return;\n    }\n\n    catchEvent(moveable, \"onBeforeRotate\", (parentEvent) => {\n      triggerEvent(\n        moveable,\n        \"onBeforeRotateGroup\",\n        fillParams<OnBeforeRotateGroup>(\n          moveable,\n          e,\n          {\n            ...parentEvent,\n            targets: moveable.props.targets!,\n          },\n          true\n        )\n      );\n    });\n    const params = this.dragControl(moveable, e);\n\n    if (!params) {\n      return;\n    }\n    const direction = datas.beforeDirection;\n    const parentRotate = params.beforeDist;\n    const rad = (parentRotate / 180) * Math.PI;\n    const events = triggerChildAbles(\n      moveable,\n      this,\n      \"dragControl\",\n      e,\n      (_, ev) => {\n        const startGroupClient = ev.datas.startGroupClient;\n        const [prevClientX, prevClientY] = ev.datas.groupClient;\n        const [clientX, clientY] = rotateMatrix(\n          startGroupClient,\n          rad * direction\n        );\n        const delta = [clientX - prevClientX, clientY - prevClientY];\n\n        ev.datas.groupClient = [clientX, clientY];\n        return { ...ev, parentRotate, groupDelta: delta };\n      }\n    );\n    moveable.rotation = direction * params.beforeRotation;\n\n    const nextParams: OnRotateGroup = {\n      targets: moveable.props.targets!,\n      events,\n      set(rotation: number) {\n        moveable.rotation = rotation;\n      },\n      setGroupRotation(rotation: number) {\n        moveable.rotation = rotation;\n      },\n      ...params,\n    };\n\n    triggerEvent(moveable, \"onRotateGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { isDrag, datas } = e;\n\n    if (!datas.isRotate) {\n      return;\n    }\n\n    this.dragControlEnd(moveable, e);\n    const events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n\n    const nextParams = fillEndParams<OnRotateGroupEnd>(moveable, e, {\n      targets: moveable.props.targets!,\n      events,\n    });\n\n    triggerEvent(moveable, \"onRotateGroupEnd\", nextParams);\n    return isDrag;\n  },\n  /**\n     * @method Moveable.Rotatable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.deltaRotate=0] -  delta number of rotation\n     * @param {number} [e.rotate=0] - absolute number of moveable's rotation\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"rotatable\", { deltaRotate: 10 }, true);\n     *\n     * * moveable.request(\"rotatable\", { rotate: 10 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"rotatable\");\n     *\n     * // request\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     *\n     * requester.request({ rotate: 10 });\n     * requester.request({ rotate: 20 });\n     * requester.request({ rotate: 30 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n  request(moveable: MoveableManagerInterface<RotatableProps>) {\n    const datas = {};\n    let distRotate = 0;\n\n    const startRotation = moveable.getRotation();\n    return {\n      isControl: true,\n      requestStart() {\n        return { datas };\n      },\n      request(e: IObject<any>) {\n        if (\"deltaRotate\" in e) {\n          distRotate += e.deltaRotate;\n        } else if (\"rotate\" in e) {\n          distRotate = e.rotate - startRotation;\n        }\n\n        return { datas, parentDist: distRotate };\n      },\n      requestEnd() {\n        return { datas, isDrag: true };\n      },\n    };\n  },\n};\n/**\n * Whether or not target can be rotated. (default: false)\n * @name Moveable.Rotatable#rotatable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.rotatable = true;\n */\n/**\n * You can specify the position of the rotation. (default: \"top\")\n * @name Moveable.Rotatable#rotationPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   rotationPosition: \"top\",\n * });\n *\n * moveable.rotationPosition = \"bottom\"\n */\n\n/**\n * throttle of angle(degree) when rotate.\n * @name Moveable.Rotatable#throttleRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleRotate = 1;\n */\n\n/**\n * When the rotate starts, the rotateStart event is called.\n * @memberof Moveable.Rotatable\n * @event rotateStart\n * @param {Moveable.Rotatable.OnRotateStart} - Parameters for the rotateStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When rotating, the rotate event is called.\n * @memberof Moveable.Rotatable\n * @event rotate\n * @param {Moveable.Rotatable.OnRotate} - Parameters for the rotate event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotate\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the rotate finishes, the rotateEnd event is called.\n * @memberof Moveable.Rotatable\n * @event rotateEnd\n * @param {Moveable.Rotatable.OnRotateEnd} - Parameters for the rotateEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n * When the group rotate starts, the `rotateGroupStart` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupStart\n * @param {Moveable.Rotatable.OnRotateGroupStart} - Parameters for the `rotateGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupStart\", ({ targets }) => {\n *     console.log(\"onRotateGroupStart\", targets);\n * });\n */\n\n/**\n * When the group rotate, the `rotateGroup` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroup\n * @param {Moveable.Rotatable.OnRotateGroup} - Parameters for the `rotateGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroup\", ({ targets, events }) => {\n *     console.log(\"onRotateGroup\", targets);\n *     events.forEach(ev => {\n *         const target = ev.target;\n *         // ev.drag is a drag event that occurs when the group rotate.\n *         const left = ev.drag.beforeDist[0];\n *         const top = ev.drag.beforeDist[1];\n *         const deg = ev.beforeDist;\n *     });\n * });\n */\n\n/**\n * When the group rotate finishes, the `rotateGroupEnd` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupEnd\n * @param {Moveable.Rotatable.OnRotateGroupEnd} - Parameters for the `rotateGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onRotateGroupEnd\", targets, isDrag);\n * });\n */\n","import { throttle } from \"../../../utility\";\nimport {\n  RenderGuidelineInfo,\n  Renderer,\n  RenderGuidelineInnerInfo,\n  MoveableManagerInterface,\n  SnappableProps,\n  SnapGuideline,\n  SnappableRenderType,\n  SnappableState,\n  SnapDirectionPoses,\n} from \"../../types\";\nimport { prefix, groupBy } from \"../../utils\";\nimport { HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP } from \"./utils\";\n\nexport function renderGuideline(\n  info: RenderGuidelineInfo,\n  React: Renderer\n): any {\n  const { direction, classNames, size, pos, zoom, key } = info;\n  const isHorizontal = direction === \"horizontal\";\n  const scaleType = isHorizontal ? \"Y\" : \"X\";\n  // const scaleType2 = isHorizontal ? \"Y\" : \"X\";\n\n  return React.createElement(\"div\", {\n    key,\n    className: classNames.join(\" \"),\n    style: {\n      [isHorizontal ? \"width\" : \"height\"]: `${size}`,\n      transform: `translate(${pos[0]}, ${pos[1]}) translate${scaleType}(-50%) scale${scaleType}(${zoom})`,\n    },\n  });\n}\n\nexport function renderInnerGuideline(\n  info: RenderGuidelineInnerInfo,\n  React: Renderer\n): any {\n  return renderGuideline(\n    {\n      ...info,\n      classNames: [\n        prefix(\"line\", \"guideline\", info.direction),\n        ...info.classNames,\n      ].filter((className) => className) as string[],\n      size: info.size || `${info.sizeValue}px`,\n      pos: info.pos || info.posValue.map((v) => `${throttle(v, 0.1)}px`),\n    },\n    React\n  );\n}\n\nexport function renderSnapPoses(\n  moveable: MoveableManagerInterface,\n  direction: string,\n  snapPoses: SnappableRenderType[],\n  minPos: number,\n  targetPos: number,\n  size: number,\n  index: number,\n  React: Renderer\n) {\n  const { zoom } = moveable.props;\n  return snapPoses.map(({ type, pos }, i) => {\n    const renderPos = [0, 0];\n\n    renderPos[index] = minPos;\n    renderPos[index ? 0 : 1] = -targetPos + pos;\n\n    return renderInnerGuideline(\n      {\n        key: `${direction}TargetGuideline${i}`,\n        classNames: [prefix(\"target\", \"bold\", type)],\n        posValue: renderPos,\n        sizeValue: size,\n        zoom: zoom!,\n        direction: direction,\n      },\n      React\n    );\n  });\n}\nexport function renderGuidelines(\n  moveable: MoveableManagerInterface<SnappableProps>,\n  type: \"vertical\" | \"horizontal\",\n  guidelines: SnapGuideline[],\n  targetPos: number[],\n  targetRect: SnapDirectionPoses,\n  React: Renderer\n): any[] {\n  const { zoom, isDisplayInnerSnapDigit } = moveable.props;\n\n  const mainNames =\n    type === \"horizontal\" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n  const targetStart = targetRect[mainNames.start]!;\n  const targetEnd = targetRect[mainNames.end]!;\n  return guidelines\n    .filter(({ hide, elementRect }) => {\n      if (hide) {\n        return false;\n      }\n      if (isDisplayInnerSnapDigit && elementRect) {\n        // inner\n        const rect = elementRect.rect;\n\n        if (\n          rect[mainNames.start]! <= targetStart &&\n          targetEnd <= rect[mainNames.end]!\n        ) {\n          return false;\n        }\n      }\n      return true;\n    })\n    .map((guideline, i) => {\n      const { pos, size, element, className } = guideline;\n\n      const renderPos = [-targetPos[0] + pos[0], -targetPos[1] + pos[1]];\n\n      return renderInnerGuideline(\n        {\n          key: `${type}-default-guideline-${i}`,\n          classNames: element\n            ? [prefix(\"bold\"), className]\n            : [prefix(\"normal\"), className],\n          direction: type,\n          posValue: renderPos,\n          sizeValue: size,\n          zoom: zoom!,\n        },\n        React\n      );\n    });\n}\n\nexport function renderDigitLine(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n  type: \"vertical\" | \"horizontal\",\n  lineType: \"dashed\" | \"gap\",\n  index: number,\n  gap: number,\n  renderPos: number[],\n  className: string | undefined,\n  React: Renderer\n): any {\n  const {\n    snapDigit = 0,\n    isDisplaySnapDigit = true,\n    snapDistFormat = (v: number, type: \"vertical\" | \"horizontal\") => {\n      // Type can be used render different values.\n      if (type === \"vertical\") {\n        return v;\n      }\n      return v;\n    },\n    zoom,\n  } = moveable.props;\n  const scaleType = type === \"horizontal\" ? \"X\" : \"Y\";\n  const sizeName = type === \"vertical\" ? \"height\" : \"width\";\n  const absGap = Math.abs(gap!);\n  const snapSize = isDisplaySnapDigit\n    ? parseFloat(absGap.toFixed(snapDigit))\n    : 0;\n  return (\n    <div\n      key={`${type}-${lineType}-guideline-${index}`}\n      className={prefix(\"guideline-group\", type)}\n      style={{\n        left: `${renderPos[0]}px`,\n        top: `${renderPos[1]}px`,\n        [sizeName]: `${absGap}px`,\n      }}\n    >\n      {renderInnerGuideline(\n        {\n          direction: type,\n          classNames: [prefix(lineType), className],\n          size: \"100%\",\n          posValue: [0, 0],\n          sizeValue: absGap,\n          zoom: zoom!,\n        },\n        React\n      )}\n      <div\n        className={prefix(\"size-value\", \"gap\")}\n        style={{\n          transform: `translate${scaleType}(-50%) scale(${zoom})`,\n        }}\n      >\n        {snapSize > 0 ? snapDistFormat(snapSize, type) : \"\"}\n      </div>\n    </div>\n  );\n}\n\nexport function groupByElementGuidelines(\n  type: \"vertical\" | \"horizontal\",\n  guidelines: SnapGuideline[],\n  targetRect: SnapDirectionPoses,\n  isDisplayInnerSnapDigit: boolean\n) {\n  const index = type === \"vertical\" ? 0 : 1;\n  const otherIndex = type === \"vertical\" ? 1 : 0;\n  const names = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n  const targetStart = targetRect[names.start]!;\n  const targetEnd = targetRect[names.end]!;\n  return groupBy(guidelines, (guideline) => {\n    return guideline.pos[index];\n  }).map((nextGuidelines) => {\n    const start: SnapGuideline[] = [];\n    const end: SnapGuideline[] = [];\n    const inner: SnapGuideline[] = [];\n\n    nextGuidelines.forEach((guideline) => {\n      const element = guideline.element!;\n      const rect = guideline.elementRect!.rect;\n      if (rect[names.end]! < targetStart) {\n        start.push(guideline);\n      } else if (targetEnd < rect[names.start]!) {\n        end.push(guideline);\n      } else if (\n        rect[names.start]! <= targetStart &&\n        targetEnd <= rect[names.end]! &&\n        isDisplayInnerSnapDigit\n      ) {\n        const pos = guideline.pos;\n        const elementRect1 = {\n          element,\n          rect: { ...rect, [names.end]: rect[names.start]! },\n        };\n        const elementRect2 = {\n          element,\n          rect: { ...rect, [names.start]: rect[names.end]! },\n        };\n        const nextPos1 = [0, 0];\n        const nextPos2 = [0, 0];\n        nextPos1[index] = pos[index];\n        nextPos1[otherIndex] = pos[otherIndex];\n\n        nextPos2[index] = pos[index];\n        nextPos2[otherIndex] = pos[otherIndex] + guideline.size;\n\n        start.push({\n          type,\n          pos: nextPos1,\n          size: 0,\n          elementRect: elementRect1,\n          direction: \"\",\n          elementDirection: \"end\",\n        });\n        end.push({\n          type,\n          pos: nextPos2,\n          size: 0,\n          elementRect: elementRect2,\n          direction: \"\",\n          elementDirection: \"start\",\n        });\n        // inner.push(guideline);\n      }\n    });\n\n    start.sort((a, b) => {\n      return b.pos[otherIndex] - a.pos[otherIndex];\n    });\n    end.sort((a, b) => {\n      return a.pos[otherIndex] - b.pos[otherIndex];\n    });\n    return {\n      total: nextGuidelines,\n      start,\n      end,\n      inner,\n    };\n  });\n}\nexport function renderDashedGuidelines(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n  guidelines: SnapGuideline[],\n  targetPos: number[],\n  targetRect: SnapDirectionPoses,\n  React: Renderer\n): any[] {\n  const { isDisplayInnerSnapDigit } = moveable.props;\n  const rendered: any[] = [];\n\n  ([\"vertical\", \"horizontal\"] as const).forEach((type) => {\n    const nextGuidelines = guidelines.filter(\n      (guideline) => guideline.type === type\n    );\n    const index = type === \"vertical\" ? 1 : 0;\n    const otherIndex = index ? 0 : 1;\n\n    const groups = groupByElementGuidelines(\n      type,\n      nextGuidelines,\n      targetRect,\n      isDisplayInnerSnapDigit!\n    );\n    const mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;\n    const sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n    const targetStart = targetRect[mainNames.start]!;\n    const targetEnd = targetRect[mainNames.end]!;\n\n    groups.forEach(({ total, start, end, inner }) => {\n      const sidePos =\n        targetPos[otherIndex] +\n        total[0].pos[otherIndex] -\n        targetRect[sideNames.start]!;\n\n      let prevRect = targetRect;\n\n      start.forEach((guideline) => {\n        const nextRect = guideline.elementRect!.rect;\n        const size = prevRect[mainNames.start]! - nextRect[mainNames.end]!;\n\n        if (size > 0) {\n          const renderPos = [0, 0];\n\n          renderPos[index] =\n            targetPos[index] + prevRect[mainNames.start]! - targetStart - size;\n          renderPos[otherIndex] = sidePos;\n\n          rendered.push(\n            renderDigitLine(\n              moveable,\n              type,\n              \"dashed\",\n              rendered.length,\n              size,\n              renderPos,\n              guideline.className,\n              React\n            )\n          );\n        }\n        prevRect = nextRect;\n      });\n\n      prevRect = targetRect;\n      end.forEach((guideline) => {\n        const nextRect = guideline.elementRect!.rect;\n        const size = nextRect[mainNames.start]! - prevRect[mainNames.end]!;\n\n        if (size > 0) {\n          const renderPos = [0, 0];\n\n          renderPos[index] =\n            targetPos[index] + prevRect[mainNames.end]! - targetStart;\n          renderPos[otherIndex] = sidePos;\n\n          rendered.push(\n            renderDigitLine(\n              moveable,\n              type,\n              \"dashed\",\n              rendered.length,\n              size,\n              renderPos,\n              guideline.className,\n              React\n            )\n          );\n        }\n        prevRect = nextRect;\n      });\n\n      inner.forEach((guideline) => {\n        const nextRect = guideline.elementRect!.rect;\n\n        const size1 = targetStart - nextRect[mainNames.start]!;\n        const size2 = nextRect[mainNames.end]! - targetEnd;\n        const renderPos1 = [0, 0];\n        const renderPos2 = [0, 0];\n\n        renderPos1[index] = targetPos[index] - size1;\n        renderPos1[otherIndex] = sidePos;\n\n        renderPos2[index] = targetPos[index] + targetEnd - targetStart;\n        renderPos2[otherIndex] = sidePos;\n\n        rendered.push(\n          renderDigitLine(\n            moveable,\n            type,\n            \"dashed\",\n            rendered.length,\n            size1,\n            renderPos1,\n            guideline.className,\n            React\n          )\n        );\n        rendered.push(\n          renderDigitLine(\n            moveable,\n            type,\n            \"dashed\",\n            rendered.length,\n            size2,\n            renderPos2,\n            guideline.className,\n            React\n          )\n        );\n      });\n    });\n  });\n  return rendered;\n}\nexport function renderGapGuidelines(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n  guidelines: SnapGuideline[],\n  targetPos: number[],\n  targetRect: SnapDirectionPoses,\n  React: any\n): any[] {\n  const rendered: any[] = [];\n  ([\"horizontal\", \"vertical\"] as const).forEach((type) => {\n    const nextGuidelines = guidelines\n      .filter((guideline) => guideline.type === type)\n      .slice(0, 1);\n    const index = type === \"vertical\" ? 0 : 1;\n    const otherIndex = index ? 0 : 1;\n    const mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;\n    const sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n    const targetStart = targetRect[mainNames.start]!;\n    const targetEnd = targetRect[mainNames.end]!;\n    const targetSideStart = targetRect[sideNames.start]!;\n    const targetSideEnd = targetRect[sideNames.end]!;\n\n    nextGuidelines.forEach(({ gap, gapRects }) => {\n      const sideStartPos = Math.max(\n        targetSideStart,\n        ...gapRects!.map(({ rect }) => rect[sideNames.start]!)\n      );\n      const sideEndPos = Math.min(\n        targetSideEnd,\n        ...gapRects!.map(({ rect }) => rect[sideNames.end]!)\n      );\n      const sideCenterPos = (sideStartPos + sideEndPos) / 2;\n\n      if (\n        sideStartPos === sideEndPos ||\n        sideCenterPos === (targetSideStart + targetSideEnd) / 2\n      ) {\n        return;\n      }\n      gapRects!.forEach(({ rect, className }) => {\n        const renderPos = [targetPos[0], targetPos[1]];\n\n        if (rect[mainNames.end]! < targetStart) {\n          renderPos[index] += rect[mainNames.end]! - targetStart;\n        } else if (targetEnd < rect[mainNames.start]!) {\n          renderPos[index] += rect[mainNames.start]! - targetStart - gap!;\n        } else {\n          return;\n        }\n\n        renderPos[otherIndex] += sideCenterPos - targetSideStart;\n        rendered.push(\n          renderDigitLine(\n            moveable,\n            index ? \"vertical\" : \"horizontal\",\n            \"gap\",\n            rendered.length,\n            gap!,\n            renderPos,\n            className,\n            React\n          )\n        );\n      });\n    });\n  });\n  return rendered;\n}\n","import {\n  convertUnitSize,\n  dot,\n  flat,\n  isNumber,\n  isObject,\n  throttle,\n} from \"../../../utility\";\nimport { diff } from \"../../../differ\";\nimport {\n  MoveableManagerInterface,\n  SnappableProps,\n  SnappableState,\n  SnapGuideline,\n  SnapDirectionPoses,\n  PosGuideline,\n  ElementGuidelineValue,\n  SnapElementRect,\n  NumericPosGuideline,\n} from \"../../types\";\nimport {\n  getRect,\n  getAbsolutePosesByState,\n  getRefTarget,\n  calculateInversePosition,\n  prefix,\n  abs,\n} from \"../../utils\";\nimport {\n  splitSnapDirectionPoses,\n  getSnapDirections,\n  HORIZONTAL_NAMES_MAP,\n  VERTICAL_NAMES_MAP,\n  calculateContainerPos,\n  SNAP_SKIP_NAMES_MAP,\n} from \"./utils\";\n\nexport function getTotalGuidelines(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n) {\n  const state = moveable.state;\n  const { containerClientRect, hasFixed } = state;\n  const {\n    overflow,\n    scrollHeight: containerHeight,\n    scrollWidth: containerWidth,\n    clientHeight: containerClientHeight,\n    clientWidth: containerClientWidth,\n    clientLeft,\n    clientTop,\n  } = containerClientRect;\n  const {\n    snapGap = true,\n    verticalGuidelines,\n    horizontalGuidelines,\n    snapThreshold = 5,\n    maxSnapElementGuidelineDistance = Infinity,\n    isDisplayGridGuidelines,\n  } = moveable.props;\n  const { top, left, bottom, right } = getRect(\n    getAbsolutePosesByState(moveable.state)\n  );\n  const targetRect = {\n    top,\n    left,\n    bottom,\n    right,\n    center: (left + right) / 2,\n    middle: (top + bottom) / 2,\n  };\n  const elementGuidelines = getElementGuidelines(moveable);\n  let totalGuidelines: SnapGuideline[] = [...elementGuidelines];\n\n  const snapThresholdMultiples = (\n    state.snapThresholdInfo?.multiples ?? [1, 1]\n  ).map((n) => n * snapThreshold);\n\n  if (snapGap) {\n    totalGuidelines.push(\n      ...getGapGuidelines(moveable, targetRect, snapThresholdMultiples)\n    );\n  }\n  const snapOffset = {\n    ...(state.snapOffset || {\n      left: 0,\n      top: 0,\n      bottom: 0,\n      right: 0,\n    }),\n  };\n\n  totalGuidelines.push(\n    ...getGridGuidelines(\n      moveable,\n      overflow ? containerWidth! : containerClientWidth!,\n      overflow ? containerHeight! : containerClientHeight!,\n      clientLeft,\n      clientTop,\n      snapOffset,\n      isDisplayGridGuidelines\n    )\n  );\n\n  if (hasFixed) {\n    const { left, top } = containerClientRect;\n\n    snapOffset.left += left;\n    snapOffset.top += top;\n    snapOffset.right += left;\n    snapOffset.bottom += top;\n  }\n\n  totalGuidelines.push(\n    ...getDefaultGuidelines(\n      horizontalGuidelines || false,\n      verticalGuidelines || false,\n      overflow ? containerWidth! : containerClientWidth!,\n      overflow ? containerHeight! : containerClientHeight!,\n      clientLeft,\n      clientTop,\n      snapOffset\n    )\n  );\n\n  totalGuidelines = totalGuidelines.filter(({ element, elementRect, type }) => {\n    if (!element || !elementRect) {\n      return true;\n    }\n    const rect = elementRect.rect;\n\n    return checkBetweenRects(\n      targetRect,\n      rect,\n      type,\n      maxSnapElementGuidelineDistance\n    );\n  });\n\n  return totalGuidelines;\n}\n\nexport function getGapGuidelines(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n  targetRect: SnapDirectionPoses,\n  snapThresholds: number[]\n) {\n  const {\n    maxSnapElementGuidelineDistance = Infinity,\n    maxSnapElementGapDistance = Infinity,\n  } = moveable.props;\n  const elementRects = moveable.state.elementRects;\n  const gapGuidelines: SnapGuideline[] = [];\n  [\n    [\"vertical\", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP] as const,\n    [\"horizontal\", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP] as const,\n  ].forEach(([type, mainNames, sideNames]) => {\n    const targetStart = targetRect[mainNames.start]!;\n    const targetEnd = targetRect[mainNames.end]!;\n    const targetCenter = targetRect[mainNames.center]!;\n    const targetStart2 = targetRect[sideNames.start]!;\n    const targetEnd2 = targetRect[sideNames.end]!;\n\n    // element : moveable\n    const snapThresholdMap = {\n      left: snapThresholds[0],\n      top: snapThresholds[1],\n    };\n\n    function getDist(elementRect: SnapElementRect) {\n      const rect = elementRect.rect;\n      const snapThreshold = snapThresholdMap[mainNames.start];\n\n      if (rect[mainNames.end]! < targetStart + snapThreshold) {\n        return targetStart - rect[mainNames.end]!;\n      } else if (targetEnd - snapThreshold < rect[mainNames.start]!) {\n        return rect[mainNames.start]! - targetEnd;\n      } else {\n        return -1;\n      }\n    }\n    const nextElementRects = elementRects\n      .filter((elementRect) => {\n        const rect = elementRect.rect;\n\n        if (\n          rect[sideNames.start]! > targetEnd2 ||\n          rect[sideNames.end]! < targetStart2\n        ) {\n          return false;\n        }\n\n        return getDist(elementRect) > 0;\n      })\n      .sort((a, b) => {\n        return getDist(a) - getDist(b);\n      });\n\n    const groups: SnapElementRect[][] = [];\n\n    nextElementRects.forEach((snapRect1) => {\n      nextElementRects.forEach((snapRect2) => {\n        if (snapRect1 === snapRect2) {\n          return;\n        }\n        const { rect: rect1 } = snapRect1;\n        const { rect: rect2 } = snapRect2;\n\n        const rect1Start = rect1[sideNames.start]!;\n        const rect1End = rect1[sideNames.end]!;\n        const rect2Start = rect2[sideNames.start]!;\n        const rect2End = rect2[sideNames.end]!;\n\n        if (rect1Start > rect2End || rect2Start > rect1End) {\n          return;\n        }\n\n        groups.push([snapRect1, snapRect2]);\n      });\n    });\n\n    groups.forEach(([snapRect1, snapRect2]) => {\n      const { rect: rect1 } = snapRect1;\n      const { rect: rect2 } = snapRect2;\n\n      const rect1Start = rect1[mainNames.start]!;\n      const rect1End = rect1[mainNames.end]!;\n      const rect2Start = rect2[mainNames.start]!;\n      const rect2End = rect2[mainNames.end]!;\n      const snapThreshold = snapThresholdMap[mainNames.start];\n      let gap = 0;\n      let pos = 0;\n      let isStart = false;\n      let isCenter = false;\n      let isEnd = false;\n\n      if (rect1End <= targetStart && targetEnd <= rect2Start) {\n        // (l)element1(r) : (l)target(r) : (l)element2(r)\n        isCenter = true;\n        gap = (rect2Start - rect1End - (targetEnd - targetStart)) / 2;\n        pos = rect1End + gap + (targetEnd - targetStart) / 2;\n\n        if (abs(pos - targetCenter) > snapThreshold) {\n          return;\n        }\n      } else if (\n        rect1End < rect2Start &&\n        rect2End < targetStart + snapThreshold\n      ) {\n        // (l)element1(r) : (l)element2(r) : (l)target\n        isStart = true;\n\n        gap = rect2Start - rect1End;\n        pos = rect2End + gap;\n\n        if (abs(pos - targetStart) > snapThreshold) {\n          return;\n        }\n      } else if (\n        rect1End < rect2Start &&\n        targetEnd - snapThreshold < rect1Start\n      ) {\n        // target(r) : (l)element1(r) : (l)element2(r)\n\n        isEnd = true;\n        gap = rect2Start - rect1End;\n        pos = rect1Start - gap;\n\n        if (abs(pos - targetEnd) > snapThreshold) {\n          return;\n        }\n      } else {\n        return;\n      }\n      if (!gap) {\n        return;\n      }\n      if (\n        !checkBetweenRects(\n          targetRect,\n          rect2,\n          type,\n          maxSnapElementGuidelineDistance\n        )\n      ) {\n        return;\n      }\n      if (gap > maxSnapElementGapDistance) {\n        return;\n      }\n      gapGuidelines.push({\n        type,\n        pos: type === \"vertical\" ? [pos, 0] : [0, pos],\n        element: snapRect2.element,\n        size: 0,\n        className: snapRect2.className,\n        isStart,\n        isCenter,\n        isEnd,\n        gap,\n        hide: true,\n        gapRects: [snapRect1, snapRect2],\n        direction: \"\",\n        elementDirection: \"\",\n      });\n    });\n  });\n  return gapGuidelines;\n}\n\nexport function startGridGroupGuidelines(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n  clientLeft: number,\n  clientTop: number,\n  snapOffset: { left: number; top: number; right: number; bottom: number }\n) {\n  const props = moveable.props;\n  const state = moveable.state;\n  const { snapGridAll } = props;\n  const { snapGridWidth = 0, snapGridHeight = 0 } = props;\n  const { snapRenderInfo } = state;\n  const hasDirection =\n    snapRenderInfo &&\n    (snapRenderInfo.direction?.[0] || snapRenderInfo.direction?.[1]);\n  const moveables = moveable.moveables;\n  const ignores = [false, false];\n\n  // snap group's all child to grid.\n  if (\n    snapGridAll &&\n    moveables &&\n    hasDirection &&\n    (snapGridWidth || snapGridHeight)\n  ) {\n    if (state.snapThresholdInfo) {\n      return;\n    }\n    state.snapThresholdInfo = {\n      multiples: [1, 1],\n      offset: [0, 0],\n    };\n\n    const rect = moveable.getRect();\n    const children = rect.children;\n    const direction = snapRenderInfo.direction!;\n\n    if (children) {\n      const result = direction.map((dir, i) => {\n        const { snapSize, posName, sizeName, clientOffset } =\n          i === 0\n            ? ({\n                snapSize: snapGridWidth,\n                posName: \"left\",\n                sizeName: \"width\",\n                clientOffset: snapOffset.left - clientLeft,\n              } as const)\n            : ({\n                snapSize: snapGridHeight,\n                posName: \"top\",\n                sizeName: \"height\",\n                clientOffset: snapOffset.top - clientTop,\n              } as const);\n\n        if (!snapSize) {\n          return {\n            dir,\n            multiple: 1,\n            snapSize,\n            snapOffset: 0,\n          };\n        }\n        const rectSize = rect[sizeName];\n        const rectPos = rect[posName];\n\n        // 사이즈보다 만약 작다면 어떻게 해야되죠?\n        const childSizes = flat(\n          children.map((child) => {\n            return [\n              child[posName] - rectPos,\n              child[sizeName],\n              rectSize - child[sizeName] - child[posName] + rectPos,\n            ];\n          })\n        )\n          .filter((v) => v)\n          .sort((a, b) => {\n            return a - b;\n          });\n\n        const firstChildSize = childSizes[0];\n        const childSnapSizes = childSizes.map(\n          (size) => throttle(size / firstChildSize, 0.1) * snapSize\n        );\n        let n = 1;\n\n        const rectRatio = throttle(rectSize / firstChildSize, 0.1);\n\n        for (n = 1; n <= 10; ++n) {\n          if (\n            childSnapSizes.every((childSize) => {\n              return (childSize * n) % 1 === 0;\n            })\n          ) {\n            break;\n          }\n        }\n\n        // dir 1 (fixed -1)\n        // dir 0 (fixed 0)\n        // dir -1 (fixed 1)\n\n        const ratio = (-dir + 1) / 2;\n        const offsetPos = dot(\n          rectPos - clientOffset,\n          rectPos - clientOffset + rectSize,\n          ratio,\n          1 - ratio\n        );\n\n        return {\n          multiple: rectRatio * n,\n          dir,\n          snapSize,\n          snapOffset: Math.round(offsetPos / snapSize),\n        };\n      });\n\n      const multiples = result.map((r) => r.multiple || 1);\n      state.snapThresholdInfo.multiples = multiples;\n      state.snapThresholdInfo.offset = result.map((r) => r.snapOffset);\n\n      result.forEach((r, i) => {\n        if (r.snapSize) {\n          ignores[i] = true;\n        }\n      });\n    }\n  } else {\n    state.snapThresholdInfo = null;\n  }\n}\n\nexport function getGridGuidelines(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n  containerWidth: number,\n  containerHeight: number,\n  clientLeft = 0,\n  clientTop = 0,\n  snapOffset: { left: number; top: number; right: number; bottom: number },\n  isDisplayGridGuidelines?: boolean\n): SnapGuideline[] {\n  const props = moveable.props;\n  const state = moveable.state;\n  let { snapGridWidth = 0, snapGridHeight = 0 } = props;\n  const guidelines: SnapGuideline[] = [];\n  const { left: snapOffsetLeft, top: snapOffsetTop } = snapOffset;\n  let startOffset = [0, 0];\n\n  startGridGroupGuidelines(moveable, clientLeft, clientTop, snapOffset);\n\n  const snapThresholdInfo = state.snapThresholdInfo;\n  const defaultSnapGridWidth = snapGridWidth;\n  const defaultSnapGridHeight = snapGridHeight;\n\n  if (snapThresholdInfo) {\n    snapGridWidth *= snapThresholdInfo.multiples[0] || 1;\n    snapGridHeight *= snapThresholdInfo.multiples[1] || 1;\n    startOffset = snapThresholdInfo.offset;\n  }\n\n  if (snapGridHeight) {\n    const pushGuideline = (pos: number) => {\n      guidelines.push({\n        type: \"horizontal\",\n        pos: [\n          snapOffsetLeft,\n          throttle(\n            startOffset[1] * defaultSnapGridHeight +\n              pos -\n              clientTop +\n              snapOffsetTop,\n            0.1\n          ),\n        ],\n        className: prefix(\"grid-guideline\"),\n        size: containerWidth!,\n        hide: !isDisplayGridGuidelines,\n        direction: \"\",\n        grid: true,\n      });\n    };\n    for (let pos = 0; pos <= containerHeight * 2; pos += snapGridHeight) {\n      pushGuideline(pos);\n    }\n    for (\n      let pos = -snapGridHeight;\n      pos >= -containerHeight;\n      pos -= snapGridHeight\n    ) {\n      pushGuideline(pos);\n    }\n  }\n\n  if (snapGridWidth) {\n    const pushGuideline = (pos: number) => {\n      guidelines.push({\n        type: \"vertical\",\n        pos: [\n          throttle(\n            startOffset[0] * defaultSnapGridWidth +\n              pos -\n              clientLeft +\n              snapOffsetLeft,\n            0.1\n          ),\n          snapOffsetTop,\n        ],\n        className: prefix(\"grid-guideline\"),\n        size: containerHeight!,\n        hide: !isDisplayGridGuidelines,\n        direction: \"\",\n        grid: true,\n      });\n    };\n    for (let pos = 0; pos <= containerWidth * 2; pos += snapGridWidth) {\n      pushGuideline(pos);\n    }\n    for (\n      let pos = -snapGridWidth;\n      pos >= -containerWidth;\n      pos -= snapGridWidth\n    ) {\n      pushGuideline(pos);\n    }\n  }\n\n  return guidelines;\n}\n\nexport function checkBetweenRects(\n  rect1: SnapDirectionPoses,\n  rect2: SnapDirectionPoses,\n  type: \"horizontal\" | \"vertical\",\n  distance: number\n) {\n  if (type === \"horizontal\") {\n    return (\n      abs(rect1.right! - rect2.left!) <= distance ||\n      abs(rect1.left! - rect2.right!) <= distance ||\n      (rect1.left! <= rect2.right! && rect2.left! <= rect1.right!)\n    );\n  } else if (type === \"vertical\") {\n    return (\n      abs(rect1.bottom! - rect2.top!) <= distance ||\n      abs(rect1.top! - rect2.bottom!) <= distance ||\n      (rect1.top! <= rect2.bottom! && rect2.top! <= rect1.bottom!)\n    );\n  }\n  return true;\n}\n\nexport function getElementGuidelines(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n) {\n  const state = moveable.state;\n\n  const { elementGuidelines = [] } = moveable.props;\n\n  if (!elementGuidelines.length) {\n    state.elementRects = [];\n    return [];\n  }\n\n  const prevValues = (state.elementRects || []).filter(\n    (snapRect) => !snapRect.refresh\n  );\n  const nextElementGuidelines = elementGuidelines\n    .map((el) => {\n      if (isObject(el) && \"element\" in el) {\n        return {\n          ...el,\n          element: getRefTarget(el.element, true)!,\n        };\n      }\n      return {\n        element: getRefTarget(el, true)!,\n      };\n    })\n    .filter((value) => {\n      return value.element;\n    }) as ElementGuidelineValue[];\n\n  const { maintained, added } = diff(\n    prevValues.map((v) => v.element),\n    nextElementGuidelines.map((v) => v.element)\n  );\n\n  const nextValues: SnapElementRect[] = [];\n  maintained.forEach(([prevIndex, nextIndex]) => {\n    nextValues[nextIndex] = prevValues[prevIndex];\n  });\n\n  getSnapElementRects(\n    moveable,\n    added.map((index) => nextElementGuidelines[index])\n  ).map((rect, i) => {\n    nextValues[added[i]] = rect;\n  });\n\n  state.elementRects = nextValues;\n  const elementSnapDirections = getSnapDirections(\n    moveable.props.elementSnapDirections\n  );\n  const nextGuidelines: SnapGuideline[] = [];\n\n  nextValues.forEach((snapRect) => {\n    const {\n      element,\n      top: topValue = elementSnapDirections.top,\n      left: leftValue = elementSnapDirections.left,\n      right: rightValue = elementSnapDirections.right,\n      bottom: bottomValue = elementSnapDirections.bottom,\n      center: centerValue = elementSnapDirections.center,\n      middle: middleValue = elementSnapDirections.middle,\n      className,\n      rect,\n    } = snapRect;\n    const { horizontal, vertical, horizontalNames, verticalNames } =\n      splitSnapDirectionPoses(\n        {\n          top: topValue,\n          right: rightValue,\n          left: leftValue,\n          bottom: bottomValue,\n          center: centerValue,\n          middle: middleValue,\n        },\n        rect\n      );\n    const rectTop = rect.top!;\n    const rectLeft = rect.left!;\n    const width = rect.right! - rectLeft;\n    const height = rect.bottom! - rectTop;\n    const sizes = [width, height];\n\n    vertical.forEach((pos, i) => {\n      nextGuidelines.push({\n        type: \"vertical\",\n        element,\n        pos: [throttle(pos, 0.1), rectTop],\n        size: height,\n        sizes,\n        className,\n        elementRect: snapRect,\n        elementDirection:\n          SNAP_SKIP_NAMES_MAP[verticalNames[i]] || verticalNames[i],\n        direction: \"\",\n      });\n    });\n    horizontal.forEach((pos, i) => {\n      nextGuidelines.push({\n        type: \"horizontal\",\n        element,\n        pos: [rectLeft, throttle(pos, 0.1)],\n        size: width,\n        sizes,\n        className,\n        elementRect: snapRect,\n        elementDirection:\n          SNAP_SKIP_NAMES_MAP[horizontalNames[i]] || horizontalNames[i],\n        direction: \"\",\n      });\n    });\n  });\n\n  return nextGuidelines;\n}\n\nfunction getObjectGuidelines(\n  guidelines: Array<PosGuideline | number | string> | false,\n  containerSize: number\n): NumericPosGuideline[] {\n  return guidelines\n    ? guidelines.map((info) => {\n        const posGuideline = isObject(info) ? info : { pos: info };\n        const pos = posGuideline.pos;\n\n        if (isNumber(pos)) {\n          return posGuideline as NumericPosGuideline;\n        } else {\n          return {\n            ...posGuideline,\n            pos: convertUnitSize(pos, containerSize),\n          };\n        }\n      })\n    : [];\n}\n\nexport function getDefaultGuidelines(\n  horizontalGuidelines: Array<PosGuideline | number | string> | false,\n  verticalGuidelines: Array<PosGuideline | number | string> | false,\n  width: number,\n  height: number,\n  clientLeft = 0,\n  clientTop = 0,\n  snapOffset = { left: 0, top: 0, right: 0, bottom: 0 }\n): SnapGuideline[] {\n  const guidelines: SnapGuideline[] = [];\n  const {\n    left: snapOffsetLeft,\n    top: snapOffsetTop,\n    bottom: snapOffsetBottom,\n    right: snapOffsetRight,\n  } = snapOffset;\n  const snapWidth = width! + snapOffsetRight - snapOffsetLeft;\n  const snapHeight = height! + snapOffsetBottom - snapOffsetTop;\n\n  getObjectGuidelines(horizontalGuidelines, snapHeight).forEach((posInfo) => {\n    guidelines.push({\n      type: \"horizontal\",\n      pos: [\n        snapOffsetLeft,\n        throttle(posInfo.pos - clientTop + snapOffsetTop, 0.1),\n      ],\n      size: snapWidth,\n      className: posInfo.className,\n      direction: \"\",\n    });\n  });\n  getObjectGuidelines(verticalGuidelines, snapWidth).forEach((posInfo) => {\n    guidelines.push({\n      type: \"vertical\",\n      pos: [\n        throttle(posInfo.pos - clientLeft + snapOffsetLeft, 0.1),\n        snapOffsetTop,\n      ],\n      size: snapHeight,\n      className: posInfo.className,\n      direction: \"\",\n    });\n  });\n  return guidelines;\n}\n\nexport function getSnapElementRects(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n  values: ElementGuidelineValue[]\n): SnapElementRect[] {\n  if (!values.length) {\n    return [];\n  }\n  const groupable = moveable.props.groupable;\n  const state = moveable.state;\n  const {\n    containerClientRect,\n    // targetClientRect: {\n    //     top: clientTop,\n    //     left: clientLeft,\n    // },\n    rootMatrix,\n    is3d,\n    offsetDelta,\n  } = state;\n  const n = is3d ? 4 : 3;\n  const [containerLeft, containerTop] = calculateContainerPos(\n    rootMatrix,\n    containerClientRect,\n    n\n  );\n  // const poses = getAbsolutePosesByState(state);\n  // const {\n  //     minX: targetLeft,\n  //     minY: targetTop,\n  // } = getMinMaxs(poses);\n  // const [distLeft, distTop] = minus([targetLeft, targetTop], calculateInversePosition(rootMatrix, [\n  //     clientLeft - containerLeft,\n  //     clientTop - containerTop,\n  // ], n)).map(pos => roundSign(pos));\n\n  const offsetLeft = groupable ? 0 : offsetDelta[0];\n  const offsetTop = groupable ? 0 : offsetDelta[1];\n\n  return values.map((value) => {\n    const rect = value.element.getBoundingClientRect();\n    const left = rect.left - containerLeft - offsetLeft;\n    const top = rect.top - containerTop - offsetTop;\n    const bottom = top + rect.height;\n    const right = left + rect.width;\n    const [elementLeft, elementTop] = calculateInversePosition(\n      rootMatrix,\n      [left, top],\n      n\n    );\n    const [elementRight, elementBottom] = calculateInversePosition(\n      rootMatrix,\n      [right, bottom],\n      n\n    );\n\n    return {\n      ...value,\n      rect: {\n        left: elementLeft,\n        right: elementRight,\n        top: elementTop,\n        bottom: elementBottom,\n        center: (elementLeft + elementRight) / 2,\n        middle: (elementTop + elementBottom) / 2,\n      },\n    };\n  });\n}\n","import {\n  Renderer,\n  SnappableProps,\n  SnappableState,\n  SnapGuideline,\n  ScalableProps,\n  SnapPosInfo,\n  RotatableProps,\n  RectInfo,\n  MoveableManagerInterface,\n  SnappableRenderType,\n  BoundType,\n  MoveableGroupInterface,\n  SnapDirectionInfo,\n} from \"../types\";\nimport {\n  prefix,\n  calculatePoses,\n  getRect,\n  getAbsolutePosesByState,\n  getAbsolutePoses,\n  getClientRect,\n  getRefTarget,\n  getDragDistByState,\n  triggerEvent,\n  getDirectionCondition,\n  abs,\n  watchValue,\n} from \"../utils\";\nimport { find, findIndex, hasClass, throttle } from \"../../utility\";\nimport {\n  getDragDist,\n  scaleMatrix,\n  getPosByDirection,\n} from \"../gesto/gesto-utils\";\nimport { minus, rotate, plus } from \"../../matrix\";\nimport { dragControlCondition as rotatableDragControlCondtion } from \"./rotatable\";\nimport { FLOAT_POINT_NUM } from \"../consts\";\nimport {\n  getInnerBoundInfo,\n  getCheckInnerBoundLineInfos,\n  checkRotateInnerBounds,\n  checkInnerBoundPoses,\n} from \"./snappable/inner-bounds\";\nimport {\n  checkBoundPoses,\n  checkRotateBounds,\n  getBounds,\n} from \"./snappable/bounds\";\nimport {\n  checkSnaps,\n  getSnapInfosByDirection,\n  getNearOffsetInfo,\n  getCheckSnapDirections,\n} from \"./snappable/snap\";\nimport {\n  renderSnapPoses,\n  renderGuidelines,\n  renderDashedGuidelines,\n  renderGapGuidelines,\n} from \"./snappable/render\";\nimport { getInitialBounds, hasGuidelines } from \"./snappable/utils\";\nimport {\n  checkMaxBounds,\n  checkMoveableSnapBounds,\n  getSnapBoundInfo,\n} from \"./snappable/snap-bounds\";\nimport { getTotalGuidelines } from \"./snappable/get-total-guidelines\";\nimport {\n  NAME_snapRotationThreshold,\n  NAME_snapRotationDegrees,\n  NAME_snapHorizontalThreshold,\n  NAME_snapVerticalThreshold,\n} from \"./snappable/names\";\n\nexport interface SnapPoses {\n  vertical: number[];\n  horizontal: number[];\n}\n\nexport function checkSnapInfo(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n) {\n  const state = moveable.state;\n  const container = state.container;\n  const snapContainer = moveable.props.snapContainer || container!;\n\n  if (\n    state.snapContainer === snapContainer &&\n    state.guidelines &&\n    state.guidelines.length\n  ) {\n    return false;\n  }\n\n  const containerClientRect = state.containerClientRect;\n  const snapOffset = {\n    left: 0,\n    top: 0,\n    bottom: 0,\n    right: 0,\n  };\n\n  if (container !== snapContainer) {\n    const snapContainerTarget = getRefTarget(snapContainer, true);\n\n    if (snapContainerTarget) {\n      const snapContainerRect = getClientRect(snapContainerTarget);\n      const offset1 = getDragDistByState(state, [\n        snapContainerRect.left - containerClientRect.left,\n        snapContainerRect.top - containerClientRect.top,\n      ]);\n      const offset2 = getDragDistByState(state, [\n        snapContainerRect.right - containerClientRect.right,\n        snapContainerRect.bottom - containerClientRect.bottom,\n      ]);\n\n      snapOffset.left = throttle(offset1[0], 0.00001);\n      snapOffset.top = throttle(offset1[1], 0.00001);\n      snapOffset.right = throttle(offset2[0], 0.00001);\n      snapOffset.bottom = throttle(offset2[1], 0.00001);\n    }\n  }\n\n  state.snapContainer = snapContainer;\n  state.snapOffset = snapOffset;\n  state.guidelines = getTotalGuidelines(moveable);\n  state.enableSnap = true;\n  return true;\n}\n\nfunction getNextFixedPoses(\n  matrix: number[],\n  width: number,\n  height: number,\n  fixedDirection: number[],\n  fixedPos: number[],\n  is3d: boolean\n) {\n  const nextPoses = calculatePoses(matrix, width, height, is3d ? 4 : 3);\n  const nextFixedPos = getPosByDirection(nextPoses, fixedDirection);\n\n  return getAbsolutePoses(nextPoses, minus(fixedPos, nextFixedPos));\n}\n\nexport function normalized(value: number) {\n  return value ? value / abs(value) : 0;\n}\n\nexport function getSizeOffsetInfo(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n  poses: number[][],\n  direction: number[],\n  keepRatio: boolean,\n  isRequest: boolean,\n  datas: any\n) {\n  const { fixedDirection } = datas;\n  const directions = getCheckSnapDirections(\n    direction,\n    fixedDirection,\n    keepRatio\n  );\n  const innerBoundLineInfos = getCheckInnerBoundLineInfos(\n    moveable,\n    poses,\n    direction,\n    keepRatio\n  );\n  const offsets = [\n    ...getSnapBoundInfo(\n      moveable,\n      poses,\n      directions,\n      keepRatio,\n      isRequest,\n      datas\n    ),\n    ...getInnerBoundInfo(moveable, innerBoundLineInfos, datas),\n  ];\n  const widthOffsetInfo = getNearOffsetInfo(offsets, 0);\n  const heightOffsetInfo = getNearOffsetInfo(offsets, 1);\n\n  return {\n    width: {\n      isBound: widthOffsetInfo.isBound,\n      offset: widthOffsetInfo.offset[0],\n    },\n    height: {\n      isBound: heightOffsetInfo.isBound,\n      offset: heightOffsetInfo.offset[1],\n    },\n  };\n}\n\nexport function recheckSizeByTwoDirection(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n  poses: number[][],\n  width: number,\n  height: number,\n  maxWidth: number,\n  maxHeight: number,\n  direction: number[],\n  isRequest: boolean,\n  datas: any\n) {\n  const snapPos = getPosByDirection(poses, direction);\n\n  const {\n    horizontal: { offset: horizontalOffset },\n    vertical: { offset: verticalOffset },\n  } = checkMoveableSnapBounds(moveable, isRequest, {\n    vertical: [snapPos[0]],\n    horizontal: [snapPos[1]],\n  });\n\n  if (\n    throttle(verticalOffset, FLOAT_POINT_NUM) ||\n    throttle(horizontalOffset, FLOAT_POINT_NUM)\n  ) {\n    const [nextWidthOffset, nextHeightOffset] = getDragDist({\n      datas,\n      distX: -verticalOffset,\n      distY: -horizontalOffset,\n    });\n    const nextWidth = Math.min(\n      maxWidth || Infinity,\n      width + direction[0] * nextWidthOffset\n    );\n    const nextHeight = Math.min(\n      maxHeight || Infinity,\n      height + direction[1] * nextHeightOffset\n    );\n\n    return [nextWidth - width, nextHeight - height];\n  }\n  return [0, 0];\n}\n\nexport function checkSizeDist(\n  moveable: MoveableManagerInterface<any, any>,\n  getNextPoses: (widthOffset: number, heightOffset: number) => number[][],\n  width: number,\n  height: number,\n  direction: number[],\n  fixedPosition: number[],\n  isRequest: boolean,\n  datas: any\n) {\n  const poses = getAbsolutePosesByState(moveable.state);\n  const keepRatio = moveable.props.keepRatio;\n\n  let widthOffset = 0;\n  let heightOffset = 0;\n\n  for (let i = 0; i < 2; ++i) {\n    const nextPoses = getNextPoses(widthOffset, heightOffset);\n    const { width: widthOffsetInfo, height: heightOffsetInfo } =\n      getSizeOffsetInfo(\n        moveable,\n        nextPoses,\n        direction,\n        keepRatio,\n        isRequest,\n        datas\n      );\n\n    const isWidthBound = widthOffsetInfo.isBound;\n    const isHeightBound = heightOffsetInfo.isBound;\n    let nextWidthOffset = widthOffsetInfo.offset;\n    let nextHeightOffset = heightOffsetInfo.offset;\n\n    if (i === 1) {\n      if (!isWidthBound) {\n        nextWidthOffset = 0;\n      }\n      if (!isHeightBound) {\n        nextHeightOffset = 0;\n      }\n    }\n    if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {\n      return [0, 0];\n    }\n    if (keepRatio) {\n      const widthDist = abs(nextWidthOffset) * (width ? 1 / width : 1);\n      const heightDist = abs(nextHeightOffset) * (height ? 1 / height : 1);\n      const isGetWidthOffset =\n        isWidthBound && isHeightBound\n          ? widthDist < heightDist\n          : isHeightBound || (!isWidthBound && widthDist < heightDist);\n      if (isGetWidthOffset) {\n        // width : height = ? : heightOffset\n        nextWidthOffset = (width * nextHeightOffset) / height;\n      } else {\n        // width : height = widthOffset : ?\n        nextHeightOffset = (height * nextWidthOffset) / width;\n      }\n    }\n    widthOffset += nextWidthOffset;\n    heightOffset += nextHeightOffset;\n  }\n\n  if (!keepRatio && direction[0] && direction[1]) {\n    const { maxWidth, maxHeight } = checkMaxBounds(\n      moveable,\n      poses,\n      direction,\n      fixedPosition,\n      datas\n    );\n\n    const [nextWidthOffset, nextHeightOffset] = recheckSizeByTwoDirection(\n      moveable,\n      getNextPoses(widthOffset, heightOffset).map((pos) =>\n        pos.map((p) => throttle(p, FLOAT_POINT_NUM))\n      ),\n      width + widthOffset,\n      height + heightOffset,\n      maxWidth,\n      maxHeight,\n      direction,\n      isRequest,\n      datas\n    );\n\n    widthOffset += nextWidthOffset;\n    heightOffset += nextHeightOffset;\n  }\n\n  return [widthOffset, heightOffset];\n}\n\nexport function absDegree(deg: number) {\n  if (deg < 0) {\n    deg = (deg % 360) + 360;\n  }\n  deg %= 360;\n  return deg;\n}\n\nexport function bumpDegree(baseDeg: number, snapDeg: number) {\n  // baseDeg -80\n  // snapDeg 270\n  // return -90\n  snapDeg = absDegree(snapDeg);\n\n  const count = Math.floor(baseDeg / 360);\n\n  const deg1 = count * 360 + 360 - snapDeg;\n  const deg2 = count * 360 + snapDeg;\n\n  return abs(baseDeg - deg1) < abs(baseDeg - deg2) ? deg1 : deg2;\n}\n\nexport function getMinDegreeDistance(deg1: number, deg2: number) {\n  deg1 = absDegree(deg1);\n  deg2 = absDegree(deg2);\n\n  const deg3 = absDegree(deg1 - deg2);\n\n  return Math.min(deg3, 360 - deg3);\n}\n\nexport function checkSnapRotate(\n  moveable: MoveableManagerInterface<SnappableProps & RotatableProps, any>,\n  rect: RectInfo,\n  dist: number,\n  rotation: number\n) {\n  const props = moveable.props;\n  const snapRotationThreshold = props[NAME_snapRotationThreshold] ?? 5;\n  const snapRotationDegrees = props[NAME_snapRotationDegrees];\n\n  if (hasGuidelines(moveable, \"rotatable\")) {\n    const { pos1, pos2, pos3, pos4, origin: origin2 } = rect;\n    const rad = (dist * Math.PI) / 180;\n    const prevPoses = [pos1, pos2, pos3, pos4].map((pos) =>\n      minus(pos, origin2)\n    );\n    const nextPoses = prevPoses.map((pos) => rotate(pos, rad));\n\n    // console.log(moveable.state.left, moveable.state.top, moveable.state.origin);\n    // console.log(pos1, pos2, pos3, pos4, origin, rad, prevPoses, nextPoses);\n    const result = [\n      ...checkRotateBounds(moveable, prevPoses, nextPoses, origin2, dist),\n      ...checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin2, dist),\n    ];\n    result.sort((a, b) => abs(a - dist) - abs(b - dist));\n    const isSnap = result.length > 0;\n\n    if (isSnap) {\n      return {\n        isSnap,\n        dist: isSnap ? result[0] : dist,\n      };\n    }\n  }\n  if (snapRotationDegrees?.length && snapRotationThreshold) {\n    const sorted = snapRotationDegrees.slice().sort((a, b) => {\n      return (\n        getMinDegreeDistance(a, rotation) - getMinDegreeDistance(b, rotation)\n      );\n    });\n    const firstDegree = sorted[0];\n\n    if (getMinDegreeDistance(firstDegree, rotation) <= snapRotationThreshold) {\n      return {\n        isSnap: true,\n        dist: dist + bumpDegree(rotation, firstDegree) - rotation,\n      };\n    }\n  }\n  return {\n    isSnap: false,\n    dist,\n  };\n}\n\nexport function checkSnapResize(\n  moveable: MoveableManagerInterface<{}, {}>,\n  width: number,\n  height: number,\n  direction: number[],\n  fixedPosition: number[],\n  isRequest: boolean,\n  datas: any\n) {\n  if (!hasGuidelines(moveable, \"resizable\")) {\n    return [0, 0];\n  }\n  const { fixedDirection, nextAllMatrix } = datas;\n  const { allMatrix, is3d } = moveable.state;\n\n  return checkSizeDist(\n    moveable,\n    (widthOffset: number, heightOffset: number) => {\n      return getNextFixedPoses(\n        nextAllMatrix || allMatrix,\n        width + widthOffset,\n        height + heightOffset,\n        fixedDirection,\n        fixedPosition,\n        is3d\n      );\n    },\n    width,\n    height,\n    direction,\n    fixedPosition,\n    isRequest,\n    datas\n  );\n}\nexport function checkSnapScale(\n  moveable: MoveableManagerInterface<ScalableProps, any>,\n  scale: number[],\n  direction: number[],\n  isRequest: boolean,\n  datas: any\n) {\n  if (!hasGuidelines(moveable, \"scalable\")) {\n    return [0, 0];\n  }\n  const {\n    startOffsetWidth,\n    startOffsetHeight,\n    fixedPosition,\n    fixedDirection,\n    is3d,\n  } = datas;\n  const sizeDist = checkSizeDist(\n    moveable,\n    (widthOffset: number, heightOffset: number) => {\n      return getNextFixedPoses(\n        scaleMatrix(\n          datas,\n          plus(scale, [\n            widthOffset / startOffsetWidth,\n            heightOffset / startOffsetHeight,\n          ])\n        ),\n        startOffsetWidth,\n        startOffsetHeight,\n        fixedDirection,\n        fixedPosition,\n        is3d\n      );\n    },\n    startOffsetWidth,\n    startOffsetHeight,\n    direction,\n    fixedPosition,\n    isRequest,\n    datas\n  );\n  return [sizeDist[0] / startOffsetWidth, sizeDist[1] / startOffsetHeight];\n}\n\nexport function startCheckSnapDrag(\n  moveable: MoveableManagerInterface<any, any>,\n  datas: any\n) {\n  datas.absolutePoses = getAbsolutePosesByState(moveable.state);\n}\n\nfunction getSnapGuidelines(posInfos: SnapPosInfo[]) {\n  const guidelines: Array<{ guideline: SnapGuideline; posInfo: SnapPosInfo }> =\n    [];\n\n  posInfos.forEach((posInfo) => {\n    posInfo.guidelineInfos.forEach(({ guideline }) => {\n      if (find(guidelines, (info) => info.guideline === guideline)) {\n        return;\n      }\n      guideline.direction = \"\";\n      guidelines.push({ guideline, posInfo });\n    });\n  });\n\n  return guidelines.map(({ guideline, posInfo }) => {\n    return {\n      ...guideline,\n      direction: posInfo.direction,\n    };\n  });\n}\n\nfunction addBoundGuidelines(\n  moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n  verticalPoses: number[],\n  horizontalPoses: number[],\n  verticalSnapPoses: SnappableRenderType[],\n  horizontalSnapPoses: SnappableRenderType[],\n  externalBounds?: BoundType | false | null\n) {\n  const { vertical: verticalBoundInfos, horizontal: horizontalBoundInfos } =\n    checkBoundPoses(\n      getBounds(moveable, externalBounds),\n      verticalPoses,\n      horizontalPoses\n    );\n\n  const boundMap = getInitialBounds();\n\n  verticalBoundInfos.forEach((info) => {\n    if (info.isBound) {\n      if (info.direction === \"start\") {\n        boundMap.left = true;\n      }\n      if (info.direction === \"end\") {\n        boundMap.right = true;\n      }\n      verticalSnapPoses.push({\n        type: \"bounds\",\n        pos: info.pos,\n      });\n    }\n  });\n  horizontalBoundInfos.forEach((info) => {\n    if (info.isBound) {\n      if (info.direction === \"start\") {\n        boundMap.top = true;\n      }\n      if (info.direction === \"end\") {\n        boundMap.bottom = true;\n      }\n      horizontalSnapPoses.push({\n        type: \"bounds\",\n        pos: info.pos,\n      });\n    }\n  });\n  const {\n    boundMap: innerBoundMap,\n    vertical: verticalInnerBoundPoses,\n    horizontal: horizontalInnerBoundPoses,\n  } = checkInnerBoundPoses(moveable);\n\n  verticalInnerBoundPoses.forEach((innerPos) => {\n    if (\n      findIndex(\n        verticalSnapPoses,\n        ({ type, pos }) => type === \"bounds\" && pos === innerPos\n      ) >= 0\n    ) {\n      return;\n    }\n    verticalSnapPoses.push({\n      type: \"bounds\",\n      pos: innerPos,\n    });\n  });\n\n  horizontalInnerBoundPoses.forEach((innerPos) => {\n    if (\n      findIndex(\n        horizontalSnapPoses,\n        ({ type, pos }) => type === \"bounds\" && pos === innerPos\n      ) >= 0\n    ) {\n      return;\n    }\n    horizontalSnapPoses.push({\n      type: \"bounds\",\n      pos: innerPos,\n    });\n  });\n\n  return {\n    boundMap,\n    innerBoundMap,\n  };\n}\n\nconst directionCondition = getDirectionCondition(\"\", [\"resizable\", \"scalable\"]);\n\n/**\n * @namespace Moveable.Snappable\n * @description Whether or not target can be snapped to the guideline. (default: false)\n * @sort 2\n */\nexport default {\n  name: \"snappable\",\n  dragRelation: \"strong\",\n  props: [\n    \"snappable\",\n    \"snapContainer\",\n    \"snapDirections\",\n    \"elementSnapDirections\",\n    \"snapGap\",\n    \"snapGridWidth\",\n    \"snapGridHeight\",\n    \"isDisplaySnapDigit\",\n    \"isDisplayInnerSnapDigit\",\n    \"isDisplayGridGuidelines\",\n    \"snapDigit\",\n    \"snapThreshold\",\n    \"snapRenderThreshold\",\n    \"snapGridAll\",\n    NAME_snapRotationThreshold,\n    NAME_snapRotationDegrees,\n    NAME_snapHorizontalThreshold,\n    NAME_snapVerticalThreshold,\n    \"horizontalGuidelines\",\n    \"verticalGuidelines\",\n    \"elementGuidelines\",\n    \"bounds\",\n    \"innerBounds\",\n    \"snapDistFormat\",\n    \"maxSnapElementGuidelineDistance\",\n    \"maxSnapElementGapDistance\",\n  ] as const,\n  events: [\"snap\", \"bound\"] as const,\n  css: [\n    `:host {\n--bounds-color: #d66;\n}\n.guideline {\npointer-events: none;\nz-index: 2;\n}\n.guideline.bounds {\nbackground: #d66;\nbackground: var(--bounds-color);\n}\n.guideline-group {\nposition: absolute;\ntop: 0;\nleft: 0;\n}\n.guideline-group .size-value {\nposition: absolute;\ncolor: #f55;\nfont-size: 12px;\nfont-size: calc(12px * var(--zoom));\nfont-weight: bold;\n}\n.guideline-group.horizontal .size-value {\ntransform-origin: 50% 100%;\ntransform: translateX(-50%);\nleft: 50%;\nbottom: 5px;\nbottom: calc(2px + 3px * var(--zoom));\n}\n.guideline-group.vertical .size-value {\ntransform-origin: 0% 50%;\ntop: 50%;\ntransform: translateY(-50%);\nleft: 5px;\nleft: calc(2px + 3px * var(--zoom));\n}\n.guideline.gap {\nbackground: #f55;\n}\n.size-value.gap {\ncolor: #f55;\n}\n`,\n  ],\n  render(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    React: Renderer\n  ): any[] {\n    const state = moveable.state;\n    const {\n      top: targetTop,\n      left: targetLeft,\n      pos1,\n      pos2,\n      pos3,\n      pos4,\n      snapRenderInfo,\n    } = state;\n    const { snapRenderThreshold = 1 } = moveable.props;\n\n    if (\n      !snapRenderInfo ||\n      !snapRenderInfo.render ||\n      !hasGuidelines(moveable, \"\")\n    ) {\n      // reset store\n      watchValue(moveable, \"boundMap\", getInitialBounds(), (v) =>\n        JSON.stringify(v)\n      );\n      watchValue(moveable, \"innerBoundMap\", getInitialBounds(), (v) =>\n        JSON.stringify(v)\n      );\n      return [];\n    }\n    state.guidelines = getTotalGuidelines(moveable);\n\n    const minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\n    const minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\n    const externalPoses = snapRenderInfo.externalPoses || [];\n    const poses = getAbsolutePosesByState(moveable.state);\n    const verticalSnapPoses: SnappableRenderType[] = [];\n    const horizontalSnapPoses: SnappableRenderType[] = [];\n    const verticalGuidelines: SnapGuideline[] = [];\n    const horizontalGuidelines: SnapGuideline[] = [];\n    const snapInfos: Array<{\n      vertical: SnapDirectionInfo;\n      horizontal: SnapDirectionInfo;\n    }> = [];\n    const { width, height, top, left, bottom, right } = getRect(poses);\n    const targetRect = {\n      left,\n      right,\n      top,\n      bottom,\n      center: (left + right) / 2,\n      middle: (top + bottom) / 2,\n    };\n    const hasExternalPoses = externalPoses.length > 0;\n    const externalRect = hasExternalPoses\n      ? getRect(externalPoses)\n      : ({} as ReturnType<typeof getRect>);\n\n    if (!snapRenderInfo.request) {\n      if (snapRenderInfo.direction) {\n        snapInfos.push(\n          getSnapInfosByDirection(\n            moveable,\n            poses,\n            snapRenderInfo.direction,\n            snapRenderThreshold,\n            snapRenderThreshold\n          )\n        );\n      }\n      if (snapRenderInfo.snap) {\n        const rect = getRect(poses);\n        if (snapRenderInfo.center) {\n          (rect as any).middle = (rect.top + rect.bottom) / 2;\n          (rect as any).center = (rect.left + rect.right) / 2;\n        }\n        snapInfos.push(\n          checkSnaps(moveable, rect, snapRenderThreshold, snapRenderThreshold)\n        );\n      }\n      if (hasExternalPoses) {\n        if (snapRenderInfo.center) {\n          (externalRect as any).middle =\n            (externalRect.top + externalRect.bottom) / 2;\n          (externalRect as any).center =\n            (externalRect.left + externalRect.right) / 2;\n        }\n        snapInfos.push(\n          checkSnaps(\n            moveable,\n            externalRect,\n            snapRenderThreshold,\n            snapRenderThreshold\n          )\n        );\n      }\n      snapInfos.forEach((snapInfo) => {\n        const {\n          vertical: { posInfos: verticalPosInfos },\n          horizontal: { posInfos: horizontalPosInfos },\n        } = snapInfo;\n        verticalSnapPoses.push(\n          ...verticalPosInfos\n            .filter(({ guidelineInfos }) => {\n              return guidelineInfos.some(({ guideline }) => !guideline.hide);\n            })\n            .map(\n              (posInfo) =>\n                ({\n                  type: \"snap\",\n                  pos: posInfo.pos,\n                } as const)\n            )\n        );\n        horizontalSnapPoses.push(\n          ...horizontalPosInfos\n            .filter(({ guidelineInfos }) => {\n              return guidelineInfos.some(({ guideline }) => !guideline.hide);\n            })\n            .map(\n              (posInfo) =>\n                ({\n                  type: \"snap\",\n                  pos: posInfo.pos,\n                } as const)\n            )\n        );\n\n        verticalGuidelines.push(...getSnapGuidelines(verticalPosInfos));\n        horizontalGuidelines.push(...getSnapGuidelines(horizontalPosInfos));\n      });\n    }\n\n    const { boundMap, innerBoundMap } = addBoundGuidelines(\n      moveable,\n      [left, right],\n      [top, bottom],\n      verticalSnapPoses,\n      horizontalSnapPoses\n    );\n    if (hasExternalPoses) {\n      addBoundGuidelines(\n        moveable,\n        [externalRect.left, externalRect.right],\n        [externalRect.top, externalRect.bottom],\n        verticalSnapPoses,\n        horizontalSnapPoses,\n        snapRenderInfo.externalBounds\n      );\n    }\n    const allGuidelines = [...verticalGuidelines, ...horizontalGuidelines];\n    const elementGuidelines = allGuidelines.filter(\n      (guideline) => guideline.element && !guideline.gapRects\n    );\n    const gapGuidelines = allGuidelines\n      .filter((guideline) => guideline.gapRects)\n      .sort((a, b) => {\n        return a.gap! - b.gap!;\n      });\n\n    triggerEvent(\n      moveable,\n      \"onSnap\",\n      {\n        guidelines: allGuidelines.filter(({ element }) => !element),\n        elements: elementGuidelines,\n        gaps: gapGuidelines,\n      },\n      true\n    );\n\n    const nextBoundMap = watchValue(\n      moveable,\n      \"boundMap\",\n      boundMap,\n      (v) => JSON.stringify(v),\n      getInitialBounds()\n    );\n    const nextInnerBoundMap = watchValue(\n      moveable,\n      \"innerBoundMap\",\n      innerBoundMap,\n      (v) => JSON.stringify(v),\n      getInitialBounds()\n    );\n\n    if (boundMap === nextBoundMap || innerBoundMap === nextInnerBoundMap) {\n      triggerEvent(\n        moveable,\n        \"onBound\",\n        {\n          bounds: boundMap,\n          innerBounds: innerBoundMap,\n        },\n        true\n      );\n    }\n\n    // verticalSnapPoses.\n    return [\n      ...renderDashedGuidelines(\n        moveable,\n        elementGuidelines,\n        [minLeft, minTop],\n        targetRect,\n        React\n      ),\n      ...renderGapGuidelines(\n        moveable,\n        gapGuidelines,\n        [minLeft, minTop],\n        targetRect,\n        React\n      ),\n      ...renderGuidelines(\n        moveable,\n        \"horizontal\",\n        horizontalGuidelines,\n        [targetLeft, targetTop],\n        targetRect,\n        React\n      ),\n      ...renderGuidelines(\n        moveable,\n        \"vertical\",\n        verticalGuidelines,\n        [targetLeft, targetTop],\n        targetRect,\n        React\n      ),\n      ...renderSnapPoses(\n        moveable,\n        \"horizontal\",\n        horizontalSnapPoses,\n        minLeft,\n        targetTop,\n        width,\n        0,\n        React\n      ),\n      ...renderSnapPoses(\n        moveable,\n        \"vertical\",\n        verticalSnapPoses,\n        minTop,\n        targetLeft,\n        height,\n        1,\n        React\n      ),\n    ];\n  },\n  dragStart(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    e: any\n  ) {\n    moveable.state.snapRenderInfo = {\n      request: e.isRequest,\n      snap: true,\n      center: true,\n    };\n    checkSnapInfo(moveable);\n  },\n  drag(moveable: MoveableManagerInterface<SnappableProps, SnappableState>) {\n    const state = moveable.state;\n    if (!checkSnapInfo(moveable)) {\n      state.guidelines = getTotalGuidelines(moveable);\n    }\n    if (state.snapRenderInfo) {\n      state.snapRenderInfo.render = true;\n    }\n  },\n  pinchStart(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n  ) {\n    this.unset(moveable);\n  },\n  dragEnd(moveable: MoveableManagerInterface<SnappableProps, SnappableState>) {\n    this.unset(moveable);\n  },\n  dragControlCondition(moveable: MoveableManagerInterface, e: any) {\n    if (\n      directionCondition(moveable, e) ||\n      rotatableDragControlCondtion(moveable, e)\n    ) {\n      return true;\n    }\n    if (!e.isRequest && e.inputEvent) {\n      return hasClass(e.inputEvent.target, prefix(\"snap-control\"));\n    }\n  },\n  dragControlStart(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n  ) {\n    moveable.state.snapRenderInfo = null;\n    checkSnapInfo(moveable);\n  },\n  dragControl(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n  ) {\n    this.drag(moveable);\n  },\n  dragControlEnd(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n  ) {\n    this.unset(moveable);\n  },\n  dragGroupStart(moveable: any, e: any) {\n    this.dragStart(moveable, e);\n  },\n  dragGroup(moveable: MoveableGroupInterface<SnappableProps, SnappableState>) {\n    this.drag(moveable);\n  },\n  dragGroupEnd(\n    moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n  ) {\n    this.unset(moveable);\n  },\n  dragGroupControlStart(\n    moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n  ) {\n    moveable.state.snapRenderInfo = null;\n    checkSnapInfo(moveable);\n  },\n  dragGroupControl(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n  ) {\n    this.drag(moveable);\n  },\n  dragGroupControlEnd(\n    moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n  ) {\n    this.unset(moveable);\n  },\n  unset(moveable: any) {\n    const state = moveable.state;\n\n    state.enableSnap = false;\n    state.guidelines = [];\n    state.snapRenderInfo = null;\n    state.elementRects = [];\n  },\n};\n\n/**\n * Whether or not target can be snapped to the guideline. (default: false)\n * @name Moveable.Snappable#snappable\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snappable = true;\n */\n/**\n *  A snap container that is the basis for snap, bounds, and innerBounds. (default: null = container)\n * @name Moveable.Snappable#snapContainer\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.querySelector(\".container\"));\n *\n * moveable.snapContainer = document.body;\n */\n/**\n * You can specify the directions to snap to the target. (default: { left: true, top: true, right: true, bottom: true })\n * @name Moveable.Snappable#snapDirections\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapDirections: true,\n * });\n * // snap center\n * moveable.snapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };\n */\n\n/**\n * You can specify the snap directions of elements. (default: { left: true, ftrue, right: true, bottom: true })\n * @name Moveable.Snappable#elementSnapDirections\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   elementSnapDirections: true,\n * });\n * // snap center\n * moveable.elementSnapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };\n */\n/**\n * When you drag, make the gap snap in the element guidelines. (default: true)\n * @name Moveable.Snappable#snapGap\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapElement: true,\n *   snapGap: true,\n * });\n *\n * moveable.snapGap = false;\n */\n/**\n * Distance value that can snap to guidelines. (default: 5)\n * @name Moveable.Snappable#snapThreshold\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapThreshold = 5;\n */\n\n/**\n * Add guidelines in the horizontal direction. (default: [])\n * @name Moveable.Snappable#horizontalGuidelines\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.horizontalGuidelines = [100, 200, 500];\n */\n\n/**\n * Add guidelines in the vertical direction. (default: [])\n * @name Moveable.Snappable#verticalGuidelines\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.verticalGuidelines = [100, 200, 500];\n */\n/**\n * Add guidelines for the element. (default: [])\n * @name Moveable.Snappable#elementGuidelines\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.elementGuidelines = [\n *   document.querySelector(\".element\"),\n * ];\n */\n/**\n * You can set up boundaries.\n * @name Moveable.Snappable#bounds\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @default null\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.bounds = { left: 0, right: 1000, top: 0, bottom: 1000};\n */\n/**\n * You can set up inner boundaries.\n * @name Moveable.Snappable#innerBounds\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @default null\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.innerBounds = { left: 500, top: 500, width: 100, height: 100};\n */\n/**\n * snap distance digits (default: 0)\n * @name Moveable.Snappable#snapDigit\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapDigit = 0\n */\n\n/**\n * If width size is greater than 0, you can vertical snap to the grid. (default: 0)\n * @name Moveable.Snappable#snapGridWidth\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapGridWidth = 5;\n */\n\n/**\n * If height size is greater than 0, you can horizontal snap to the grid. (default: 0)\n * @name Moveable.Snappable#snapGridHeight\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapGridHeight = 5;\n */\n/**\n * Whether to show snap distance (default: true)\n * @name Moveable.Snappable#isDisplaySnapDigit\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.isDisplaySnapDigit = true;\n */\n\n/**\n * Whether to show element inner snap distance (default: false)\n * @name Moveable.Snappable#isDisplayInnerSnapDigit\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.isDisplayInnerSnapDigit = true;\n */\n\n/**\n * You can set the text format of the distance shown in the guidelines. (default: self)\n * @name Moveable.Snappable#snapDistFormat\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  snappable: true,\n *  snapDistFormat: (v, type) => v,\n * });\n * moveable.snapDistFormat = (v, type) => `${v}px`;\n */\n\n/**\n * When you drag or dragControl, the `snap` event is called.\n * @memberof Moveable.Snappable\n * @event snap\n * @param {Moveable.Snappable.OnSnap} - Parameters for the `snap` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     snappable: true\n * });\n * moveable.on(\"snap\", e => {\n *     console.log(\"onSnap\", e);\n * });\n */\n","import { PREFIX, IS_WEBKIT605, TINY_NUM } from \"./consts\";\nimport { prefixNames } from \"../utility/framework\";\nimport {\n  isUndefined,\n  isObject,\n  splitUnit,\n  IObject,\n  hasClass,\n  isArray,\n  isString,\n  getRad,\n  isFunction,\n  convertUnitSize,\n  between,\n  getKeys,\n  decamelize,\n  isNumber,\n  getDocumentBody,\n  getDocumentElement,\n  getWindow,\n  isNode,\n  isWindow,\n  counter,\n} from \"../utility\";\nimport {\n  multiply,\n  invert,\n  convertDimension,\n  createIdentityMatrix,\n  createOriginMatrix,\n  convertPositionMatrix,\n  calculate,\n  multiplies,\n  minus,\n  createScaleMatrix,\n  plus,\n  convertMatrixtoCSS,\n  rotate,\n} from \"..//matrix\";\nimport {\n  MoveableManagerState,\n  Able,\n  MoveableClientRect,\n  MoveableProps,\n  ArrayFormat,\n  MoveableRefType,\n  MatrixInfo,\n  ExcludeEndParams,\n  ExcludeParams,\n  ElementSizes,\n  TransformObject,\n  MoveableRefTargetsResultType,\n  MoveableRefTargetType,\n  MoveableManagerInterface,\n  CSSObject,\n  PaddingBox,\n} from \"./types\";\nimport { parse, toMat, calculateMatrixDist, parseMat } from \"../css-to-mat\";\nimport { getBeforeRenderableDatas, getDragDist } from \"./gesto/gesto-utils\";\nimport { getGestoData } from \"./gesto/gesto-data\";\nimport { GetStyle, getCachedStyle } from \"./store/store\";\nimport { normalized } from \"./ables/snappable\";\n\nexport function round(num: number) {\n  return Math.round(num);\n}\nexport function multiply2(pos1: number[], pos2: number[]) {\n  return [pos1[0] * pos2[0], pos1[1] * pos2[1]];\n}\nexport function prefix(...classNames: string[]) {\n  return prefixNames(PREFIX, ...classNames);\n}\n\nexport function defaultSync(fn: () => void) {\n  fn();\n}\n\nexport function createIdentityMatrix3() {\n  return createIdentityMatrix(3);\n}\n\nexport function getTransformMatrix(transform: string | number[]) {\n  if (!transform || transform === \"none\") {\n    return [1, 0, 0, 1, 0, 0];\n  }\n  if (isObject(transform)) {\n    return transform;\n  }\n  return parseMat(transform);\n}\nexport function getAbsoluteMatrix(\n  matrix: number[],\n  n: number,\n  origin: number[]\n) {\n  return multiplies(\n    n,\n    createOriginMatrix(origin, n),\n    matrix,\n    createOriginMatrix(\n      origin.map((a) => -a),\n      n\n    )\n  );\n}\nexport function measureSVGSize(\n  el: SVGElement,\n  unit: string,\n  isHorizontal: boolean\n) {\n  if (unit === \"%\") {\n    const viewBox = getSVGViewBox(el.ownerSVGElement!);\n\n    return viewBox[isHorizontal ? \"width\" : \"height\"] / 100;\n  }\n  return 1;\n}\nexport function getBeforeTransformOrigin(el: SVGElement) {\n  const relativeOrigin = getTransformOrigin(getComputedStyle(el, \":before\"));\n\n  return relativeOrigin.map((o, i) => {\n    const { value, unit } = splitUnit(o);\n\n    return value * measureSVGSize(el, unit, i === 0);\n  });\n}\nexport function getTransformOriginArray(transformOrigin: string) {\n  return transformOrigin ? transformOrigin.split(\" \") : [\"0\", \"0\"];\n}\nexport function getTransformOrigin(style: CSSStyleDeclaration) {\n  return getTransformOriginArray(style.transformOrigin);\n}\nexport function getElementTransform(target: HTMLElement | SVGElement): string {\n  const getStyle = getCachedStyle(target);\n  const computedTransform = getStyle(\"transform\");\n\n  if (computedTransform && computedTransform !== \"none\") {\n    return computedTransform;\n  }\n  if (\"transform\" in target) {\n    const list = (target as any).transform as SVGAnimatedTransformList;\n    const baseVal = list.baseVal;\n\n    if (!baseVal) {\n      return \"\";\n    }\n    const length = baseVal.length;\n\n    if (!length) {\n      return \"\";\n    }\n\n    const matrixes: string[] = [];\n\n    for (let i = 0; i < length; ++i) {\n      const matrix = baseVal[i].matrix;\n\n      matrixes.push(\n        `matrix(${([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] as const)\n          .map((chr) => matrix[chr])\n          .join(\", \")})`\n      );\n    }\n    return matrixes.join(\" \");\n  }\n  return \"\";\n}\n\nexport function getOffsetInfo(\n  el: SVGElement | HTMLElement | null | undefined,\n  lastParent: SVGElement | HTMLElement | null | undefined,\n  isParent?: boolean,\n  checkZoom?: boolean,\n  getTargetStyle?: GetStyle\n) {\n  const documentElement = getDocumentElement(el!) || getDocumentBody(el!);\n  let hasSlot = false;\n  let target: HTMLElement | SVGElement | null | undefined;\n  let parentSlotElement: HTMLElement | null | undefined;\n\n  if (!el || isParent) {\n    target = el;\n  } else {\n    const assignedSlotParentElement = el?.assignedSlot?.parentElement;\n    const parentElement = el.parentElement;\n\n    if (assignedSlotParentElement) {\n      hasSlot = true;\n      parentSlotElement = parentElement;\n      target = assignedSlotParentElement;\n    } else {\n      target = parentElement;\n    }\n  }\n\n  let isCustomElement = false;\n  let isEnd = el === lastParent || target === lastParent;\n  let position = \"relative\";\n  let offsetZoom = 1;\n\n  const targetZoom = parseFloat(getTargetStyle?.(\"zoom\")) || 1;\n  const targetPosition = getTargetStyle?.(\"position\");\n\n  while (target && target !== documentElement) {\n    if (lastParent === target) {\n      isEnd = true;\n    }\n    const getStyle = getCachedStyle(target);\n    const tagName = target.tagName.toLowerCase();\n    const transform = getElementTransform(target as SVGElement);\n    const willChange = getStyle(\"willChange\");\n    const zoom = parseFloat(getStyle(\"zoom\")) || 1;\n\n    position = getStyle(\"position\");\n    if (checkZoom && zoom !== 1) {\n      offsetZoom = zoom;\n      break;\n    }\n    if (\n      // offsetParent is the parentElement if the target's zoom is not 1 and not absolute.\n      (!isParent &&\n        checkZoom &&\n        targetZoom !== 1 &&\n        targetPosition &&\n        targetPosition !== \"absolute\") ||\n      tagName === \"svg\" ||\n      tagName === \"foreignobject\" ||\n      position !== \"static\" ||\n      (transform && transform !== \"none\") ||\n      willChange === \"transform\"\n    ) {\n      break;\n    }\n    const slotParentNode = el?.assignedSlot?.parentNode;\n    const targetParentNode = target.parentNode;\n\n    if (slotParentNode) {\n      hasSlot = true;\n      parentSlotElement = targetParentNode as HTMLElement;\n    }\n    const parentNode = targetParentNode;\n\n    if (parentNode && parentNode.nodeType === 11) {\n      // Shadow Root\n      target = (parentNode as ShadowRoot).host as HTMLElement;\n      isCustomElement = true;\n      position = getCachedStyle(target)(\"position\");\n      break;\n    }\n    target = parentNode as HTMLElement | SVGElement;\n    position = \"relative\";\n  }\n  return {\n    offsetZoom,\n    hasSlot,\n    parentSlotElement,\n    isCustomElement,\n    isStatic: position === \"static\",\n    isEnd: isEnd || !target || target === documentElement,\n    offsetParent: (target as HTMLElement) || documentElement,\n  };\n}\n\nexport function getOffsetPosInfo(\n  el: HTMLElement | SVGElement,\n  target: HTMLElement | SVGElement\n) {\n  const tagName = el.tagName.toLowerCase();\n  let offsetLeft = (el as HTMLElement).offsetLeft;\n  let offsetTop = (el as HTMLElement).offsetTop;\n  const getStyle = getCachedStyle(el);\n  // svg\n  const isSVG = isUndefined(offsetLeft);\n  let hasOffset = !isSVG;\n  let origin: number[];\n  let targetOrigin: number[];\n  // inner svg element\n  if (!hasOffset && (tagName !== \"svg\" || (el as SVGElement).ownerSVGElement)) {\n    origin = IS_WEBKIT605\n      ? getBeforeTransformOrigin(el as SVGElement)\n      : getTransformOriginArray(getStyle(\"transformOrigin\")).map((pos) =>\n          parseFloat(pos)\n        );\n\n    targetOrigin = origin.slice();\n    hasOffset = true;\n\n    if (tagName === \"svg\") {\n      offsetLeft = 0;\n      offsetTop = 0;\n    } else {\n      [offsetLeft, offsetTop, origin[0], origin[1]] = getSVGGraphicsOffset(\n        el as SVGGraphicsElement,\n        origin,\n        el === target && target.tagName.toLowerCase() === \"g\"\n      );\n    }\n  } else {\n    origin = getTransformOriginArray(getStyle(\"transformOrigin\")).map((pos) =>\n      parseFloat(pos)\n    );\n\n    targetOrigin = origin.slice();\n    // console.log(getStyle(\"transformOrigin\"), targetOrigin);\n  }\n  return {\n    tagName,\n    isSVG,\n    hasOffset,\n    offset: [offsetLeft || 0, offsetTop || 0],\n    origin,\n    targetOrigin,\n  };\n}\nexport function getBodyOffset(el: HTMLElement | SVGElement, isSVG: boolean) {\n  const getStyle = getCachedStyle(el);\n  const getBodyStyle = getCachedStyle(getDocumentBody(el));\n  const bodyPosition = getBodyStyle(\"position\");\n  if (!isSVG && (!bodyPosition || bodyPosition === \"static\")) {\n    return [0, 0];\n  }\n\n  let marginLeft = parseInt(getBodyStyle(\"marginLeft\"), 10);\n  let marginTop = parseInt(getBodyStyle(\"marginTop\"), 10);\n\n  if (getStyle(\"position\") === \"absolute\") {\n    if (getStyle(\"top\") !== \"auto\" || getStyle(\"bottom\") !== \"auto\") {\n      marginTop = 0;\n    }\n    if (getStyle(\"left\") !== \"auto\" || getStyle(\"right\") !== \"auto\") {\n      marginLeft = 0;\n    }\n  }\n\n  return [marginLeft, marginTop];\n}\nexport function convert3DMatrixes(matrixes: MatrixInfo[]) {\n  matrixes.forEach((info) => {\n    const matrix = info.matrix;\n\n    if (matrix) {\n      info.matrix = convertDimension(matrix, 3, 4);\n    }\n  });\n}\n\nexport function getPositionFixedInfo(el: HTMLElement | SVGElement) {\n  let fixedContainer = el.parentElement;\n  let hasTransform = false;\n  const body = getDocumentBody(el);\n\n  while (fixedContainer) {\n    const transform = getComputedStyle(fixedContainer).transform;\n\n    if (transform && transform !== \"none\") {\n      hasTransform = true;\n      break;\n    }\n    if (fixedContainer === body) {\n      break;\n    }\n    fixedContainer = fixedContainer.parentElement;\n  }\n\n  return {\n    fixedContainer: fixedContainer || body,\n    hasTransform,\n  };\n}\n\nexport function makeMatrixCSS(\n  matrix: number[],\n  is3d: boolean = matrix.length > 9\n) {\n  return `${is3d ? \"matrix3d\" : \"matrix\"}(${convertMatrixtoCSS(\n    matrix,\n    !is3d\n  ).join(\",\")})`;\n}\nexport function getSVGViewBox(el: SVGSVGElement) {\n  const clientWidth = el.clientWidth;\n  const clientHeight = el.clientHeight;\n\n  if (!el) {\n    return { x: 0, y: 0, width: 0, height: 0, clientWidth, clientHeight };\n  }\n  const viewBox = el.viewBox;\n  const baseVal = (viewBox && viewBox.baseVal) || {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n  };\n\n  return {\n    x: baseVal.x,\n    y: baseVal.y,\n    width: baseVal.width || clientWidth,\n    height: baseVal.height || clientHeight,\n    clientWidth,\n    clientHeight,\n  };\n}\nexport function getSVGMatrix(el: SVGSVGElement, n: number) {\n  const {\n    width: viewBoxWidth,\n    height: viewBoxHeight,\n    clientWidth,\n    clientHeight,\n  } = getSVGViewBox(el);\n  const scaleX = clientWidth / viewBoxWidth;\n  const scaleY = clientHeight / viewBoxHeight;\n\n  const preserveAspectRatio = el.preserveAspectRatio.baseVal;\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio\n  const align = preserveAspectRatio.align;\n  // 1 : meet 2: slice\n  const meetOrSlice = preserveAspectRatio.meetOrSlice;\n  const svgOrigin = [0, 0];\n  const scale = [scaleX, scaleY];\n  const translate = [0, 0];\n\n  if (align !== 1) {\n    const xAlign = (align - 2) % 3;\n    const yAlign = Math.floor((align - 2) / 3);\n\n    svgOrigin[0] = (viewBoxWidth * xAlign) / 2;\n    svgOrigin[1] = (viewBoxHeight * yAlign) / 2;\n\n    const scaleDimension =\n      meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\n\n    scale[0] = scaleDimension;\n    scale[1] = scaleDimension;\n\n    translate[0] = ((clientWidth - viewBoxWidth) / 2) * xAlign;\n    translate[1] = ((clientHeight - viewBoxHeight) / 2) * yAlign;\n  }\n  const scaleMatrix = createScaleMatrix(scale, n);\n  [scaleMatrix[n * (n - 1)], scaleMatrix[n * (n - 1) + 1]] = translate;\n\n  return getAbsoluteMatrix(scaleMatrix, n, svgOrigin);\n}\nexport function getSVGGraphicsOffset(\n  el: SVGGraphicsElement,\n  origin: number[],\n  isGTarget?: boolean\n) {\n  const tagName = el.tagName.toLowerCase();\n\n  if (!el.getBBox || (!isGTarget && tagName === \"g\")) {\n    return [0, 0, 0, 0];\n  }\n  const getStyle = getCachedStyle(el);\n  const isFillBox = getStyle(\"transform-box\") === \"fill-box\";\n\n  const bbox = el.getBBox();\n  const viewBox = getSVGViewBox(el.ownerSVGElement!);\n  let x = bbox.x;\n  let y = bbox.y;\n\n  // x, y가 0으로 나타나는 버그\n  if (tagName === \"foreignobject\" && !x && !y) {\n    x = parseFloat(el.getAttribute(\"x\")!) || 0;\n    y = parseFloat(el.getAttribute(\"y\")!) || 0;\n  }\n  const left = x - viewBox.x;\n  const top = y - viewBox.y;\n  const originX = isFillBox ? origin[0] : origin[0] - left;\n  const originY = isFillBox ? origin[1] : origin[1] - top;\n\n  // if (isFillBox) {\n  //     const bbox = (el as SVGGraphicsElement).getBBox();\n  //     const x = parseFloat(getStyle(\"x\")) || bbox.x;\n  //     const y = parseFloat(getStyle(\"y\")) || bbox.y;\n\n  //     const xScale = bbox.x / x;\n  //     const yScale = bbox.y / y;\n\n  //     console.log(x, y);\n\n  //     originX *= xScale;\n  //     originY *= yScale;\n  // }\n\n  return [left, top, originX, originY];\n}\nexport function calculatePosition(matrix: number[], pos: number[], n: number) {\n  return calculate(matrix, convertPositionMatrix(pos, n), n);\n}\nexport function calculatePoses(\n  matrix: number[],\n  width: number,\n  height: number,\n  n: number\n) {\n  return [\n    [0, 0],\n    [width, 0],\n    [0, height],\n    [width, height],\n  ].map((pos) => calculatePosition(matrix, pos, n));\n}\nexport function getRect(poses: number[][]) {\n  const posesX = poses.map((pos) => pos[0]);\n  const posesY = poses.map((pos) => pos[1]);\n  const left = Math.min(...posesX);\n  const top = Math.min(...posesY);\n  const right = Math.max(...posesX);\n  const bottom = Math.max(...posesY);\n  const rectWidth = right - left;\n  const rectHeight = bottom - top;\n\n  return {\n    left,\n    top,\n    right,\n    bottom,\n    width: rectWidth,\n    height: rectHeight,\n  };\n}\nexport function calculateRect(\n  matrix: number[],\n  width: number,\n  height: number,\n  n: number\n) {\n  const poses = calculatePoses(matrix, width, height, n);\n\n  return getRect(poses);\n}\nexport function getSVGOffset(\n  offsetInfo: MatrixInfo,\n  targetInfo: MatrixInfo,\n  container: HTMLElement | SVGElement,\n  n: number,\n  beforeMatrix: number[]\n) {\n  const target = offsetInfo.target;\n  const origin = offsetInfo.origin!;\n  const targetMatrix = targetInfo.matrix!;\n  const { offsetWidth: width, offsetHeight: height } = getSize(target);\n  const containerClientRect = container.getBoundingClientRect();\n  let margin = [0, 0];\n\n  if (container === getDocumentBody(container)) {\n    margin = getBodyOffset(target, true);\n  }\n\n  const rect = target.getBoundingClientRect();\n  const rectLeft =\n    rect.left -\n    containerClientRect.left +\n    container.scrollLeft -\n    (container.clientLeft || 0) +\n    margin[0];\n  const rectTop =\n    rect.top -\n    containerClientRect.top +\n    container.scrollTop -\n    (container.clientTop || 0) +\n    margin[1];\n  const rectWidth = rect.width;\n  const rectHeight = rect.height;\n\n  const mat = multiplies(n, beforeMatrix, targetMatrix);\n  const {\n    left: prevLeft,\n    top: prevTop,\n    width: prevWidth,\n    height: prevHeight,\n  } = calculateRect(mat, width, height, n);\n  const posOrigin = calculatePosition(mat, origin, n);\n  const prevOrigin = minus(posOrigin, [prevLeft, prevTop]);\n  const rectOrigin = [\n    rectLeft + (prevOrigin[0] * rectWidth) / prevWidth,\n    rectTop + (prevOrigin[1] * rectHeight) / prevHeight,\n  ];\n  const offset = [0, 0];\n  let count = 0;\n\n  while (++count < 10) {\n    const inverseBeforeMatrix = invert(beforeMatrix, n);\n    [offset[0], offset[1]] = minus(\n      calculatePosition(inverseBeforeMatrix, rectOrigin, n),\n      calculatePosition(inverseBeforeMatrix, posOrigin, n)\n    );\n    const mat2 = multiplies(\n      n,\n      beforeMatrix,\n      createOriginMatrix(offset, n),\n      targetMatrix\n    );\n    const { left: nextLeft, top: nextTop } = calculateRect(\n      mat2,\n      width,\n      height,\n      n\n    );\n    const distLeft = nextLeft - rectLeft;\n    const distTop = nextTop - rectTop;\n\n    if (abs(distLeft) < 2 && abs(distTop) < 2) {\n      break;\n    }\n    rectOrigin[0] -= distLeft;\n    rectOrigin[1] -= distTop;\n  }\n  return offset.map((p) => Math.round(p));\n}\n\nexport function calculateMoveableClientPositions(\n  rootMatrix: number[],\n  poses: number[][],\n  rootClientRect: MoveableClientRect\n) {\n  const is3d = rootMatrix.length === 16;\n  const n = is3d ? 4 : 3;\n  const rootPoses = poses.map((pos) => calculatePosition(rootMatrix, pos, n));\n  const { left, top } = rootClientRect;\n\n  return rootPoses.map((pos) => {\n    return [pos[0] + left, pos[1] + top];\n  });\n}\n\nexport function getDistSize(vec: number[]) {\n  return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\nexport function getDiagonalSize(pos1: number[], pos2: number[]) {\n  return getDistSize([pos2[0] - pos1[0], pos2[1] - pos1[1]]);\n}\nexport function getLineStyle(\n  pos1: number[],\n  pos2: number[],\n  zoom = 1,\n  rad: number = getRad(pos1, pos2)\n) {\n  const width = getDiagonalSize(pos1, pos2);\n\n  return {\n    transform: `translateY(-50%) translate(${pos1[0]}px, ${pos1[1]}px) rotate(${rad}rad) scaleY(${zoom})`,\n    width: `${width}px`,\n  };\n}\nexport function getControlTransform(\n  rotation: number,\n  zoom: number,\n  ...poses: number[][]\n) {\n  const length = poses.length;\n\n  const x = poses.reduce((prev, pos) => prev + pos[0], 0) / length;\n  const y = poses.reduce((prev, pos) => prev + pos[1], 0) / length;\n  return {\n    transform: `translateZ(0px) translate(${x}px, ${y}px) rotate(${rotation}rad) scale(${zoom})`,\n  };\n}\n\nexport function getProps<Props>(props: Props, ableName: keyof Props): Props {\n  const self = props[ableName];\n\n  if (isObject(self)) {\n    return {\n      ...props,\n      ...self,\n    };\n  }\n  return props;\n}\n\nexport function getSize(\n  target?: SVGElement | HTMLElement | null\n): ElementSizes {\n  const hasOffset = target && !isUndefined((target as any).offsetWidth);\n\n  let offsetWidth = 0;\n  let offsetHeight = 0;\n  let clientWidth = 0;\n  let clientHeight = 0;\n  let cssWidth = 0;\n  let cssHeight = 0;\n  let contentWidth = 0;\n  let contentHeight = 0;\n\n  let minWidth = 0;\n  let minHeight = 0;\n  let minOffsetWidth = 0;\n  let minOffsetHeight = 0;\n\n  let maxWidth = Infinity;\n  let maxHeight = Infinity;\n  let maxOffsetWidth = Infinity;\n  let maxOffsetHeight = Infinity;\n  let inlineCSSWidth = 0;\n  let inlineCSSHeight = 0;\n  let svg = false;\n\n  if (target) {\n    if (!hasOffset && (target as SVGElement).ownerSVGElement) {\n      // check svg elements\n      const bbox = (target as SVGGraphicsElement).getBBox();\n\n      svg = true;\n      offsetWidth = bbox.width;\n      offsetHeight = bbox.height;\n      cssWidth = offsetWidth;\n      cssHeight = offsetHeight;\n      contentWidth = offsetWidth;\n      contentHeight = offsetHeight;\n      clientWidth = offsetWidth;\n      clientHeight = offsetHeight;\n    } else {\n      // check html elements\n      const getStyle = getCachedStyle(target);\n      const targetStyle = target.style;\n      const boxSizing = getStyle(\"boxSizing\") === \"border-box\";\n      const borderLeft = parseFloat(getStyle(\"borderLeftWidth\")) || 0;\n      const borderRight = parseFloat(getStyle(\"borderRightWidth\")) || 0;\n      const borderTop = parseFloat(getStyle(\"borderTopWidth\")) || 0;\n      const borderBottom = parseFloat(getStyle(\"borderBottomWidth\")) || 0;\n      const paddingLeft = parseFloat(getStyle(\"paddingLeft\")) || 0;\n      const paddingRight = parseFloat(getStyle(\"paddingRight\")) || 0;\n      const paddingTop = parseFloat(getStyle(\"paddingTop\")) || 0;\n      const paddingBottom = parseFloat(getStyle(\"paddingBottom\")) || 0;\n\n      const horizontalPadding = paddingLeft + paddingRight;\n      const verticalPadding = paddingTop + paddingBottom;\n      const horizontalBorder = borderLeft + borderRight;\n      const verticalBorder = borderTop + borderBottom;\n      const horizontalOffset = horizontalPadding + horizontalBorder;\n      const verticalOffset = verticalPadding + verticalBorder;\n      const position = getStyle(\"position\");\n\n      let containerWidth = 0;\n      let containerHeight = 0;\n\n      // SVGSVGElement, HTMLElement\n      if (\"clientLeft\" in target) {\n        let parentElement: HTMLElement | null = null;\n\n        if (position === \"absolute\") {\n          const offsetInfo = getOffsetInfo(target, getDocumentBody(target));\n          parentElement = offsetInfo.offsetParent;\n        } else {\n          parentElement = target.parentElement;\n        }\n        if (parentElement) {\n          const getParentStyle = getCachedStyle(parentElement);\n\n          containerWidth = parseFloat(getParentStyle(\"width\"));\n          containerHeight = parseFloat(getParentStyle(\"height\"));\n        }\n      }\n      minWidth = Math.max(\n        horizontalPadding,\n        convertUnitSize(getStyle(\"minWidth\"), containerWidth) || 0\n      );\n      minHeight = Math.max(\n        verticalPadding,\n        convertUnitSize(getStyle(\"minHeight\"), containerHeight) || 0\n      );\n      maxWidth = convertUnitSize(getStyle(\"maxWidth\"), containerWidth);\n      maxHeight = convertUnitSize(getStyle(\"maxHeight\"), containerHeight);\n\n      if (isNaN(maxWidth)) {\n        maxWidth = Infinity;\n      }\n      if (isNaN(maxHeight)) {\n        maxHeight = Infinity;\n      }\n      inlineCSSWidth = convertUnitSize(targetStyle.width, 0) || 0;\n      inlineCSSHeight = convertUnitSize(targetStyle.height, 0) || 0;\n      cssWidth = parseFloat(getStyle(\"width\")) || 0;\n      cssHeight = parseFloat(getStyle(\"height\")) || 0;\n\n      contentWidth =\n        abs(cssWidth - inlineCSSWidth) < 1\n          ? between(minWidth, inlineCSSWidth || cssWidth, maxWidth)\n          : cssWidth;\n      contentHeight =\n        abs(cssHeight - inlineCSSHeight) < 1\n          ? between(minHeight, inlineCSSHeight || cssHeight, maxHeight)\n          : cssHeight;\n\n      offsetWidth = contentWidth;\n      offsetHeight = contentHeight;\n      clientWidth = contentWidth;\n      clientHeight = contentHeight;\n\n      if (boxSizing) {\n        maxOffsetWidth = maxWidth;\n        maxOffsetHeight = maxHeight;\n        minOffsetWidth = minWidth;\n        minOffsetHeight = minHeight;\n        contentWidth = offsetWidth - horizontalOffset;\n        contentHeight = offsetHeight - verticalOffset;\n      } else {\n        maxOffsetWidth = maxWidth + horizontalOffset;\n        maxOffsetHeight = maxHeight + verticalOffset;\n        minOffsetWidth = minWidth + horizontalOffset;\n        minOffsetHeight = minHeight + verticalOffset;\n        offsetWidth = contentWidth + horizontalOffset;\n        offsetHeight = contentHeight + verticalOffset;\n      }\n      clientWidth = contentWidth + horizontalPadding;\n      clientHeight = contentHeight + verticalPadding;\n    }\n  }\n\n  return {\n    svg,\n    offsetWidth,\n    offsetHeight,\n    clientWidth,\n    clientHeight,\n    contentWidth,\n    contentHeight,\n    inlineCSSWidth,\n    inlineCSSHeight,\n    cssWidth,\n    cssHeight,\n    minWidth,\n    minHeight,\n    maxWidth,\n    maxHeight,\n    minOffsetWidth,\n    minOffsetHeight,\n    maxOffsetWidth,\n    maxOffsetHeight,\n  };\n}\nexport function getRotationRad(poses: number[][], direction: number) {\n  return getRad(\n    direction > 0 ? poses[0] : poses[1],\n    direction > 0 ? poses[1] : poses[0]\n  );\n}\n\nexport function resetClientRect(): MoveableClientRect {\n  return {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    right: 0,\n    bottom: 0,\n    clientLeft: 0,\n    clientTop: 0,\n    clientWidth: 0,\n    clientHeight: 0,\n    scrollWidth: 0,\n    scrollHeight: 0,\n  };\n}\n\nexport function getExtendsRect(\n  el: HTMLElement | SVGElement,\n  rect: MoveableClientRect\n): MoveableClientRect {\n  const isRoot = el === getDocumentBody(el) || el === getDocumentElement(el);\n\n  const extendsRect = {\n    clientLeft: el.clientLeft,\n    clientTop: el.clientTop,\n    clientWidth: el.clientWidth,\n    clientHeight: el.clientHeight,\n    scrollWidth: el.scrollWidth,\n    scrollHeight: el.scrollHeight,\n    overflow: false,\n  };\n\n  if (isRoot) {\n    extendsRect.clientHeight = Math.max(rect.height, extendsRect.clientHeight);\n    extendsRect.scrollHeight = Math.max(rect.height, extendsRect.scrollHeight);\n  }\n\n  extendsRect.overflow = getCachedStyle(el)(\"overflow\") !== \"visible\";\n\n  return {\n    ...rect,\n    ...extendsRect,\n  };\n}\n\nexport function getClientRectByPosition(\n  position: { left: number; right: number; top: number; bottom: number },\n  base: MoveableClientRect,\n  el?: HTMLElement | SVGElement,\n  isExtends?: boolean\n) {\n  const { left, right, top, bottom } = position;\n  const baseTop = base.top;\n  const baseLeft = base.left;\n\n  const rect: MoveableClientRect = {\n    left: baseLeft + left,\n    top: baseTop + top,\n    right: baseLeft + right,\n    bottom: baseTop + bottom,\n    width: right - left,\n    height: bottom - top,\n  };\n\n  if (el && isExtends) {\n    return getExtendsRect(el, rect);\n  }\n  return rect;\n}\nexport function getClientRect(\n  el: HTMLElement | SVGElement,\n  isExtends?: boolean\n): MoveableClientRect {\n  let left = 0;\n  let top = 0;\n  let width = 0;\n  let height = 0;\n  // let isRoot = false;\n\n  if (el) {\n    const clientRect = el.getBoundingClientRect();\n\n    left = clientRect.left;\n    top = clientRect.top;\n    width = clientRect.width;\n    height = clientRect.height;\n  }\n\n  const rect: MoveableClientRect = {\n    left,\n    top,\n    width,\n    height,\n    right: left + width,\n    bottom: top + height,\n  };\n\n  if (el && isExtends) {\n    return getExtendsRect(el, rect);\n  }\n  return rect;\n}\n\nexport function getTotalOrigin(moveable: MoveableManagerInterface<any>) {\n  const { groupable, svgOrigin } = moveable.props;\n  const { offsetWidth, offsetHeight, svg, transformOrigin } =\n    moveable.getState();\n\n  if (!groupable && svg && svgOrigin) {\n    return convertTransformOriginArray(svgOrigin, offsetWidth, offsetHeight);\n  }\n\n  return transformOrigin;\n}\n\nexport function getTotalDirection(\n  parentDirection: number[],\n  isPinch: boolean,\n  inputEvent: any,\n  datas: any\n) {\n  let direction: number[] | undefined;\n\n  if (parentDirection) {\n    direction = parentDirection;\n  } else if (isPinch) {\n    direction = [0, 0];\n  } else {\n    const target = inputEvent.target;\n\n    direction = getDirection(target, datas);\n  }\n  return direction;\n}\nexport function getDirection(target: SVGElement | HTMLElement, datas: any) {\n  if (!target) {\n    return;\n  }\n  const deg = target.getAttribute(\"data-rotation\") || \"\";\n  const direciton = target.getAttribute(\"data-direction\")!;\n\n  datas.deg = deg;\n\n  if (!direciton) {\n    return;\n  }\n  const dir = [0, 0];\n\n  direciton.indexOf(\"w\") > -1 && (dir[0] = -1);\n  direciton.indexOf(\"e\") > -1 && (dir[0] = 1);\n  direciton.indexOf(\"n\") > -1 && (dir[1] = -1);\n  direciton.indexOf(\"s\") > -1 && (dir[1] = 1);\n\n  return dir;\n}\nexport function getAbsolutePoses(poses: number[][], dist: number[]) {\n  return [\n    plus(dist, poses[0]),\n    plus(dist, poses[1]),\n    plus(dist, poses[2]),\n    plus(dist, poses[3]),\n  ];\n}\nexport function getAbsolutePosesByState({\n  left,\n  top,\n  pos1,\n  pos2,\n  pos3,\n  pos4,\n}: {\n  left: number;\n  top: number;\n  pos1: number[];\n  pos2: number[];\n  pos3: number[];\n  pos4: number[];\n}) {\n  return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);\n}\n\nexport function roundSign(num: number) {\n  return Math.round(num % 1 === -0.5 ? num - 1 : num);\n}\n\nexport function unsetAbles(self: MoveableManagerInterface, isControl: boolean) {\n  self[isControl ? \"controlAbles\" : \"targetAbles\"].forEach((able) => {\n    able.unset && able.unset(self);\n  });\n}\nexport function unsetGesto(self: MoveableManagerInterface, isControl: boolean) {\n  const gestoName = isControl ? \"controlGesto\" : \"targetGesto\";\n  const gesto = self[gestoName];\n\n  if (gesto?.isIdle() === false) {\n    unsetAbles(self, isControl);\n  }\n  gesto?.unset();\n  self[gestoName] = null as any;\n}\n\nexport function fillCSSObject(\n  style: Record<string, any>,\n  resolvedEvent?: any\n): CSSObject {\n  if (resolvedEvent) {\n    const originalDatas = getBeforeRenderableDatas(resolvedEvent);\n\n    originalDatas.nextStyle = {\n      ...originalDatas.nextStyle,\n      ...style,\n    };\n  }\n  return {\n    style,\n    cssText: getKeys(style)\n      .map((name) => `${decamelize(name, \"-\")}: ${style[name]};`)\n      .join(\"\"),\n  };\n}\n\nexport function fillAfterTransform(\n  prevEvent: { style: Record<string, string>; transform: string },\n  nextEvent: {\n    style: Record<string, string>;\n    transform: string;\n    afterTransform?: string;\n  },\n  resolvedEvent?: any\n): TransformObject {\n  const afterTransform = nextEvent.afterTransform || nextEvent.transform;\n\n  return {\n    ...fillCSSObject(\n      {\n        ...prevEvent.style,\n        ...nextEvent.style,\n        transform: afterTransform,\n      },\n      resolvedEvent\n    ),\n    afterTransform,\n    transform: prevEvent.transform,\n  };\n}\n\nexport function fillParams<T extends IObject<any>>(\n  moveable: any,\n  e: any,\n  params: ExcludeParams<T>,\n  isBeforeEvent?: boolean\n): T {\n  const datas = e.datas;\n\n  if (!datas.datas) {\n    datas.datas = {};\n  }\n  const nextParams = {\n    ...params,\n    target: moveable.state.target,\n    clientX: e.clientX,\n    clientY: e.clientY,\n    inputEvent: e.inputEvent,\n    currentTarget: moveable,\n    moveable,\n    datas: datas.datas,\n    isRequest: e.isRequest,\n    isRequestChild: e.isRequestChild,\n    isFirstDrag: !!e.isFirstDrag,\n    isTrusted: e.isTrusted !== false,\n    stopAble() {\n      datas.isEventStart = false;\n    },\n    stopDrag() {\n      e.stop?.();\n    },\n  } as any;\n\n  if (!datas.isStartEvent) {\n    datas.isStartEvent = true;\n  } else if (!isBeforeEvent) {\n    datas.lastEvent = nextParams;\n  }\n  return nextParams;\n}\nexport function fillEndParams<T extends IObject<any>>(\n  moveable: any,\n  e: any,\n  params: ExcludeEndParams<T> & { isDrag?: boolean }\n): T {\n  const datas = e.datas;\n  const isDrag = \"isDrag\" in params ? params.isDrag : e.isDrag;\n\n  if (!datas.datas) {\n    datas.datas = {};\n  }\n\n  return {\n    isDrag,\n    ...params,\n    moveable,\n    target: moveable.state.target,\n    clientX: e.clientX,\n    clientY: e.clientY,\n    inputEvent: e.inputEvent,\n    currentTarget: moveable,\n    lastEvent: datas.lastEvent,\n    isDouble: e.isDouble,\n    datas: datas.datas,\n    isFirstDrag: !!e.isFirstDrag,\n  } as any;\n}\nexport function catchEvent<\n  EventName extends keyof Props,\n  Props extends IObject<any> = MoveableProps\n>(\n  moveable: any,\n  name: EventName,\n  callback: (\n    e: Props[EventName] extends ((e: infer P) => any) | undefined\n      ? P\n      : IObject<any>\n  ) => void\n): any {\n  moveable._emitter.on(name, callback);\n}\n\nexport function triggerEvent<\n  EventName extends keyof Props,\n  Props extends IObject<any> = MoveableProps\n>(\n  moveable: any,\n  name: EventName,\n  params: Props[EventName] extends ((e: infer P) => any) | undefined\n    ? P\n    : IObject<any>,\n  isManager?: boolean,\n  isRequest?: boolean\n): any {\n  return moveable.triggerEvent(name, params, isManager, isRequest);\n}\n\nexport function getComputedStyle(el: Element, pseudoElt?: string | null) {\n  return getWindow(el).getComputedStyle(el, pseudoElt);\n}\n\nexport function filterAbles(\n  ables: Able[],\n  methods: Array<keyof Able>,\n  triggerAblesSimultaneously?: boolean\n) {\n  const enabledAbles: IObject<boolean> = {};\n  const ableGroups: IObject<boolean> = {};\n\n  return ables.filter((able) => {\n    const name = able.name;\n\n    if (enabledAbles[name] || !methods.some((method) => able[method])) {\n      return false;\n    }\n    if (!triggerAblesSimultaneously && able.ableGroup) {\n      if (ableGroups[able.ableGroup]) {\n        return false;\n      }\n      ableGroups[able.ableGroup] = true;\n    }\n    enabledAbles[name] = true;\n    return true;\n  });\n}\n\nexport function equals(a1: any, a2: any) {\n  return a1 === a2 || (a1 == null && a2 == null);\n}\n\nexport function selectValue<T = any>(...values: any[]): T {\n  const length = values.length - 1;\n  for (let i = 0; i < length; ++i) {\n    const value = values[i];\n\n    if (!isUndefined(value)) {\n      return value;\n    }\n  }\n\n  return values[length];\n}\n\nexport function groupBy<T>(\n  arr: T[],\n  func: (el: T, index: number, arr: T[]) => any\n) {\n  const groups: T[][] = [];\n  const groupKeys: any[] = [];\n\n  arr.forEach((el, index) => {\n    const groupKey = func(el, index, arr);\n    const keyIndex = groupKeys.indexOf(groupKey);\n    const group = groups[keyIndex] || [];\n\n    if (keyIndex === -1) {\n      groupKeys.push(groupKey);\n      groups.push(group);\n    }\n    group.push(el);\n  });\n  return groups;\n}\nexport function groupByMap<T>(\n  arr: T[],\n  func: (el: T, index: number, arr: T[]) => string | number\n) {\n  const groups: T[][] = [];\n  const groupKeys: IObject<T[]> = {};\n\n  arr.forEach((el, index) => {\n    const groupKey = func(el, index, arr);\n    let group = groupKeys[groupKey];\n\n    if (!group) {\n      group = [];\n      groupKeys[groupKey] = group;\n      groups.push(group);\n    }\n    group.push(el);\n  });\n  return groups;\n}\nexport function flat<T>(arr: T[][]): T[] {\n  return arr.reduce((prev, cur) => {\n    return prev.concat(cur);\n  }, []);\n}\n\nexport function equalSign(a: number, b: number) {\n  return (a >= 0 && b >= 0) || (a < 0 && b < 0);\n}\n\nexport function maxOffset(...args: number[]) {\n  args.sort((a, b) => abs(b) - abs(a));\n\n  return args[0];\n}\nexport function minOffset(...args: number[]) {\n  args.sort((a, b) => abs(a) - abs(b));\n\n  return args[0];\n}\n\nexport function calculateInversePosition(\n  matrix: number[],\n  pos: number[],\n  n: number\n) {\n  return calculate(invert(matrix, n), convertPositionMatrix(pos, n), n);\n}\nexport function convertDragDist(state: MoveableManagerState, e: any) {\n  const { is3d, rootMatrix } = state;\n  const n = is3d ? 4 : 3;\n  [e.distX, e.distY] = calculateInversePosition(\n    rootMatrix,\n    [e.distX, e.distY],\n    n\n  );\n\n  return e;\n}\n\nexport function calculatePadding(\n  matrix: number[],\n  pos: number[],\n  added: number[],\n  n: number\n) {\n  if (!added[0] && !added[1]) {\n    return pos;\n  }\n\n  const xAdded = calculatePosition(matrix, [normalized(added[0] || 1), 0], n);\n  const yAdded = calculatePosition(matrix, [0, normalized(added[1] || 1)], n);\n  const nextAdded = calculatePosition(\n    matrix,\n    [added[0] / getDistSize(xAdded), added[1] / getDistSize(yAdded)],\n    n\n  );\n\n  return plus(pos, nextAdded);\n}\n\nexport function convertCSSSize(\n  value: number,\n  size: number,\n  isRelative?: boolean\n) {\n  return isRelative ? `${(value / size) * 100}%` : `${value}px`;\n}\n\nexport function getTinyDist(v: number) {\n  return abs(v) <= TINY_NUM ? 0 : v;\n}\n\nexport function viewDraggingPrefix(ableName: string) {\n  return prefix(`${ableName}-view-dragging`);\n}\nexport function getDirectionViewClassName(ableName: string) {\n  return (moveable: MoveableManagerInterface) => {\n    if (!moveable.isDragging(ableName)) {\n      return \"\";\n    }\n    const data = getGestoData(moveable, ableName);\n    const deg = data.deg;\n    if (!deg) {\n      return \"\";\n    }\n    return prefix(`view-control-rotation${deg}`);\n  };\n}\nexport function getDirectionCondition(\n  ableName: string,\n  checkAbles: string[] = [ableName]\n) {\n  return (moveable: any, e: any) => {\n    if (e.isRequest) {\n      if (checkAbles.some((name) => e.requestAble === name)) {\n        return e.parentDirection!;\n      } else {\n        return false;\n      }\n    }\n    const target = e.inputEvent.target;\n\n    return (\n      hasClass(target, prefix(\"direction\")) &&\n      (!ableName || hasClass(target, prefix(ableName)))\n    );\n  };\n}\n\nexport function convertTransformInfo(\n  transforms: string[],\n  state: MoveableManagerState,\n  index: number\n) {\n  const matrixInfos = parse(transforms, {\n    \"x%\": (v) => (v / 100) * state.offsetWidth,\n    \"y%\": (v) => (v / 100) * state.offsetHeight,\n  });\n\n  const beforeFunctionTexts = transforms.slice(\n    0,\n    index < 0 ? undefined : index\n  );\n  const beforeFunctionTexts2 = transforms.slice(\n    0,\n    index < 0 ? undefined : index + 1\n  );\n  const targetFunctionText = transforms[index] || \"\";\n  const afterFunctionTexts = index < 0 ? [] : transforms.slice(index);\n  const afterFunctionTexts2 = index < 0 ? [] : transforms.slice(index + 1);\n\n  const beforeFunctions = matrixInfos.slice(0, index < 0 ? undefined : index);\n  const beforeFunctions2 = matrixInfos.slice(\n    0,\n    index < 0 ? undefined : index + 1\n  );\n  const targetFunction = matrixInfos[index] ?? parse([\"\"])[0];\n  const afterFunctions = index < 0 ? [] : matrixInfos.slice(index);\n  const afterFunctions2 = index < 0 ? [] : matrixInfos.slice(index + 1);\n  const targetFunctions = targetFunction ? [targetFunction] : [];\n\n  const beforeFunctionMatrix = toMat(beforeFunctions);\n  const beforeFunctionMatrix2 = toMat(beforeFunctions2);\n  const afterFunctionMatrix = toMat(afterFunctions);\n  const afterFunctionMatrix2 = toMat(afterFunctions2);\n  const allFunctionMatrix = multiply(\n    beforeFunctionMatrix,\n    afterFunctionMatrix,\n    4\n  );\n  return {\n    transforms,\n    beforeFunctionMatrix,\n    beforeFunctionMatrix2,\n    targetFunctionMatrix: toMat(targetFunctions),\n    afterFunctionMatrix,\n    afterFunctionMatrix2,\n    allFunctionMatrix,\n    beforeFunctions,\n    beforeFunctions2,\n    targetFunction: targetFunctions[0],\n    afterFunctions,\n    afterFunctions2,\n    beforeFunctionTexts,\n    beforeFunctionTexts2,\n    targetFunctionText,\n    afterFunctionTexts,\n    afterFunctionTexts2,\n  };\n}\n\nexport function isArrayFormat<T = any>(arr: any): arr is ArrayFormat<T> {\n  if (!arr || !isObject(arr)) {\n    return false;\n  }\n  if (isNode(arr)) {\n    return false;\n  }\n  return isArray(arr) || \"length\" in arr;\n}\n\nexport function getRefTarget<T extends Element = HTMLElement | SVGElement>(\n  target: MoveableRefType<T> | Window,\n  isSelector: true\n): T | null;\nexport function getRefTarget<T extends Element = HTMLElement | SVGElement>(\n  target: MoveableRefType<T> | Window,\n  isSelector?: boolean\n): T | string | null;\nexport function getRefTarget<T extends Element = HTMLElement | SVGElement>(\n  target: MoveableRefType<T> | Window,\n  isSelector?: boolean\n): any {\n  if (!target) {\n    return null;\n  }\n  if (isNode(target)) {\n    return target;\n  }\n  if (isString(target)) {\n    if (isSelector) {\n      return document.querySelector(target);\n    }\n    return target;\n  }\n  if (isFunction(target)) {\n    return target();\n  }\n  if (isWindow(target)) {\n    return target;\n  }\n  if (\"current\" in target) {\n    return target.current;\n  }\n  return target;\n}\n\nexport function getRefTargets(\n  targets: MoveableRefTargetType,\n  isSelector: true\n): Array<HTMLElement | SVGElement | null>;\nexport function getRefTargets(\n  targets: MoveableRefTargetType,\n  isSelector?: boolean\n): MoveableRefTargetsResultType;\nexport function getRefTargets(\n  targets: MoveableRefTargetType,\n  isSelector?: boolean\n): any[] {\n  if (!targets) {\n    return [];\n  }\n  const userTargets = isArrayFormat(targets)\n    ? [].slice.call(targets)\n    : [targets];\n\n  return userTargets.reduce((prev, target) => {\n    if (isString(target) && isSelector) {\n      return [\n        ...prev,\n        ...[].slice.call(document.querySelectorAll<HTMLElement>(target)),\n      ];\n    }\n    if (isArray(target)) {\n      prev.push(getRefTargets(target, isSelector));\n    } else {\n      prev.push(getRefTarget(target, isSelector));\n    }\n    return prev;\n  }, [] as MoveableRefTargetsResultType);\n}\n\nexport function minmax(...values: number[]) {\n  return [Math.min(...values), Math.max(...values)];\n}\n\nexport function getAbsoluteRotation(\n  pos1: number[],\n  pos2: number[],\n  direction: number\n) {\n  let deg = (getRad(pos1, pos2) / Math.PI) * 180;\n\n  deg = direction >= 0 ? deg : 180 - deg;\n  deg = deg >= 0 ? deg : 360 + deg;\n\n  return deg;\n}\n\nexport function getDragDistByState(\n  state: MoveableManagerState,\n  dist: number[]\n) {\n  const { rootMatrix, is3d } = state;\n  const n = is3d ? 4 : 3;\n\n  let inverseMatrix = invert(rootMatrix, n);\n\n  if (!is3d) {\n    inverseMatrix = convertDimension(inverseMatrix, 3, 4);\n  }\n  inverseMatrix[12] = 0;\n  inverseMatrix[13] = 0;\n  inverseMatrix[14] = 0;\n\n  return calculateMatrixDist(inverseMatrix, dist);\n}\n\nexport function getSizeDistByDist(\n  startSize: number[],\n  dist: number[],\n  ratio: number,\n  direction: number[],\n  keepRatio?: boolean\n) {\n  const [startOffsetWidth, startOffsetHeight] = startSize;\n  let distWidth = 0;\n  let distHeight = 0;\n\n  if (keepRatio && startOffsetWidth && startOffsetHeight) {\n    const rad = getRad([0, 0], dist);\n    const standardRad = getRad([0, 0], direction);\n    const size = getDistSize(dist);\n    const signSize = Math.cos(rad - standardRad) * size;\n\n    if (!direction[0]) {\n      // top, bottom\n      distHeight = signSize;\n      distWidth = distHeight * ratio;\n    } else if (!direction[1]) {\n      // left, right\n      distWidth = signSize;\n      distHeight = distWidth / ratio;\n    } else {\n      // two-way\n      const startWidthSize = direction[0] * startOffsetWidth;\n      const startHeightSize = direction[1] * startOffsetHeight;\n\n      let secondRad = Math.atan2(\n        startWidthSize + dist[0],\n        startHeightSize + dist[1]\n      );\n      let firstRad = Math.atan2(startWidthSize, startHeightSize);\n\n      if (secondRad < 0) {\n        secondRad += Math.PI * 2;\n      }\n      if (firstRad < 0) {\n        firstRad += Math.PI * 2;\n      }\n      let rad = 0;\n\n      if (\n        abs(secondRad - firstRad) < Math.PI / 2 ||\n        abs(secondRad - firstRad) > (Math.PI / 2) * 3\n      ) {\n        rad = secondRad - firstRad;\n      } else {\n        firstRad += Math.PI;\n        rad = secondRad - firstRad;\n      }\n      if (rad > Math.PI * 2) {\n        rad -= Math.PI * 2;\n      } else if (rad > Math.PI) {\n        rad = 2 * Math.PI - rad;\n      } else if (rad < -Math.PI) {\n        rad = -2 * Math.PI - rad;\n      }\n      //       180\n      // -1, -1,  // 1, -1\n      // 270            90\n      // -1, 1    // 1, 1\n      //       0\n      const distSize =\n        getDistSize([startWidthSize + dist[0], startHeightSize + dist[1]]) *\n        Math.cos(rad);\n\n      distWidth = distSize * Math.sin(firstRad) - startWidthSize;\n      distHeight = distSize * Math.cos(firstRad) - startHeightSize;\n\n      if (direction[0] < 0) {\n        distWidth *= -1;\n      }\n      if (direction[1] < 0) {\n        distHeight *= -1;\n      }\n    }\n  } else {\n    distWidth = direction[0] * dist[0];\n    distHeight = direction[1] * dist[1];\n  }\n\n  return [distWidth, distHeight];\n}\nexport function getOffsetSizeDist(\n  sizeDirection: number[],\n  keepRatio: boolean,\n  datas: any,\n  e: any\n) {\n  const { ratio, startOffsetWidth, startOffsetHeight } = datas;\n  let distWidth = 0;\n  let distHeight = 0;\n  const { distX, distY, pinchScale, parentDistance, parentDist, parentScale } =\n    e;\n  const startFixedDirection = datas.fixedDirection;\n  const directionsDists = [0, 1].map((index) => {\n    return abs(sizeDirection[index] - startFixedDirection[index]);\n  });\n  const directionRatios = [0, 1].map((index) => {\n    let dist = directionsDists[index];\n\n    if (dist !== 0) {\n      dist = 2 / dist;\n    }\n    return dist;\n  });\n  if (parentDist) {\n    distWidth = parentDist[0];\n    distHeight = parentDist[1];\n\n    if (keepRatio) {\n      if (!distWidth) {\n        distWidth = distHeight * ratio;\n      } else if (!distHeight) {\n        distHeight = distWidth / ratio;\n      }\n    }\n  } else if (isNumber(pinchScale)) {\n    distWidth = (pinchScale - 1) * startOffsetWidth;\n    distHeight = (pinchScale - 1) * startOffsetHeight;\n  } else if (parentScale) {\n    distWidth = (parentScale[0] - 1) * startOffsetWidth;\n    distHeight = (parentScale[1] - 1) * startOffsetHeight;\n  } else if (parentDistance) {\n    const scaleX = startOffsetWidth * directionsDists[0];\n    const scaleY = startOffsetHeight * directionsDists[1];\n    const ratioDistance = getDistSize([scaleX, scaleY]);\n\n    distWidth = (parentDistance / ratioDistance) * scaleX * directionRatios[0];\n    distHeight = (parentDistance / ratioDistance) * scaleY * directionRatios[1];\n  } else {\n    let dist = getDragDist({ datas, distX, distY });\n\n    dist = directionRatios.map((ratio, i) => {\n      return dist[i] * ratio;\n    });\n\n    [distWidth, distHeight] = getSizeDistByDist(\n      [startOffsetWidth, startOffsetHeight],\n      dist,\n      ratio,\n      sizeDirection,\n      keepRatio\n    );\n  }\n  return {\n    // direction,\n    // sizeDirection,\n    distWidth,\n    distHeight,\n  };\n}\n\nexport function convertTransformUnit(\n  origin: string,\n  xy?: boolean\n): { x?: string; y?: string; value?: string } {\n  if (xy) {\n    if (origin === \"left\") {\n      return { x: \"0%\", y: \"50%\" };\n    } else if (origin === \"top\") {\n      return { x: \"50%\", y: \"50%\" };\n    } else if (origin === \"center\") {\n      return { x: \"50%\", y: \"50%\" };\n    } else if (origin === \"right\") {\n      return { x: \"100%\", y: \"50%\" };\n    } else if (origin === \"bottom\") {\n      return { x: \"50%\", y: \"100%\" };\n    }\n    const [left, right] = origin.split(\" \");\n    const leftOrigin = convertTransformUnit(left || \"\");\n    const rightOrigin = convertTransformUnit(right || \"\");\n    const originObject = {\n      ...leftOrigin,\n      ...rightOrigin,\n    };\n\n    const nextOriginObject = {\n      x: \"50%\",\n      y: \"50%\",\n    };\n    if (originObject.x) {\n      nextOriginObject.x = originObject.x;\n    }\n    if (originObject.y) {\n      nextOriginObject.y = originObject.y;\n    }\n    if (originObject.value) {\n      if (originObject.x && !originObject.y) {\n        nextOriginObject.y = originObject.value;\n      }\n      if (!originObject.x && originObject.y) {\n        nextOriginObject.x = originObject.value;\n      }\n    }\n    return nextOriginObject;\n  }\n  if (origin === \"left\") {\n    return { x: \"0%\" };\n  }\n  if (origin === \"right\") {\n    return { x: \"100%\" };\n  }\n  if (origin === \"top\") {\n    return { y: \"0%\" };\n  }\n  if (origin === \"bottom\") {\n    return { y: \"100%\" };\n  }\n  if (!origin) {\n    return {};\n  }\n  if (origin === \"center\") {\n    return { value: \"50%\" };\n  }\n  return { value: origin };\n}\nexport function convertTransformOriginArray(\n  transformOrigin: string,\n  width: number,\n  height: number\n) {\n  const { x, y } = convertTransformUnit(transformOrigin, true);\n\n  return [convertUnitSize(x!, width) || 0, convertUnitSize(y!, height) || 0];\n}\n\nexport function rotatePosesInfo(\n  poses: number[][],\n  origin: number[],\n  rad: number\n) {\n  const prevPoses = poses.map((pos) => minus(pos, origin));\n  const nextPoses = prevPoses.map((pos) => rotate(pos, rad));\n\n  return {\n    prev: prevPoses,\n    next: nextPoses,\n    result: nextPoses.map((pos) => plus(pos, origin)),\n  };\n}\n\nexport function isDeepArrayEquals(arr1: any[], arr2: any[]): boolean {\n  return (\n    arr1.length === arr2.length &&\n    arr1.every((value1, i) => {\n      const value2 = arr2[i];\n      const isArray1 = isArray(value1);\n      const isArray2 = isArray(value2);\n      if (isArray1 && isArray2) {\n        return isDeepArrayEquals(value1, value2);\n      } else if (!isArray1 && !isArray2) {\n        return value1 === value2;\n      }\n      return false;\n    })\n  );\n}\n\nexport function watchValue<T>(\n  moveable: any,\n  property: string,\n  nextValue: T,\n  valueKey: (value: T) => string | number,\n  defaultValue?: T\n): T {\n  const store = (moveable as any)._store;\n  let prevValue = store[property];\n\n  if (!(property in store)) {\n    if (defaultValue != null) {\n      store[property] = defaultValue;\n      prevValue = defaultValue;\n    } else {\n      store[property] = nextValue;\n      return nextValue;\n    }\n  }\n  if (prevValue === nextValue || valueKey(prevValue) === valueKey(nextValue)) {\n    return prevValue;\n  }\n\n  store[property] = nextValue;\n  return nextValue;\n}\n\nexport function sign(value: number) {\n  return value >= 0 ? 1 : -1;\n}\n\nexport function abs(value: number) {\n  return Math.abs(value);\n}\n\nexport function countEach<T>(\n  count: number,\n  callback: (index: number) => T\n): T[] {\n  return counter(count).map((index) => callback(index));\n}\n\nexport function getPaddingBox(padding: PaddingBox | number) {\n  if (isNumber(padding)) {\n    return {\n      top: padding,\n      left: padding,\n      right: padding,\n      bottom: padding,\n    };\n  }\n\n  return {\n    left: padding.left || 0,\n    top: padding.top || 0,\n    right: padding.right || 0,\n    bottom: padding.bottom || 0,\n  };\n}\n","import { makeAble } from \"./able-manager\";\nimport { triggerEvent, fillParams, fillEndParams } from \"../utils\";\nimport {\n  PinchableProps,\n  Able,\n  SnappableState,\n  OnPinchStart,\n  OnPinch,\n  OnPinchEnd,\n  MoveableManagerInterface,\n  MoveableGroupInterface,\n} from \"../types\";\n\n/**\n * @namespace Moveable.Pinchable\n * @description Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n */\nexport default makeAble(\"pinchable\", {\n  props: [\"pinchable\"] as const,\n  events: [\n    \"pinchStart\",\n    \"pinch\",\n    \"pinchEnd\",\n    \"pinchGroupStart\",\n    \"pinchGroup\",\n    \"pinchGroupEnd\",\n  ] as const,\n  dragStart() {\n    return true;\n  },\n  pinchStart(\n    moveable: MoveableManagerInterface<PinchableProps, SnappableState>,\n    e: any\n  ) {\n    const { datas, targets, angle, originalDatas } = e;\n    const { pinchable, ables } = moveable.props;\n\n    if (!pinchable) {\n      return false;\n    }\n    const eventName = `onPinch${targets ? \"Group\" : \"\"}Start` as \"onPinchStart\";\n    const controlEventName = `drag${\n      targets ? \"Group\" : \"\"\n    }ControlStart` as \"dragControlStart\";\n\n    const pinchAbles = (\n      pinchable === true\n        ? moveable.controlAbles\n        : ables!.filter((able) => {\n            return pinchable.indexOf(able.name as any) > -1;\n          })\n    ).filter((able) => able.canPinch && able[controlEventName]);\n\n    const params = fillParams<OnPinchStart>(moveable, e, {}) as any;\n\n    if (targets) {\n      params.targets = targets;\n    }\n    const result = triggerEvent(moveable, eventName, params);\n\n    datas.isPinch = result !== false;\n    datas.ables = pinchAbles;\n\n    const isPinch = datas.isPinch;\n\n    if (!isPinch) {\n      return false;\n    }\n    pinchAbles.forEach((able) => {\n      originalDatas[able.name] = originalDatas[able.name] || {};\n\n      if (!able[controlEventName]) {\n        return;\n      }\n      const ableEvent: any = {\n        ...e,\n        datas: originalDatas[able.name],\n        parentRotate: angle,\n        isPinch: true,\n      };\n      able[controlEventName]!(moveable, ableEvent);\n    });\n\n    moveable.state.snapRenderInfo = {\n      request: e.isRequest,\n      direction: [0, 0],\n    };\n    return isPinch;\n  },\n  pinch(moveable: MoveableManagerInterface<PinchableProps>, e: any) {\n    const {\n      datas,\n      scale: pinchScale,\n      distance,\n      originalDatas,\n      inputEvent,\n      targets,\n      angle,\n    } = e;\n    if (!datas.isPinch) {\n      return;\n    }\n    const parentDistance = distance * (1 - 1 / pinchScale);\n    const params = fillParams<OnPinch>(moveable, e, {}) as any;\n\n    if (targets) {\n      params.targets = targets;\n    }\n    const eventName = `onPinch${targets ? \"Group\" : \"\"}` as \"onPinch\";\n    triggerEvent(moveable, eventName, params);\n\n    const ables: Able[] = datas.ables;\n    const controlEventName = `drag${\n      targets ? \"Group\" : \"\"\n    }Control` as \"dragControl\";\n\n    ables.forEach((able) => {\n      if (!able[controlEventName]) {\n        return;\n      }\n      able[controlEventName]!(moveable, {\n        ...e,\n        datas: originalDatas[able.name],\n        inputEvent,\n        resolveMatrix: true,\n        pinchScale: pinchScale,\n        parentDistance,\n        parentRotate: angle,\n        isPinch: true,\n      } as any);\n    });\n    return params;\n  },\n  pinchEnd(moveable: MoveableManagerInterface<PinchableProps>, e: any) {\n    const { datas, isPinch, inputEvent, targets, originalDatas } = e;\n    if (!datas.isPinch) {\n      return;\n    }\n    const eventName = `onPinch${targets ? \"Group\" : \"\"}End` as \"onPinchEnd\";\n\n    const params = fillEndParams<OnPinchEnd>(moveable, e, {\n      isDrag: isPinch,\n    }) as any;\n\n    if (targets) {\n      params.targets = targets;\n    }\n    triggerEvent(moveable, eventName, params);\n    const ables: Able[] = datas.ables;\n    const controlEventName = `drag${\n      targets ? \"Group\" : \"\"\n    }ControlEnd` as \"dragControlEnd\";\n\n    ables.forEach((able) => {\n      if (!able[controlEventName]) {\n        return;\n      }\n      able[controlEventName]!(moveable, {\n        ...e,\n        isDrag: isPinch,\n        datas: originalDatas[able.name],\n        inputEvent,\n        isPinch: true,\n      } as any);\n    });\n    return isPinch;\n  },\n  pinchGroupStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n    return this.pinchStart!(moveable, {\n      ...e,\n      targets: moveable.props.targets,\n    });\n  },\n  pinchGroup(moveable: MoveableGroupInterface, e: any) {\n    return this.pinch!(moveable, { ...e, targets: moveable.props.targets });\n  },\n  pinchGroupEnd(moveable: MoveableGroupInterface, e: any) {\n    return this.pinchEnd!(moveable, { ...e, targets: moveable.props.targets });\n  },\n});\n\n/**\n * Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n * @name Moveable.Pinchable#pinchable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.pinchable = true;\n */\n\n/**\n * When the pinch starts, the pinchStart event is called with part of scaleStart, rotateStart, resizeStart\n * @memberof Moveable.Pinchable\n * @event pinchStart\n * @param {Moveable.Pinchable.OnPinchStart} - Parameters for the pinchStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When pinching, the pinch event is called with part of scale, rotate, resize\n * @memberof Moveable.Pinchable\n * @event pinch\n * @param {Moveable.Pinchable.OnPinch} - Parameters for the pinch event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinch\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotate\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scale\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When the pinch finishes, the pinchEnd event is called.\n * @memberof Moveable.Pinchable\n * @event pinchEnd\n * @param {Moveable.Pinchable.OnPinchEnd} - Parameters for the pinchEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleEnd\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When the group pinch starts, the `pinchGroupStart` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupStart\n * @param {Moveable.Pinchable.OnPinchGroupStart} - Parameters for the `pinchGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupStart\", ({ targets }) => {\n *     console.log(\"onPinchGroupStart\", targets);\n * });\n */\n\n/**\n * When the group pinch, the `pinchGroup` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroup\n * @param {Moveable.Pinchable.OnPinchGroup} - Parameters for the `pinchGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroup\", ({ targets, events }) => {\n *     console.log(\"onPinchGroup\", targets);\n * });\n */\n\n/**\n * When the group pinch finishes, the `pinchGroupEnd` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupEnd\n * @param {Moveable.Pinchable.OnPinchGroupEnd} - Parameters for the `pinchGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onPinchGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n  triggerEvent,\n  multiply2,\n  fillParams,\n  fillEndParams,\n  getAbsolutePosesByState,\n  catchEvent,\n  getOffsetSizeDist,\n  getDirectionCondition,\n  getDirectionViewClassName,\n  getTotalDirection,\n  sign,\n  countEach,\n  abs,\n} from \"../utils\";\nimport { MIN_SCALE } from \"../consts\";\nimport {\n  setDragStart,\n  resolveTransformEvent,\n  convertTransformFormat,\n  getScaleDist,\n  fillTransformStartEvent,\n  fillTransformEvent,\n  setDefaultTransformIndex,\n  getTranslateFixedPosition,\n} from \"../gesto/gesto-utils\";\nimport { getRenderDirections } from \"../render-directions\";\nimport {\n  ScalableProps,\n  OnScaleGroup,\n  OnScaleGroupEnd,\n  OnScaleGroupStart,\n  DraggableProps,\n  OnDragStart,\n  SnappableState,\n  GroupableProps,\n  OnScaleStart,\n  OnScale,\n  OnScaleEnd,\n  MoveableManagerInterface,\n  MoveableGroupInterface,\n  OnBeforeScaleGroup,\n  OnBeforeScale,\n} from \"../types\";\nimport {\n  fillChildEvents,\n  startChildDist,\n  triggerChildAbles,\n} from \"../group-utils\";\nimport Draggable from \"./draggable\";\nimport { calculate, createRotateMatrix, plus, minus } from \"../../matrix\";\nimport CustomGesto from \"../gesto/custom-gesto\";\nimport { checkSnapScale } from \"./snappable\";\nimport {\n  isArray,\n  IObject,\n  getDist,\n  throttle,\n  calculateBoundSize,\n} from \"../../utility\";\nimport { getFixedDirectionInfo } from \"../utils/get-fixed-direction\";\n\nconst directionCondition = getDirectionCondition(\"scalable\");\n\n/**\n * @namespace Scalable\n * @memberof Moveable\n * @description Scalable indicates whether the target's x and y can be scale of transform.\n */\nexport default {\n  name: \"scalable\",\n  ableGroup: \"size\",\n  canPinch: true,\n  props: [\n    \"scalable\",\n    \"throttleScale\",\n    \"renderDirections\",\n    \"keepRatio\",\n    \"edge\",\n    \"displayAroundControls\",\n  ] as const,\n  events: [\n    \"scaleStart\",\n    \"beforeScale\",\n    \"scale\",\n    \"scaleEnd\",\n    \"scaleGroupStart\",\n    \"beforeScaleGroup\",\n    \"scaleGroup\",\n    \"scaleGroupEnd\",\n  ] as const,\n  render: getRenderDirections(\"scalable\"),\n  dragControlCondition: directionCondition,\n  viewClassName: getDirectionViewClassName(\"scalable\"),\n  dragControlStart(\n    moveable: MoveableManagerInterface<\n      ScalableProps & DraggableProps,\n      SnappableState\n    >,\n    e: any\n  ) {\n    const { datas, isPinch, inputEvent, parentDirection } = e;\n\n    const direction = getTotalDirection(\n      parentDirection,\n      isPinch,\n      inputEvent,\n      datas\n    );\n    const { width, height, targetTransform, target, pos1, pos2, pos4 } =\n      moveable.state;\n\n    if (!direction || !target) {\n      return false;\n    }\n    if (!isPinch) {\n      setDragStart(moveable, e);\n    }\n    datas.datas = {};\n    datas.transform = targetTransform;\n    datas.prevDist = [1, 1];\n    datas.direction = direction;\n    datas.startOffsetWidth = width;\n    datas.startOffsetHeight = height;\n    datas.startValue = [1, 1];\n\n    // const scaleWidth = getDist(pos1, pos2);\n    // const scaleHeight = getDist(pos2, pos4);\n    const isWidth =\n      (!direction[0] && !direction[1]) || direction[0] || !direction[1];\n\n    // datas.scaleWidth = scaleWidth;\n    // datas.scaleHeight = scaleHeight;\n    // datas.scaleXRatio = scaleWidth / width;\n    // datas.scaleYRatio = scaleHeight / height;\n\n    setDefaultTransformIndex(moveable, e, \"scale\");\n\n    datas.isWidth = isWidth;\n\n    function setRatio(ratio: number) {\n      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\n    }\n\n    datas.startPositions = getAbsolutePosesByState(moveable.state);\n    function setFixedDirection(fixedDirection: number[]) {\n      const result = getFixedDirectionInfo(\n        datas.startPositions,\n        fixedDirection\n      );\n\n      datas.fixedDirection = result.fixedDirection;\n      datas.fixedPosition = result.fixedPosition;\n      datas.fixedOffset = result.fixedOffset;\n    }\n\n    datas.setFixedDirection = setFixedDirection;\n    setRatio(getDist(pos1, pos2) / getDist(pos2, pos4));\n    setFixedDirection([-direction[0], -direction[1]]);\n\n    const setMinScaleSize = (min: number[]) => {\n      datas.minScaleSize = min;\n    };\n    const setMaxScaleSize = (max: number[]) => {\n      datas.maxScaleSize = max;\n    };\n    // const setMinScale = (min: number[]) => {\n    // };\n    // const setMaxScale = (max: number[]) => {\n    // };\n\n    setMinScaleSize([-Infinity, -Infinity]);\n    setMaxScaleSize([Infinity, Infinity]);\n    const params = fillParams<OnScaleStart>(moveable, e, {\n      direction,\n      set: (scale: number[]) => {\n        datas.startValue = scale;\n      },\n      setRatio,\n      setFixedDirection,\n      setMinScaleSize,\n      setMaxScaleSize,\n      ...fillTransformStartEvent(moveable, e),\n      dragStart: Draggable.dragStart(\n        moveable,\n        new CustomGesto().dragStart([0, 0], e)\n      ) as OnDragStart,\n    });\n    const result = triggerEvent(moveable, \"onScaleStart\", params);\n\n    datas.startFixedDirection = datas.fixedDirection;\n\n    if (result !== false) {\n      datas.isScale = true;\n      moveable.state.snapRenderInfo = {\n        request: e.isRequest,\n        direction,\n      };\n    }\n    return datas.isScale ? params : false;\n  },\n  dragControl(\n    moveable: MoveableManagerInterface<\n      ScalableProps & DraggableProps & GroupableProps,\n      SnappableState\n    >,\n    e: any\n  ) {\n    resolveTransformEvent(moveable, e, \"scale\");\n    const {\n      datas,\n      parentKeepRatio,\n      parentFlag,\n      isPinch,\n      dragClient,\n      isRequest,\n      useSnap,\n      resolveMatrix,\n    } = e;\n    const {\n      prevDist,\n      direction,\n      startOffsetWidth,\n      startOffsetHeight,\n      isScale,\n      startValue,\n      isWidth,\n      ratio,\n    } = datas;\n\n    if (!isScale) {\n      return false;\n    }\n\n    const props = moveable.props;\n    const { throttleScale, parentMoveable } = props;\n    let sizeDirection = direction;\n\n    if (!direction[0] && !direction[1]) {\n      sizeDirection = [1, 1];\n    }\n    const keepRatio =\n      (ratio &&\n        (parentKeepRatio != null ? parentKeepRatio : props.keepRatio)) ||\n      false;\n    const state = moveable.state;\n\n    const tempScaleValue = [startValue[0], startValue[1]];\n\n    function getNextScale() {\n      const { distWidth, distHeight } = getOffsetSizeDist(\n        sizeDirection,\n        keepRatio,\n        datas,\n        e\n      );\n\n      const distX = startOffsetWidth\n        ? (startOffsetWidth + distWidth) / startOffsetWidth\n        : 1;\n      const distY = startOffsetHeight\n        ? (startOffsetHeight + distHeight) / startOffsetHeight\n        : 1;\n\n      if (!startValue[0]) {\n        tempScaleValue[0] = distWidth / startOffsetWidth;\n      }\n      if (!startValue[1]) {\n        tempScaleValue[1] = distHeight / startOffsetHeight;\n      }\n      let scaleX =\n        (sizeDirection[0] || keepRatio ? distX : 1) * tempScaleValue[0];\n      let scaleY =\n        (sizeDirection[1] || keepRatio ? distY : 1) * tempScaleValue[1];\n\n      if (scaleX === 0) {\n        scaleX = sign(prevDist[0]) * MIN_SCALE;\n      }\n      if (scaleY === 0) {\n        scaleY = sign(prevDist[1]) * MIN_SCALE;\n      }\n      return [scaleX, scaleY];\n    }\n\n    let scale = getNextScale();\n\n    if (!isPinch && moveable.props.groupable) {\n      const snapRenderInfo = state.snapRenderInfo || {};\n      const stateDirection = snapRenderInfo.direction;\n\n      if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {\n        state.snapRenderInfo = { direction, request: e.isRequest };\n      }\n    }\n\n    triggerEvent(\n      moveable,\n      \"onBeforeScale\",\n      fillParams<OnBeforeScale>(\n        moveable,\n        e,\n        {\n          scale,\n          setFixedDirection(nextFixedDirection: number[]) {\n            datas.setFixedDirection(nextFixedDirection);\n\n            scale = getNextScale();\n            return scale;\n          },\n          startFixedDirection: datas.startFixedDirection,\n          setScale(nextScale: number[]) {\n            scale = nextScale;\n          },\n        },\n        true\n      )\n    );\n\n    let dist = [scale[0] / tempScaleValue[0], scale[1] / tempScaleValue[1]];\n    let fixedPosition = dragClient;\n    let snapDist = [0, 0];\n\n    const distSign = sign(dist[0] * dist[1]);\n    const isSelfPinch = !dragClient && !parentFlag && isPinch;\n\n    if (isSelfPinch || resolveMatrix) {\n      fixedPosition = getTranslateFixedPosition(\n        moveable,\n        datas.targetAllTransform,\n        [0, 0],\n        [0, 0],\n        datas\n      );\n    } else if (!dragClient) {\n      fixedPosition = datas.fixedPosition;\n    }\n    if (!isPinch) {\n      snapDist = checkSnapScale(\n        moveable,\n        dist,\n        direction,\n        !useSnap && isRequest,\n        datas\n      );\n    }\n\n    if (keepRatio) {\n      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n        if (\n          Math.abs(snapDist[0] * startOffsetWidth) >\n          Math.abs(snapDist[1] * startOffsetHeight)\n        ) {\n          snapDist[1] = 0;\n        } else {\n          snapDist[0] = 0;\n        }\n      }\n\n      const isNoSnap = !snapDist[0] && !snapDist[1];\n\n      if (isNoSnap) {\n        // throttle scale value (not absolute scale size)\n        if (isWidth) {\n          dist[0] =\n            throttle(dist[0] * tempScaleValue[0], throttleScale!) /\n            tempScaleValue[0];\n        } else {\n          dist[1] =\n            throttle(dist[1] * tempScaleValue[1], throttleScale!) /\n            tempScaleValue[1];\n        }\n      }\n      if (\n        (sizeDirection[0] && !sizeDirection[1]) ||\n        (snapDist[0] && !snapDist[1]) ||\n        (isNoSnap && isWidth)\n      ) {\n        dist[0] += snapDist[0];\n        const snapHeight =\n          (startOffsetWidth * dist[0] * tempScaleValue[0]) / ratio;\n\n        dist[1] =\n          sign(distSign * dist[0]) *\n          abs(snapHeight / startOffsetHeight / tempScaleValue[1]);\n      } else if (\n        (!sizeDirection[0] && sizeDirection[1]) ||\n        (!snapDist[0] && snapDist[1]) ||\n        (isNoSnap && !isWidth)\n      ) {\n        dist[1] += snapDist[1];\n        const snapWidth =\n          startOffsetHeight * dist[1] * tempScaleValue[1] * ratio;\n\n        dist[0] =\n          sign(distSign * dist[1]) *\n          abs(snapWidth / startOffsetWidth / tempScaleValue[0]);\n      }\n    } else {\n      dist[0] += snapDist[0];\n      dist[1] += snapDist[1];\n\n      if (!snapDist[0]) {\n        dist[0] =\n          throttle(dist[0] * tempScaleValue[0], throttleScale!) /\n          tempScaleValue[0];\n      }\n      if (!snapDist[1]) {\n        dist[1] =\n          throttle(dist[1] * tempScaleValue[1], throttleScale!) /\n          tempScaleValue[1];\n      }\n    }\n\n    if (dist[0] === 0) {\n      dist[0] = sign(prevDist[0]) * MIN_SCALE;\n    }\n    if (dist[1] === 0) {\n      dist[1] = sign(prevDist[1]) * MIN_SCALE;\n    }\n    scale = multiply2(dist, [tempScaleValue[0], tempScaleValue[1]]);\n\n    const startOffsetSize = [startOffsetWidth, startOffsetHeight];\n    let scaleSize = [startOffsetWidth * scale[0], startOffsetHeight * scale[1]];\n\n    scaleSize = calculateBoundSize(\n      scaleSize,\n      datas.minScaleSize,\n      datas.maxScaleSize,\n      keepRatio ? ratio : false\n    );\n\n    // if (keepRatio && (isGroup || keepRatioFinally)) {\n    //     if (isWidth) {\n    //         boundingHeight = boundingWidth / ratio;\n    //     } else {\n    //         boundingWidth = boundingHeight * ratio;\n    //     }\n    // }\n    scale = countEach(2, (i) => {\n      return startOffsetSize[i]\n        ? scaleSize[i] / startOffsetSize[i]\n        : scaleSize[i];\n    });\n    dist = countEach(2, (i) => {\n      return scale[i] / tempScaleValue[i];\n    });\n\n    const delta = countEach(2, (i) =>\n      prevDist[i] ? dist[i] / prevDist[i] : dist[i]\n    );\n\n    const distText = `scale(${dist.join(\", \")})`;\n    const scaleText = `scale(${scale.join(\", \")})`;\n    const nextTransform = convertTransformFormat(datas, scaleText, distText);\n    const isZeroScale = !startValue[0] || !startValue[1];\n\n    const inverseDist = getScaleDist(\n      moveable,\n      isZeroScale ? scaleText : distText,\n      datas.fixedDirection,\n      fixedPosition,\n      datas.fixedOffset,\n      datas,\n      isZeroScale\n    );\n    const inverseDelta = isSelfPinch\n      ? inverseDist\n      : minus(inverseDist, datas.prevInverseDist || [0, 0]);\n\n    datas.prevDist = dist;\n    datas.prevInverseDist = inverseDist;\n    if (\n      scale[0] === prevDist[0] &&\n      scale[1] === prevDist[1] &&\n      inverseDelta.every((num) => !num) &&\n      !parentMoveable &&\n      !isSelfPinch\n    ) {\n      return false;\n    }\n\n    const params = fillParams<OnScale>(moveable, e, {\n      offsetWidth: startOffsetWidth,\n      offsetHeight: startOffsetHeight,\n      direction,\n\n      scale,\n      dist,\n      delta,\n\n      isPinch: !!isPinch,\n      ...fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e),\n    });\n    triggerEvent(moveable, \"onScale\", params);\n\n    return params;\n  },\n  dragControlEnd(moveable: MoveableManagerInterface<ScalableProps>, e: any) {\n    const { datas } = e;\n    if (!datas.isScale) {\n      return false;\n    }\n\n    datas.isScale = false;\n\n    const scaleEndParam = fillEndParams<OnScaleEnd>(moveable, e, {});\n    triggerEvent(moveable, \"onScaleEnd\", scaleEndParam);\n    return scaleEndParam;\n  },\n  dragGroupControlCondition: directionCondition,\n  dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { datas } = e;\n\n    const params = this.dragControlStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n    const originalEvents = fillChildEvents(moveable, \"resizable\", e);\n\n    datas.moveableScale = moveable.scale;\n\n    const events = triggerChildAbles(\n      moveable,\n      this,\n      \"dragControlStart\",\n      e,\n      (child, ev) => {\n        return startChildDist(moveable, child, datas, ev);\n      }\n    );\n\n    const setFixedDirection = (fixedDirection: number[]) => {\n      params.setFixedDirection(fixedDirection);\n      events.forEach((ev, i) => {\n        ev.setFixedDirection(fixedDirection);\n        startChildDist(moveable, ev.moveable, datas, originalEvents[i]);\n      });\n    };\n\n    datas.setFixedDirection = setFixedDirection;\n    const nextParams: OnScaleGroupStart = {\n      ...params,\n      targets: moveable.props.targets!,\n      events,\n      setFixedDirection,\n    };\n    const result = triggerEvent(moveable, \"onScaleGroupStart\", nextParams);\n\n    datas.isScale = result !== false;\n    return datas.isScale ? nextParams : false;\n  },\n  dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { datas } = e;\n    if (!datas.isScale) {\n      return;\n    }\n\n    catchEvent(moveable, \"onBeforeScale\", (parentEvent) => {\n      triggerEvent(\n        moveable,\n        \"onBeforeScaleGroup\",\n        fillParams<OnBeforeScaleGroup>(\n          moveable,\n          e,\n          {\n            ...parentEvent,\n            targets: moveable.props.targets!,\n          },\n          true\n        )\n      );\n    });\n\n    const params = this.dragControl(moveable, e);\n    if (!params) {\n      return;\n    }\n    const { dist } = params;\n    const moveableScale = datas.moveableScale;\n    moveable.scale = [dist[0] * moveableScale[0], dist[1] * moveableScale[1]];\n    const keepRatio = moveable.props.keepRatio;\n\n    const fixedPosition = datas.fixedPosition;\n    const events = triggerChildAbles(\n      moveable,\n      this,\n      \"dragControl\",\n      e,\n      (_, ev) => {\n        const [clientX, clientY] = calculate(\n          createRotateMatrix((moveable.rotation / 180) * Math.PI, 3),\n          [ev.datas.originalX * dist[0], ev.datas.originalY * dist[1], 1],\n          3\n        );\n\n        return {\n          ...ev,\n          parentDist: null,\n          parentScale: dist,\n          parentKeepRatio: keepRatio,\n          // recalculate child fixed position for parent group's dragging.\n          dragClient: plus(fixedPosition, [clientX, clientY]),\n        };\n      }\n    );\n    const nextParams: OnScaleGroup = {\n      targets: moveable.props.targets!,\n      events,\n      ...params,\n    };\n\n    triggerEvent(moveable, \"onScaleGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { isDrag, datas } = e;\n\n    if (!datas.isScale) {\n      return;\n    }\n    this.dragControlEnd(moveable, e);\n    const events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n\n    const nextParams = fillEndParams<OnScaleGroupEnd>(moveable, e, {\n      targets: moveable.props.targets!,\n      events,\n    });\n\n    triggerEvent(moveable, \"onScaleGroupEnd\", nextParams);\n    return isDrag;\n  },\n  /**\n     * @method Moveable.Scalable#request\n     * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"scalable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"scalable\");\n     *\n     * // request\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n  request() {\n    const datas = {};\n    let distWidth = 0;\n    let distHeight = 0;\n    let useSnap = false;\n\n    return {\n      isControl: true,\n      requestStart(e: IObject<any>) {\n        useSnap = e.useSnap;\n\n        return {\n          datas,\n          parentDirection: e.direction || [1, 1],\n          useSnap,\n        };\n      },\n      request(e: IObject<any>) {\n        distWidth += e.deltaWidth;\n        distHeight += e.deltaHeight;\n\n        return {\n          datas,\n          parentDist: [distWidth, distHeight],\n          parentKeepRatio: e.keepRatio,\n          useSnap,\n        };\n      },\n      requestEnd() {\n        return { datas, isDrag: true, useSnap };\n      },\n    };\n  },\n};\n\n/**\n * Whether or not target can scaled.\n *\n * @name Moveable.Scalable#scalable\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.scalable = true;\n */\n\n/**\n * throttle of scaleX, scaleY when scale.\n * @name Moveable.Scalable#throttleScale\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleScale = 0.1;\n */\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Scalable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable.Scalable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n/**\n * When the scale starts, the scaleStart event is called.\n * @memberof Moveable.Scalable\n * @event scaleStart\n * @param {Moveable.Scalable.OnScaleStart} - Parameters for the scaleStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When scaling, `beforeScale` is called before `scale` occurs. In `beforeScale`, you can get and set the pre-value before scaling.\n * @memberof Moveable.Scalable\n * @event beforeScale\n * @param {Moveable.Scalable.OnBeforeScale} - Parameters for the `beforeScale` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"beforeScale\", ({ setFixedDirection }) => {\n *     if (shiftKey) {\n *        setFixedDirection([0, 0]);\n *     }\n * });\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n\n/**\n * When scaling, the `scale` event is called.\n * @memberof Moveable.Scalable\n * @event scale\n * @param {Moveable.Scalable.OnScale} - Parameters for the `scale` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the scale finishes, the `scaleEnd` event is called.\n * @memberof Moveable.Scalable\n * @event scaleEnd\n * @param {Moveable.Scalable.OnScaleEnd} - Parameters for the `scaleEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n * When the group scale starts, the `scaleGroupStart` event is called.\n * @memberof Moveable.Scalable\n * @event scaleGroupStart\n * @param {Moveable.Scalable.OnScaleGroupStart} - Parameters for the `scaleGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroupStart\", ({ targets }) => {\n *     console.log(\"onScaleGroupStart\", targets);\n * });\n */\n\n/**\n * When the group scale, the `scaleGroup` event is called.\n * @memberof Moveable.Scalable\n * @event scaleGroup\n * @param {Moveable.Scalable.OnScaleGroup} - Parameters for the `scaleGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroup\", ({ targets, events }) => {\n *     console.log(\"onScaleGroup\", targets);\n *     events.forEach(ev => {\n *         const target = ev.target;\n *         // ev.drag is a drag event that occurs when the group scale.\n *         const left = ev.drag.beforeDist[0];\n *         const top = ev.drag.beforeDist[1];\n *         const scaleX = ev.scale[0];\n *         const scaleY = ev.scale[1];\n *     });\n * });\n */\n\n/**\n * When the group scale finishes, the `scaleGroupEnd` event is called.\n * @memberof Moveable.Scalable\n * @event scaleGroupEnd\n * @param {Moveable.Scalable.OnScaleGroupEnd} - Parameters for the `scaleGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onScaleGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n  prefix,\n  getLineStyle,\n  getDirection,\n  getAbsolutePosesByState,\n  triggerEvent,\n  fillParams,\n  fillEndParams,\n  getDirectionViewClassName,\n  fillCSSObject,\n} from \"../utils\";\nimport {\n  convertDimension,\n  invert,\n  multiply,\n  calculate,\n  createIdentityMatrix,\n  ignoreDimension,\n  minus,\n  createWarpMatrix,\n  plus,\n} from \"../../matrix\";\nimport { NEARBY_POS } from \"../consts\";\nimport {\n  setDragStart,\n  getDragDist,\n  getPosIndexesByDirection,\n  setDefaultTransformIndex,\n  fillTransformStartEvent,\n  resolveTransformEvent,\n  convertTransformFormat,\n  fillOriginalTransform,\n  getTransfromMatrix,\n} from \"../gesto/gesto-utils\";\nimport {\n  WarpableProps,\n  ScalableProps,\n  ResizableProps,\n  Renderer,\n  SnappableProps,\n  SnappableState,\n  OnWarpStart,\n  OnWarp,\n  OnWarpEnd,\n  MoveableManagerInterface,\n} from \"../types\";\nimport { hasClass, dot, getRad } from \"../../utility\";\nimport { renderAllDirections } from \"../render-directions\";\nimport { hasGuidelines } from \"./snappable/utils\";\nimport { checkMoveableSnapBounds } from \"./snappable/snap-bounds\";\n\nfunction getMiddleLinePos(pos1: number[], pos2: number[]) {\n  return pos1.map((pos, i) => dot(pos, pos2[i], 1, 2));\n}\n\nfunction getTriangleRad(pos1: number[], pos2: number[], pos3: number[]) {\n  // pos1 Rad\n  const rad1 = getRad(pos1, pos2);\n  const rad2 = getRad(pos1, pos3);\n\n  const rad = rad2 - rad1;\n\n  return rad >= 0 ? rad : rad + 2 * Math.PI;\n}\n\nfunction isValidPos(poses1: number[][], poses2: number[][]) {\n  const rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\n  const rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\n  const pi = Math.PI;\n\n  if ((rad1 >= pi && rad2 <= pi) || (rad1 <= pi && rad2 >= pi)) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * @namespace Moveable.Warpable\n * @description Warpable indicates whether the target can be warped(distorted, bented).\n */\nexport default {\n  name: \"warpable\",\n  ableGroup: \"size\",\n  props: [\n    \"warpable\",\n    \"renderDirections\",\n    \"edge\",\n    \"displayAroundControls\",\n  ] as const,\n  events: [\"warpStart\", \"warp\", \"warpEnd\"] as const,\n  viewClassName: getDirectionViewClassName(\"warpable\"),\n  render(\n    moveable: MoveableManagerInterface<\n      ResizableProps & ScalableProps & WarpableProps\n    >,\n    React: Renderer\n  ): any[] {\n    const { resizable, scalable, warpable, zoom } = moveable.props;\n\n    if (resizable || scalable || !warpable) {\n      return [];\n    }\n    const { pos1, pos2, pos3, pos4 } = moveable.state;\n\n    const linePosFrom1 = getMiddleLinePos(pos1, pos2);\n    const linePosFrom2 = getMiddleLinePos(pos2, pos1);\n    const linePosFrom3 = getMiddleLinePos(pos1, pos3);\n    const linePosFrom4 = getMiddleLinePos(pos3, pos1);\n    const linePosTo1 = getMiddleLinePos(pos3, pos4);\n    const linePosTo2 = getMiddleLinePos(pos4, pos3);\n    const linePosTo3 = getMiddleLinePos(pos2, pos4);\n    const linePosTo4 = getMiddleLinePos(pos4, pos2);\n\n    return [\n      <div\n        className={prefix(\"line\")}\n        key=\"middeLine1\"\n        style={getLineStyle(linePosFrom1, linePosTo1, zoom)}\n      ></div>,\n      <div\n        className={prefix(\"line\")}\n        key=\"middeLine2\"\n        style={getLineStyle(linePosFrom2, linePosTo2, zoom)}\n      ></div>,\n      <div\n        className={prefix(\"line\")}\n        key=\"middeLine3\"\n        style={getLineStyle(linePosFrom3, linePosTo3, zoom)}\n      ></div>,\n      <div\n        className={prefix(\"line\")}\n        key=\"middeLine4\"\n        style={getLineStyle(linePosFrom4, linePosTo4, zoom)}\n      ></div>,\n      ...renderAllDirections(moveable, \"warpable\", React),\n    ];\n  },\n  dragControlCondition(moveable: any, e: any) {\n    if (e.isRequest) {\n      return false;\n    }\n    const target = e.inputEvent.target;\n\n    return (\n      hasClass(target, prefix(\"direction\")) &&\n      hasClass(target, prefix(\"warpable\"))\n    );\n  },\n  dragControlStart(\n    moveable: MoveableManagerInterface<WarpableProps, SnappableState>,\n    e: any\n  ) {\n    const { datas, inputEvent } = e;\n    const { target } = moveable.props;\n    const { target: inputTarget } = inputEvent;\n    const direction = getDirection(inputTarget, datas);\n\n    if (!direction || !target) {\n      return false;\n    }\n    const state = moveable.state;\n    const {\n      transformOrigin,\n      is3d,\n      targetTransform,\n      targetMatrix,\n      width,\n      height,\n      left,\n      top,\n    } = state;\n\n    datas.datas = {};\n    datas.targetTransform = targetTransform;\n    datas.warpTargetMatrix = is3d\n      ? targetMatrix\n      : convertDimension(targetMatrix, 3, 4);\n    datas.targetInverseMatrix = ignoreDimension(\n      invert(datas.warpTargetMatrix, 4),\n      3,\n      4\n    );\n    datas.direction = direction;\n    datas.left = left;\n    datas.top = top;\n    datas.poses = [\n      [0, 0],\n      [width, 0],\n      [0, height],\n      [width, height],\n    ].map((p) => minus(p, transformOrigin));\n\n    datas.nextPoses = datas.poses.map(([x, y]: number[]) =>\n      calculate(datas.warpTargetMatrix, [x, y, 0, 1], 4)\n    );\n    datas.startValue = createIdentityMatrix(4);\n    datas.prevMatrix = createIdentityMatrix(4);\n    datas.absolutePoses = getAbsolutePosesByState(state);\n    datas.posIndexes = getPosIndexesByDirection(direction);\n\n    setDragStart(moveable, e);\n    setDefaultTransformIndex(moveable, e, \"matrix3d\");\n\n    state.snapRenderInfo = {\n      request: e.isRequest,\n      direction,\n    };\n\n    const params = fillParams<OnWarpStart>(moveable, e, {\n      set: (matrix: number[]) => {\n        datas.startValue = matrix;\n      },\n      ...fillTransformStartEvent(moveable, e),\n    });\n    const result = triggerEvent(moveable, \"onWarpStart\", params);\n    if (result !== false) {\n      datas.isWarp = true;\n    }\n    return datas.isWarp;\n  },\n  dragControl(\n    moveable: MoveableManagerInterface<\n      WarpableProps & SnappableProps,\n      SnappableState\n    >,\n    e: any\n  ) {\n    const { datas, isRequest } = e;\n    let { distX, distY } = e;\n    const {\n      targetInverseMatrix,\n      prevMatrix,\n      isWarp,\n      startValue,\n      poses,\n      posIndexes,\n      absolutePoses,\n    } = datas;\n\n    if (!isWarp) {\n      return false;\n    }\n    resolveTransformEvent(moveable, e, \"matrix3d\");\n    if (hasGuidelines(moveable, \"warpable\")) {\n      const selectedPoses: number[][] = posIndexes.map(\n        (index: number) => absolutePoses[index]\n      );\n\n      if (selectedPoses.length > 1) {\n        selectedPoses.push([\n          (selectedPoses[0][0] + selectedPoses[1][0]) / 2,\n          (selectedPoses[0][1] + selectedPoses[1][1]) / 2,\n        ]);\n      }\n\n      const { horizontal: horizontalSnapInfo, vertical: verticalSnapInfo } =\n        checkMoveableSnapBounds(moveable, isRequest, {\n          horizontal: selectedPoses.map((pos) => pos[1] + distY),\n          vertical: selectedPoses.map((pos) => pos[0] + distX),\n        });\n\n      distY -= horizontalSnapInfo.offset;\n      distX -= verticalSnapInfo.offset;\n    }\n\n    const dist = getDragDist({ datas, distX, distY }, true);\n    const nextPoses = datas.nextPoses.slice();\n\n    posIndexes.forEach((index: number) => {\n      nextPoses[index] = plus(nextPoses[index], dist);\n    });\n\n    if (\n      !NEARBY_POS.every((nearByPoses) =>\n        isValidPos(\n          nearByPoses.map((i) => poses[i]),\n          nearByPoses.map((i) => nextPoses[i])\n        )\n      )\n    ) {\n      return false;\n    }\n    const h = createWarpMatrix(\n      poses[0],\n      poses[2],\n      poses[1],\n      poses[3],\n      nextPoses[0],\n      nextPoses[2],\n      nextPoses[1],\n      nextPoses[3]\n    );\n\n    if (!h.length) {\n      return false;\n    }\n    // B * A * M\n    const afterMatrix = multiply(targetInverseMatrix, h, 4);\n\n    // B * M * A\n    const matrix = getTransfromMatrix(datas, afterMatrix, true);\n\n    const delta = multiply(invert(prevMatrix, 4), matrix, 4);\n\n    datas.prevMatrix = matrix;\n    const totalMatrix = multiply(startValue, matrix, 4);\n    const nextTransform = convertTransformFormat(\n      datas,\n      `matrix3d(${totalMatrix.join(\", \")})`,\n      `matrix3d(${matrix.join(\", \")})`\n    );\n\n    fillOriginalTransform(e, nextTransform);\n    triggerEvent(\n      moveable,\n      \"onWarp\",\n      fillParams<OnWarp>(moveable, e, {\n        delta,\n        matrix: totalMatrix,\n        dist: matrix,\n        multiply,\n        transform: nextTransform,\n        ...fillCSSObject(\n          {\n            transform: nextTransform,\n          },\n          e\n        ),\n      })\n    );\n    return true;\n  },\n  dragControlEnd(moveable: MoveableManagerInterface<WarpableProps>, e: any) {\n    const { datas, isDrag } = e;\n    if (!datas.isWarp) {\n      return false;\n    }\n    datas.isWarp = false;\n\n    triggerEvent(\n      moveable,\n      \"onWarpEnd\",\n      fillEndParams<OnWarpEnd>(moveable, e, {})\n    );\n    return isDrag;\n  },\n};\n\n/**\n * Whether or not target can be warped. (default: false)\n * @name Moveable.Warpable#warpable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.warpable = true;\n */\n\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Warpable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     warpable: true,\n *     renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n/**\n * When the warp starts, the warpStart event is called.\n * @memberof Moveable.Warpable\n * @event warpStart\n * @param {Moveable.Warpable.OnWarpStart} - Parameters for the warpStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warpStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When warping, the warp event is called.\n * @memberof Moveable.Warpable\n * @event warp\n * @param {Moveable.Warpable.OnWarp} - Parameters for the warp event\n * @example\n * import Moveable from \"moveable\";\n * let matrix = [\n *  1, 0, 0, 0,\n *  0, 1, 0, 0,\n *  0, 0, 1, 0,\n *  0, 0, 0, 1,\n * ];\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warp\", ({ target, transform, delta, multiply }) => {\n *    // target.style.transform = transform;\n *    matrix = multiply(matrix, delta);\n *    target.style.transform = `matrix3d(${matrix.join(\",\")})`;\n * });\n */\n/**\n * When the warp finishes, the warpEnd event is called.\n * @memberof Moveable.Warpable\n * @event warpEnd\n * @param {Moveable.Warpable.OnWarpEnd} - Parameters for the warpEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warpEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n","import { prefix } from \"./utils\";\n\nexport const AREA_PIECES = prefix(\"area-pieces\");\nexport const AREA_PIECE = prefix(\"area-piece\");\nexport const AVOID = prefix(\"avoid\");\nexport const VIEW_DRAGGING = prefix(\"view-dragging\");\n","import { createWarpMatrix } from \"../../matrix\";\nimport { ref } from \"../../utility/framework\";\nimport {\n  getRect,\n  calculateInversePosition,\n  makeMatrixCSS,\n  prefix,\n} from \"../utils\";\nimport {\n  Renderer,\n  GroupableProps,\n  DragAreaProps,\n  MoveableManagerInterface,\n  MoveableGroupInterface,\n} from \"../types\";\nimport { AREA_PIECE, AVOID, AREA_PIECES } from \"../classnames\";\nimport { addClass, removeClass, requestAnimationFrame } from \"../../utility\";\n\nfunction restoreStyle(moveable: MoveableManagerInterface) {\n  const el = moveable.areaElement;\n\n  if (!el) {\n    return;\n  }\n  const { width, height } = moveable.state;\n\n  removeClass(el, AVOID);\n\n  el.style.cssText += `left: 0px; top: 0px; width: ${width}px; height: ${height}px`;\n}\n\nfunction renderPieces(React: Renderer): any {\n  return (\n    <div key=\"area_pieces\" className={AREA_PIECES}>\n      <div className={AREA_PIECE}></div>\n      <div className={AREA_PIECE}></div>\n      <div className={AREA_PIECE}></div>\n      <div className={AREA_PIECE}></div>\n    </div>\n  );\n}\nexport default {\n  name: \"dragArea\",\n  props: [\"dragArea\", \"passDragArea\"] as const,\n  events: [\"click\", \"clickGroup\"] as const,\n  render(\n    moveable: MoveableManagerInterface<GroupableProps>,\n    React: Renderer\n  ): any[] {\n    const { target, dragArea, groupable, passDragArea } = moveable.props;\n    const { width, height, renderPoses } = moveable.getState();\n\n    const className = passDragArea ? prefix(\"area\", \"pass\") : prefix(\"area\");\n    if (groupable) {\n      return [\n        <div\n          key=\"area\"\n          ref={ref(moveable, \"areaElement\")}\n          className={className}\n        ></div>,\n        renderPieces(React),\n      ];\n    }\n    if (!target || !dragArea) {\n      return [];\n    }\n    const h = createWarpMatrix(\n      [0, 0],\n      [width, 0],\n      [0, height],\n      [width, height],\n      renderPoses[0],\n      renderPoses[1],\n      renderPoses[2],\n      renderPoses[3]\n    );\n    const transform = h.length ? makeMatrixCSS(h, true) : \"none\";\n\n    return [\n      <div\n        key=\"area\"\n        ref={ref(moveable, \"areaElement\")}\n        className={className}\n        style={{\n          top: \"0px\",\n          left: \"0px\",\n          width: `${width}px`,\n          height: `${height}px`,\n          transformOrigin: \"0 0\",\n          transform,\n        }}\n      ></div>,\n      renderPieces(React),\n    ];\n  },\n  dragStart(\n    moveable: MoveableManagerInterface,\n    { datas, clientX, clientY, inputEvent }: any\n  ) {\n    if (!inputEvent) {\n      return false;\n    }\n    datas.isDragArea = false;\n    const areaElement = moveable.areaElement;\n    const state = moveable.state;\n    const { moveableClientRect, renderPoses, rootMatrix, is3d } = state;\n    const { left, top } = moveableClientRect;\n    const {\n      left: relativeLeft,\n      top: relativeTop,\n      width,\n      height,\n    } = getRect(renderPoses);\n    const n = is3d ? 4 : 3;\n    let [posX, posY] = calculateInversePosition(\n      rootMatrix,\n      [clientX - left, clientY - top],\n      n\n    );\n\n    posX -= relativeLeft;\n    posY -= relativeTop;\n    const rects = [\n      { left: relativeLeft, top: relativeTop, width, height: posY - 10 },\n      { left: relativeLeft, top: relativeTop, width: posX - 10, height },\n      {\n        left: relativeLeft,\n        top: relativeTop + posY + 10,\n        width,\n        height: height - posY - 10,\n      },\n      {\n        left: relativeLeft + posX + 10,\n        top: relativeTop,\n        width: width - posX - 10,\n        height,\n      },\n    ];\n\n    const children = [].slice.call(\n      areaElement.nextElementSibling!.children\n    ) as HTMLElement[];\n    rects.forEach((rect, i) => {\n      children[\n        i\n      ].style.cssText = `left: ${rect.left}px;top: ${rect.top}px; width: ${rect.width}px; height: ${rect.height}px;`;\n    });\n    addClass(areaElement, AVOID);\n    state.disableNativeEvent = true;\n    return;\n  },\n  drag(moveable: MoveableManagerInterface, { datas, inputEvent }: any) {\n    this.enableNativeEvent(moveable);\n    if (!inputEvent) {\n      return false;\n    }\n    if (!datas.isDragArea) {\n      datas.isDragArea = true;\n      restoreStyle(moveable);\n    }\n  },\n  dragEnd(moveable: MoveableManagerInterface<DragAreaProps>, e: any) {\n    this.enableNativeEvent(moveable);\n    const { inputEvent, datas } = e;\n    if (!inputEvent) {\n      return false;\n    }\n    if (!datas.isDragArea) {\n      restoreStyle(moveable);\n    }\n  },\n  dragGroupStart(moveable: MoveableGroupInterface, e: any) {\n    return this.dragStart(moveable, e);\n  },\n  dragGroup(moveable: MoveableGroupInterface, e: any) {\n    return this.drag(moveable, e);\n  },\n  dragGroupEnd(moveable: MoveableGroupInterface<DragAreaProps>, e: any) {\n    return this.dragEnd(moveable, e);\n  },\n  unset(moveable: MoveableManagerInterface<DragAreaProps>) {\n    restoreStyle(moveable);\n    moveable.state.disableNativeEvent = false;\n  },\n  enableNativeEvent(moveable: MoveableManagerInterface<DragAreaProps>) {\n    const state = moveable.state;\n    if (state.disableNativeEvent) {\n      requestAnimationFrame(() => {\n        state.disableNativeEvent = false;\n      });\n    }\n  },\n};\n\n/**\n * Add an event to the moveable area instead of the target for stopPropagation. (default: false, true in group)\n * @name Moveable#dragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n/**\n * Set `pointerEvents: none;` css to pass events in dragArea. (default: false)\n * @name Moveable#passDragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n","import {\n  prefix,\n  getControlTransform,\n  calculatePosition,\n  convertTransformOriginArray,\n} from \"../utils\";\nimport { Renderer, OriginOptions, MoveableManagerInterface } from \"../types\";\nimport { makeAble } from \"./able-manager\";\nimport { minus } from \"../../matrix\";\n\nexport default makeAble(\"origin\", {\n  props: [\"origin\", \"svgOrigin\"] as const,\n  render(\n    moveable: MoveableManagerInterface<OriginOptions>,\n    React: Renderer\n  ): any[] {\n    const { zoom, svgOrigin, groupable } = moveable.props;\n    const {\n      beforeOrigin,\n      rotation,\n      svg,\n      allMatrix,\n      is3d,\n      left,\n      top,\n      offsetWidth,\n      offsetHeight,\n    } = moveable.getState();\n\n    let originStyle!: Record<string, any>;\n\n    if (!groupable && svg && svgOrigin) {\n      const [originX, originY] = convertTransformOriginArray(\n        svgOrigin,\n        offsetWidth,\n        offsetHeight\n      );\n      const n = is3d ? 4 : 3;\n      const result = calculatePosition(allMatrix, [originX, originY], n);\n      originStyle = getControlTransform(\n        rotation,\n        zoom!,\n        minus(result, [left, top])\n      );\n    } else {\n      originStyle = getControlTransform(rotation, zoom!, beforeOrigin);\n    }\n    return [\n      <div\n        className={prefix(\"control\", \"origin\")}\n        style={originStyle}\n        key=\"beforeOrigin\"\n      ></div>,\n    ];\n  },\n});\n\n/**\n * Whether or not the origin controlbox will be visible or not (default: true)\n * @name Moveable#origin\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.origin = true;\n */\n","import {\n  ScrollableProps,\n  OnScroll,\n  MoveableManagerInterface,\n  MoveableGroupInterface,\n  MoveableRefType,\n} from \"../types\";\nimport { triggerEvent, fillParams, getRefTarget } from \"../utils\";\nimport DragScroll from \"../../drag-scroll\";\n\nfunction getDefaultScrollPosition(e: {\n  scrollContainer: HTMLElement;\n  direction: number[];\n}) {\n  const scrollContainer = e.scrollContainer;\n\n  return [scrollContainer.scrollLeft, scrollContainer.scrollTop];\n}\n/**\n * @namespace Moveable.Scrollable\n * @description Whether or not target can be scrolled to the scroll container (default: false)\n */\nexport default {\n  name: \"scrollable\",\n  canPinch: true,\n  props: [\n    \"scrollable\",\n    \"scrollContainer\",\n    \"scrollThreshold\",\n    \"scrollThrottleTime\",\n    \"getScrollPosition\",\n    \"scrollOptions\",\n  ] as const,\n  events: [\"scroll\", \"scrollGroup\"] as const,\n  dragRelation: \"strong\",\n  dragStart(\n    moveable: MoveableManagerInterface<ScrollableProps, Record<string, any>>,\n    e: any\n  ) {\n    const props = moveable.props;\n    const {\n      scrollContainer = moveable.getContainer() as HTMLElement,\n      scrollOptions,\n    } = props;\n\n    const dragScroll = new DragScroll();\n    const scrollContainerElement = getRefTarget<HTMLElement>(\n      scrollContainer,\n      true\n    );\n\n    e.datas.dragScroll = dragScroll;\n    moveable.state.dragScroll = dragScroll;\n\n    const gestoName = e.isControl ? \"controlGesto\" : \"targetGesto\";\n    const targets = e.targets;\n\n    dragScroll\n      .on(\"scroll\", ({ container, direction }) => {\n        const params = fillParams<OnScroll>(moveable, e, {\n          scrollContainer: container,\n          direction,\n        }) as any;\n\n        const eventName = targets ? \"onScrollGroup\" : (\"onScroll\" as any);\n        if (targets) {\n          params.targets = targets;\n        }\n        triggerEvent(moveable, eventName, params);\n      })\n      .on(\"move\", ({ offsetX, offsetY, inputEvent }) => {\n        moveable[gestoName].scrollBy(\n          offsetX,\n          offsetY,\n          inputEvent.inputEvent,\n          false\n        );\n      })\n      .on(\"scrollDrag\", ({ next }) => {\n        next(moveable[gestoName].getCurrentEvent());\n      });\n    dragScroll.dragStart(e, {\n      container: scrollContainerElement!,\n      ...scrollOptions,\n    });\n  },\n  checkScroll(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n    const dragScroll = e.datas.dragScroll as DragScroll;\n\n    if (!dragScroll) {\n      return;\n    }\n    const {\n      scrollContainer = moveable.getContainer() as MoveableRefType<HTMLElement>,\n      scrollThreshold = 0,\n      scrollThrottleTime = 0,\n      getScrollPosition = getDefaultScrollPosition,\n      scrollOptions,\n    } = moveable.props;\n\n    dragScroll.drag(e, {\n      container: scrollContainer!,\n      threshold: scrollThreshold,\n      throttleTime: scrollThrottleTime,\n      getScrollPosition: (ev: any) => {\n        return getScrollPosition({\n          scrollContainer: ev.container,\n          direction: ev.direction,\n        });\n      },\n      ...scrollOptions,\n    });\n\n    return true;\n  },\n  drag(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n    return this.checkScroll(moveable, e);\n  },\n  dragEnd(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n    e.datas.dragScroll.dragEnd();\n    e.datas.dragScroll = null;\n  },\n  dragControlStart(\n    moveable: MoveableManagerInterface<ScrollableProps>,\n    e: any\n  ) {\n    return this.dragStart(moveable, { ...e, isControl: true });\n  },\n  dragControl(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n    return this.drag(moveable, e);\n  },\n  dragControlEnd(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n    return this.dragEnd(moveable, e);\n  },\n  dragGroupStart(moveable: MoveableGroupInterface, e: any) {\n    return this.dragStart(moveable, { ...e, targets: moveable.props.targets });\n  },\n  dragGroup(moveable: MoveableGroupInterface, e: any) {\n    return this.drag(moveable, { ...e, targets: moveable.props.targets });\n  },\n  dragGroupEnd(moveable: MoveableGroupInterface, e: any) {\n    return this.dragEnd(moveable, { ...e, targets: moveable.props.targets });\n  },\n  dragGroupControlStart(moveable: MoveableGroupInterface, e: any) {\n    return this.dragStart(moveable, {\n      ...e,\n      targets: moveable.props.targets,\n      isControl: true,\n    });\n  },\n  dragGroupControl(moveable: MoveableGroupInterface, e: any) {\n    return this.drag(moveable, { ...e, targets: moveable.props.targets });\n  },\n  dragGroupControEnd(moveable: MoveableGroupInterface, e: any) {\n    return this.dragEnd(moveable, { ...e, targets: moveable.props.targets });\n  },\n  unset(\n    moveable: MoveableManagerInterface<ScrollableProps, Record<string, any>>\n  ) {\n    const state = moveable.state;\n\n    state.dragScroll?.dragEnd();\n    state.dragScroll = null;\n  },\n};\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scroll` event occur to scroll.\n * @memberof Moveable.Scrollable\n * @event scroll\n * @param {Moveable.Scrollable.OnScroll} - Parameters for the `scroll` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scrollGroup` event occur to scroll in group.\n * @memberof Moveable.Scrollable\n * @event scrollGroup\n * @param {Moveable.Scrollable.OnScrollGroup} - Parameters for the `scrollGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n","export default {\n  name: \"\",\n  props: [\n    \"target\",\n    \"dragTargetSelf\",\n    \"dragTarget\",\n    \"dragContainer\",\n    \"container\",\n    \"warpSelf\",\n    \"rootContainer\",\n    \"useResizeObserver\",\n    \"useMutationObserver\",\n    \"zoom\",\n    \"dragFocusedInput\",\n    \"transformOrigin\",\n    \"ables\",\n    \"className\",\n    \"pinchThreshold\",\n    \"pinchOutside\",\n    \"triggerAblesSimultaneously\",\n    \"checkInput\",\n    \"cspNonce\",\n    \"translateZ\",\n    \"hideDefaultLines\",\n    \"props\",\n    \"flushSync\",\n    \"stopPropagation\",\n    \"preventClickEventOnDrag\",\n    \"preventClickDefault\",\n    \"viewContainer\",\n    \"persistData\",\n    \"useAccuratePosition\",\n    \"firstRenderState\",\n    \"linePadding\",\n    \"controlPadding\",\n    \"preventDefault\",\n    \"preventRightClick\",\n    \"preventWheelClick\",\n    \"requestStyles\",\n  ] as const,\n  events: [\"changeTargets\"] as const,\n};\n","import { prefix, makeMatrixCSS, getPaddingBox } from \"../utils\";\nimport { Renderer, MoveableManagerInterface } from \"../types\";\nimport { createWarpMatrix } from \"../../matrix\";\nimport { makeAble } from \"./able-manager\";\n\nexport default makeAble(\"padding\", {\n  props: [\"padding\"] as const,\n  render(moveable: MoveableManagerInterface, React: Renderer): any[] {\n    const props = moveable.props;\n    if (props.dragArea) {\n      return [];\n    }\n    const { left, top, right, bottom } = getPaddingBox(props.padding || {});\n    const { renderPoses, pos1, pos2, pos3, pos4 } = moveable.getState();\n\n    const poses = [pos1, pos2, pos3, pos4];\n    const paddingDirections: number[][] = [];\n\n    if (left > 0) {\n      paddingDirections.push([0, 2]);\n    }\n    if (top > 0) {\n      paddingDirections.push([0, 1]);\n    }\n    if (right > 0) {\n      paddingDirections.push([1, 3]);\n    }\n    if (bottom > 0) {\n      paddingDirections.push([2, 3]);\n    }\n    return paddingDirections.map(([dir1, dir2], i) => {\n      const paddingPos1 = poses[dir1];\n      const paddingPos2 = poses[dir2];\n      const paddingPos3 = renderPoses[dir1];\n      const paddingPos4 = renderPoses[dir2];\n\n      const h = createWarpMatrix(\n        [0, 0],\n        [100, 0],\n        [0, 100],\n        [100, 100],\n        paddingPos1,\n        paddingPos2,\n        paddingPos3,\n        paddingPos4\n      );\n      if (!h.length) {\n        return undefined;\n      }\n      return (\n        <div\n          key={`padding${i}`}\n          className={prefix(\"padding\")}\n          style={{\n            transform: makeMatrixCSS(h, true),\n          }}\n        ></div>\n      );\n    });\n  },\n});\n\n/**\n * Add padding around the target to increase the drag area.\n * @name Moveable#padding\n * @default null\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  target: document.querySelector(\".target\"),\n *  padding: { left: 0, top: 0, right: 0, bottom: 0 },\n * });\n * moveable.padding = { left: 10, top: 10, right: 10, bottom: 10 },\n * moveable.updateRect();\n */\n","import { convertCSSSize } from \"../../utils\";\nimport { ControlPose } from \"../../types\";\nimport { convertUnitSize } from \"../../../utility\";\n\nconst RADIUS_DIRECTIONS = [\"nw\", \"ne\", \"se\", \"sw\"] as const;\n\nfunction calculateRatio(values: number[], size: number) {\n  const sumSize = values[0] + values[1];\n  const sumRatio = sumSize > size ? size / sumSize : 1;\n\n  values[0] *= sumRatio;\n  values[1] = size - values[1] * sumRatio;\n\n  return values;\n}\nexport const HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6];\nexport const VERTICAL_RADIUS_ORDER = [0, 3, 4, 7];\nexport const HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1] as const;\nexport const VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1] as const;\n\nexport function getRadiusStyles(\n  nextPoses: ControlPose[],\n  isRelative: boolean,\n  width: number,\n  height: number,\n  left = 0,\n  top = 0,\n  right: number = width,\n  bottom: number = height\n) {\n  const clipStyles: string[] = [];\n  let isVertical = false;\n\n  const radiusPoses = nextPoses.filter((pos) => !pos.virtual);\n  const raws = radiusPoses.map((posInfo) => {\n    const { horizontal, vertical, pos } = posInfo;\n\n    if (vertical && !isVertical) {\n      isVertical = true;\n      clipStyles.push(\"/\");\n    }\n\n    if (isVertical) {\n      const rawPos = Math.max(\n        0,\n        vertical === 1 ? pos[1] - top : bottom - pos[1]\n      );\n      clipStyles.push(convertCSSSize(rawPos, height, isRelative));\n\n      return rawPos;\n    } else {\n      const rawPos = Math.max(\n        0,\n        horizontal === 1 ? pos[0] - left : right - pos[0]\n      );\n      clipStyles.push(convertCSSSize(rawPos, width, isRelative));\n\n      return rawPos;\n    }\n  });\n\n  return {\n    radiusPoses,\n    styles: clipStyles,\n    raws,\n  };\n}\nexport function getRadiusRange(controlPoses: ControlPose[]) {\n  // [start, length]\n  const horizontalRange = [0, 0];\n  const verticalRange = [0, 0];\n  const length = controlPoses.length;\n\n  for (let i = 0; i < length; ++i) {\n    const clipPose = controlPoses[i];\n\n    if (!clipPose.sub) {\n      continue;\n    }\n    if (clipPose.horizontal) {\n      if (horizontalRange[1] === 0) {\n        horizontalRange[0] = i;\n      }\n      horizontalRange[1] = i - horizontalRange[0] + 1;\n      verticalRange[0] = i + 1;\n    }\n    if (clipPose.vertical) {\n      if (verticalRange[1] === 0) {\n        verticalRange[0] = i;\n      }\n      verticalRange[1] = i - verticalRange[0] + 1;\n    }\n  }\n\n  return {\n    horizontalRange,\n    verticalRange,\n  };\n}\nexport function getRadiusValues(\n  values: string[],\n  width: number,\n  height: number,\n  left: number,\n  top: number,\n  minCounts: number[] = [0, 0],\n  full = false\n): ControlPose[] {\n  const splitIndex = values.indexOf(\"/\");\n  const splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values)\n    .length;\n  const horizontalValues = values.slice(0, splitLength);\n  const verticalValues = values.slice(splitLength + 1);\n  const horizontalValuesLength = horizontalValues.length;\n  const verticalValuesLength = verticalValues.length;\n  const hasVerticalValues = verticalValuesLength > 0;\n  const [\n    nwValue = \"0px\",\n    neValue = nwValue,\n    seValue = nwValue,\n    swValue = neValue,\n  ] = horizontalValues;\n  const [\n    wnValue = nwValue,\n    enValue = hasVerticalValues ? wnValue : neValue,\n    esValue = hasVerticalValues ? wnValue : seValue,\n    wsValue = hasVerticalValues ? enValue : swValue,\n  ] = verticalValues;\n\n  const horizontalRawPoses = [nwValue, neValue, seValue, swValue].map((pos) =>\n    convertUnitSize(pos, width)\n  );\n  const verticalRawPoses = [wnValue, enValue, esValue, wsValue].map((pos) =>\n    convertUnitSize(pos, height)\n  );\n  const horizontalPoses = horizontalRawPoses.slice();\n  const verticalPoses = verticalRawPoses.slice();\n\n  [horizontalPoses[0], horizontalPoses[1]] = calculateRatio(\n    [horizontalPoses[0], horizontalPoses[1]],\n    width\n  );\n  [horizontalPoses[3], horizontalPoses[2]] = calculateRatio(\n    [horizontalPoses[3], horizontalPoses[2]],\n    width\n  );\n  [verticalPoses[0], verticalPoses[3]] = calculateRatio(\n    [verticalPoses[0], verticalPoses[3]],\n    height\n  );\n  [verticalPoses[1], verticalPoses[2]] = calculateRatio(\n    [verticalPoses[1], verticalPoses[2]],\n    height\n  );\n\n  const nextHorizontalPoses = full\n    ? horizontalPoses\n    : horizontalPoses.slice(0, Math.max(minCounts[0], horizontalValuesLength));\n  const nextVerticalPoses = full\n    ? verticalPoses\n    : verticalPoses.slice(0, Math.max(minCounts[1], verticalValuesLength));\n\n  return [\n    ...nextHorizontalPoses.map((pos, i) => {\n      const direction = RADIUS_DIRECTIONS[i];\n\n      return {\n        virtual: i >= horizontalValuesLength,\n        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n        vertical: 0,\n        pos: [\n          left + pos,\n          top + (VERTICAL_RADIUS_DIRECTIONS[i] === -1 ? height : 0),\n        ],\n        sub: true,\n        raw: horizontalRawPoses[i],\n        direction,\n      };\n    }),\n    ...nextVerticalPoses.map((pos, i) => {\n      const direction = RADIUS_DIRECTIONS[i];\n\n      return {\n        virtual: i >= verticalValuesLength,\n        horizontal: 0,\n        vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n        pos: [\n          left + (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1 ? width : 0),\n          top + pos,\n        ],\n        sub: true,\n        raw: verticalRawPoses[i],\n        direction,\n      };\n    }),\n  ];\n}\nexport function removeRadiusPos(\n  controlPoses: ControlPose[],\n  poses: number[][],\n  index: number,\n  startIndex: number,\n  length: number = poses.length\n) {\n  const { horizontalRange, verticalRange } = getRadiusRange(\n    controlPoses.slice(startIndex)\n  );\n  const radiuslIndex = index - startIndex;\n  let deleteCount = 0;\n\n  if (radiuslIndex === 0) {\n    deleteCount = length;\n  } else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {\n    deleteCount = horizontalRange[1] - radiuslIndex;\n  } else if (radiuslIndex >= verticalRange[0]) {\n    deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;\n  } else {\n    return;\n  }\n  controlPoses.splice(index, deleteCount);\n  poses.splice(index, deleteCount);\n}\nexport function addRadiusPos(\n  controlPoses: ControlPose[],\n  poses: number[][],\n  startIndex: number,\n  horizontalIndex: number,\n  verticalIndex: number,\n  distX: number,\n  distY: number,\n  right: number,\n  bottom: number,\n  left = 0,\n  top = 0\n) {\n  const { horizontalRange, verticalRange } = getRadiusRange(\n    controlPoses.slice(startIndex)\n  );\n  if (horizontalIndex > -1) {\n    const radiusX =\n      HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1\n        ? distX - left\n        : right - distX;\n    for (let i = horizontalRange[1]; i <= horizontalIndex; ++i) {\n      const y = VERTICAL_RADIUS_DIRECTIONS[i] === 1 ? top : bottom;\n      let x = 0;\n      if (horizontalIndex === i) {\n        x = distX;\n      } else if (i === 0) {\n        x = left + radiusX;\n      } else if (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1) {\n        x = right - (poses[startIndex][0] - left);\n      }\n      controlPoses.splice(startIndex + i, 0, {\n        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n        vertical: 0,\n        pos: [x, y],\n      });\n      poses.splice(startIndex + i, 0, [x, y]);\n\n      if (i === 0) {\n        break;\n      }\n    }\n  } else if (verticalIndex > -1) {\n    const radiusY =\n      VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1\n        ? distY - top\n        : bottom - distY;\n    if (horizontalRange[1] === 0 && verticalRange[1] === 0) {\n      const pos = [left + radiusY, top];\n      controlPoses.push({\n        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],\n        vertical: 0,\n        pos,\n      });\n      poses.push(pos);\n    }\n\n    const startVerticalIndex = verticalRange[0];\n    for (let i = verticalRange[1]; i <= verticalIndex; ++i) {\n      const x = HORIZONTAL_RADIUS_DIRECTIONS[i] === 1 ? left : right;\n      let y = 0;\n      if (verticalIndex === i) {\n        y = distY;\n      } else if (i === 0) {\n        y = top + radiusY;\n      } else if (VERTICAL_RADIUS_DIRECTIONS[i] === 1) {\n        y = poses[startIndex + startVerticalIndex][1];\n      } else if (VERTICAL_RADIUS_DIRECTIONS[i] === -1) {\n        y = bottom - (poses[startIndex + startVerticalIndex][1] - top);\n      }\n      controlPoses.push({\n        horizontal: 0,\n        vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n        pos: [x, y],\n      });\n      poses.push([x, y]);\n      if (i === 0) {\n        break;\n      }\n    }\n  }\n}\nexport function splitRadiusPoses(\n  controlPoses: ControlPose[],\n  raws: number[] = controlPoses.map((pos) => pos.raw!)\n) {\n  const horizontals = controlPoses\n    .map((pos, i) => (pos.horizontal ? raws[i] : null))\n    .filter((pos) => pos != null) as number[];\n  const verticals = controlPoses\n    .map((pos, i) => (pos.vertical ? raws[i] : null))\n    .filter((pos) => pos != null) as number[];\n\n  return {\n    horizontals,\n    verticals,\n  };\n}\n","import {\n  splitBracket,\n  splitComma,\n  convertUnitSize,\n  splitSpace,\n  splitUnit,\n} from \"../../../utility\";\nimport { minus } from \"../../../matrix\";\nimport { abs, convertCSSSize } from \"../../utils\";\nimport { getRadiusStyles, getRadiusValues } from \"../roundable/border-radius\";\nimport {\n  MoveableManagerInterface,\n  ClippableProps,\n  ControlPose,\n} from \"../../types\";\nimport { getMinMaxs } from \"../../../overlap-area\";\nimport { getCachedStyle } from \"../../store/store\";\n\nexport const CLIP_DIRECTIONS = [\n  [0, -1, \"n\"],\n  [1, 0, \"e\"],\n] as const;\n\nexport const CLIP_RECT_DIRECTIONS = [\n  [-1, -1, \"nw\"],\n  [0, -1, \"n\"],\n  [1, -1, \"ne\"],\n  [1, 0, \"e\"],\n  [1, 1, \"se\"],\n  [0, 1, \"s\"],\n  [-1, 1, \"sw\"],\n  [-1, 0, \"w\"],\n] as const;\n\n// 1 2 5 6 0 3 4 7\n// 0 1 2 3 4 5 6 7\n\nexport function getClipStyles(\n  moveable: MoveableManagerInterface<ClippableProps>,\n  clipPath: ReturnType<typeof getClipPath>,\n  poses: number[][]\n) {\n  const { clipRelative } = moveable.props;\n  const { width, height } = moveable.state;\n  const { type: clipType, poses: clipPoses } = clipPath!;\n\n  const isRect = clipType === \"rect\";\n  const isCircle = clipType === \"circle\";\n  if (clipType === \"polygon\") {\n    return poses.map(\n      (pos) =>\n        `${convertCSSSize(pos[0], width, clipRelative)} ${convertCSSSize(\n          pos[1],\n          height,\n          clipRelative\n        )}`\n    );\n  } else if (isRect || clipType === \"inset\") {\n    const top = poses[1][1];\n    const right = poses[3][0];\n    const left = poses[7][0];\n    const bottom = poses[5][1];\n\n    if (isRect) {\n      return [top, right, bottom, left].map((pos) => `${pos}px`);\n    }\n    const clipStyles = [top, width - right, height - bottom, left].map(\n      (pos, i) => convertCSSSize(pos, i % 2 ? width : height, clipRelative)\n    );\n\n    if (poses.length > 8) {\n      const [subWidth, subHeight] = minus(poses[4], poses[0]);\n\n      clipStyles.push(\n        \"round\",\n        ...getRadiusStyles(\n          clipPoses.slice(8).map((info, i) => {\n            return {\n              ...info,\n              pos: poses[i],\n            };\n          }),\n          clipRelative!,\n          subWidth,\n          subHeight,\n          left,\n          top,\n          right,\n          bottom\n        ).styles\n      );\n    }\n    return clipStyles;\n  } else if (isCircle || clipType === \"ellipse\") {\n    const center = poses[0];\n    const ry = convertCSSSize(\n      abs(poses[1][1] - center[1]),\n      isCircle ? Math.sqrt((width * width + height * height) / 2) : height,\n      clipRelative\n    );\n\n    const clipStyles = isCircle\n      ? [ry]\n      : [convertCSSSize(abs(poses[2][0] - center[0]), width, clipRelative), ry];\n\n    clipStyles.push(\n      \"at\",\n      convertCSSSize(center[0], width, clipRelative),\n      convertCSSSize(center[1], height, clipRelative)\n    );\n\n    return clipStyles;\n  }\n}\n\nexport function getRectPoses(\n  top: number,\n  right: number,\n  bottom: number,\n  left: number\n): ControlPose[] {\n  const xs = [left, (left + right) / 2, right];\n  const ys = [top, (top + bottom) / 2, bottom];\n\n  return CLIP_RECT_DIRECTIONS.map(([dirx, diry, dir]) => {\n    const x = xs[dirx + 1];\n    const y = ys[diry + 1];\n    return {\n      vertical: abs(diry),\n      horizontal: abs(dirx),\n      direction: dir,\n      pos: [x, y],\n    };\n  });\n}\n\nexport function getControlSize(controlPoses: ControlPose[]) {\n  const xRange = [Infinity, -Infinity];\n  const yRange = [Infinity, -Infinity];\n\n  controlPoses.forEach(({ pos }) => {\n    xRange[0] = Math.min(xRange[0], pos[0]);\n    xRange[1] = Math.max(xRange[1], pos[0]);\n    yRange[0] = Math.min(yRange[0], pos[1]);\n    yRange[1] = Math.max(yRange[1], pos[1]);\n  });\n\n  return [abs(xRange[1] - xRange[0]), abs(yRange[1] - yRange[0])];\n}\n\nexport function getClipPath(\n  target: HTMLElement | SVGElement | undefined | null,\n  width: number,\n  height: number,\n  defaultClip?: string,\n  customClip?: string\n) {\n  if (!target) {\n    return;\n  }\n  let clipText: string | undefined = customClip;\n\n  if (!clipText) {\n    const getStyle = getCachedStyle(target!);\n    const clipPath = getStyle(\"clipPath\");\n\n    clipText = clipPath !== \"none\" ? clipPath : getStyle(\"clip\");\n  }\n  if (!clipText || clipText === \"none\" || clipText === \"auto\") {\n    clipText = defaultClip;\n\n    if (!clipText) {\n      return;\n    }\n  }\n  const { prefix: clipPrefix = clipText, value = \"\" } = splitBracket(clipText);\n  const isCircle = clipPrefix === \"circle\";\n  let splitter = \" \";\n\n  if (clipPrefix === \"polygon\") {\n    const values = splitComma(value! || `0% 0%, 100% 0%, 100% 100%, 0% 100%`);\n    splitter = \",\";\n\n    const poses: ControlPose[] = values.map((pos) => {\n      const [xPos, yPos] = pos.split(\" \");\n\n      return {\n        vertical: 1,\n        horizontal: 1,\n        pos: [convertUnitSize(xPos, width), convertUnitSize(yPos, height)],\n      };\n    });\n    const minMaxs = getMinMaxs(poses.map((pos) => pos.pos));\n\n    return {\n      type: clipPrefix,\n      clipText,\n      poses,\n      splitter,\n      left: minMaxs.minX,\n      right: minMaxs.maxX,\n      top: minMaxs.minY,\n      bottom: minMaxs.maxY,\n    } as const;\n  } else if (isCircle || clipPrefix === \"ellipse\") {\n    let xPos = \"\";\n    let yPos = \"\";\n    let radiusX = 0;\n    let radiusY = 0;\n    const values = splitSpace(value!);\n\n    if (isCircle) {\n      let radius = \"\";\n      [radius = \"50%\", , xPos = \"50%\", yPos = \"50%\"] = values;\n\n      radiusX = convertUnitSize(\n        radius,\n        Math.sqrt((width * width + height * height) / 2)\n      );\n      radiusY = radiusX;\n    } else {\n      let xRadius = \"\";\n      let yRadius = \"\";\n      [xRadius = \"50%\", yRadius = \"50%\", , xPos = \"50%\", yPos = \"50%\"] = values;\n\n      radiusX = convertUnitSize(xRadius, width);\n      radiusY = convertUnitSize(yRadius, height);\n    }\n    const centerPos = [\n      convertUnitSize(xPos, width),\n      convertUnitSize(yPos, height),\n    ];\n    const poses: ControlPose[] = [\n      {\n        vertical: 1,\n        horizontal: 1,\n        pos: centerPos,\n        direction: \"nesw\",\n      },\n      ...CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map((dir) => ({\n        vertical: abs(dir[1]),\n        horizontal: dir[0],\n        direction: dir[2],\n        sub: true,\n        pos: [centerPos[0] + dir[0] * radiusX, centerPos[1] + dir[1] * radiusY],\n      })),\n    ];\n    return {\n      type: clipPrefix as \"circle\" | \"ellipse\",\n      clipText,\n      radiusX,\n      radiusY,\n      left: centerPos[0] - radiusX,\n      top: centerPos[1] - radiusY,\n      right: centerPos[0] + radiusX,\n      bottom: centerPos[1] + radiusY,\n      poses,\n      splitter,\n    } as const;\n  } else if (clipPrefix === \"inset\") {\n    const values = splitSpace(value! || \"0 0 0 0\");\n    const roundIndex = values.indexOf(\"round\");\n\n    const rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values)\n      .length;\n    const radiusValues = values.slice(rectLength + 1);\n    const [\n      topValue,\n      rightValue = topValue,\n      bottomValue = topValue,\n      leftValue = rightValue,\n    ] = values.slice(0, rectLength);\n    const [top, bottom] = [topValue, bottomValue].map((pos) =>\n      convertUnitSize(pos, height)\n    );\n    const [left, right] = [leftValue, rightValue].map((pos) =>\n      convertUnitSize(pos, width)\n    );\n    const nextRight = width - right;\n    const nextBottom = height - bottom;\n    const radiusPoses = getRadiusValues(\n      radiusValues,\n      nextRight - left,\n      nextBottom - top,\n      left,\n      top\n    );\n    const poses: ControlPose[] = [\n      ...getRectPoses(top, nextRight, nextBottom, left),\n      ...radiusPoses,\n    ];\n\n    return {\n      type: \"inset\",\n      clipText,\n      poses,\n      top,\n      left,\n      right: nextRight,\n      bottom: nextBottom,\n      radius: radiusValues,\n      splitter,\n    } as const;\n  } else if (clipPrefix === \"rect\") {\n    // top right bottom left\n    const values = splitComma(value! || `0px, ${width}px, ${height}px, 0px`);\n\n    splitter = \",\";\n    const [top, right, bottom, left] = values.map((pos) => {\n      const { value: posValue } = splitUnit(pos);\n\n      return posValue;\n    });\n    const poses = getRectPoses(top, right, bottom, left);\n\n    return {\n      type: \"rect\",\n      clipText,\n      poses,\n      top,\n      right,\n      bottom,\n      left,\n      values,\n      splitter,\n    } as const;\n  }\n  return;\n}\n","import {\n  Renderer,\n  ClippableProps,\n  OnClip,\n  ClippableState,\n  OnClipEnd,\n  OnClipStart,\n  ControlPose,\n  MoveableManagerInterface,\n  DraggableProps,\n} from \"../types\";\nimport { convertUnitSize, getRad } from \"../../utility\";\nimport {\n  prefix,\n  calculatePosition,\n  getDiagonalSize,\n  fillParams,\n  triggerEvent,\n  makeMatrixCSS,\n  getRect,\n  fillEndParams,\n  getSizeDistByDist,\n  getProps,\n  fillCSSObject,\n  abs,\n  sign,\n} from \"../utils\";\nimport { plus, minus, multiply } from \"../../matrix\";\nimport {\n  getDragDist,\n  calculatePointerDist,\n  setDragStart,\n} from \"../gesto/gesto-utils\";\nimport {\n  HORIZONTAL_RADIUS_ORDER,\n  VERTICAL_RADIUS_ORDER,\n  addRadiusPos,\n  removeRadiusPos,\n} from \"./roundable/border-radius\";\nimport { renderLine } from \"../render-directions\";\nimport { checkSnapBoundPriority } from \"./snappable/snap\";\nimport { checkSnapBounds } from \"./snappable/snap-bounds\";\nimport { getDefaultGuidelines } from \"./snappable/get-total-guidelines\";\nimport {\n  getControlSize,\n  getClipPath,\n  getClipStyles,\n  getRectPoses,\n} from \"./clippable/utils\";\n\nexport function moveControlPos(\n  controlPoses: ControlPose[],\n  index: number,\n  dist: number[],\n  isRect?: boolean,\n  keepRatio?: boolean\n) {\n  const { direction, sub } = controlPoses[index];\n  const dists = controlPoses.map(() => [0, 0]);\n  const directions = direction ? direction.split(\"\") : [];\n\n  if (isRect && index < 8) {\n    const verticalDirections = directions.filter(\n      (dir) => dir === \"w\" || dir === \"e\"\n    );\n    const horizontalDirections = directions.filter(\n      (dir) => dir === \"n\" || dir === \"s\"\n    );\n\n    const verticalDirection = verticalDirections[0];\n    const horizontalDirection = horizontalDirections[0];\n\n    dists[index] = dist;\n    const [width, height] = getControlSize(controlPoses);\n    const ratio = width && height ? width / height : 0;\n\n    if (ratio && keepRatio) {\n      // 0 1 2\n      // 7   3\n      // 6 5 4\n      const fixedIndex = (index + 4) % 8;\n      const fixedPosition = controlPoses[fixedIndex].pos;\n      const sizeDirection = [0, 0];\n\n      if (direction!.indexOf(\"w\") > -1) {\n        sizeDirection[0] = -1;\n      } else if (direction!.indexOf(\"e\") > -1) {\n        sizeDirection[0] = 1;\n      }\n      if (direction!.indexOf(\"n\") > -1) {\n        sizeDirection[1] = -1;\n      } else if (direction!.indexOf(\"s\") > -1) {\n        sizeDirection[1] = 1;\n      }\n\n      const nextDist = getSizeDistByDist(\n        [width, height],\n        dist,\n        ratio,\n        sizeDirection,\n        true\n      );\n      const nextWidth = width + nextDist[0];\n      const nextHeight = height + nextDist[1];\n      let top = fixedPosition[1];\n      let bottom = fixedPosition[1];\n      let left = fixedPosition[0];\n      let right = fixedPosition[0];\n\n      if (sizeDirection[0] === -1) {\n        left = right - nextWidth;\n      } else if (sizeDirection[0] === 1) {\n        right = left + nextWidth;\n      } else {\n        left = left - nextWidth / 2;\n        right = right + nextWidth / 2;\n      }\n      if (sizeDirection[1] === -1) {\n        top = bottom - nextHeight;\n      } else if (sizeDirection[1] === 1) {\n        bottom = top + nextHeight;\n      } else {\n        top = bottom - nextHeight / 2;\n        bottom = top + nextHeight;\n      }\n\n      const nextControlPoses = getRectPoses(top, right, bottom, left);\n\n      controlPoses.forEach((controlPose, i) => {\n        dists[i][0] = nextControlPoses[i].pos[0] - controlPose.pos[0];\n        dists[i][1] = nextControlPoses[i].pos[1] - controlPose.pos[1];\n      });\n    } else {\n      controlPoses.forEach((controlPose, i) => {\n        const { direction: controlDir } = controlPose;\n\n        if (!controlDir) {\n          return;\n        }\n        if (controlDir.indexOf(verticalDirection) > -1) {\n          dists[i][0] = dist[0];\n        }\n        if (controlDir.indexOf(horizontalDirection) > -1) {\n          dists[i][1] = dist[1];\n        }\n      });\n      if (verticalDirection) {\n        dists[1][0] = dist[0] / 2;\n        dists[5][0] = dist[0] / 2;\n      }\n      if (horizontalDirection) {\n        dists[3][1] = dist[1] / 2;\n        dists[7][1] = dist[1] / 2;\n      }\n    }\n  } else if (direction && !sub) {\n    directions.forEach((dir) => {\n      const isVertical = dir === \"n\" || dir === \"s\";\n\n      controlPoses.forEach((controlPose, i) => {\n        const {\n          direction: dirDir,\n          horizontal: dirHorizontal,\n          vertical: dirVertical,\n        } = controlPose;\n\n        if (!dirDir || dirDir.indexOf(dir) === -1) {\n          return;\n        }\n        dists[i] = [\n          isVertical || !dirHorizontal ? 0 : dist[0],\n          !isVertical || !dirVertical ? 0 : dist[1],\n        ];\n      });\n    });\n  } else {\n    dists[index] = dist;\n  }\n\n  return dists;\n}\n\nfunction addClipPath(\n  moveable: MoveableManagerInterface<ClippableProps>,\n  e: any\n) {\n  const [distX, distY] = calculatePointerDist(moveable, e);\n  const { clipPath, clipIndex } = e.datas;\n  const {\n    type: clipType,\n    poses: clipPoses,\n    splitter,\n  } = (clipPath as ReturnType<typeof getClipPath>)!;\n  const poses = clipPoses.map((pos) => pos.pos);\n  if (clipType === \"polygon\") {\n    poses.splice(clipIndex, 0, [distX, distY]);\n  } else if (clipType === \"inset\") {\n    const horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(clipIndex);\n    const verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(clipIndex);\n    const length = clipPoses.length;\n\n    addRadiusPos(\n      clipPoses,\n      poses,\n      8,\n      horizontalIndex,\n      verticalIndex,\n      distX,\n      distY,\n      poses[4][0],\n      poses[4][1],\n      poses[0][0],\n      poses[0][1]\n    );\n\n    if (length === clipPoses.length) {\n      return;\n    }\n  } else {\n    return;\n  }\n  const clipStyles = getClipStyles(moveable, clipPath, poses)!;\n  const clipStyle = `${clipType}(${clipStyles.join(splitter)})`;\n\n  triggerEvent(\n    moveable,\n    \"onClip\",\n    fillParams<OnClip>(moveable, e, {\n      clipEventType: \"added\",\n      clipType,\n      poses,\n      clipStyles,\n      clipStyle,\n      distX: 0,\n      distY: 0,\n      ...fillCSSObject(\n        {\n          clipPath: clipStyle,\n        },\n        e\n      ),\n    })\n  );\n}\nfunction removeClipPath(\n  moveable: MoveableManagerInterface<ClippableProps>,\n  e: any\n) {\n  const { clipPath, clipIndex } = e.datas;\n  const {\n    type: clipType,\n    poses: clipPoses,\n    splitter,\n  } = (clipPath as ReturnType<typeof getClipPath>)!;\n  const poses = clipPoses.map((pos) => pos.pos);\n  const length = poses.length;\n  if (clipType === \"polygon\") {\n    clipPoses.splice(clipIndex, 1);\n    poses.splice(clipIndex, 1);\n  } else if (clipType === \"inset\") {\n    if (clipIndex < 8) {\n      return;\n    }\n    removeRadiusPos(clipPoses, poses, clipIndex, 8, length);\n\n    if (length === clipPoses.length) {\n      return;\n    }\n  } else {\n    return;\n  }\n  const clipStyles = getClipStyles(moveable, clipPath, poses)!;\n  const clipStyle = `${clipType}(${clipStyles.join(splitter)})`;\n\n  triggerEvent(\n    moveable,\n    \"onClip\",\n    fillParams<OnClip>(moveable, e, {\n      clipEventType: \"removed\",\n      clipType,\n      poses,\n      clipStyles,\n      clipStyle,\n      distX: 0,\n      distY: 0,\n      ...fillCSSObject(\n        {\n          clipPath: clipStyle,\n        },\n        e\n      ),\n    })\n  );\n}\n/**\n * @namespace Moveable.Clippable\n * @description Whether to clip the target.\n */\n\nexport default {\n  name: \"clippable\",\n  props: [\n    \"clippable\",\n    \"defaultClipPath\",\n    \"customClipPath\",\n    \"keepRatio\",\n    \"clipRelative\",\n    \"clipArea\",\n    \"dragWithClip\",\n    \"clipTargetBounds\",\n    \"clipVerticalGuidelines\",\n    \"clipHorizontalGuidelines\",\n    \"clipSnapThreshold\",\n  ] as const,\n  events: [\"clipStart\", \"clip\", \"clipEnd\"] as const,\n  css: [\n    `.control.clip-control {\nbackground: #6d6;\ncursor: pointer;\n}\n.control.clip-control.clip-radius {\nbackground: #d66;\n}\n.line.clip-line {\nbackground: #6e6;\ncursor: move;\nz-index: 1;\n}\n.clip-area {\nposition: absolute;\ntop: 0;\nleft: 0;\n}\n.clip-ellipse {\nposition: absolute;\ncursor: move;\nborder: 1px solid #6d6;\nborder: var(--zoompx) solid #6d6;\nborder-radius: 50%;\ntransform-origin: 0px 0px;\n}`,\n    `:host {\n--bounds-color: #d66;\n}`,\n    `.guideline {\npointer-events: none;\nz-index: 2;\n}`,\n    `.line.guideline.bounds {\nbackground: #d66;\nbackground: var(--bounds-color);\n}`,\n  ],\n  render(\n    moveable: MoveableManagerInterface<ClippableProps, ClippableState>,\n    React: Renderer\n  ): any[] {\n    const { customClipPath, defaultClipPath, clipArea, zoom, groupable } =\n      moveable.props;\n    const {\n      target,\n      width,\n      height,\n      allMatrix,\n      is3d,\n      left,\n      top,\n      pos1,\n      pos2,\n      pos3,\n      pos4,\n      clipPathState,\n      snapBoundInfos,\n      rotation: rotationRad,\n    } = moveable.getState();\n\n    if (!target || groupable) {\n      return [];\n    }\n\n    const clipPath = getClipPath(\n      target,\n      width,\n      height,\n      defaultClipPath || \"inset\",\n      clipPathState || customClipPath\n    );\n\n    if (!clipPath) {\n      return [];\n    }\n    const n = is3d ? 4 : 3;\n    const type = clipPath.type;\n    const clipPoses = clipPath.poses;\n    const poses = clipPoses.map((pos) => {\n      // return [x, y];\n      const calculatedPos = calculatePosition(allMatrix, pos.pos, n);\n\n      return [calculatedPos[0] - left, calculatedPos[1] - top];\n    });\n\n    let controls: any[] = [];\n    let lines: any[] = [];\n\n    const isRect = type === \"rect\";\n    const isInset = type === \"inset\";\n    const isPolygon = type === \"polygon\";\n\n    if (isRect || isInset || isPolygon) {\n      const linePoses = isInset ? poses.slice(0, 8) : poses;\n\n      lines = linePoses.map((to, i) => {\n        const from =\n          i === 0 ? linePoses[linePoses.length - 1] : linePoses[i - 1];\n\n        const rad = getRad(from, to);\n        const dist = getDiagonalSize(from, to);\n        return (\n          <div\n            key={`clipLine${i}`}\n            className={prefix(\"line\", \"clip-line\", \"snap-control\")}\n            data-clip-index={i}\n            style={{\n              width: `${dist}px`,\n              transform: `translate(${from[0]}px, ${from[1]}px) rotate(${rad}rad) scaleY(${zoom})`,\n            }}\n          ></div>\n        );\n      });\n    }\n    controls = poses.map((pos, i) => {\n      return (\n        <div\n          key={`clipControl${i}`}\n          className={prefix(\"control\", \"clip-control\", \"snap-control\")}\n          data-clip-index={i}\n          style={{\n            transform: `translate(${pos[0]}px, ${pos[1]}px) rotate(${rotationRad}rad) scale(${zoom})`,\n          }}\n        ></div>\n      );\n    });\n\n    if (isInset) {\n      controls.push(\n        ...poses.slice(8).map((pos, i) => {\n          return (\n            <div\n              key={`clipRadiusControl${i}`}\n              className={prefix(\n                \"control\",\n                \"clip-control\",\n                \"clip-radius\",\n                \"snap-control\"\n              )}\n              data-clip-index={8 + i}\n              style={{\n                transform: `translate(${pos[0]}px, ${pos[1]}px) rotate(${rotationRad}rad) scale(${zoom})`,\n              }}\n            ></div>\n          );\n        })\n      );\n    }\n    if (type === \"circle\" || type === \"ellipse\") {\n      const { left: clipLeft, top: clipTop, radiusX, radiusY } = clipPath;\n\n      const [distLeft, distTop] = minus(\n        calculatePosition(allMatrix, [clipLeft!, clipTop!], n),\n        calculatePosition(allMatrix, [0, 0], n)\n      );\n      let ellipseClipPath = \"none\";\n\n      if (!clipArea) {\n        const piece = Math.max(10, radiusX! / 5, radiusY! / 5);\n        const areaPoses: number[][] = [];\n\n        for (let i = 0; i <= piece; ++i) {\n          const rad = ((Math.PI * 2) / piece) * i;\n          areaPoses.push([\n            radiusX! + (radiusX! - zoom!) * Math.cos(rad),\n            radiusY! + (radiusY! - zoom!) * Math.sin(rad),\n          ]);\n        }\n        areaPoses.push([radiusX!, -2]);\n        areaPoses.push([-2, -2]);\n        areaPoses.push([-2, radiusY! * 2 + 2]);\n        areaPoses.push([radiusX! * 2 + 2, radiusY! * 2 + 2]);\n        areaPoses.push([radiusX! * 2 + 2, -2]);\n        areaPoses.push([radiusX!, -2]);\n\n        ellipseClipPath = `polygon(${areaPoses\n          .map((pos) => `${pos[0]}px ${pos[1]}px`)\n          .join(\", \")})`;\n      }\n      controls.push(\n        <div\n          key=\"clipEllipse\"\n          className={prefix(\"clip-ellipse\", \"snap-control\")}\n          style={{\n            width: `${radiusX! * 2}px`,\n            height: `${radiusY! * 2}px`,\n            clipPath: ellipseClipPath,\n            transform: `translate(${-left + distLeft}px, ${\n              -top + distTop\n            }px) ${makeMatrixCSS(allMatrix)}`,\n          }}\n        ></div>\n      );\n    }\n    if (clipArea) {\n      const {\n        width: allWidth,\n        height: allHeight,\n        left: allLeft,\n        top: allTop,\n      } = getRect([pos1, pos2, pos3, pos4, ...poses]);\n      if (isPolygon || isRect || isInset) {\n        const areaPoses = isInset ? poses.slice(0, 8) : poses;\n        controls.push(\n          <div\n            key=\"clipArea\"\n            className={prefix(\"clip-area\", \"snap-control\")}\n            style={{\n              width: `${allWidth}px`,\n              height: `${allHeight}px`,\n              transform: `translate(${allLeft}px, ${allTop}px)`,\n              clipPath: `polygon(${areaPoses\n                .map((pos) => `${pos[0] - allLeft}px ${pos[1] - allTop}px`)\n                .join(\", \")})`,\n            }}\n          ></div>\n        );\n      }\n    }\n    if (snapBoundInfos) {\n      ([\"vertical\", \"horizontal\"] as const).forEach((directionType) => {\n        const info = snapBoundInfos[directionType];\n        const isHorizontal = directionType === \"horizontal\";\n\n        if (info.isSnap) {\n          lines.push(\n            ...info.snap.posInfos.map(({ pos }, i) => {\n              const snapPos1 = minus(\n                calculatePosition(\n                  allMatrix,\n                  isHorizontal ? [0, pos] : [pos, 0],\n                  n\n                ),\n                [left, top]\n              );\n              const snapPos2 = minus(\n                calculatePosition(\n                  allMatrix,\n                  isHorizontal ? [width, pos] : [pos, height],\n                  n\n                ),\n                [left, top]\n              );\n\n              return renderLine(\n                React,\n                \"\",\n                snapPos1,\n                snapPos2,\n                zoom!,\n                `clip${directionType}snap${i}`,\n                \"guideline\"\n              );\n            })\n          );\n        }\n        if (info.isBound) {\n          lines.push(\n            ...info.bounds.map(({ pos }, i) => {\n              const snapPos1 = minus(\n                calculatePosition(\n                  allMatrix,\n                  isHorizontal ? [0, pos] : [pos, 0],\n                  n\n                ),\n                [left, top]\n              );\n              const snapPos2 = minus(\n                calculatePosition(\n                  allMatrix,\n                  isHorizontal ? [width, pos] : [pos, height],\n                  n\n                ),\n                [left, top]\n              );\n\n              return renderLine(\n                React,\n                \"\",\n                snapPos1,\n                snapPos2,\n                zoom!,\n                `clip${directionType}bounds${i}`,\n                \"guideline\",\n                \"bounds\",\n                \"bold\"\n              );\n            })\n          );\n        }\n      });\n    }\n    return [...controls, ...lines];\n  },\n  dragControlCondition(moveable: any, e: any) {\n    return (\n      e.inputEvent &&\n      (e.inputEvent.target.getAttribute(\"class\") || \"\").indexOf(\"clip\") > -1\n    );\n  },\n  dragStart(\n    moveable: MoveableManagerInterface<ClippableProps, ClippableState>,\n    e: any\n  ) {\n    const props = moveable.props;\n    const { dragWithClip = true } = props;\n\n    if (dragWithClip) {\n      return false;\n    }\n\n    return this.dragControlStart(moveable, e);\n  },\n  drag(\n    moveable: MoveableManagerInterface<ClippableProps, ClippableState>,\n    e: any\n  ) {\n    return this.dragControl(moveable, { ...e, isDragTarget: true });\n  },\n  dragEnd(\n    moveable: MoveableManagerInterface<ClippableProps, ClippableState>,\n    e: any\n  ) {\n    return this.dragControlEnd(moveable, e);\n  },\n  dragControlStart(\n    moveable: MoveableManagerInterface<ClippableProps, ClippableState>,\n    e: any\n  ) {\n    const state = moveable.state;\n    const { defaultClipPath, customClipPath } = moveable.props;\n    const { target, width, height } = state;\n    const inputTarget = e.inputEvent ? e.inputEvent.target : null;\n    const className = (inputTarget && inputTarget.getAttribute(\"class\")) || \"\";\n    const datas = e.datas;\n    const clipPath = getClipPath(\n      target!,\n      width,\n      height,\n      defaultClipPath || \"inset\",\n      customClipPath\n    );\n\n    if (!clipPath) {\n      return false;\n    }\n    const { clipText, type, poses } = clipPath;\n    const result = triggerEvent(\n      moveable,\n      \"onClipStart\",\n      fillParams<OnClipStart>(moveable, e, {\n        clipType: type,\n        clipStyle: clipText,\n        poses: poses.map((pos) => pos.pos),\n      })\n    );\n\n    if (result === false) {\n      datas.isClipStart = false;\n      return false;\n    }\n    datas.isControl = className && className.indexOf(\"clip-control\") > -1;\n    datas.isLine = className.indexOf(\"clip-line\") > -1;\n    datas.isArea =\n      className.indexOf(\"clip-area\") > -1 ||\n      className.indexOf(\"clip-ellipse\") > -1;\n    datas.clipIndex = inputTarget\n      ? parseInt(inputTarget.getAttribute(\"data-clip-index\"), 10)\n      : -1;\n    datas.clipPath = clipPath;\n    datas.isClipStart = true;\n    state.clipPathState = clipText;\n    setDragStart(moveable, e);\n\n    return true;\n  },\n  dragControl(\n    moveable: MoveableManagerInterface<\n      ClippableProps & DraggableProps,\n      ClippableState\n    >,\n    e: any\n  ) {\n    const { datas, originalDatas, isDragTarget } = e;\n\n    if (!datas.isClipStart) {\n      return false;\n    }\n    const { isControl, isLine, isArea, clipIndex, clipPath } = datas as {\n      clipPath: ReturnType<typeof getClipPath>;\n      [key: string]: any;\n    };\n    if (!clipPath) {\n      return false;\n    }\n    const props = getProps(moveable.props, \"clippable\");\n\n    const { keepRatio } = props;\n    let distX = 0;\n    let distY = 0;\n\n    const originalDraggable = originalDatas.draggable;\n    const originalDist = getDragDist(e);\n\n    if (isDragTarget && originalDraggable) {\n      [distX, distY] = originalDraggable.prevBeforeDist;\n    } else {\n      [distX, distY] = originalDist;\n    }\n\n    const firstDist = [distX, distY];\n\n    const state = moveable.state;\n    const { width, height } = state;\n    const isDragWithTarget = !isArea && !isControl && !isLine;\n    const { type: clipType, poses: clipPoses, splitter } = clipPath;\n    const poses = clipPoses.map((pos) => pos.pos);\n\n    if (isDragWithTarget) {\n      distX = -distX;\n      distY = -distY;\n    }\n    const isAll = !isControl || clipPoses[clipIndex].direction === \"nesw\";\n    const isRect = clipType === \"inset\" || clipType === \"rect\";\n    let dists = clipPoses.map(() => [0, 0]);\n\n    if (isControl && !isAll) {\n      const { horizontal, vertical } = clipPoses[clipIndex];\n      const dist = [distX * abs(horizontal), distY * abs(vertical)];\n      dists = moveControlPos(clipPoses, clipIndex, dist, isRect, keepRatio);\n    } else if (isAll) {\n      dists = poses.map(() => [distX, distY]);\n    }\n    const nextPoses: number[][] = poses.map((pos, i) => plus(pos, dists[i]));\n    const guidePoses = [...nextPoses];\n\n    state.snapBoundInfos = null;\n    const isCircle = clipPath.type === \"circle\";\n    const isEllipse = clipPath.type === \"ellipse\";\n\n    if (isCircle || isEllipse) {\n      const guideRect = getRect(nextPoses);\n      const ry = abs(guideRect.bottom - guideRect.top);\n      const rx = abs(isEllipse ? guideRect.right - guideRect.left : ry);\n      const bottom = nextPoses[0][1] + ry;\n      const left = nextPoses[0][0] - rx;\n      const right = nextPoses[0][0] + rx;\n\n      // right\n      if (isCircle) {\n        guidePoses.push([right, guideRect.bottom]);\n        dists.push([1, 0]);\n      }\n      // bottom\n      guidePoses.push([guideRect.left, bottom]);\n      dists.push([0, 1]);\n      // left\n      guidePoses.push([left, guideRect.bottom]);\n      dists.push([1, 0]);\n    }\n\n    const guidelines = getDefaultGuidelines(\n      (props.clipHorizontalGuidelines || []).map((v) =>\n        convertUnitSize(`${v}`, height)\n      ),\n      (props.clipVerticalGuidelines || []).map((v) =>\n        convertUnitSize(`${v}`, width)\n      ),\n      width!,\n      height!\n    );\n    let guideXPoses: number[] = [];\n    let guideYPoses: number[] = [];\n\n    if (isCircle || isEllipse) {\n      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];\n      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];\n    } else if (isRect) {\n      const rectPoses = [\n        guidePoses[0],\n        guidePoses[2],\n        guidePoses[4],\n        guidePoses[6],\n      ];\n      const rectDists = [dists[0], dists[2], dists[4], dists[6]];\n\n      guideXPoses = rectPoses\n        .filter((_, i) => rectDists[i][0])\n        .map((pos) => pos[0]);\n      guideYPoses = rectPoses\n        .filter((_, i) => rectDists[i][1])\n        .map((pos) => pos[1]);\n    } else {\n      guideXPoses = guidePoses\n        .filter((_, i) => dists[i][0])\n        .map((pos) => pos[0]);\n      guideYPoses = guidePoses\n        .filter((_, i) => dists[i][1])\n        .map((pos) => pos[1]);\n    }\n    const boundDelta = [0, 0];\n    const { horizontal: horizontalSnapInfo, vertical: verticalSnapInfo } =\n      checkSnapBounds(\n        guidelines,\n        props.clipTargetBounds && {\n          left: 0,\n          top: 0,\n          right: width,\n          bottom: height,\n        },\n        guideXPoses,\n        guideYPoses,\n        5,\n        5\n      );\n    let snapOffsetY = horizontalSnapInfo.offset;\n    let snapOffsetX = verticalSnapInfo.offset;\n\n    if (horizontalSnapInfo.isBound) {\n      boundDelta[1] += snapOffsetY;\n    }\n    if (verticalSnapInfo.isBound) {\n      boundDelta[0] += snapOffsetX;\n    }\n    if ((isEllipse || isCircle) && dists[0][0] === 0 && dists[0][1] === 0) {\n      const guideRect = getRect(nextPoses);\n      let cy = guideRect.bottom - guideRect.top;\n      let cx = isEllipse ? guideRect.right - guideRect.left : cy;\n\n      const distSnapX = verticalSnapInfo.isBound\n        ? abs(snapOffsetX)\n        : verticalSnapInfo.snapIndex === 0\n        ? -snapOffsetX\n        : snapOffsetX;\n      const distSnapY = horizontalSnapInfo.isBound\n        ? abs(snapOffsetY)\n        : horizontalSnapInfo.snapIndex === 0\n        ? -snapOffsetY\n        : snapOffsetY;\n      cx -= distSnapX;\n      cy -= distSnapY;\n\n      if (isCircle) {\n        cy =\n          checkSnapBoundPriority(verticalSnapInfo, horizontalSnapInfo) > 0\n            ? cy\n            : cx;\n        cx = cy;\n      }\n      const center = guidePoses[0];\n\n      guidePoses[1][1] = center[1] - cy;\n      guidePoses[2][0] = center[0] + cx;\n      guidePoses[3][1] = center[1] + cy;\n      guidePoses[4][0] = center[0] - cx;\n    } else if (isRect && keepRatio && isControl) {\n      const [width, height] = getControlSize(clipPoses);\n      const ratio = width && height ? width / height : 0;\n      const clipPose = clipPoses[clipIndex];\n      const direction = clipPose.direction! || \"\";\n      let top = guidePoses[1][1];\n      let bottom = guidePoses[5][1];\n      let left = guidePoses[7][0];\n      let right = guidePoses[3][0];\n\n      if (abs(snapOffsetY) <= abs(snapOffsetX)) {\n        snapOffsetY = (sign(snapOffsetY) * abs(snapOffsetX)) / ratio;\n      } else {\n        snapOffsetX = sign(snapOffsetX) * abs(snapOffsetY) * ratio;\n      }\n      if (direction!.indexOf(\"w\") > -1) {\n        left -= snapOffsetX;\n      } else if (direction!.indexOf(\"e\") > -1) {\n        right -= snapOffsetX;\n      } else {\n        left += snapOffsetX / 2;\n        right -= snapOffsetX / 2;\n      }\n      if (direction!.indexOf(\"n\") > -1) {\n        top -= snapOffsetY;\n      } else if (direction!.indexOf(\"s\") > -1) {\n        bottom -= snapOffsetY;\n      } else {\n        top += snapOffsetY / 2;\n        bottom -= snapOffsetY / 2;\n      }\n      const nextControlPoses = getRectPoses(top, right, bottom, left);\n\n      guidePoses.forEach((pos, i) => {\n        [pos[0], pos[1]] = nextControlPoses[i].pos;\n      });\n    } else {\n      guidePoses.forEach((pos, j) => {\n        const dist = dists[j];\n\n        if (dist[0]) {\n          pos[0] -= snapOffsetX;\n        }\n        if (dist[1]) {\n          pos[1] -= snapOffsetY;\n        }\n      });\n    }\n    const nextClipStyles = getClipStyles(moveable, clipPath, nextPoses)!;\n    const clipStyle = `${clipType}(${nextClipStyles.join(splitter)})`;\n\n    state.clipPathState = clipStyle;\n\n    if (isCircle || isEllipse) {\n      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];\n      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];\n    } else if (isRect) {\n      const rectPoses = [\n        guidePoses[0],\n        guidePoses[2],\n        guidePoses[4],\n        guidePoses[6],\n      ];\n\n      guideXPoses = rectPoses.map((pos) => pos[0]);\n      guideYPoses = rectPoses.map((pos) => pos[1]);\n    } else {\n      guideXPoses = guidePoses.map((pos) => pos[0]);\n      guideYPoses = guidePoses.map((pos) => pos[1]);\n    }\n    state.snapBoundInfos = checkSnapBounds(\n      guidelines,\n      props.clipTargetBounds && {\n        left: 0,\n        top: 0,\n        right: width,\n        bottom: height,\n      },\n      guideXPoses,\n      guideYPoses,\n      1,\n      1\n    );\n\n    if (originalDraggable) {\n      const { is3d, allMatrix } = state;\n      const n = is3d ? 4 : 3;\n\n      let dragDist = boundDelta;\n\n      if (isDragTarget) {\n        dragDist = [\n          firstDist[0] + boundDelta[0] - originalDist[0],\n          firstDist[1] + boundDelta[1] - originalDist[1],\n        ];\n      }\n      originalDraggable.deltaOffset = multiply(\n        allMatrix,\n        [dragDist[0], dragDist[1], 0, 0],\n        n\n      );\n    }\n    triggerEvent(\n      moveable,\n      \"onClip\",\n      fillParams<OnClip>(moveable, e, {\n        clipEventType: \"changed\",\n        clipType,\n        poses: nextPoses,\n        clipStyle,\n        clipStyles: nextClipStyles,\n        distX,\n        distY,\n        ...fillCSSObject(\n          {\n            [clipType === \"rect\" ? \"clip\" : \"clipPath\"]: clipStyle,\n          },\n          e\n        ),\n      })\n    );\n\n    return true;\n  },\n  dragControlEnd(\n    moveable: MoveableManagerInterface<ClippableProps, ClippableState>,\n    e: any\n  ) {\n    this.unset(moveable);\n    const { isDrag, datas, isDouble } = e;\n    const { isLine, isClipStart, isControl } = datas;\n\n    if (!isClipStart) {\n      return false;\n    }\n    triggerEvent(\n      moveable,\n      \"onClipEnd\",\n      fillEndParams<OnClipEnd>(moveable, e, {})\n    );\n    if (isDouble) {\n      if (isControl) {\n        removeClipPath(moveable, e);\n      } else if (isLine) {\n        // add\n        addClipPath(moveable, e);\n      }\n    }\n    return isDouble || isDrag;\n  },\n  unset(moveable: MoveableManagerInterface<ClippableProps, ClippableState>) {\n    moveable.state.clipPathState = \"\";\n    moveable.state.snapBoundInfos = null;\n  },\n};\n\n/**\n * Whether to clip the target. (default: false)\n * @name Moveable.Clippable#clippable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n *  If clippath is not set, the default value can be set. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#defaultClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (`rect` not possible) (default: false)\n * @name Moveable.Clippable#clipRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can force the custom clipPath. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#customClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When dragging the target, the clip also moves. (default: true)\n * @name Moveable.Clippable#dragWithClip\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can drag the clip by setting clipArea.\n * @name Moveable.Clippable#clipArea\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * Whether the clip is bound to the target.\n * @name Moveable.Clippable#clipTargetBounds\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n *     clipTargetBounds: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * Add clip guidelines in the vertical direction.\n * @name Moveable.Clippable#clipVerticalGuidelines\n * @default 0\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n *     clipVerticalGuidelines: [0, 100, 200],\n *     clipHorizontalGuidelines: [0, 100, 200],\n *     clipSnapThreshold: 5,\n * });\n */\n\n/**\n * Add clip guidelines in the horizontal direction.\n * @name Moveable.Clippable#clipHorizontalGuidelines\n * @default []\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n *     clipVerticalGuidelines: [0, 100, 200],\n *     clipHorizontalGuidelines: [0, 100, 200],\n *     clipSnapThreshold: 5,\n * });\n */\n/**\n * istance value that can snap to clip guidelines.\n * @name Moveable.Clippable#clipSnapThreshold\n * @default 5\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n *     clipVerticalGuidelines: [0, 100, 200],\n *     clipHorizontalGuidelines: [0, 100, 200],\n *     clipSnapThreshold: 5,\n * });\n */\n/**\n * When drag start the clip area or controls, the `clipStart` event is called.\n * @memberof Moveable.Clippable\n * @event clipStart\n * @param {Moveable.Clippable.OnClipStart} - Parameters for the `clipStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag the clip area or controls, the `clip` event is called.\n * @memberof Moveable.Clippable\n * @event clip\n * @param {Moveable.Clippable.OnClip} - Parameters for the `clip` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag end the clip area or controls, the `clipEnd` event is called.\n * @memberof Moveable.Clippable\n * @event clipEnd\n * @param {Moveable.Clippable.OnClipEnd} - Parameters for the `clipEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n","import {\n  prefix,\n  triggerEvent,\n  fillParams,\n  calculatePoses,\n  getRect,\n  fillEndParams,\n  convertCSSSize,\n  fillCSSObject,\n} from \"../utils\";\nimport {\n  OnDragOriginStart,\n  OnDragOrigin,\n  OnDragOriginEnd,\n  MoveableManagerInterface,\n  DraggableProps,\n  OriginDraggableProps,\n  MoveableGroupInterface,\n} from \"../types\";\nimport { hasClass, IObject } from \"../../utility\";\nimport { setDragStart, getDragDist, getNextMatrix } from \"../gesto/gesto-utils\";\nimport { minus, plus } from \"../../matrix\";\nimport Draggable from \"./draggable\";\nimport CustomGesto, { setCustomDrag } from \"../gesto/custom-gesto\";\n\n/**\n * @namespace OriginDraggable\n * @memberof Moveable\n * @description Whether to drag origin (default: false)\n */\nexport default {\n  name: \"originDraggable\",\n  props: [\"originDraggable\", \"originRelative\"] as const,\n  events: [\"dragOriginStart\", \"dragOrigin\", \"dragOriginEnd\"] as const,\n  css: [\n    `:host[data-able-origindraggable] .control.origin {\npointer-events: auto;\n}`,\n  ],\n  dragControlCondition(_: any, e: any) {\n    if (e.isRequest) {\n      return e.requestAble === \"originDraggable\";\n    }\n    return hasClass(e.inputEvent.target, prefix(\"origin\"));\n  },\n  dragControlStart(\n    moveable: MoveableManagerInterface<OriginDraggableProps & DraggableProps>,\n    e: any\n  ) {\n    const { datas } = e;\n\n    setDragStart(moveable, e);\n\n    const params = fillParams<OnDragOriginStart>(moveable, e, {\n      dragStart: Draggable.dragStart(\n        moveable,\n        new CustomGesto().dragStart([0, 0], e)\n      ),\n    });\n    const result = triggerEvent(moveable, \"onDragOriginStart\", params);\n\n    datas.startOrigin = moveable.state.transformOrigin;\n    datas.startTargetOrigin = moveable.state.targetOrigin;\n    datas.prevOrigin = [0, 0];\n    datas.isDragOrigin = true;\n\n    if (result === false) {\n      datas.isDragOrigin = false;\n      return false;\n    }\n\n    return params;\n  },\n  dragControl(\n    moveable: MoveableManagerInterface<OriginDraggableProps & DraggableProps>,\n    e: any\n  ) {\n    const { datas, isPinch, isRequest } = e;\n\n    if (!datas.isDragOrigin) {\n      return false;\n    }\n    const [distX, distY] = getDragDist(e);\n    const state = moveable.state;\n    const { width, height, offsetMatrix, targetMatrix, is3d } = state;\n    const { originRelative = true } = moveable.props;\n    const n = is3d ? 4 : 3;\n    let dist = [distX, distY];\n\n    if (isRequest) {\n      const distOrigin = e.distOrigin;\n      if (distOrigin[0] || distOrigin[1]) {\n        dist = distOrigin;\n      }\n    }\n    const origin = plus(datas.startOrigin, dist);\n    const targetOrigin = plus(datas.startTargetOrigin, dist);\n    const delta = minus(dist, datas.prevOrigin);\n\n    const nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, origin, n);\n\n    const rect = moveable.getRect();\n    const nextRect = getRect(calculatePoses(nextMatrix, width, height, n));\n\n    const dragDelta = [rect.left - nextRect.left, rect.top - nextRect.top];\n\n    datas.prevOrigin = dist;\n    const transformOrigin = [\n      convertCSSSize(targetOrigin[0], width, originRelative),\n      convertCSSSize(targetOrigin[1], height, originRelative),\n    ].join(\" \");\n    const result = Draggable.drag(\n      moveable,\n      setCustomDrag(e, moveable.state, dragDelta, !!isPinch, false)\n    )!;\n    const params = fillParams<OnDragOrigin>(moveable, e, {\n      width,\n      height,\n      origin,\n      dist,\n      delta,\n      transformOrigin,\n      drag: result,\n      ...fillCSSObject(\n        {\n          transformOrigin,\n          transform: result.transform,\n        },\n        e\n      ),\n      afterTransform: result.transform,\n    });\n    triggerEvent(moveable, \"onDragOrigin\", params);\n    return params;\n  },\n  dragControlEnd(\n    moveable: MoveableManagerInterface<OriginDraggableProps>,\n    e: any\n  ) {\n    const { datas } = e;\n\n    if (!datas.isDragOrigin) {\n      return false;\n    }\n    triggerEvent(\n      moveable,\n      \"onDragOriginEnd\",\n      fillEndParams<OnDragOriginEnd>(moveable, e, {})\n    );\n    return true;\n  },\n  dragGroupControlCondition(moveable: any, e: any) {\n    return this.dragControlCondition(moveable, e);\n  },\n  dragGroupControlStart(\n    moveable: MoveableGroupInterface<OriginDraggableProps>,\n    e: any\n  ) {\n    const params = this.dragControlStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    return true;\n  },\n  dragGroupControl(\n    moveable: MoveableGroupInterface<OriginDraggableProps>,\n    e: any\n  ) {\n    const params = this.dragControl(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n    moveable.transformOrigin = params.transformOrigin;\n\n    return true;\n  },\n  /**\n    * @method Moveable.OriginDraggable#request\n    * @param {object} e - the OriginDraggable's request parameter\n    * @param {number} [e.x] - x position\n    * @param {number} [e.y] - y position\n    * @param {number} [e.deltaX] - x number to move\n    * @param {number} [e.deltaY] - y number to move\n    * @param {array} [e.deltaOrigin] - left, top number to move transform-origin\n    * @param {array} [e.origin] - transform-origin position\n    * @param {number} [e.isInstant] - Whether to execute the request instantly\n    * @return {Moveable.Requester} Moveable Requester\n    * @example\n\n    * // Instantly Request (requestStart - request - requestEnd)\n    * // Use Relative Value\n    * moveable.request(\"originDraggable\", { deltaX: 10, deltaY: 10 }, true);\n    * // Use Absolute Value\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 }, true);\n    * // Use Transform Value\n    * moveable.request(\"originDraggable\", { deltaOrigin: [10, 0] }, true);\n    * moveable.request(\"originDraggable\", { origin: [100, 0] }, true);\n    * // requestStart\n    * const requester = moveable.request(\"originDraggable\");\n    *\n    * // request\n    * // Use Relative Value\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * // Use Absolute Value\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 });\n    * moveable.request(\"originDraggable\", { x: 220, y: 100 });\n    * moveable.request(\"originDraggable\", { x: 240, y: 100 });\n    *\n    * // requestEnd\n    * requester.requestEnd();\n    */\n  request(moveable: MoveableManagerInterface<any, any>) {\n    const datas = {};\n    const rect = moveable.getRect();\n    let distX = 0;\n    let distY = 0;\n\n    const transformOrigin = rect.transformOrigin;\n    const distOrigin = [0, 0];\n\n    return {\n      isControl: true,\n      requestStart() {\n        return { datas };\n      },\n      request(e: IObject<any>) {\n        if (\"deltaOrigin\" in e) {\n          distOrigin[0] += e.deltaOrigin[0];\n          distOrigin[1] += e.deltaOrigin[1];\n        } else if (\"origin\" in e) {\n          distOrigin[0] = e.origin[0] - transformOrigin[0];\n          distOrigin[1] = e.origin[1] - transformOrigin[1];\n        } else {\n          if (\"x\" in e) {\n            distX = e.x - rect.left;\n          } else if (\"deltaX\" in e) {\n            distX += e.deltaX;\n          }\n          if (\"y\" in e) {\n            distY = e.y - rect.top;\n          } else if (\"deltaY\" in e) {\n            distY += e.deltaY;\n          }\n        }\n\n        return { datas, distX, distY, distOrigin };\n      },\n      requestEnd() {\n        return { datas, isDrag: true };\n      },\n    };\n  },\n};\n/**\n * Whether to drag origin (default: false)\n * @name Moveable.OriginDraggable#originDraggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n * });\n * let translate = [0, 0];\n * moveable.on(\"dragOriginStart\", e => {\n *     e.dragStart && e.dragStart.set(translate);\n * }).on(\"dragOrigin\", e => {\n *     translate = e.drag.beforeTranslate;\n *     e.target.style.cssText\n *         = `transform-origin: ${e.transformOrigin};`\n *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n * }).on(\"dragOriginEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (default: true)\n * @name Moveable.OriginDraggable#originRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n *     originRelative: false,\n * });\n * moveable.originRelative = true;\n */\n\n/**\n * When drag start the origin, the `dragOriginStart` event is called.\n * @memberof Moveable.OriginDraggable\n * @event dragOriginStart\n * @param {Moveable.OriginDraggable.OnDragOriginStart} - Parameters for the `dragOriginStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n * });\n * let translate = [0, 0];\n * moveable.on(\"dragOriginStart\", e => {\n *     e.dragStart && e.dragStart.set(translate);\n * }).on(\"dragOrigin\", e => {\n *     translate = e.drag.beforeTranslate;\n *     e.target.style.cssText\n *         = `transform-origin: ${e.transformOrigin};`\n *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n * }).on(\"dragOriginEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag the origin, the `dragOrigin` event is called.\n * @memberof Moveable.OriginDraggable\n * @event dragOrigin\n * @param {Moveable.OriginDraggable.OnDragOrigin} - Parameters for the `dragOrigin` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n * });\n * let translate = [0, 0];\n * moveable.on(\"dragOriginStart\", e => {\n *     e.dragStart && e.dragStart.set(translate);\n * }).on(\"dragOrigin\", e => {\n *     translate = e.drag.beforeTranslate;\n *     e.target.style.cssText\n *         = `transform-origin: ${e.transformOrigin};`\n *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n * }).on(\"dragOriginEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag end the origin, the `dragOriginEnd` event is called.\n * @memberof Moveable.OriginDraggable\n * @event dragOriginEnd\n * @param {Moveable.OriginDraggable.OnDragOriginEnd} - Parameters for the `dragOriginEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n * });\n * let translate = [0, 0];\n * moveable.on(\"dragOriginStart\", e => {\n *     e.dragStart && e.dragStart.set(translate);\n * }).on(\"dragOrigin\", e => {\n *     translate = e.drag.beforeTranslate;\n *     e.target.style.cssText\n *         = `transform-origin: ${e.transformOrigin};`\n *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n * }).on(\"dragOriginEnd\", e => {\n *     console.log(e);\n * });\n */\n","import {\n  prefix,\n  triggerEvent,\n  fillParams,\n  fillEndParams,\n  calculatePosition,\n  fillCSSObject,\n  catchEvent,\n  getComputedStyle,\n} from \"../utils\";\nimport {\n  Renderer,\n  RoundableProps,\n  OnRoundStart,\n  RoundableState,\n  OnRound,\n  ControlPose,\n  OnRoundEnd,\n  MoveableManagerInterface,\n  OnRoundGroup,\n  MoveableGroupInterface,\n  OnRoundGroupStart,\n  OnRoundGroupEnd,\n} from \"../types\";\nimport { splitSpace } from \"../../utility\";\nimport {\n  setDragStart,\n  getDragDist,\n  calculatePointerDist,\n} from \"../gesto/gesto-utils\";\nimport { minus, plus } from \"../../matrix\";\nimport {\n  getRadiusValues,\n  getRadiusStyles,\n  splitRadiusPoses,\n} from \"./roundable/border-radius\";\nimport { fillChildEvents } from \"../group-utils\";\n\nfunction addBorderRadiusByLine(\n  controlPoses: ControlPose[],\n  lineIndex: number,\n  distX: number,\n  distY: number\n) {\n  // lineIndex\n  // 0 top\n  // 1 right\n  // 2 bottom\n  // 3 left\n\n  const horizontalsLength = controlPoses.filter(\n    ({ virtual, horizontal }) => horizontal && !virtual\n  ).length;\n  const verticalsLength = controlPoses.filter(\n    ({ virtual, vertical }) => vertical && !virtual\n  ).length;\n  let controlIndex = -1;\n\n  //top\n  if (lineIndex === 0) {\n    if (horizontalsLength === 0) {\n      controlIndex = 0;\n    } else if (horizontalsLength === 1) {\n      controlIndex = 1;\n    }\n  }\n  // bottom\n  if (lineIndex === 2) {\n    if (horizontalsLength <= 2) {\n      controlIndex = 2;\n    } else if (horizontalsLength <= 3) {\n      controlIndex = 3;\n    }\n  }\n  // left\n  if (lineIndex === 3) {\n    if (verticalsLength === 0) {\n      controlIndex = 4;\n    } else if (verticalsLength < 4) {\n      controlIndex = 7;\n    }\n  }\n\n  // right\n  if (lineIndex === 1) {\n    if (verticalsLength <= 1) {\n      controlIndex = 5;\n    } else if (verticalsLength <= 2) {\n      controlIndex = 6;\n    }\n  }\n  if (controlIndex === -1 || !controlPoses[controlIndex].virtual) {\n    return;\n  }\n  const controlPoseInfo = controlPoses[controlIndex];\n\n  addBorderRadius(controlPoses, controlIndex);\n\n  if (controlIndex < 4) {\n    controlPoseInfo.pos[0] = distX;\n  } else {\n    controlPoseInfo.pos[1] = distY;\n  }\n}\nfunction addBorderRadius(controlPoses: ControlPose[], index: number) {\n  if (index < 4) {\n    controlPoses.slice(0, index + 1).forEach((info) => {\n      info.virtual = false;\n    });\n  } else {\n    if (controlPoses[0].virtual) {\n      controlPoses[0].virtual = false;\n    }\n    controlPoses.slice(4, index + 1).forEach((info) => {\n      info.virtual = false;\n    });\n  }\n}\nfunction removeBorderRadius(controlPoses: ControlPose[], index: number) {\n  if (index < 4) {\n    controlPoses.slice(index, 4).forEach((info) => {\n      info.virtual = true;\n    });\n  } else {\n    controlPoses.slice(index).forEach((info) => {\n      info.virtual = true;\n    });\n  }\n}\nfunction getBorderRadius(\n  borderRadius: string,\n  width: number,\n  height: number,\n  minCounts: number[] = [0, 0],\n  full?: boolean\n) {\n  let values: string[] = [];\n\n  if (!borderRadius || borderRadius === \"0px\") {\n    values = [];\n  } else {\n    values = splitSpace(borderRadius);\n  }\n\n  return getRadiusValues(values, width, height, 0, 0, minCounts, full);\n}\n\nfunction triggerRoundEvent(\n  moveable: MoveableManagerInterface<RoundableProps, RoundableState>,\n  e: any,\n  dist: number[],\n  delta: number[],\n  nextPoses: ControlPose[]\n) {\n  const state = moveable.state;\n  const { width, height } = state;\n  const { raws, styles, radiusPoses } = getRadiusStyles(\n    nextPoses,\n    moveable.props.roundRelative!,\n    width,\n    height\n  );\n  const { horizontals, verticals } = splitRadiusPoses(radiusPoses, raws);\n  const borderRadius = styles.join(\" \");\n\n  state.borderRadiusState = borderRadius;\n  const params = fillParams<OnRound>(moveable, e, {\n    horizontals,\n    verticals,\n    borderRadius,\n    width,\n    height,\n    delta,\n    dist,\n    ...fillCSSObject(\n      {\n        borderRadius,\n      },\n      e\n    ),\n  });\n  triggerEvent(moveable, \"onRound\", params);\n\n  return params;\n}\n\nfunction getStyleBorderRadius(\n  moveable: MoveableManagerInterface<RoundableProps, RoundableState>\n) {\n  const { style } = moveable.getState();\n  let borderRadius = style.borderRadius || \"\";\n\n  if (!borderRadius && moveable.props.groupable) {\n    const firstMoveable = moveable.moveables![0];\n    const firstTarget = moveable.getTargets()[0];\n\n    if (firstTarget) {\n      if (firstMoveable?.props.target === firstTarget) {\n        borderRadius = moveable.moveables![0]?.state.style.borderRadius ?? \"\";\n        style.borderRadius = borderRadius;\n      } else {\n        borderRadius = getComputedStyle(firstTarget).borderRadius;\n        style.borderRadius = borderRadius;\n      }\n    }\n  }\n  return borderRadius;\n}\n\n/**\n * @namespace Moveable.Roundable\n * @description Whether to show and drag or double click border-radius\n */\n\nexport default {\n  name: \"roundable\",\n  props: [\n    \"roundable\",\n    \"roundRelative\",\n    \"minRoundControls\",\n    \"maxRoundControls\",\n    \"roundClickable\",\n    \"roundPadding\",\n    \"isDisplayShadowRoundControls\",\n  ] as const,\n  events: [\n    \"roundStart\",\n    \"round\",\n    \"roundEnd\",\n    \"roundGroupStart\",\n    \"roundGroup\",\n    \"roundGroupEnd\",\n  ] as const,\n  css: [\n    `.control.border-radius {\nbackground: #d66;\ncursor: pointer;\nz-index: 3;\n}`,\n    `.control.border-radius.vertical {\nbackground: #d6d;\nz-index: 2;\n}`,\n    `.control.border-radius.virtual {\nopacity: 0.5;\nz-index: 1;\n}`,\n    `:host.round-line-clickable .line.direction {\ncursor: pointer;\n}`,\n  ],\n  className(\n    moveable: MoveableManagerInterface<RoundableProps, RoundableState>\n  ) {\n    const roundClickable = moveable.props.roundClickable;\n\n    return roundClickable === true || roundClickable === \"line\"\n      ? prefix(\"round-line-clickable\")\n      : \"\";\n  },\n  requestStyle(): Array<keyof CSSStyleDeclaration> {\n    return [\"borderRadius\"];\n  },\n  requestChildStyle(): Array<keyof CSSStyleDeclaration> {\n    return [\"borderRadius\"];\n  },\n  render(\n    moveable: MoveableManagerInterface<RoundableProps, RoundableState>,\n    React: Renderer\n  ): any {\n    const {\n      target,\n      width,\n      height,\n      allMatrix,\n      is3d,\n      left,\n      top,\n      borderRadiusState,\n    } = moveable.getState();\n\n    const {\n      minRoundControls = [0, 0],\n      maxRoundControls = [4, 4],\n      zoom,\n      roundPadding = 0,\n      isDisplayShadowRoundControls,\n      groupable,\n    } = moveable.props;\n\n    if (!target) {\n      return null;\n    }\n\n    const borderRadius = borderRadiusState || getStyleBorderRadius(moveable);\n    const n = is3d ? 4 : 3;\n    const radiusValues = getBorderRadius(\n      borderRadius,\n      width,\n      height,\n      minRoundControls,\n      true\n    );\n\n    if (!radiusValues) {\n      return null;\n    }\n    let verticalCount = 0;\n    let horizontalCount = 0;\n    const basePos = groupable ? [0, 0] : [left, top];\n\n    return radiusValues.map((v, i) => {\n      const horizontal = v.horizontal;\n      const vertical = v.vertical;\n      const direction = v.direction || \"\";\n      const originalPos = [...v.pos];\n\n      horizontalCount += Math.abs(horizontal);\n      verticalCount += Math.abs(vertical);\n\n      if (horizontal && direction.indexOf(\"n\") > -1) {\n        originalPos[1] -= roundPadding;\n      }\n      if (vertical && direction.indexOf(\"w\") > -1) {\n        originalPos[0] -= roundPadding;\n      }\n      if (horizontal && direction.indexOf(\"s\") > -1) {\n        originalPos[1] += roundPadding;\n      }\n      if (vertical && direction.indexOf(\"e\") > -1) {\n        originalPos[0] += roundPadding;\n      }\n      const pos = minus(calculatePosition(allMatrix, originalPos, n), basePos);\n      const isDisplayVerticalShadow =\n        isDisplayShadowRoundControls &&\n        isDisplayShadowRoundControls !== \"horizontal\";\n      const isDisplay = v.vertical\n        ? verticalCount <= maxRoundControls[1] &&\n          (isDisplayVerticalShadow || !v.virtual)\n        : horizontalCount <= maxRoundControls[0] &&\n          (isDisplayShadowRoundControls || !v.virtual);\n\n      return (\n        <div\n          key={`borderRadiusControl${i}`}\n          className={prefix(\n            \"control\",\n            \"border-radius\",\n            v.vertical ? \"vertical\" : \"\",\n            v.virtual ? \"virtual\" : \"\"\n          )}\n          data-radius-index={i}\n          style={{\n            display: isDisplay ? \"block\" : \"none\",\n            transform: `translate(${pos[0]}px, ${pos[1]}px) scale(${zoom})`,\n          }}\n        ></div>\n      );\n    });\n  },\n  dragControlCondition(moveable: any, e: any) {\n    if (!e.inputEvent || e.isRequest) {\n      return false;\n    }\n    const className = e.inputEvent.target.getAttribute(\"class\") || \"\";\n\n    return (\n      className.indexOf(\"border-radius\") > -1 ||\n      (className.indexOf(\"moveable-line\") > -1 &&\n        className.indexOf(\"moveable-direction\") > -1)\n    );\n  },\n  dragGroupControlCondition(moveable: any, e: any) {\n    return this.dragControlCondition(moveable, e);\n  },\n  dragControlStart(\n    moveable: MoveableManagerInterface<RoundableProps, RoundableState>,\n    e: any\n  ) {\n    const { inputEvent, datas } = e;\n    const inputTarget = inputEvent.target;\n    const className = inputTarget.getAttribute(\"class\") || \"\";\n    const isControl = className.indexOf(\"border-radius\") > -1;\n    const isLine =\n      className.indexOf(\"moveable-line\") > -1 &&\n      className.indexOf(\"moveable-direction\") > -1;\n    const controlIndex = isControl\n      ? parseInt(inputTarget.getAttribute(\"data-radius-index\"), 10)\n      : -1;\n    let lineIndex = -1;\n\n    if (isLine) {\n      const indexAttr = inputTarget.getAttribute(\"data-line-key\")! || \"\";\n\n      if (indexAttr) {\n        lineIndex = parseInt(indexAttr.replace(/render-line-/g, \"\"), 10);\n\n        if (isNaN(lineIndex)) {\n          lineIndex = -1;\n        }\n      }\n    }\n\n    if (!isControl && !isLine) {\n      return false;\n    }\n\n    const params = fillParams<OnRoundStart>(moveable, e, {});\n\n    const result = triggerEvent(moveable, \"onRoundStart\", params);\n\n    if (result === false) {\n      return false;\n    }\n\n    datas.lineIndex = lineIndex;\n    datas.controlIndex = controlIndex;\n    datas.isControl = isControl;\n    datas.isLine = isLine;\n\n    setDragStart(moveable, e);\n\n    const { roundRelative, minRoundControls = [0, 0] } = moveable.props;\n    const state = moveable.state;\n    const { width, height } = state;\n\n    datas.isRound = true;\n    datas.prevDist = [0, 0];\n    const borderRadius = getStyleBorderRadius(moveable);\n    const controlPoses =\n      getBorderRadius(\n        borderRadius || \"\",\n        width,\n        height,\n        minRoundControls,\n        true\n      ) || [];\n\n    datas.controlPoses = controlPoses;\n\n    state.borderRadiusState = getRadiusStyles(\n      controlPoses,\n      roundRelative!,\n      width,\n      height\n    ).styles.join(\" \");\n    return params;\n  },\n  dragControl(\n    moveable: MoveableManagerInterface<RoundableProps, RoundableState>,\n    e: any\n  ) {\n    const { datas } = e;\n    const controlPoses = datas.controlPoses as ControlPose[];\n\n    if (!datas.isRound || !datas.isControl || !controlPoses.length) {\n      return false;\n    }\n    const index = datas.controlIndex as number;\n\n    const [distX, distY] = getDragDist(e);\n    const dist = [distX, distY];\n    const delta = minus(dist, datas.prevDist);\n    const { maxRoundControls = [4, 4] } = moveable.props;\n    const { width, height } = moveable.state;\n    const selectedControlPose = controlPoses[index];\n\n    const selectedVertical = selectedControlPose.vertical;\n    const selectedHorizontal = selectedControlPose.horizontal;\n\n    // 0: [0, 1, 2, 3] maxCount === 1\n    // 0: [0, 2] maxCount === 2\n    // 1: [1, 3] maxCount === 2\n\n    // 0: [0] maxCount === 3\n    // 1: [1, 3] maxCount === 3\n\n    const dists = controlPoses.map((pose) => {\n      const { horizontal, vertical } = pose;\n      const poseDist = [\n        horizontal * selectedHorizontal * dist[0],\n        vertical * selectedVertical * dist[1],\n      ];\n      if (horizontal) {\n        if (maxRoundControls[0] === 1) {\n          return poseDist;\n        } else if (\n          maxRoundControls[0] < 4 &&\n          horizontal !== selectedHorizontal\n        ) {\n          return poseDist;\n        }\n      } else if (maxRoundControls[1] === 0) {\n        poseDist[1] =\n          ((vertical * selectedHorizontal * dist[0]) / width) * height;\n\n        return poseDist;\n      } else if (selectedVertical) {\n        if (maxRoundControls[1] === 1) {\n          return poseDist;\n        } else if (maxRoundControls[1] < 4 && vertical !== selectedVertical) {\n          return poseDist;\n        }\n      }\n      return [0, 0];\n    });\n\n    dists[index] = dist;\n    const nextPoses = controlPoses.map((info, i) => {\n      return {\n        ...info,\n        pos: plus(info.pos, dists[i]),\n      };\n    });\n\n    if (index < 4) {\n      nextPoses.slice(0, index + 1).forEach((info) => {\n        info.virtual = false;\n      });\n    } else {\n      nextPoses.slice(4, index + 1).forEach((info) => {\n        info.virtual = false;\n      });\n    }\n\n    datas.prevDist = [distX, distY];\n\n    return triggerRoundEvent(moveable, e, dist, delta, nextPoses);\n  },\n  dragControlEnd(\n    moveable: MoveableManagerInterface<RoundableProps, RoundableState>,\n    e: any\n  ) {\n    const state = moveable.state;\n\n    state.borderRadiusState = \"\";\n    const { datas, isDouble } = e;\n    if (!datas.isRound) {\n      return false;\n    }\n    const { isControl, controlIndex, isLine, lineIndex } = datas;\n    const controlPoses = datas.controlPoses as ControlPose[];\n    const length = controlPoses.filter(({ virtual }) => virtual).length;\n    const { roundClickable = true } = moveable.props;\n\n    if (isDouble && roundClickable) {\n      if (\n        isControl &&\n        (roundClickable === true || roundClickable === \"control\")\n      ) {\n        removeBorderRadius(controlPoses, controlIndex);\n      } else if (\n        isLine &&\n        (roundClickable === true || roundClickable === \"line\")\n      ) {\n        const [distX, distY] = calculatePointerDist(moveable, e);\n\n        addBorderRadiusByLine(controlPoses, lineIndex, distX, distY);\n      }\n\n      if (length !== controlPoses.filter(({ virtual }) => virtual).length) {\n        triggerRoundEvent(moveable, e, [0, 0], [0, 0], controlPoses);\n      }\n    }\n    const params = fillEndParams<OnRoundEnd>(moveable, e, {});\n\n    triggerEvent(moveable, \"onRoundEnd\", params);\n    state.borderRadiusState = \"\";\n    return params;\n  },\n  dragGroupControlStart(\n    moveable: MoveableGroupInterface<RoundableProps, RoundableState>,\n    e: any\n  ) {\n    const result = this.dragControlStart(moveable, e);\n\n    if (!result) {\n      return false;\n    }\n\n    const moveables = moveable.moveables;\n    const targets = moveable.props.targets!;\n    const events = fillChildEvents(moveable, \"roundable\", e);\n\n    const nextParams: OnRoundGroupStart = {\n      targets: moveable.props.targets!,\n      events: events.map((ev, i) => {\n        return {\n          ...ev,\n          target: targets[i],\n          moveable: moveables[i],\n          currentTarget: moveables[i],\n        };\n      }),\n      ...result,\n    };\n\n    triggerEvent(moveable, \"onRoundGroupStart\", nextParams);\n    return result;\n  },\n  dragGroupControl(\n    moveable: MoveableGroupInterface<RoundableProps, RoundableState>,\n    e: any\n  ) {\n    const result = this.dragControl(moveable, e);\n\n    if (!result) {\n      return false;\n    }\n\n    const moveables = moveable.moveables;\n    const targets = moveable.props.targets!;\n    const events = fillChildEvents(moveable, \"roundable\", e);\n\n    const nextParams: OnRoundGroup = {\n      targets: moveable.props.targets!,\n      events: events.map((ev, i) => {\n        return {\n          ...ev,\n          target: targets[i],\n          moveable: moveables[i],\n          currentTarget: moveables[i],\n          ...fillCSSObject(\n            {\n              borderRadius: result.borderRadius,\n            },\n            ev\n          ),\n        };\n      }),\n      ...result,\n    };\n\n    triggerEvent(moveable, \"onRoundGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd(\n    moveable: MoveableGroupInterface<RoundableProps, RoundableState>,\n    e: any\n  ) {\n    const moveables = moveable.moveables;\n    const targets = moveable.props.targets!;\n    const events = fillChildEvents(moveable, \"roundable\", e);\n\n    catchEvent(moveable, \"onRound\", (parentEvent) => {\n      const nextParams: OnRoundGroup = {\n        targets: moveable.props.targets!,\n        events: events.map((ev, i) => {\n          return {\n            ...ev,\n            target: targets[i],\n            moveable: moveables[i],\n            currentTarget: moveables[i],\n            ...fillCSSObject(\n              {\n                borderRadius: parentEvent.borderRadius,\n              },\n              ev\n            ),\n          };\n        }),\n        ...parentEvent,\n      };\n      triggerEvent(moveable, \"onRoundGroup\", nextParams);\n    });\n    const result = this.dragControlEnd(moveable, e);\n\n    if (!result) {\n      return false;\n    }\n    const nextParams: OnRoundGroupEnd = {\n      targets: moveable.props.targets!,\n      events: events.map((ev, i) => {\n        return {\n          ...ev,\n          target: targets[i],\n          moveable: moveables[i],\n          currentTarget: moveables[i],\n          lastEvent: ev.datas?.lastEvent,\n        };\n      }),\n      ...result,\n    };\n\n    triggerEvent(moveable, \"onRoundGroupEnd\", nextParams);\n    return nextParams;\n  },\n  unset(moveable: MoveableManagerInterface<RoundableProps, RoundableState>) {\n    moveable.state.borderRadiusState = \"\";\n  },\n};\n/**\n * Whether to show and drag or double click border-radius, (default: false)\n * @name Moveable.Roundable#roundable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * % Can be used instead of the absolute px\n * @name Moveable.Roundable#roundRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * Minimum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [0, 0])\n * @name Moveable.Roundable#minRoundControls\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     minRoundControls: [0, 0],\n * });\n * moveable.minRoundControls = [1, 0];\n */\n/**\n * Maximum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [4, 4])\n * @name Moveable.Roundable#maxRoundControls\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     maxRoundControls: [4, 4],\n * });\n * moveable.maxRoundControls = [1, 0];\n */\n/**\n * Whether you can add/delete round controls by double-clicking a line or control.\n * @name Moveable.Roundable#roundClickable\n * @default true\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     roundClickable: true,\n * });\n * moveable.roundClickable = false;\n */\n\n/**\n * Whether to show a round control that does not actually exist as a shadow\n * @name Moveable.Roundable#isDisplayShadowRoundControls\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     isDisplayShadowRoundControls: false,\n * });\n * moveable.isDisplayShadowRoundControls = true;\n */\n\n/**\n * The padding value of the position of the round control\n * @name Moveable.Roundable#roundPadding\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundPadding: 0,\n * });\n * moveable.roundPadding = 15;\n */\n\n/**\n * When drag start the clip area or controls, the `roundStart` event is called.\n * @memberof Moveable.Roundable\n * @event roundStart\n * @param {Moveable.Roundable.OnRoundStart} - Parameters for the `roundStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag or double click the border area or controls, the `round` event is called.\n * @memberof Moveable.Roundable\n * @event round\n * @param {Moveable.Roundable.OnRound} - Parameters for the `round` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag end the border area or controls, the `roundEnd` event is called.\n * @memberof Moveable.Roundable\n * @event roundEnd\n * @param {Moveable.Roundable.onRoundEnd} - Parameters for the `roundEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag start the clip area or controls, the `roundGroupStart` event is called.\n * @memberof Moveable.Roundable\n * @event roundGroupStart\n * @param {Moveable.Roundable.OnRoundGroupStart} - Parameters for the `roundGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     targets: [target1, target2, target3],\n *     roundable: true,\n * });\n * moveable.on(\"roundGroupStart\", e => {\n *     console.log(e.targets);\n * }).on(\"roundGroup\", e => {\n *   e.events.forEach(ev => {\n *       ev.target.style.cssText += ev.cssText;\n *   });\n * }).on(\"roundGroupEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag or double click the border area or controls, the `roundGroup` event is called.\n * @memberof Moveable.Roundable\n * @event roundGroup\n * @param {Moveable.Roundable.OnRoundGroup} - Parameters for the `roundGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     targets: [target1, target2, target3],\n *     roundable: true,\n * });\n * moveable.on(\"roundGroupStart\", e => {\n *     console.log(e.targets);\n * }).on(\"roundGroup\", e => {\n *   e.events.forEach(ev => {\n *       ev.target.style.cssText += ev.cssText;\n *   });\n * }).on(\"roundGroupEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag end the border area or controls, the `roundGroupEnd` event is called.\n * @memberof Moveable.Roundable\n * @event roundGroupEnd\n * @param {Moveable.Roundable.onRoundGroupEnd} - Parameters for the `roundGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     targets: [target1, target2, target3],\n *     roundable: true,\n * });\n * moveable.on(\"roundGroupStart\", e => {\n *     console.log(e.targets);\n * }).on(\"roundGroup\", e => {\n *     e.events.forEach(ev => {\n *         ev.target.style.cssText += ev.cssText;\n *     });\n * }).on(\"roundGroupEnd\", e => {\n *     console.log(e);\n * });\n */\n","import {\n  MoveableManagerInterface,\n  BeforeRenderableProps,\n  OnBeforeRenderStart,\n  OnBeforeRender,\n  OnBeforeRenderEnd,\n  MoveableGroupInterface,\n  OnBeforeRenderGroupStart,\n  OnBeforeRenderGroup,\n  OnBeforeRenderGroupEnd,\n} from \"../types\";\nimport { fillParams, triggerEvent } from \"../utils\";\nimport { convertMatrixtoCSS, createIdentityMatrix } from \"../../matrix\";\nimport { isArray, splitSpace } from \"../../utility\";\nimport { fillChildEvents } from \"../group-utils\";\n\nfunction isIdentityMatrix(matrix: string, is3d?: boolean) {\n  const n = is3d ? 4 : 3;\n  const identityMatrix = createIdentityMatrix(n);\n  const value = `matrix${is3d ? \"3d\" : \"\"}(${identityMatrix.join(\",\")})`;\n\n  return matrix === value || matrix === `matrix(1,0,0,1,0,0)`;\n}\nexport default {\n  isPinch: true,\n  name: \"beforeRenderable\",\n  props: [] as const,\n  events: [\n    \"beforeRenderStart\",\n    \"beforeRender\",\n    \"beforeRenderEnd\",\n    \"beforeRenderGroupStart\",\n    \"beforeRenderGroup\",\n    \"beforeRenderGroupEnd\",\n  ] as const,\n  dragRelation: \"weak\",\n  setTransform(\n    moveable: MoveableManagerInterface<BeforeRenderableProps>,\n    e: any\n  ) {\n    const { is3d, targetMatrix, inlineTransform } = moveable.state;\n    const cssMatrix = is3d\n      ? `matrix3d(${targetMatrix.join(\",\")})`\n      : `matrix(${convertMatrixtoCSS(targetMatrix, true)})`;\n    const startTransform =\n      !inlineTransform || inlineTransform === \"none\"\n        ? cssMatrix\n        : inlineTransform;\n\n    e.datas.startTransforms = isIdentityMatrix(startTransform, is3d)\n      ? []\n      : splitSpace(startTransform);\n  },\n  resetStyle(e: any) {\n    const datas = e.datas;\n\n    datas.nextStyle = {};\n    datas.nextTransforms = e.datas.startTransforms;\n    datas.nextTransformAppendedIndexes = [];\n  },\n  fillDragStartParams(\n    moveable: MoveableManagerInterface<BeforeRenderableProps>,\n    e: any\n  ) {\n    return fillParams<OnBeforeRenderStart>(moveable, e, {\n      setTransform: (transform: string | string[]) => {\n        e.datas.startTransforms = isArray(transform)\n          ? transform\n          : splitSpace(transform);\n      },\n      isPinch: !!e.isPinch,\n    });\n  },\n  fillDragParams(\n    moveable: MoveableManagerInterface<BeforeRenderableProps>,\n    e: any\n  ) {\n    return fillParams<OnBeforeRender>(moveable, e, {\n      isPinch: !!e.isPinch,\n    });\n  },\n  dragStart(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n    this.setTransform(moveable, e);\n    this.resetStyle(e);\n\n    triggerEvent(\n      moveable,\n      `onBeforeRenderStart`,\n      this.fillDragStartParams(moveable, e)\n    );\n  },\n  drag(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n    if (!e.datas.startTransforms) {\n      this.setTransform(moveable, e);\n    }\n    this.resetStyle(e);\n    triggerEvent(\n      moveable,\n      `onBeforeRender`,\n      fillParams<OnBeforeRender>(moveable, e, {\n        isPinch: !!e.isPinch,\n      })\n    );\n  },\n  dragEnd(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n    if (!e.datas.startTransforms) {\n      this.setTransform(moveable, e);\n      this.resetStyle(e);\n    }\n    triggerEvent(\n      moveable,\n      `onBeforeRenderEnd`,\n      fillParams<OnBeforeRenderEnd>(moveable, e, {\n        isPinch: !!e.isPinch,\n        isDrag: e.isDrag,\n      })\n    );\n  },\n  dragGroupStart(\n    moveable: MoveableGroupInterface<BeforeRenderableProps>,\n    e: any\n  ) {\n    this.dragStart(moveable, e);\n\n    const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n    const moveables = moveable.moveables;\n    const params = events.map((childEvent, i) => {\n      const childMoveable = moveables[i];\n\n      this.setTransform(childMoveable, childEvent);\n      this.resetStyle(childEvent);\n\n      return this.fillDragStartParams(childMoveable, childEvent);\n    });\n    triggerEvent(\n      moveable,\n      `onBeforeRenderGroupStart`,\n      fillParams<OnBeforeRenderGroupStart>(moveable, e, {\n        isPinch: !!e.isPinch,\n        targets: moveable.props.targets,\n        setTransform() {},\n        events: params,\n      })\n    );\n  },\n  dragGroup(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n    this.drag(moveable, e);\n\n    const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n    const moveables = moveable.moveables;\n    const params = events.map((childEvent, i) => {\n      const childMoveable = moveables[i];\n\n      this.resetStyle(childEvent);\n      return this.fillDragParams(childMoveable, childEvent);\n    });\n    triggerEvent(\n      moveable,\n      `onBeforeRenderGroup`,\n      fillParams<OnBeforeRenderGroup>(moveable, e, {\n        isPinch: !!e.isPinch,\n        targets: moveable.props.targets,\n        events: params,\n      })\n    );\n  },\n  dragGroupEnd(\n    moveable: MoveableGroupInterface<BeforeRenderableProps>,\n    e: any\n  ) {\n    this.dragEnd(moveable, e);\n\n    triggerEvent(\n      moveable,\n      `onBeforeRenderGroupEnd`,\n      fillParams<OnBeforeRenderGroupEnd>(moveable, e, {\n        isPinch: !!e.isPinch,\n        isDrag: e.isDrag,\n        targets: moveable.props.targets,\n      })\n    );\n  },\n  dragControlStart(\n    moveable: MoveableManagerInterface<BeforeRenderableProps>,\n    e: any\n  ) {\n    return this.dragStart(moveable, e);\n  },\n  dragControl(\n    moveable: MoveableManagerInterface<BeforeRenderableProps>,\n    e: any\n  ) {\n    return this.drag(moveable, e);\n  },\n  dragControlEnd(\n    moveable: MoveableManagerInterface<BeforeRenderableProps>,\n    e: any\n  ) {\n    return this.dragEnd(moveable, e);\n  },\n  dragGroupControlStart(\n    moveable: MoveableGroupInterface<BeforeRenderableProps>,\n    e: any\n  ) {\n    return this.dragGroupStart(moveable, e);\n  },\n  dragGroupControl(\n    moveable: MoveableGroupInterface<BeforeRenderableProps>,\n    e: any\n  ) {\n    return this.dragGroup(moveable, e);\n  },\n  dragGroupControlEnd(\n    moveable: MoveableGroupInterface<BeforeRenderableProps>,\n    e: any\n  ) {\n    return this.dragGroupEnd(moveable, e);\n  },\n} as const;\n","import { parse } from \"../../css-to-mat\";\nimport {\n  getNextStyle,\n  getNextTransformText,\n  getNextTransforms,\n} from \"../gesto/gesto-utils\";\nimport { fillChildEvents } from \"../group-utils\";\nimport {\n  MoveableManagerInterface,\n  RenderableProps,\n  OnRenderStart,\n  OnRender,\n  OnRenderEnd,\n  MoveableGroupInterface,\n  OnRenderGroupStart,\n  OnRenderGroup,\n  OnRenderGroupEnd,\n} from \"../types\";\nimport { triggerEvent, fillParams, fillCSSObject } from \"../utils\";\n\nexport default {\n  name: \"renderable\",\n  props: [] as const,\n  events: [\n    \"renderStart\",\n    \"render\",\n    \"renderEnd\",\n    \"renderGroupStart\",\n    \"renderGroup\",\n    \"renderGroupEnd\",\n  ] as const,\n  dragRelation: \"weak\",\n  dragStart(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n    triggerEvent(\n      moveable,\n      `onRenderStart`,\n      fillParams<OnRenderStart>(moveable, e, {\n        isPinch: !!e.isPinch,\n      })\n    );\n  },\n  drag(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n    triggerEvent(moveable, `onRender`, this.fillDragParams(moveable, e));\n  },\n  dragAfter(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n    return this.drag(moveable, e);\n  },\n  dragEnd(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n    triggerEvent(moveable, `onRenderEnd`, this.fillDragEndParams(moveable, e));\n  },\n  dragGroupStart(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n    triggerEvent(\n      moveable,\n      `onRenderGroupStart`,\n      fillParams<OnRenderGroupStart>(moveable, e, {\n        isPinch: !!e.isPinch,\n        targets: moveable.props.targets,\n      })\n    );\n  },\n  dragGroup(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n    const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n    const moveables = moveable.moveables;\n    const params = events.map((childEvent, i) => {\n      const childMoveable = moveables[i];\n\n      return this.fillDragParams(childMoveable, childEvent);\n    });\n\n    triggerEvent(\n      moveable,\n      `onRenderGroup`,\n      fillParams<OnRenderGroup>(moveable, e, {\n        isPinch: !!e.isPinch,\n        targets: moveable.props.targets,\n        transform: getNextTransformText(e),\n        transformObject: {},\n        ...fillCSSObject(getNextStyle(e)),\n        events: params,\n      })\n    );\n  },\n  dragGroupEnd(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n    const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n    const moveables = moveable.moveables;\n    const params = events.map((childEvent, i) => {\n      const childMoveable = moveables[i];\n\n      return this.fillDragEndParams(childMoveable, childEvent);\n    });\n\n    triggerEvent(\n      moveable,\n      `onRenderGroupEnd`,\n      fillParams<OnRenderGroupEnd>(moveable, e, {\n        isPinch: !!e.isPinch,\n        isDrag: e.isDrag,\n        targets: moveable.props.targets,\n        events: params,\n        transformObject: {},\n        transform: getNextTransformText(e),\n        ...fillCSSObject(getNextStyle(e)),\n      })\n    );\n  },\n  dragControlStart(\n    moveable: MoveableManagerInterface<RenderableProps>,\n    e: any\n  ) {\n    return this.dragStart(moveable, e);\n  },\n  dragControl(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n    return this.drag(moveable, e);\n  },\n  dragControlAfter(\n    moveable: MoveableManagerInterface<RenderableProps>,\n    e: any\n  ) {\n    return this.dragAfter(moveable, e);\n  },\n  dragControlEnd(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n    return this.dragEnd(moveable, e);\n  },\n  dragGroupControlStart(\n    moveable: MoveableGroupInterface<RenderableProps>,\n    e: any\n  ) {\n    return this.dragGroupStart(moveable, e);\n  },\n  dragGroupControl(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n    return this.dragGroup(moveable, e);\n  },\n  dragGroupControlEnd(\n    moveable: MoveableGroupInterface<RenderableProps>,\n    e: any\n  ) {\n    return this.dragGroupEnd(moveable, e);\n  },\n  fillDragParams(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n    const transformObject: Record<string, any> = {};\n\n    parse(getNextTransforms(e) || []).forEach((matrixInfo) => {\n      transformObject[matrixInfo.name] = matrixInfo.functionValue;\n    });\n\n    return fillParams<OnRender>(moveable, e, {\n      isPinch: !!e.isPinch,\n      transformObject,\n      transform: getNextTransformText(e),\n      ...fillCSSObject(getNextStyle(e)),\n    });\n  },\n  fillDragEndParams(\n    moveable: MoveableManagerInterface<RenderableProps>,\n    e: any\n  ) {\n    const transformObject: Record<string, any> = {};\n\n    parse(getNextTransforms(e) || []).forEach((matrixInfo) => {\n      transformObject[matrixInfo.name] = matrixInfo.functionValue;\n    });\n    return fillParams<OnRenderEnd>(moveable, e, {\n      isPinch: !!e.isPinch,\n      isDrag: e.isDrag,\n      transformObject,\n      transform: getNextTransformText(e),\n      ...fillCSSObject(getNextStyle(e)),\n    });\n  },\n} as const;\n","import {\n  Able,\n  MoveableManagerInterface,\n  MoveableGroupInterface,\n} from \"../types\";\nimport { getWindow, hasClass, IObject } from \"../../utility\";\nimport { convertDragDist, defaultSync, getRefTarget } from \"../utils\";\nimport Gesto, { GestoOptions } from \"../../gesto\";\nimport BeforeRenderable from \"../ables/before-renderable\";\nimport Renderable from \"../ables/renderable\";\n\nexport function triggerAble(\n  moveable: MoveableManagerInterface,\n  moveableAbles: Able[],\n  eventOperations: string[],\n  eventAffix: string,\n  eventType: any,\n  e: any,\n  requestInstant?: boolean\n) {\n  // pre setting\n  e.clientDistX = e.distX;\n  e.clientDistY = e.distY;\n\n  const isStart = eventType === \"Start\";\n  const isEnd = eventType === \"End\";\n  const isAfter = eventType === \"After\";\n  const target = moveable.state.target;\n  const isRequest = e.isRequest;\n  const isControl = eventAffix.indexOf(\"Control\") > -1;\n\n  if (\n    !target ||\n    (isStart &&\n      isControl &&\n      !isRequest &&\n      moveable.areaElement === e.inputEvent.target)\n  ) {\n    return false;\n  }\n  const ables: Able[] = [...moveableAbles];\n\n  if (isRequest) {\n    const requestAble = e.requestAble;\n\n    if (!ables.some((able) => able.name === requestAble)) {\n      ables.push(\n        ...moveable.props.ables!.filter((able) => able.name === requestAble)\n      );\n    }\n  }\n  if (!ables.length || ables.every((able) => able.dragRelation)) {\n    return false;\n  }\n  // \"drag\" \"Control\" \"After\"\n\n  const inputEvent = e.inputEvent;\n  let inputTarget: Element;\n\n  if (isEnd && inputEvent) {\n    inputTarget =\n      document.elementFromPoint(e.clientX, e.clientY) || inputEvent.target;\n  }\n  let isDragStop = false;\n  const stop = () => {\n    isDragStop = true;\n    e.stop?.();\n  };\n  const isFirstStart =\n    isStart &&\n    (!moveable.targetGesto ||\n      !moveable.controlGesto ||\n      !moveable.targetGesto.isFlag() ||\n      !moveable.controlGesto.isFlag());\n\n  if (isFirstStart) {\n    moveable.updateRect(eventType, true, false);\n  }\n\n  // trigger ables\n  const datas = e.datas;\n  const gestoType = isControl ? \"controlGesto\" : \"targetGesto\";\n  const prevGesto = moveable[gestoType];\n\n  const trigger = (able: any, eventName: string, conditionName?: string) => {\n    if (!(eventName in able) || prevGesto !== moveable[gestoType]) {\n      return false;\n    }\n    const ableName = able.name;\n    const nextDatas = datas[ableName] || (datas[ableName] = {});\n\n    if (isStart) {\n      nextDatas.isEventStart =\n        !conditionName ||\n        !able[conditionName] ||\n        able[conditionName](moveable, e);\n    }\n\n    if (!nextDatas.isEventStart) {\n      return false;\n    }\n    const result = able[eventName](moveable, {\n      ...e,\n      stop,\n      datas: nextDatas,\n      originalDatas: datas,\n      inputTarget,\n    });\n    (moveable as any)._emitter.off();\n\n    if (isStart && result === false) {\n      nextDatas.isEventStart = false;\n    }\n    return result;\n  };\n\n  // unset ables for first drag start\n  if (isFirstStart) {\n    ables.forEach((able) => {\n      able.unset && able.unset(moveable);\n    });\n  }\n  // BeforeRenderable\n  trigger(BeforeRenderable, `drag${eventAffix}${eventType}`);\n\n  let forceEndedCount = 0;\n  let updatedCount = 0;\n\n  eventOperations.forEach((eventOperation) => {\n    if (isDragStop) {\n      return false;\n    }\n    const eventName = `${eventOperation}${eventAffix}${eventType}`;\n    const conditionName = `${eventOperation}${eventAffix}Condition`;\n\n    if (eventType === \"\" && !isRequest) {\n      // Convert distX, distY\n      convertDragDist(moveable.state, e);\n    }\n    // const isGroup = eventAffix.indexOf(\"Group\") > -1;\n    let eventAbles: Able[] = ables.filter((able: any) => able[eventName]);\n\n    eventAbles = eventAbles.filter((able, i) => {\n      return able.name && eventAbles.indexOf(able) === i;\n    });\n\n    const results = eventAbles.filter((able) =>\n      trigger(able, eventName, conditionName)\n    );\n    const isUpdate = results.length;\n\n    // end ables\n    if (isDragStop) {\n      ++forceEndedCount;\n    }\n    if (isUpdate) {\n      ++updatedCount;\n    }\n\n    if (!isDragStop && isStart && eventAbles.length && !isUpdate) {\n      forceEndedCount += eventAbles.filter((able) => {\n        const ableName = able.name;\n        const nextDatas = datas[ableName];\n\n        if (nextDatas.isEventStart) {\n          if (able.dragRelation === \"strong\") {\n            return false;\n          }\n          // stop drag\n          return true;\n        }\n        // pre stop drag\n        return false;\n      }).length\n        ? 1\n        : 0;\n    }\n  });\n\n  if (!isAfter || updatedCount) {\n    trigger(Renderable, `drag${eventAffix}${eventType}`);\n  }\n  // stop gesto condition\n  const isForceEnd =\n    prevGesto !== moveable[gestoType] ||\n    forceEndedCount === eventOperations.length;\n\n  if (isEnd || isDragStop || isForceEnd) {\n    moveable.state.gestos = {};\n\n    if ((moveable as MoveableGroupInterface).moveables) {\n      (moveable as MoveableGroupInterface).moveables.forEach(\n        (childMoveable) => {\n          childMoveable.state.gestos = {};\n        }\n      );\n    }\n    ables.forEach((able) => {\n      able.unset && able.unset(moveable);\n    });\n  }\n  if (\n    isStart &&\n    !isForceEnd &&\n    !isRequest &&\n    updatedCount &&\n    moveable.props.preventDefault\n  ) {\n    e?.preventDefault();\n  }\n  if (moveable.isUnmounted || isForceEnd) {\n    return false;\n  }\n  if ((!isStart && updatedCount && !requestInstant) || isEnd) {\n    const flushSync = moveable.props.flushSync || defaultSync;\n\n    flushSync(() => {\n      moveable.updateRect(isEnd ? eventType : \"\", true, false);\n      moveable.forceUpdate();\n    });\n  }\n  if (!isStart && !isEnd && !isAfter && updatedCount && !requestInstant) {\n    triggerAble(\n      moveable,\n      moveableAbles,\n      eventOperations,\n      eventAffix,\n      eventType + \"After\",\n      e\n    );\n  }\n  return true;\n}\n\nexport function checkMoveableTarget(\n  moveable: MoveableManagerInterface,\n  isControl?: boolean\n) {\n  return (\n    e: { inputEvent: Event },\n    target: EventTarget | null = e.inputEvent.target\n  ) => {\n    const eventTarget = target as Element;\n    const areaElement = moveable.areaElement;\n    const dragTargetElement = (moveable as any)._dragTarget;\n\n    if (!dragTargetElement || (!isControl && moveable.controlGesto?.isFlag())) {\n      return false;\n    }\n\n    return (\n      eventTarget === dragTargetElement ||\n      dragTargetElement.contains(eventTarget) ||\n      eventTarget === areaElement ||\n      (!moveable.isMoveableElement(eventTarget) &&\n        !moveable.controlBox.contains(eventTarget)) ||\n      hasClass(eventTarget, \"moveable-area\") ||\n      hasClass(eventTarget, \"moveable-padding\") ||\n      hasClass(eventTarget, \"moveable-edgeDraggable\")\n    );\n  };\n}\n\nexport function getTargetAbleGesto(\n  moveable: MoveableManagerInterface,\n  moveableTarget: HTMLElement | SVGElement,\n  eventAffix: string\n) {\n  const controlBox = moveable.controlBox;\n  const targets: Array<HTMLElement | SVGElement> = [];\n  const props = moveable.props;\n  const dragArea = props.dragArea;\n  const target = moveable.state.target;\n  const dragTarget = props.dragTarget;\n\n  targets.push(controlBox);\n\n  if (!dragArea || dragTarget) {\n    targets.push(moveableTarget);\n  }\n\n  if (\n    !dragArea &&\n    dragTarget &&\n    target &&\n    moveableTarget !== target &&\n    props.dragTargetSelf\n  ) {\n    targets.push(target);\n  }\n  const checkTarget = checkMoveableTarget(moveable);\n\n  return getAbleGesto(moveable, targets, \"targetAbles\", eventAffix, {\n    dragStart: checkTarget,\n    pinchStart: checkTarget,\n  });\n}\n\nexport function getControlAbleGesto(\n  moveable: MoveableManagerInterface,\n  eventAffix: string\n) {\n  const controlBox = moveable.controlBox;\n  const targets: Array<HTMLElement | SVGElement> = [];\n\n  targets.push(controlBox);\n\n  const checkTarget = checkMoveableTarget(moveable, true);\n  const checkControlTarget = (\n    e: any,\n    target: EventTarget | null = e.inputEvent.target\n  ) => {\n    if (target === controlBox) {\n      return true;\n    }\n    const result = checkTarget(e, target);\n\n    return !result;\n  };\n\n  return getAbleGesto(moveable, targets, \"controlAbles\", eventAffix, {\n    dragStart: checkControlTarget,\n    pinchStart: checkControlTarget,\n  });\n}\n\nexport function getAbleGesto(\n  moveable: MoveableManagerInterface,\n  target: HTMLElement | SVGElement | Array<HTMLElement | SVGElement>,\n  ableType: string,\n  eventAffix: string,\n  conditionFunctions: IObject<any> = {}\n) {\n  const isTargetAbles = ableType === \"targetAbles\";\n  const {\n    pinchOutside,\n    pinchThreshold,\n    preventClickEventOnDrag,\n    preventClickDefault,\n    checkInput,\n    dragFocusedInput,\n    preventDefault = true,\n    preventRightClick = true,\n    preventWheelClick = true,\n    dragContainer: dragContaienrOption,\n  } = moveable.props;\n  const dragContainer = getRefTarget(dragContaienrOption, true);\n\n  const options: GestoOptions = {\n    preventDefault,\n    preventRightClick,\n    preventWheelClick,\n    container: dragContainer || getWindow(moveable.getControlBoxElement()),\n    pinchThreshold,\n    pinchOutside,\n    preventClickEventOnDrag: isTargetAbles ? preventClickEventOnDrag : false,\n    preventClickEventOnDragStart: isTargetAbles ? preventClickDefault : false,\n    preventClickEventByCondition: isTargetAbles\n      ? null\n      : (e: MouseEvent) => {\n          return moveable.controlBox.contains(e.target as Element);\n        },\n    checkInput: isTargetAbles ? checkInput : false,\n    dragFocusedInput,\n  };\n  const gesto = new Gesto(target!, options);\n  const isControl = eventAffix === \"Control\";\n\n  [\"drag\", \"pinch\"].forEach((eventOperation) => {\n    [\"Start\", \"\", \"End\"].forEach((eventType) => {\n      gesto.on(`${eventOperation}${eventType}` as any, (e) => {\n        const eventName = e.eventType;\n        const isPinchScheduled = eventOperation === \"drag\" && e.isPinch;\n\n        if (\n          conditionFunctions[eventName] &&\n          !conditionFunctions[eventName](e)\n        ) {\n          e.stop();\n          return;\n        }\n\n        if (isPinchScheduled) {\n          return;\n        }\n        const eventOperations =\n          eventOperation === \"drag\"\n            ? [eventOperation]\n            : [\"drag\", eventOperation];\n        const moveableAbles: Able[] = [...(moveable as any)[ableType]];\n        const result = triggerAble(\n          moveable,\n          moveableAbles,\n          eventOperations,\n          eventAffix,\n          eventType,\n          e\n        );\n\n        if (!result) {\n          e.stop();\n        } else if (\n          moveable.props.stopPropagation ||\n          (eventType === \"Start\" && isControl)\n        ) {\n          e?.inputEvent?.stopPropagation();\n        }\n      });\n    });\n  });\n\n  return gesto;\n}\n","import { Able, MoveableManagerInterface } from \"./types\";\n\nexport default class EventManager {\n    private ables: Able[] = [];\n    constructor(\n        private target: HTMLElement | SVGElement | null,\n        private moveable: MoveableManagerInterface | null,\n        private eventName: string,\n    ) {\n        target!.addEventListener(eventName.toLowerCase(), this._onEvent);\n    }\n    public setAbles(ables: Able[]) {\n        this.ables = ables;\n    }\n    public destroy() {\n        this.target!.removeEventListener(this.eventName.toLowerCase(), this._onEvent);\n        this.target = null;\n        this.moveable = null;\n    }\n    private _onEvent = (e: Event) => {\n        const eventName = this.eventName;\n        const moveable = this.moveable!;\n\n        if (moveable.state.disableNativeEvent) {\n            return;\n        }\n        this.ables.forEach(able => {\n            (able as any)[eventName](moveable, {\n                inputEvent: e,\n            });\n        });\n    }\n}\n","import cssStyled from \"../css-styled\";\nimport {\n  createElement,\n  forwardRef,\n  ForwardRefExoticComponent,\n  PropsWithoutRef,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n} from \"react\";\nimport { StyledElement } from \"./StyledElement\";\n\nexport default function defaultStyled<\n  T extends HTMLElement | SVGElement = HTMLElement\n>(\n  tag: string,\n  css: string\n): typeof StyledElement & (new (...args: any[]) => StyledElement<T>) {\n  const injector = cssStyled(css);\n\n  return class Styled extends StyledElement<T> {\n    public injector = injector;\n    public tag = tag;\n  } as typeof StyledElement & (new (...args: any[]) => StyledElement<T>);\n}\n\nexport function styled<\n  Target extends HTMLElement | SVGElement = HTMLElement,\n  Props extends Record<string, any> = Record<string, any>\n>(\n  Tag: string,\n  css: string\n): ForwardRefExoticComponent<\n  PropsWithoutRef<Props> & React.RefAttributes<Target>\n> {\n  const injector = cssStyled(css);\n  const cssId = injector!.className;\n\n  return forwardRef<Target, Props>((props, ref) => {\n    const { className = \"\", cspNonce, ...attributes } = props;\n    const targetRef = useRef<Target>(null);\n\n    useImperativeHandle(ref, () => targetRef.current!, []);\n    useEffect(() => {\n      const injectResult = injector.inject(targetRef.current!, {\n        nonce: props.cspNonce,\n      });\n\n      return () => {\n        injectResult.destroy();\n      };\n    }, []);\n    return createElement(Tag, {\n      ref: targetRef,\n      \"data-styled-id\": cssId,\n      className: `${className} ${cssId}`,\n      ...attributes,\n    });\n  });\n}\n","import {\n  createIdentityMatrix,\n  convertDimension,\n  multiply,\n  createOriginMatrix,\n  ignoreDimension,\n} from \"../../matrix\";\nimport { getCachedMatrixContainerInfo } from \"../store/store\";\nimport {\n  convert3DMatrixes,\n  getOffsetInfo,\n  getSVGOffset,\n  makeMatrixCSS,\n} from \"../utils\";\nimport { getMatrixStackInfo } from \"./get-matrix-stack-info\";\nimport { getDocumentBody } from \"../../utility\";\nimport { MatrixInfo } from \"../types\";\n\nexport interface MoveableElementMatrixInfo {\n  hasZoom: boolean;\n  hasFixed: boolean;\n  originalRootMatrix: number[];\n  rootMatrix: number[];\n  beforeMatrix: number[];\n  offsetMatrix: number[];\n  allMatrix: number[];\n  targetMatrix: number[];\n  transformOrigin: number[];\n  targetOrigin: number[];\n  is3d: boolean;\n  targetTransform: string;\n  inlineTransform: string;\n  offsetContainer: HTMLElement | null;\n  offsetRootContainer: HTMLElement | null;\n  matrixes: MatrixInfo[];\n}\n\nexport function calculateMatrixStack(\n  target: SVGElement | HTMLElement,\n  container?: SVGElement | HTMLElement | null,\n  rootContainer: SVGElement | HTMLElement | null | undefined = container,\n  isAbsolute3d?: boolean\n  // prevMatrix?: number[],\n  // prevRootMatrix?: number[],\n  // prevN?: number,\n): MoveableElementMatrixInfo {\n  const {\n    matrixes,\n    is3d,\n    targetMatrix: prevTargetMatrix,\n    transformOrigin,\n    targetOrigin,\n    offsetContainer,\n    hasFixed,\n    zoom: containerZoom,\n  } = getMatrixStackInfo(target, container); // prevMatrix\n\n  const {\n    matrixes: rootMatrixes,\n    is3d: isRoot3d,\n    offsetContainer: offsetRootContainer,\n    zoom: rootZoom,\n  } = getCachedMatrixContainerInfo(offsetContainer, rootContainer); // prevRootMatrix\n\n  // if (rootContainer === document.body) {\n  //     console.log(offsetContainer, rootContainer, rootMatrixes);\n  // }\n  const isNext3d = isAbsolute3d || isRoot3d || is3d;\n  const n = isNext3d ? 4 : 3;\n  const isSVGGraphicElement =\n    target.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in target;\n  let targetMatrix = prevTargetMatrix;\n  // let allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n  // let rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN!, n) : createIdentityMatrix(n);\n  // let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n  let allMatrix = createIdentityMatrix(n);\n  let rootMatrix = createIdentityMatrix(n);\n  let beforeMatrix = createIdentityMatrix(n);\n  let offsetMatrix = createIdentityMatrix(n);\n  const length = matrixes.length;\n  const nextRootMatrixes = rootMatrixes\n    .map((info) => {\n      return {\n        ...info,\n        matrix: info.matrix ? [...info.matrix] : undefined,\n      };\n    })\n    .reverse();\n  matrixes.reverse();\n\n  if (!is3d && isNext3d) {\n    targetMatrix = convertDimension(targetMatrix, 3, 4);\n\n    convert3DMatrixes(matrixes);\n  }\n  if (!isRoot3d && isNext3d) {\n    convert3DMatrixes(nextRootMatrixes);\n  }\n\n  // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)\n  // rootMatrixBeforeOffset = lastOffsetMatrix -> (...) -> container\n  // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)\n  // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)\n\n  nextRootMatrixes.forEach((info) => {\n    rootMatrix = multiply(rootMatrix, info.matrix!, n);\n  });\n  const originalRootContainer = rootContainer || getDocumentBody(target);\n  const endContainer =\n    nextRootMatrixes[0]?.target ||\n    getOffsetInfo(originalRootContainer, originalRootContainer, true)\n      .offsetParent;\n  const rootMatrixBeforeOffset = nextRootMatrixes\n    .slice(1)\n    .reduce((matrix, info) => {\n      return multiply(matrix, info.matrix!, n);\n    }, createIdentityMatrix(n));\n  matrixes.forEach((info, i) => {\n    if (length - 2 === i) {\n      // length - 3\n      beforeMatrix = allMatrix.slice();\n    }\n    if (length - 1 === i) {\n      // length - 2\n      offsetMatrix = allMatrix.slice();\n    }\n\n    // calculate for SVGElement\n    if (!info.matrix) {\n      const nextInfo = matrixes[i + 1];\n      const offset = getSVGOffset(\n        info,\n        nextInfo,\n        endContainer,\n        n,\n        multiply(rootMatrixBeforeOffset, allMatrix, n)\n      );\n      info.matrix = createOriginMatrix(offset, n);\n    }\n    allMatrix = multiply(allMatrix, info.matrix!, n);\n  });\n  const isMatrix3d = !isSVGGraphicElement && is3d;\n\n  if (!targetMatrix) {\n    targetMatrix = createIdentityMatrix(isMatrix3d ? 4 : 3);\n  }\n  const targetTransform = makeMatrixCSS(\n    isSVGGraphicElement && targetMatrix.length === 16\n      ? convertDimension(targetMatrix, 4, 3)\n      : targetMatrix,\n    isMatrix3d\n  );\n\n  const originalRootMatrix = rootMatrix;\n  rootMatrix = ignoreDimension(rootMatrix, n, n);\n\n  return {\n    hasZoom: containerZoom !== 1 || rootZoom !== 1,\n    hasFixed,\n    matrixes,\n    rootMatrix,\n    originalRootMatrix,\n    beforeMatrix,\n    offsetMatrix,\n    allMatrix,\n    targetMatrix,\n    targetTransform,\n    inlineTransform: target.style.transform,\n    transformOrigin,\n    targetOrigin,\n    is3d: isNext3d,\n    offsetContainer,\n    offsetRootContainer,\n  };\n}\n","import { createIdentityMatrix } from \"../../matrix\";\nimport { ElementSizes, MoveablePosition } from \"../types\";\nimport { getSize, getRotationRad } from \"../utils\";\nimport {\n  calculateMatrixStack,\n  MoveableElementMatrixInfo,\n} from \"./calculate-matrix-stack\";\nimport { calculateElementPosition } from \"./calculate-element-position\";\n\nexport interface MoveableElementInfo\n  extends MoveableElementMatrixInfo,\n    MoveablePosition,\n    ElementSizes {\n  width: number;\n  height: number;\n  rotation: number;\n}\n\nexport function calculateElementInfo(\n  target?: SVGElement | HTMLElement | null,\n  container?: SVGElement | HTMLElement | null,\n  rootContainer: HTMLElement | SVGElement | null | undefined = container,\n  isAbsolute3d?: boolean\n): MoveableElementInfo {\n  let width = 0;\n  let height = 0;\n  let rotation = 0;\n  let allResult: {} = {};\n\n  const sizes = getSize(target);\n\n  if (target) {\n    width = sizes.offsetWidth;\n    height = sizes.offsetHeight;\n  }\n\n  if (target) {\n    const result = calculateMatrixStack(\n      target,\n      container,\n      rootContainer,\n      isAbsolute3d\n      // prevMatrix, prevRootMatrix, prevN,\n    );\n\n    const position = calculateElementPosition(\n      result.allMatrix,\n      result.transformOrigin,\n      width,\n      height\n    );\n    allResult = {\n      ...result,\n      ...position,\n    };\n    const rotationPosition = calculateElementPosition(\n      result.allMatrix,\n      [50, 50],\n      100,\n      100\n    );\n    rotation = getRotationRad(\n      [rotationPosition.pos1, rotationPosition.pos2],\n      rotationPosition.direction\n    );\n  }\n  const n = isAbsolute3d ? 4 : 3;\n\n  return {\n    hasZoom: false,\n    width,\n    height,\n    rotation,\n    ...sizes,\n    originalRootMatrix: createIdentityMatrix(n),\n    rootMatrix: createIdentityMatrix(n),\n    beforeMatrix: createIdentityMatrix(n),\n    offsetMatrix: createIdentityMatrix(n),\n    allMatrix: createIdentityMatrix(n),\n    targetMatrix: createIdentityMatrix(n),\n    targetTransform: \"\",\n    inlineTransform: \"\",\n    transformOrigin: [0, 0],\n    targetOrigin: [0, 0],\n    is3d: !!isAbsolute3d,\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n    origin: [0, 0],\n    pos1: [0, 0],\n    pos2: [0, 0],\n    pos3: [0, 0],\n    pos4: [0, 0],\n    direction: 1,\n    hasFixed: false,\n    offsetContainer: null,\n    offsetRootContainer: null,\n    matrixes: [],\n    ...allResult,\n  };\n}\n\nexport function getElementInfo(\n  target: SVGElement | HTMLElement,\n  container?: SVGElement | HTMLElement | null,\n  rootContainer: SVGElement | HTMLElement | null | undefined = container\n) {\n  return calculateElementInfo(target, container, rootContainer, true);\n}\n","import { plus, getOrigin, multiply, minus } from \"../../matrix\";\nimport { getCachedClientRect, getCachedStyle } from \"../store/store\";\nimport { MoveableClientRect, Writable } from \"../types\";\nimport {\n  calculateInversePosition,\n  getClientRect,\n  getClientRectByPosition,\n  getOffsetInfo,\n  resetClientRect,\n  getTransformOriginArray,\n} from \"../utils\";\nimport { calculateElementInfo, MoveableElementInfo } from \"./get-element-info\";\nimport { calculateElementPosition } from \"./calculate-element-position\";\n\nexport interface MoveableTargetInfo extends MoveableElementInfo {\n  targetClientRect: MoveableClientRect;\n  containerClientRect: MoveableClientRect;\n  moveableClientRect: MoveableClientRect;\n  rootContainerClientRect: MoveableClientRect;\n  beforeDirection: 1 | -1;\n  beforeOrigin: number[];\n  offsetDelta: number[];\n  originalBeforeOrigin: number[];\n  target: HTMLElement | SVGElement | null | undefined;\n  style: Partial<Writable<CSSStyleDeclaration>>;\n}\n\nexport function getMoveableTargetInfo(\n  moveableElement?: HTMLElement | null,\n  target?: HTMLElement | SVGElement | null,\n  container?: HTMLElement | SVGElement | null,\n  parentContainer?: HTMLElement | SVGElement | null,\n  rootContainer?: HTMLElement | SVGElement | null,\n  requestStyles: Array<keyof CSSStyleDeclaration> = []\n): MoveableTargetInfo {\n  let beforeDirection: 1 | -1 = 1;\n  let beforeOrigin = [0, 0];\n  let targetClientRect = resetClientRect();\n  let moveableClientRect = resetClientRect();\n  let containerClientRect = resetClientRect();\n  let rootContainerClientRect = resetClientRect();\n  let offsetDelta = [0, 0];\n  const style: Partial<Writable<CSSStyleDeclaration>> = {};\n\n  const result = calculateElementInfo(target, container!, rootContainer!, true);\n  if (target) {\n    const getStyle = getCachedStyle(target);\n\n    requestStyles.forEach((name) => {\n      (style as any)[name] = getStyle(name as any);\n    });\n    const n = result.is3d ? 4 : 3;\n    const beforePosition = calculateElementPosition(\n      result.offsetMatrix,\n      plus(result.transformOrigin, getOrigin(result.targetMatrix, n)),\n      result.width,\n      result.height\n    );\n    beforeDirection = beforePosition.direction;\n    beforeOrigin = plus(beforePosition.origin, [\n      beforePosition.left - result.left,\n      beforePosition.top - result.top,\n    ]);\n\n    rootContainerClientRect = getClientRect(result.offsetRootContainer!);\n\n    const offsetContainer =\n      getOffsetInfo(parentContainer, parentContainer, true).offsetParent ||\n      result.offsetRootContainer!;\n\n    if (result.hasZoom) {\n      const absoluteTargetPosition = calculateElementPosition(\n        multiply(result.originalRootMatrix, result.allMatrix),\n        result.transformOrigin,\n        result.width,\n        result.height\n      );\n      const absoluteContainerPosition = calculateElementPosition(\n        result.originalRootMatrix,\n        getTransformOriginArray(\n          getCachedStyle(offsetContainer)(\"transformOrigin\")\n        ).map((pos) => parseFloat(pos)),\n        offsetContainer.offsetWidth,\n        offsetContainer.offsetHeight\n      );\n      targetClientRect = getClientRectByPosition(\n        absoluteTargetPosition,\n        rootContainerClientRect\n      );\n      containerClientRect = getClientRectByPosition(\n        absoluteContainerPosition,\n        rootContainerClientRect,\n        offsetContainer,\n        true\n      );\n\n      if (moveableElement) {\n        const left = absoluteTargetPosition.left;\n        const top = absoluteTargetPosition.top;\n        moveableClientRect = getClientRectByPosition(\n          {\n            left,\n            top,\n            bottom: top,\n            right: top,\n          },\n          rootContainerClientRect\n        );\n      }\n    } else {\n      targetClientRect = getClientRect(target);\n      containerClientRect = getCachedClientRect(offsetContainer);\n\n      if (moveableElement) {\n        moveableClientRect = getClientRect(moveableElement);\n      }\n      const {\n        left: containerClientRectLeft,\n        top: containerClientRectTop,\n        clientLeft: containterClientLeft,\n        clientTop: containerClientTop,\n      } = containerClientRect;\n      const clientDelta = [\n        targetClientRect.left - containerClientRectLeft,\n        targetClientRect.top - containerClientRectTop,\n      ];\n\n      offsetDelta = minus(\n        calculateInversePosition(result.rootMatrix, clientDelta, 4),\n        [containterClientLeft! + result.left, containerClientTop! + result.top]\n      );\n    }\n  }\n\n  return {\n    targetClientRect,\n    containerClientRect,\n    moveableClientRect,\n    rootContainerClientRect,\n    beforeDirection,\n    beforeOrigin,\n    originalBeforeOrigin: beforeOrigin,\n    target,\n    style,\n    offsetDelta,\n    ...result,\n  };\n}\n","import { minus } from \"../../matrix\";\nimport { getMinMaxs } from \"../../overlap-area\";\nimport { MoveableManagerState, PersistRectData } from \"../types\";\n\nexport function getPersistState(\n  rect: PersistRectData\n): Partial<MoveableManagerState> | null {\n  let { pos1, pos2, pos3, pos4 } = rect;\n  if (!pos1 || !pos2 || !pos3 || !pos4) {\n    return null;\n  }\n  const minPos = getMinMaxs([pos1!, pos2!, pos3!, pos4!]);\n  const posDelta = [minPos.minX, minPos.minY];\n  const origin = minus(rect.origin!, posDelta);\n\n  pos1 = minus(pos1, posDelta);\n  pos2 = minus(pos2, posDelta);\n  pos3 = minus(pos3, posDelta);\n  pos4 = minus(pos4, posDelta);\n  return {\n    ...rect,\n    left: rect.left,\n    top: rect.top,\n    posDelta,\n    pos1,\n    pos2,\n    pos3,\n    pos4,\n    origin,\n    beforeOrigin: origin,\n    // originalBeforeOrigin: origin,\n    isPersisted: true,\n  };\n}\n","import * as React from \"react\";\nimport { createElement } from \"react\";\nimport { PREFIX } from \"./consts\";\nimport {\n  prefix,\n  unsetGesto,\n  getAbsolutePosesByState,\n  getRect,\n  filterAbles,\n  equals,\n  flat,\n  groupByMap,\n  calculatePadding,\n  getAbsoluteRotation,\n  defaultSync,\n  getRefTarget,\n  groupBy,\n  unsetAbles,\n  getPaddingBox,\n} from \"./utils\";\nimport Gesto from \"../gesto\";\nimport { ref } from \"../utility/framework\";\nimport {\n  MoveableManagerProps,\n  MoveableManagerState,\n  Able,\n  RectInfo,\n  Requester,\n  HitRect,\n  MoveableManagerInterface,\n  MoveableDefaultOptions,\n  GroupableProps,\n  MoveableRefType,\n} from \"./types\";\nimport {\n  triggerAble,\n  getTargetAbleGesto,\n  checkMoveableTarget,\n  getControlAbleGesto,\n} from \"./gesto/get-able-gesto\";\nimport { createOriginMatrix, multiplies, plus } from \"../matrix\";\nimport {\n  addClass,\n  cancelAnimationFrame,\n  find,\n  getKeys,\n  getWindow,\n  IObject,\n  isNode,\n  removeClass,\n  requestAnimationFrame,\n} from \"../utility\";\nimport { renderLine } from \"./render-directions\";\nimport {\n  fitPoints,\n  getAreaSize,\n  getOverlapSize,\n  isInside,\n} from \"../overlap-area\";\nimport EventManager from \"./event-manager\";\nimport { styled } from \"../react-css-styled\";\nimport EventEmitter from \"../event-emitter\";\nimport { getMoveableTargetInfo } from \"./utils/get-moveable-target-info\";\nimport { VIEW_DRAGGING } from \"./classnames\";\nimport { diff } from \"../differ/list-differ\";\nimport { getPersistState } from \"./utils/persist\";\nimport { setStoreCache } from \"./store/store\";\n\nexport default class MoveableManager<T = {}> extends React.PureComponent<\n  MoveableManagerProps<T>,\n  MoveableManagerState\n> {\n  public static defaultProps: Required<MoveableManagerProps> = {\n    dragTargetSelf: false,\n    target: null,\n    dragTarget: null,\n    container: null,\n    rootContainer: null,\n    origin: true,\n    parentMoveable: null,\n    wrapperMoveable: null,\n    isWrapperMounted: false,\n    parentPosition: null,\n    warpSelf: false,\n    svgOrigin: \"\",\n    dragContainer: null,\n    useResizeObserver: false,\n    useMutationObserver: false,\n    preventDefault: true,\n    preventRightClick: true,\n    preventWheelClick: true,\n    linePadding: 0,\n    controlPadding: 0,\n    ables: [],\n    pinchThreshold: 20,\n    dragArea: false,\n    passDragArea: false,\n    transformOrigin: \"\",\n    className: \"\",\n    zoom: 1,\n    triggerAblesSimultaneously: false,\n    padding: {},\n    pinchOutside: true,\n    checkInput: false,\n    dragFocusedInput: false,\n    groupable: false,\n    hideDefaultLines: false,\n    cspNonce: \"\",\n    translateZ: 0,\n    cssStyled: null,\n    customStyledMap: {},\n    props: {},\n    stopPropagation: false,\n    preventClickDefault: false,\n    preventClickEventOnDrag: true,\n    flushSync: defaultSync,\n    firstRenderState: null,\n    persistData: null,\n    viewContainer: null,\n    requestStyles: [],\n    useAccuratePosition: false,\n  };\n  public state: MoveableManagerState = {\n    container: null,\n    gestos: {},\n    renderLines: [\n      [\n        [0, 0],\n        [0, 0],\n      ],\n      [\n        [0, 0],\n        [0, 0],\n      ],\n      [\n        [0, 0],\n        [0, 0],\n      ],\n      [\n        [0, 0],\n        [0, 0],\n      ],\n    ],\n    renderPoses: [\n      [0, 0],\n      [0, 0],\n      [0, 0],\n      [0, 0],\n    ],\n    disableNativeEvent: false,\n    posDelta: [0, 0],\n    ...getMoveableTargetInfo(null),\n  };\n  public renderState: Record<string, any> = {};\n  public enabledAbles: Able[] = [];\n  public targetAbles: Able[] = [];\n  public controlAbles: Able[] = [];\n  public controlBox!: HTMLElement;\n  public areaElement!: HTMLElement;\n  public targetGesto!: Gesto;\n  public controlGesto!: Gesto;\n  public rotation = 0;\n  public scale: number[] = [1, 1];\n  public isMoveableMounted = false;\n  public isUnmounted = false;\n\n  public events: Record<string, EventManager | null> = {\n    mouseEnter: null,\n    mouseLeave: null,\n  };\n\n  protected _emitter: EventEmitter = new EventEmitter();\n\n  protected _prevOriginalDragTarget: MoveableRefType | null = null;\n  protected _originalDragTarget: MoveableRefType | null = null;\n\n  protected _prevDragTarget: HTMLElement | SVGElement | null | undefined = null;\n  protected _dragTarget: HTMLElement | SVGElement | null | undefined = null;\n\n  protected _prevPropTarget: HTMLElement | SVGElement | null | undefined = null;\n  protected _propTarget: HTMLElement | SVGElement | null | undefined = null;\n\n  protected _prevDragArea = false;\n  protected _isPropTargetChanged = false;\n  protected _hasFirstTarget = false;\n\n  private _reiszeObserver: ResizeObserver | null = null;\n  private _observerId = 0;\n  private _mutationObserver: MutationObserver | null = null;\n  public _rootContainer: HTMLElement | null | undefined = null;\n  private _viewContainer: HTMLElement | null | undefined = null;\n  private _viewClassNames: string[] = [];\n  private _store: Record<string, any> = {};\n\n  public render() {\n    const props = this.props;\n    const state = this.getState();\n    const {\n      parentPosition,\n      className,\n      target: propsTarget,\n      zoom,\n      cspNonce,\n      translateZ,\n      cssStyled: ControlBoxElement,\n      groupable,\n      linePadding,\n      controlPadding,\n    } = props;\n\n    this._checkUpdateRootContainer();\n    this.checkUpdate();\n    this.updateRenderPoses();\n\n    const [parentLeft, parentTop] = (parentPosition as number[]) || [0, 0];\n    const {\n      left,\n      top,\n      target: stateTarget,\n      direction,\n      hasFixed,\n      offsetDelta,\n    } = state;\n    const groupTargets = (props as any).targets;\n    const isDragging = this.isDragging();\n    const ableAttributes: IObject<boolean> = {};\n    this.getEnabledAbles().forEach((able) => {\n      ableAttributes[`data-able-${able.name.toLowerCase()}`] = true;\n    });\n    const ableClassName = this._getAbleClassName();\n    const isDisplay =\n      (groupTargets && groupTargets.length && (stateTarget || groupable)) ||\n      propsTarget ||\n      (!this._hasFirstTarget && this.state.isPersisted);\n    const isVisible =\n      this.controlBox || this.props.firstRenderState || this.props.persistData;\n    const translate = [left - parentLeft, top - parentTop];\n\n    if (!groupable && props.useAccuratePosition) {\n      translate[0] += offsetDelta[0];\n      translate[1] += offsetDelta[1];\n    }\n    const style: Record<string, any> = {\n      position: hasFixed ? \"fixed\" : \"absolute\",\n      display: isDisplay ? \"block\" : \"none\",\n      visibility: isVisible ? \"visible\" : \"hidden\",\n      transform: `translate3d(${translate[0]}px, ${translate[1]}px, ${translateZ})`,\n      \"--zoom\": zoom,\n      \"--zoompx\": `${zoom}px`,\n    };\n    if (linePadding) {\n      style[\"--moveable-line-padding\"] = linePadding;\n    }\n    if (controlPadding) {\n      style[\"--moveable-control-padding\"] = controlPadding;\n    }\n    return (\n      <ControlBoxElement\n        cspNonce={cspNonce}\n        ref={ref(this, \"controlBox\")}\n        className={`${prefix(\n          \"control-box\",\n          direction === -1 ? \"reverse\" : \"\",\n          isDragging ? \"dragging\" : \"\"\n        )} ${ableClassName} ${className}`}\n        {...ableAttributes}\n        onClick={this._onPreventClick}\n        style={style}\n      >\n        {this.renderAbles()}\n        {this._renderLines()}\n      </ControlBoxElement>\n    );\n  }\n  public componentDidMount() {\n    this.isMoveableMounted = true;\n    this.isUnmounted = false;\n    const props = this.props;\n    const { parentMoveable, container } = props;\n\n    this._checkUpdateRootContainer();\n    this._checkUpdateViewContainer();\n    this._updateTargets();\n    this._updateNativeEvents();\n    this._updateEvents();\n    this.updateCheckInput();\n    this._updateObserver(this.props);\n\n    if (!container && !parentMoveable && !this.state.isPersisted) {\n      this.updateRect(\"\", false, false);\n      this.forceUpdate();\n    }\n  }\n  public componentDidUpdate(prevProps: any) {\n    this._checkUpdateRootContainer();\n    this._checkUpdateViewContainer();\n    this._updateNativeEvents();\n    this._updateTargets();\n    this._updateEvents();\n    this.updateCheckInput();\n    this._updateObserver(prevProps);\n  }\n  public componentWillUnmount() {\n    this.isMoveableMounted = false;\n    this.isUnmounted = true;\n    this._emitter.off();\n    this._reiszeObserver?.disconnect();\n    this._mutationObserver?.disconnect();\n\n    const viewContainer = this._viewContainer;\n\n    if (viewContainer) {\n      this._changeAbleViewClassNames([]);\n    }\n    unsetGesto(this, false);\n    unsetGesto(this, true);\n\n    const events = this.events;\n    for (const name in events) {\n      const manager = events[name];\n      manager && manager.destroy();\n    }\n  }\n  public getTargets(): Array<HTMLElement | SVGElement> {\n    const target = this.props.target;\n    return target ? [target] : [];\n  }\n  /**\n   * Get the able used in MoveableManager.\n   * @method Moveable#getAble\n   * @param - able name\n   */\n  public getAble<T extends Able>(ableName: string): T | undefined {\n    const ables: Able[] = this.props.ables || [];\n\n    return find(ables, (able) => able.name === ableName) as T;\n  }\n  public getContainer(): HTMLElement | SVGElement {\n    const { parentMoveable, wrapperMoveable, container } = this.props;\n\n    return (\n      container! ||\n      (wrapperMoveable && wrapperMoveable.getContainer()) ||\n      (parentMoveable && parentMoveable.getContainer()) ||\n      this.controlBox.parentElement!\n    );\n  }\n  /**\n   * Returns the element of the control box.\n   * @method Moveable#getControlBoxElement\n   */\n  public getControlBoxElement(): HTMLElement {\n    return this.controlBox;\n  }\n  /**\n   * Target element to be dragged in moveable\n   * @method Moveable#getDragElement\n   */\n  public getDragElement(): HTMLElement | SVGElement | null | undefined {\n    return this._dragTarget;\n  }\n  /**\n   * Check if the target is an element included in the moveable.\n   * @method Moveable#isMoveableElement\n   * @param - the target\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * window.addEventListener(\"click\", e => {\n   *     if (!moveable.isMoveableElement(e.target)) {\n   *         moveable.target = e.target;\n   *     }\n   * });\n   */\n  public isMoveableElement(target: Element) {\n    return (\n      target && (target.getAttribute?.(\"class\") || \"\").indexOf(PREFIX) > -1\n    );\n  }\n  /**\n   * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)\n   * @method Moveable#dragStart\n   * @param - external `MouseEvent`or `TouchEvent`\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * document.body.addEventListener(\"mousedown\", e => {\n   *     if (!moveable.isMoveableElement(e.target)) {\n   *          moveable.dragStart(e);\n   *     }\n   * });\n   */\n  public dragStart(\n    e: MouseEvent | TouchEvent,\n    target: EventTarget | null = e.target\n  ) {\n    const targetGesto = this.targetGesto;\n    const controlGesto = this.controlGesto;\n\n    if (targetGesto && checkMoveableTarget(this)({ inputEvent: e }, target)) {\n      if (!targetGesto.isFlag()) {\n        targetGesto.triggerDragStart(e);\n      }\n    } else if (controlGesto && this.isMoveableElement(target as Element)) {\n      if (!controlGesto.isFlag()) {\n        controlGesto.triggerDragStart(e);\n      }\n    }\n    return this;\n  }\n  /**\n   * Hit test an element or rect on a moveable target.\n   * (100% = 100)\n   * @method Moveable#hitTest\n   * @param - element or rect to test\n   * @return - Get hit test rate (rate > 0 is hitted)\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * document.body.addEventListener(\"mousedown\", e => {\n   *     if (moveable.hitTest(e.target) > 0) {\n   *          console.log(\"hiited\");\n   *     }\n   * });\n   */\n  public hitTest(el: Element | HitRect): number {\n    const { target, pos1, pos2, pos3, pos4, targetClientRect } = this.state;\n\n    if (!target) {\n      return 0;\n    }\n    let rect: Required<HitRect>;\n\n    if (isNode(el)) {\n      const clientRect = el.getBoundingClientRect();\n\n      rect = {\n        left: clientRect.left,\n        top: clientRect.top,\n        width: clientRect.width,\n        height: clientRect.height,\n      };\n    } else {\n      rect = { width: 0, height: 0, ...el };\n    }\n\n    const {\n      left: rectLeft,\n      top: rectTop,\n      width: rectWidth,\n      height: rectHeight,\n    } = rect;\n    const points = fitPoints([pos1, pos2, pos4, pos3], targetClientRect);\n    const size = getOverlapSize(points, [\n      [rectLeft, rectTop],\n      [rectLeft + rectWidth, rectTop],\n      [rectLeft + rectWidth, rectTop + rectHeight],\n      [rectLeft, rectTop + rectHeight],\n    ]);\n    const totalSize = getAreaSize(points);\n\n    if (!size || !totalSize) {\n      return 0;\n    }\n\n    return Math.min(100, (size / totalSize) * 100);\n  }\n  /**\n   * Whether the coordinates are inside Moveable\n   * @method Moveable#isInside\n   * @param - x coordinate\n   * @param - y coordinate\n   * @return - True if the coordinate is in moveable or false\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * document.body.addEventListener(\"mousedown\", e => {\n   *     if (moveable.isInside(e.clientX, e.clientY)) {\n   *          console.log(\"inside\");\n   *     }\n   * });\n   */\n  public isInside(clientX: number, clientY: number) {\n    const { target, pos1, pos2, pos3, pos4, targetClientRect } = this.state;\n\n    if (!target) {\n      return false;\n    }\n    return isInside(\n      [clientX, clientY],\n      fitPoints([pos1, pos2, pos4, pos3], targetClientRect)\n    );\n  }\n  /**\n   * If the width, height, left, and top of all elements change, update the shape of the moveable.\n   * @method Moveable#updateRect\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * window.addEventListener(\"resize\", e => {\n   *     moveable.updateRect();\n   * });\n   */\n  public updateRect(\n    type?: \"Start\" | \"\" | \"End\",\n    isTarget?: boolean,\n    isSetState: boolean = true\n  ) {\n    const props = this.props;\n    const isSingle = !props.parentPosition && !props.wrapperMoveable;\n\n    if (isSingle) {\n      setStoreCache(true);\n    }\n    const parentMoveable = props.parentMoveable;\n    const state = this.state;\n    const target = (state.target || props.target) as HTMLElement | SVGElement;\n    const container = this.getContainer();\n    const rootContainer = parentMoveable\n      ? (parentMoveable as any)._rootContainer\n      : this._rootContainer;\n    const nextState = getMoveableTargetInfo(\n      this.controlBox,\n      target,\n      container,\n      container,\n      rootContainer || container,\n      this._getRequestStyles()\n    );\n\n    if (!target && this._hasFirstTarget && props.persistData) {\n      const persistState = getPersistState(props.persistData);\n\n      for (const name in persistState) {\n        (nextState as any)[name] = (persistState as any)[name];\n      }\n    }\n\n    if (isSingle) {\n      setStoreCache();\n    }\n    this.updateState(nextState, parentMoveable ? false : isSetState);\n  }\n  /**\n   * Check if the moveable state is being dragged.\n   * @method Moveable#isDragging\n   * @param - If you want to check if able is dragging, specify ableName.\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * // false\n   * console.log(moveable.isDragging());\n   *\n   * moveable.on(\"drag\", () => {\n   *   // true\n   *   console.log(moveable.isDragging());\n   * });\n   */\n  public isDragging(ableName?: string) {\n    const targetGesto = this.targetGesto;\n    const controlGesto = this.controlGesto;\n\n    if (targetGesto?.isFlag()) {\n      if (!ableName) {\n        return true;\n      }\n      const data = targetGesto.getEventData();\n\n      return !!data[ableName]?.isEventStart;\n    }\n    if (controlGesto?.isFlag()) {\n      if (!ableName) {\n        return true;\n      }\n      const data = controlGesto.getEventData();\n\n      return !!data[ableName]?.isEventStart;\n    }\n    return false;\n  }\n  /**\n   * If the width, height, left, and top of the only target change, update the shape of the moveable.\n   * Use `.updateRect()` method\n   * @method Moveable#updateTarget\n   * @deprecated\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * moveable.updateTarget();\n   */\n  public updateTarget(type?: \"Start\" | \"\" | \"End\") {\n    this.updateRect(type, true);\n  }\n  /**\n   * You can get the vertex information, position and offset size information of the target based on the container.\n   * @method Moveable#getRect\n   * @return - The Rect Info\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * const rectInfo = moveable.getRect();\n   */\n  public getRect(): RectInfo {\n    const state = this.state;\n    const poses = getAbsolutePosesByState(this.state);\n    const [pos1, pos2, pos3, pos4] = poses;\n    const rect = getRect(poses);\n    const { width: offsetWidth, height: offsetHeight } = state;\n    const { width, height, left, top } = rect;\n    const statePos = [state.left, state.top];\n    const origin = plus(statePos, state.origin);\n    const beforeOrigin = plus(statePos, state.beforeOrigin);\n    const transformOrigin = state.transformOrigin;\n\n    return {\n      width,\n      height,\n      left,\n      top,\n      pos1,\n      pos2,\n      pos3,\n      pos4,\n      offsetWidth,\n      offsetHeight,\n      beforeOrigin,\n      origin,\n      transformOrigin,\n      rotation: this.getRotation(),\n    };\n  }\n  /**\n   * Get a manager that manages the moveable's state and props.\n   * @method Moveable#getManager\n   * @return - The Rect Info\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * const manager = moveable.getManager(); // real moveable class instance\n   */\n  public getManager(): MoveableManagerInterface<any, any> {\n    return this as any;\n  }\n  /**\n   * You can stop the dragging currently in progress through a method from outside.\n   * @method Moveable#stopDrag\n   * @return - The Rect Info\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * moveable.stopDrag();\n   */\n  public stopDrag(type?: \"target\" | \"control\"): void {\n    if (!type || type === \"target\") {\n      const gesto = this.targetGesto;\n\n      if (gesto?.isIdle() === false) {\n        unsetAbles(this, false);\n      }\n      gesto?.stop();\n    }\n    if (!type || type === \"control\") {\n      const gesto = this.controlGesto;\n\n      if (gesto?.isIdle() === false) {\n        unsetAbles(this, true);\n      }\n      gesto?.stop();\n    }\n  }\n  public getRotation() {\n    const { pos1, pos2, direction } = this.state;\n\n    return getAbsoluteRotation(pos1, pos2, direction);\n  }\n  /**\n   * Request able through a method rather than an event.\n   * At the moment of execution, requestStart is executed,\n   * and then request and requestEnd can be executed through Requester.\n   * @method Moveable#request\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}\n   * @param - ableName\n   * @param - request to be able params.\n   * @param - If isInstant is true, request and requestEnd are executed immediately.\n   * @return - Able Requester. If there is no request in able, nothing will work.\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * // Instantly Request (requestStart - request - requestEnd)\n   * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n   *\n   * // Start move\n   * const requester = moveable.request(\"draggable\");\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.requestEnd();\n   */\n  public request(\n    ableName: string,\n    param: IObject<any> = {},\n    isInstant?: boolean\n  ): Requester {\n    const self = this;\n    const props = self.props;\n    const manager = props.parentMoveable || props.wrapperMoveable || self;\n    const allAbles = manager.props.ables!;\n    const groupable = props.groupable;\n    const requsetAble = find(allAbles, (able: Able) => able.name === ableName);\n\n    if (this.isDragging() || !requsetAble || !requsetAble.request) {\n      return {\n        request() {\n          return this;\n        },\n        requestEnd() {\n          return this;\n        },\n      };\n    }\n\n    const ableRequester = requsetAble.request(self);\n    const requestInstant = isInstant || param.isInstant;\n    const ableType = ableRequester.isControl ? \"controlAbles\" : \"targetAbles\";\n    const eventAffix = `${groupable ? \"Group\" : \"\"}${\n      ableRequester.isControl ? \"Control\" : \"\"\n    }`;\n    const moveableAbles: Able[] = [...manager[ableType]];\n\n    const requester = {\n      request(ableParam: IObject<any>) {\n        triggerAble(\n          self,\n          moveableAbles,\n          [\"drag\"],\n          eventAffix,\n          \"\",\n          {\n            ...ableRequester.request(ableParam),\n            requestAble: ableName,\n            isRequest: true,\n          },\n          requestInstant\n        );\n        return requester;\n      },\n      requestEnd() {\n        triggerAble(\n          self,\n          moveableAbles,\n          [\"drag\"],\n          eventAffix,\n          \"End\",\n          {\n            ...ableRequester.requestEnd(),\n            requestAble: ableName,\n            isRequest: true,\n          },\n          requestInstant\n        );\n        return requester;\n      },\n    };\n\n    triggerAble(\n      self,\n      moveableAbles,\n      [\"drag\"],\n      eventAffix,\n      \"Start\",\n      {\n        ...ableRequester.requestStart(param),\n        requestAble: ableName,\n        isRequest: true,\n      },\n      requestInstant\n    );\n\n    return requestInstant ? requester.request(param).requestEnd() : requester;\n  }\n  /**\n   * moveable is the top level that manages targets\n   * `Single`: MoveableManager instance\n   * `Group`: MoveableGroup instance\n   * `IndividualGroup`: MoveableIndividaulGroup instance\n   * Returns leaf target MoveableManagers.\n   */\n  public getMoveables(): MoveableManagerInterface[] {\n    return [this];\n  }\n  /**\n   * Remove the Moveable object and the events.\n   * @method Moveable#destroy\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * moveable.destroy();\n   */\n  public destroy(): void {\n    this.componentWillUnmount();\n  }\n  public updateRenderPoses() {\n    const state = this.getState();\n    const props = this.props;\n    const padding = props.padding;\n    const {\n      originalBeforeOrigin,\n      transformOrigin,\n      allMatrix,\n      is3d,\n      pos1,\n      pos2,\n      pos3,\n      pos4,\n      left: stateLeft,\n      top: stateTop,\n      isPersisted,\n    } = state;\n    const zoom = props.zoom || 1;\n\n    if (!padding && zoom <= 1) {\n      state.renderPoses = [pos1, pos2, pos3, pos4];\n      state.renderLines = [\n        [pos1, pos2],\n        [pos2, pos4],\n        [pos4, pos3],\n        [pos3, pos1],\n      ];\n      return;\n    }\n    const { left, top, bottom, right } = getPaddingBox(padding || {});\n    const n = is3d ? 4 : 3;\n\n    // const clipPathInfo = getClipPath(\n    //     props.target,\n    //     offsetWidth,\n    //     offsetHeight,\n    // );\n\n    // if (clipPathInfo) {\n    //     left -= Math.max(0, clipPathInfo.left);\n    //     top -= Math.max(0, clipPathInfo.top);\n    //     bottom -= Math.max(0, offsetHeight - clipPathInfo.bottom);\n    //     right -= Math.max(0, offsetWidth - clipPathInfo.right);\n    // }\n\n    let absoluteOrigin: number[] = [];\n\n    if (isPersisted) {\n      absoluteOrigin = transformOrigin;\n    } else if (this.controlBox && props.groupable) {\n      absoluteOrigin = originalBeforeOrigin;\n    } else {\n      absoluteOrigin = plus(originalBeforeOrigin, [stateLeft, stateTop]);\n    }\n\n    const nextMatrix = multiplies(\n      n,\n      createOriginMatrix(\n        absoluteOrigin.map((v) => -v),\n        n\n      ),\n      allMatrix,\n      createOriginMatrix(transformOrigin, n)\n    );\n\n    const renderPos1 = calculatePadding(nextMatrix, pos1, [-left, -top], n);\n    const renderPos2 = calculatePadding(nextMatrix, pos2, [right, -top], n);\n    const renderPos3 = calculatePadding(nextMatrix, pos3, [-left, bottom], n);\n    const renderPos4 = calculatePadding(nextMatrix, pos4, [right, bottom], n);\n\n    state.renderPoses = [renderPos1, renderPos2, renderPos3, renderPos4];\n    state.renderLines = [\n      [renderPos1, renderPos2],\n      [renderPos2, renderPos4],\n      [renderPos4, renderPos3],\n      [renderPos3, renderPos1],\n    ];\n\n    if (zoom) {\n      const zoomOffset = zoom / 2;\n\n      state.renderLines = [\n        [\n          calculatePadding(nextMatrix, pos1, [-left - zoomOffset, -top], n),\n          calculatePadding(nextMatrix, pos2, [right + zoomOffset, -top], n),\n        ],\n        [\n          calculatePadding(nextMatrix, pos2, [right, -top - zoomOffset], n),\n          calculatePadding(nextMatrix, pos4, [right, bottom + zoomOffset], n),\n        ],\n        [\n          calculatePadding(nextMatrix, pos4, [right + zoomOffset, bottom], n),\n          calculatePadding(nextMatrix, pos3, [-left - zoomOffset, bottom], n),\n        ],\n        [\n          calculatePadding(nextMatrix, pos3, [-left, bottom + zoomOffset], n),\n          calculatePadding(nextMatrix, pos1, [-left, -top - zoomOffset], n),\n        ],\n      ];\n    }\n  }\n  public checkUpdate() {\n    this._isPropTargetChanged = false;\n    const { target, container, parentMoveable } = this.props;\n    const { target: stateTarget, container: stateContainer } = this.state;\n\n    if (!stateTarget && !target) {\n      return;\n    }\n    this.updateAbles();\n\n    const isTargetChanged = !equals(stateTarget, target);\n    const isChanged = isTargetChanged || !equals(stateContainer, container);\n\n    if (!isChanged) {\n      return;\n    }\n    const moveableContainer = container || this.controlBox;\n\n    if (moveableContainer) {\n      this.unsetAbles();\n    }\n    this.updateState({ target, container });\n\n    if (!parentMoveable && moveableContainer) {\n      this.updateRect(\"End\", false, false);\n    }\n    this._isPropTargetChanged = isTargetChanged;\n  }\n  public waitToChangeTarget(): Promise<void> {\n    return new Promise(() => {});\n  }\n  public triggerEvent(name: string, e: any): any {\n    const props = this.props;\n\n    this._emitter.trigger(name, e);\n\n    if (props.parentMoveable && e.isRequest && !e.isRequestChild) {\n      return props.parentMoveable.triggerEvent(name, e, true);\n    }\n\n    const callback = (props as any)[name];\n\n    return callback && callback(e);\n  }\n  public useCSS(tag: string, css: string) {\n    const customStyleMap = this.props.customStyledMap as Record<string, any>;\n\n    const key = tag + css;\n\n    if (!customStyleMap[key]) {\n      customStyleMap[key] = styled(tag, css);\n    }\n    return customStyleMap[key];\n  }\n  public checkUpdateRect = () => {\n    if (this.isDragging()) {\n      return;\n    }\n    const parentMoveable = this.props.parentMoveable;\n\n    if (parentMoveable) {\n      (parentMoveable as any).checkUpdateRect();\n      return;\n    }\n    cancelAnimationFrame(this._observerId);\n    this._observerId = requestAnimationFrame(() => {\n      if (this.isDragging()) {\n        return;\n      }\n      this.updateRect();\n    });\n  };\n  public getState(): MoveableManagerState {\n    const props = this.props;\n    if (props.target || (props as any).targets?.length) {\n      this._hasFirstTarget = true;\n    }\n    const hasControlBox = this.controlBox;\n    const persistData = props.persistData;\n    const firstRenderState = props.firstRenderState;\n\n    if (firstRenderState && !hasControlBox) {\n      return firstRenderState;\n    }\n    if (!this._hasFirstTarget && persistData) {\n      const persistState = getPersistState(persistData);\n\n      if (persistState) {\n        this.updateState(persistState, false);\n        return this.state;\n      }\n    }\n    (this.state as any).isPersisted = false;\n    return this.state;\n  }\n  public updateSelectors() {}\n  protected unsetAbles() {\n    this.targetAbles.forEach((able) => {\n      if (able.unset) {\n        able.unset(this);\n      }\n    });\n  }\n  protected updateAbles(\n    ables: Able[] = this.props.ables!,\n    eventAffix: string = \"\"\n  ) {\n    const props = this.props as any;\n    const triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n    const enabledAbles = this.getEnabledAbles(ables);\n\n    const dragStart = `drag${eventAffix}Start` as \"dragStart\";\n    const pinchStart = `pinch${eventAffix}Start` as \"pinchStart\";\n    const dragControlStart =\n      `drag${eventAffix}ControlStart` as \"dragControlStart\";\n\n    const targetAbles = filterAbles(\n      enabledAbles,\n      [dragStart, pinchStart],\n      triggerAblesSimultaneously\n    );\n    const controlAbles = filterAbles(\n      enabledAbles,\n      [dragControlStart],\n      triggerAblesSimultaneously\n    );\n\n    this.enabledAbles = enabledAbles;\n    this.targetAbles = targetAbles;\n    this.controlAbles = controlAbles;\n  }\n  protected updateState(nextState: any, isSetState?: boolean) {\n    if (isSetState) {\n      if (this.isUnmounted) {\n        return;\n      }\n      this.setState(nextState);\n    } else {\n      const state = this.state;\n\n      for (const name in nextState) {\n        (state as any)[name] = nextState[name];\n      }\n    }\n  }\n  protected getEnabledAbles(ables: Able[] = this.props.ables!) {\n    const props = this.props as any;\n\n    return ables.filter(\n      (able) =>\n        able &&\n        ((able.always && props[able.name] !== false) || props[able.name])\n    );\n  }\n  protected renderAbles() {\n    const props = this.props as any;\n    const triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n    const Renderer = {\n      createElement,\n    };\n\n    this.renderState = {};\n\n    return groupByMap(\n      flat<any>(\n        filterAbles(\n          this.getEnabledAbles(),\n          [\"render\"],\n          triggerAblesSimultaneously\n        ).map(({ render }) => {\n          return render!(this, Renderer) || [];\n        })\n      ).filter((el) => el),\n      ({ key }) => key\n    ).map((group) => group[0]);\n  }\n  protected updateCheckInput() {\n    this.targetGesto &&\n      (this.targetGesto.options.checkInput = this.props.checkInput);\n  }\n  protected _getRequestStyles() {\n    const styleNames = this.getEnabledAbles().reduce(\n      (names, able) => {\n        const ableStyleNames = (able.requestStyle?.() ?? []) as Array<\n          keyof CSSStyleDeclaration\n        >;\n\n        return [...names, ...ableStyleNames];\n      },\n      [...(this.props.requestStyles || [])] as Array<keyof CSSStyleDeclaration>\n    );\n\n    return styleNames;\n  }\n  protected _updateObserver(prevProps: MoveableDefaultOptions) {\n    this._updateResizeObserver(prevProps);\n    this._updateMutationObserver(prevProps);\n  }\n  protected _updateEvents() {\n    const hasTargetAble = this.targetAbles.length;\n    const hasControlAble = this.controlAbles.length;\n    const target = this._dragTarget;\n    const isUnset =\n      (!hasTargetAble && this.targetGesto) || this._isTargetChanged(true);\n\n    if (isUnset) {\n      unsetGesto(this, false);\n      this.updateState({ gestos: {} });\n    }\n    if (!hasControlAble) {\n      unsetGesto(this, true);\n    }\n\n    if (target && hasTargetAble && !this.targetGesto) {\n      this.targetGesto = getTargetAbleGesto(this, target!, \"\");\n    }\n    if (!this.controlGesto && hasControlAble) {\n      this.controlGesto = getControlAbleGesto(this, \"Control\");\n    }\n  }\n  protected _updateTargets() {\n    const props = this.props;\n\n    this._prevPropTarget = this._propTarget;\n    this._prevDragTarget = this._dragTarget;\n    this._prevOriginalDragTarget = this._originalDragTarget;\n    this._prevDragArea = props.dragArea!;\n\n    this._propTarget = props.target;\n    this._originalDragTarget = props.dragTarget || props.target;\n    this._dragTarget = getRefTarget(this._originalDragTarget, true);\n  }\n  private _renderLines() {\n    const props = this.props;\n    const {\n      zoom,\n      hideDefaultLines,\n      hideChildMoveableDefaultLines,\n      parentMoveable,\n    } = props as MoveableManagerProps<GroupableProps>;\n\n    if (hideDefaultLines || (parentMoveable && hideChildMoveableDefaultLines)) {\n      return [];\n    }\n    const state = this.getState();\n    const Renderer = {\n      createElement,\n    };\n\n    return state.renderLines.map((line, i) => {\n      return renderLine(\n        Renderer,\n        \"\",\n        line[0],\n        line[1],\n        zoom!,\n        `render-line-${i}`\n      );\n    });\n  }\n  private _onPreventClick = (e: any) => {\n    e.stopPropagation();\n    e.preventDefault();\n    // removeEvent(window, \"click\", this._onPreventClick, true);\n  };\n  private _isTargetChanged(useDragArea?: boolean) {\n    const props = this.props;\n    const nextTarget = props.dragTarget || props.target;\n    const prevTarget = this._prevOriginalDragTarget;\n    const prevDragArea = this._prevDragArea;\n    const dragArea = props.dragArea;\n\n    // check target without dragArea\n    const isDragTargetChanged = !dragArea && prevTarget !== nextTarget;\n    const isDragAreaChanged =\n      (useDragArea || dragArea) && prevDragArea !== dragArea;\n\n    return (\n      isDragTargetChanged ||\n      isDragAreaChanged ||\n      this._prevPropTarget != this._propTarget\n    );\n  }\n  private _updateNativeEvents() {\n    const props = this.props;\n    const target = props.dragArea ? this.areaElement : this.state.target;\n    const events = this.events;\n    const eventKeys = getKeys(events);\n\n    if (this._isTargetChanged()) {\n      for (const eventName in events) {\n        const manager = events[eventName];\n        manager && manager.destroy();\n        events[eventName] = null;\n      }\n    }\n    if (!target) {\n      return;\n    }\n    const enabledAbles = this.enabledAbles;\n    eventKeys.forEach((eventName) => {\n      const ables = filterAbles(enabledAbles, [eventName] as any);\n      const hasAbles = ables.length > 0;\n      let manager = events[eventName];\n\n      if (!hasAbles) {\n        if (manager) {\n          manager.destroy();\n          events[eventName] = null;\n        }\n        return;\n      }\n      if (!manager) {\n        manager = new EventManager(target, this, eventName);\n        events[eventName] = manager;\n      }\n      manager.setAbles(ables);\n    });\n  }\n  private _checkUpdateRootContainer() {\n    const rootContainer = this.props.rootContainer;\n\n    if (!this._rootContainer && rootContainer) {\n      this._rootContainer = getRefTarget(rootContainer, true);\n    }\n  }\n  private _checkUpdateViewContainer() {\n    const viewContainerOption = this.props.viewContainer;\n\n    if (!this._viewContainer && viewContainerOption) {\n      this._viewContainer = getRefTarget(viewContainerOption, true);\n    }\n    const viewContainer = this._viewContainer;\n\n    if (viewContainer) {\n      this._changeAbleViewClassNames([\n        ...this._getAbleViewClassNames(),\n        this.isDragging() ? VIEW_DRAGGING : \"\",\n      ]);\n    }\n  }\n  private _changeAbleViewClassNames(classNames: string[]) {\n    const viewContainer = this._viewContainer!;\n    const nextClassNames = groupBy(classNames.filter(Boolean), (el) => el).map(\n      ([className]) => className\n    );\n    const prevClassNames = this._viewClassNames;\n\n    const { removed, added } = diff(prevClassNames, nextClassNames);\n\n    removed.forEach((index) => {\n      removeClass(viewContainer, prevClassNames[index]);\n    });\n    added.forEach((index) => {\n      addClass(viewContainer, nextClassNames[index]);\n    });\n\n    this._viewClassNames = nextClassNames;\n  }\n  private _getAbleViewClassNames() {\n    return (\n      this.getEnabledAbles()\n        .map((able) => {\n          return able.viewClassName?.(this) || \"\";\n        })\n        .join(\" \") + ` ${this._getAbleClassName(\"-view\")}`\n    ).split(/\\s+/g);\n  }\n  private _getAbleClassName(classPrefix = \"\") {\n    const ables = this.getEnabledAbles();\n\n    const targetGesto = this.targetGesto;\n    const controlGesto = this.controlGesto;\n    const targetGestoData: Record<string, any> = targetGesto?.isFlag()\n      ? targetGesto.getEventData()\n      : {};\n    const controlGestoData: Record<string, any> = controlGesto?.isFlag()\n      ? controlGesto.getEventData()\n      : {};\n\n    return ables\n      .map((able) => {\n        const name = able.name;\n        let className = able.className?.(this) || \"\";\n\n        if (\n          targetGestoData[name]?.isEventStart ||\n          controlGestoData[name]?.isEventStart\n        ) {\n          className += ` ${prefix(`${name}${classPrefix}-dragging`)}`;\n        }\n        return className.trim();\n      })\n      .filter(Boolean)\n      .join(\" \");\n  }\n  private _updateResizeObserver(prevProps: MoveableDefaultOptions) {\n    const props = this.props;\n    const target = props.target;\n    const win = getWindow(this.getControlBoxElement());\n\n    if (!win.ResizeObserver || !target || !props.useResizeObserver) {\n      this._reiszeObserver?.disconnect();\n      return;\n    }\n\n    if (prevProps.target === target && this._reiszeObserver) {\n      return;\n    }\n\n    const observer = new win.ResizeObserver(this.checkUpdateRect);\n\n    observer.observe(target!, {\n      box: \"border-box\",\n    });\n    this._reiszeObserver = observer;\n  }\n  private _updateMutationObserver(prevProps: MoveableDefaultOptions) {\n    const props = this.props;\n    const target = props.target;\n    const win = getWindow(this.getControlBoxElement());\n\n    if (!win.MutationObserver || !target || !props.useMutationObserver) {\n      this._mutationObserver?.disconnect();\n      return;\n    }\n\n    if (prevProps.target === target && this._mutationObserver) {\n      return;\n    }\n\n    const observer = new win.MutationObserver((records) => {\n      for (const mutation of records) {\n        if (\n          mutation.type === \"attributes\" &&\n          mutation.attributeName === \"style\"\n        ) {\n          this.checkUpdateRect();\n        }\n      }\n    });\n\n    observer.observe(target!, {\n      attributes: true,\n    });\n    this._mutationObserver = observer;\n  }\n}\n\n/**\n * The target to indicate Moveable Control Box.\n * @name Moveable#target\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n */\n/**\n * Zooms in the elements of a moveable.\n * @name Moveable#zoom\n * @default 1\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.zoom = 2;\n */\n\n/**\n * Whether the target size is detected and updated whenever it changes.\n * @name Moveable#useResizeObserver\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.useResizeObserver = true;\n */\n\n/**\n * Resize, Scale Events at edges\n * @name Moveable#edge\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.edge = true;\n */\n\n/**\n * You can specify the className of the moveable controlbox.\n * @name Moveable#className\n * @default \"\"\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   className: \"\",\n * });\n *\n * moveable.className = \"moveable1\";\n */\n\n/**\n * The target(s) to drag Moveable target(s)\n * @name Moveable#dragTarget\n * @default target\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n * moveable.dragTarget = document.querySelector(\".dragTarget\");\n */\n\n/**\n * `renderStart` event occurs at the first start of all events.\n * @memberof Moveable\n * @event renderStart\n * @param {Moveable.OnRenderStart} - Parameters for the `renderStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderStart\", ({ target }) => {\n *     console.log(\"onRenderStart\", target);\n * });\n */\n\n/**\n * `render` event occurs before the target is drawn on the screen.\n * @memberof Moveable\n * @event render\n * @param {Moveable.OnRender} - Parameters for the `render` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"render\", ({ target }) => {\n *     console.log(\"onRender\", target);\n * });\n */\n\n/**\n * `renderEnd` event occurs at the end of all events.\n * @memberof Moveable\n * @event renderEnd\n * @param {Moveable.OnRenderEnd} - Parameters for the `renderEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderEnd\", ({ target }) => {\n *     console.log(\"onRenderEnd\", target);\n * });\n */\n\n/**\n * `renderGroupStart` event occurs at the first start of all events in group.\n * @memberof Moveable\n * @event renderGroupStart\n * @param {Moveable.OnRenderGroupStart} - Parameters for the `renderGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupStart\", ({ targets }) => {\n *     console.log(\"onRenderGroupStart\", targets);\n * });\n */\n\n/**\n * `renderGroup` event occurs before the target is drawn on the screen in group.\n * @memberof Moveable\n * @event renderGroup\n * @param {Moveable.OnRenderGroup} - Parameters for the `renderGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroup\", ({ targets }) => {\n *     console.log(\"onRenderGroup\", targets);\n * });\n */\n\n/**\n * `renderGroupEnd` event occurs at the end of all events in group.\n * @memberof Moveable\n * @event renderGroupEnd\n * @param {Moveable.OnRenderGroupEnd} - Parameters for the `renderGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupEnd\", ({ targets }) => {\n *     console.log(\"onRenderGroupEnd\", targets);\n * });\n */\n","import { minus } from \"../../matrix\";\nimport { refs } from \"../../utility/framework\";\nimport MoveableManager from \"../moveable-manager\";\nimport { renderLine } from \"../render-directions\";\nimport { Renderer, MoveableGroupInterface, GroupableProps } from \"../types\";\nimport { flat, watchValue } from \"../utils\";\n\nexport default {\n  name: \"groupable\",\n  props: [\n    \"defaultGroupRotate\",\n    \"useDefaultGroupRotate\",\n    \"defaultGroupOrigin\",\n    \"groupable\",\n    \"groupableProps\",\n    \"targetGroups\",\n    \"hideChildMoveableDefaultLines\",\n  ] as const,\n  events: [] as const,\n  render(\n    moveable: MoveableGroupInterface<GroupableProps>,\n    React: Renderer\n  ): any[] {\n    const props = moveable.props;\n    let targets: Array<HTMLElement | SVGElement | undefined | null> =\n      props.targets || [];\n\n    const { left, top, isPersisted } = moveable.getState();\n    const zoom = props.zoom || 1;\n    const renderGroupRects = moveable.renderGroupRects;\n    let persistDatChildren = props.persistData?.children || [];\n\n    if (isPersisted) {\n      targets = persistDatChildren.map(() => null);\n    } else {\n      persistDatChildren = [];\n    }\n    const parentPosition = watchValue(\n      moveable,\n      \"parentPosition\",\n      [left, top],\n      (styles) => styles.join(\",\")\n    );\n    const requestStyles = watchValue(\n      moveable,\n      \"requestStyles\",\n      moveable.getRequestChildStyles(),\n      (styles) => styles.join(\",\")\n    );\n\n    moveable.moveables = moveable.moveables.slice(0, targets.length);\n    return [\n      ...targets.map((target, i) => {\n        return (\n          <MoveableManager<GroupableProps>\n            key={\"moveable\" + i}\n            ref={refs(moveable, \"moveables\", i)}\n            target={target}\n            origin={false}\n            requestStyles={requestStyles}\n            cssStyled={props.cssStyled}\n            customStyledMap={props.customStyledMap}\n            useResizeObserver={props.useResizeObserver}\n            useMutationObserver={props.useMutationObserver}\n            hideChildMoveableDefaultLines={props.hideChildMoveableDefaultLines}\n            parentMoveable={moveable}\n            parentPosition={[left, top]}\n            persistData={persistDatChildren[i]}\n            zoom={zoom}\n          />\n        );\n      }),\n      ...flat(\n        renderGroupRects.map(({ pos1, pos2, pos3, pos4 }, i) => {\n          const poses = [pos1, pos2, pos3, pos4];\n\n          return [\n            [0, 1],\n            [1, 3],\n            [3, 2],\n            [2, 0],\n          ].map(([from, to], j) => {\n            return renderLine(\n              React,\n              \"\",\n              minus(poses[from], parentPosition),\n              minus(poses[to], parentPosition),\n              zoom,\n              `group-rect-${i}-${j}`\n            );\n          });\n        })\n      ),\n    ];\n  },\n};\n","import {\n  MoveableManagerInterface,\n  MoveableGroupInterface,\n  ClickableProps,\n  OnClick,\n  OnClickGroup,\n} from \"../types\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport { findIndex } from \"../../utility\";\nimport { makeAble } from \"./able-manager\";\n\nexport default makeAble(\"clickable\", {\n  props: [\"clickable\"] as const,\n  events: [\"click\", \"clickGroup\"] as const,\n  always: true,\n  dragRelation: \"weak\",\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  dragStart() {\n    return;\n  },\n  dragControlStart() {\n    return;\n  },\n  dragGroupStart(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n    e.datas.inputTarget = e.inputEvent && e.inputEvent.target;\n  },\n  dragEnd(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n    const target = moveable.props.target!;\n    const inputEvent = e.inputEvent;\n    const inputTarget = e.inputTarget;\n    const isMoveableElement = moveable.isMoveableElement(inputTarget);\n    const containsElement =\n      !isMoveableElement && moveable.controlBox.contains(inputTarget);\n\n    if (\n      !inputEvent ||\n      !inputTarget ||\n      e.isDrag ||\n      moveable.isMoveableElement(inputTarget) ||\n      containsElement\n      // External event duplicate target or dragAreaElement\n    ) {\n      return;\n    }\n    const containsTarget = target.contains(inputTarget);\n\n    triggerEvent(\n      moveable,\n      \"onClick\",\n      fillParams<OnClick>(moveable, e, {\n        isDouble: e.isDouble,\n        inputTarget,\n        isTarget: target === inputTarget,\n        moveableTarget: moveable.props.target!,\n        containsTarget,\n      })\n    );\n  },\n  dragGroupEnd(moveable: MoveableGroupInterface<ClickableProps>, e: any) {\n    const inputEvent = e.inputEvent;\n    const inputTarget = e.inputTarget;\n\n    if (\n      !inputEvent ||\n      !inputTarget ||\n      e.isDrag ||\n      moveable.isMoveableElement(inputTarget) ||\n      // External event duplicate target or dragAreaElement\n      e.datas.inputTarget === inputTarget\n    ) {\n      return;\n    }\n    const targets = moveable.props.targets!;\n    let targetIndex = targets.indexOf(inputTarget);\n    const isTarget = targetIndex > -1;\n    let containsTarget = false;\n\n    if (targetIndex === -1) {\n      targetIndex = findIndex(targets, (parentTarget) =>\n        parentTarget.contains(inputTarget)\n      );\n      containsTarget = targetIndex > -1;\n    }\n\n    triggerEvent(\n      moveable,\n      \"onClickGroup\",\n      fillParams<OnClickGroup>(moveable, e, {\n        isDouble: e.isDouble,\n        targets,\n        inputTarget,\n        targetIndex,\n        isTarget,\n        containsTarget,\n        moveableTarget: targets[targetIndex],\n      })\n    );\n  },\n  dragControlEnd(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n    this.dragEnd(moveable, e);\n  },\n  dragGroupControlEnd(\n    moveable: MoveableManagerInterface<ClickableProps>,\n    e: any\n  ) {\n    this.dragEnd(moveable, e);\n  },\n});\n\n/**\n * When you click on the element, the `click` event is called.\n * @memberof Moveable\n * @event click\n * @param {Moveable.OnClick} - Parameters for the `click` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"click\", ({ hasTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", target, hasTarget, containsTarget, targetIndex);\n * });\n */\n\n/**\n * When you click on the element inside the group, the `clickGroup` event is called.\n * @memberof Moveable\n * @event clickGroup\n * @param {Moveable.OnClickGroup} - Parameters for the `clickGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"clickGroup\", ({ inputTarget, isTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", inputTarget, isTarget, containsTarget, targetIndex);\n * });\n */\n","import { hasClass } from \"../../utility\";\nimport {\n  DraggableProps,\n  MoveableGroupInterface,\n  MoveableManagerInterface,\n  Renderer,\n} from \"../types\";\nimport { prefix } from \"../utils\";\nimport Draggable from \"./draggable\";\nimport { makeAble } from \"./able-manager\";\nimport { renderEdgeLines } from \"../render-directions\";\n\nfunction getDraggableEvent(e: any) {\n  let datas = e.originalDatas.draggable;\n  if (!datas) {\n    e.originalDatas.draggable = {};\n    datas = e.originalDatas.draggable;\n  }\n  return { ...e, datas };\n}\nexport default makeAble(\"edgeDraggable\", {\n  css: [\n    `.edge.edgeDraggable.line {\ncursor: move;\n}`,\n  ],\n  render(moveable: MoveableManagerInterface<DraggableProps>, React: Renderer) {\n    const props = moveable.props;\n    const edge = props.edgeDraggable!;\n\n    if (!edge) {\n      return [];\n    }\n    return renderEdgeLines(\n      React,\n      \"edgeDraggable\",\n      edge,\n      moveable.getState().renderPoses,\n      props.zoom!\n    );\n  },\n  dragCondition(moveable: MoveableManagerInterface<DraggableProps>, e: any) {\n    const props = moveable.props;\n    const target = e.inputEvent?.target;\n\n    if (!props.edgeDraggable || !target) {\n      return false;\n    }\n\n    return (\n      !props.draggable &&\n      hasClass(target, prefix(\"direction\")) &&\n      hasClass(target, prefix(\"edge\")) &&\n      hasClass(target, prefix(\"edgeDraggable\"))\n    );\n  },\n  dragStart(moveable: MoveableManagerInterface<DraggableProps>, e: any) {\n    return Draggable.dragStart(moveable, getDraggableEvent(e));\n  },\n  drag(moveable: MoveableManagerInterface<DraggableProps>, e: any) {\n    return Draggable.drag(moveable, getDraggableEvent(e));\n  },\n  dragEnd(moveable: MoveableManagerInterface<DraggableProps, any>, e: any) {\n    return Draggable.dragEnd(moveable, getDraggableEvent(e));\n  },\n  dragGroupCondition(moveable: MoveableGroupInterface<DraggableProps>, e: any) {\n    const props = moveable.props;\n    const target = e.inputEvent?.target;\n\n    if (!props.edgeDraggable || !target) {\n      return false;\n    }\n    return (\n      !props.draggable &&\n      hasClass(target, prefix(\"direction\")) &&\n      hasClass(target, prefix(\"line\"))\n    );\n  },\n  dragGroupStart(moveable: MoveableGroupInterface<DraggableProps>, e: any) {\n    return Draggable.dragGroupStart(moveable, getDraggableEvent(e));\n  },\n  dragGroup(moveable: MoveableGroupInterface<DraggableProps>, e: any) {\n    return Draggable.dragGroup(moveable, getDraggableEvent(e));\n  },\n  dragGroupEnd(moveable: MoveableGroupInterface<DraggableProps, any>, e: any) {\n    return Draggable.dragGroupEnd(moveable, getDraggableEvent(e));\n  },\n  unset(moveable: any) {\n    return Draggable.unset(moveable);\n  },\n});\n\n/**\n * Whether to move by dragging the edge line (default: false)\n * @name Moveable.Draggable#edgeDraggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  draggable: true,\n *  edgeDraggable: false,\n * });\n *\n * moveable.edgeDraggable = true;\n */\n","export default {\n  name: \"individualGroupable\",\n  props: [\"individualGroupable\", \"individualGroupableProps\"] as const,\n  events: [] as const,\n} as const;\n","import Pinchable from \"./pinchable\";\nimport Rotatable from \"./rotatable\";\nimport Draggable from \"./draggable\";\nimport Resizable from \"./resizable\";\nimport Scalable from \"./scalable\";\nimport Warpable from \"./warpable\";\nimport Snappable from \"./snappable\";\nimport DragArea from \"./drag-area\";\nimport Origin from \"./Origin\";\nimport Scrollable from \"./scrollable\";\nimport Default from \"./default\";\nimport Padding from \"./padding\";\nimport Clippable from \"./clippable\";\nimport OriginDraggable from \"./origin-draggable\";\nimport Roundable from \"./roundable\";\nimport Groupable from \"./groupable\";\nimport BeforeRenderable from \"./before-renderable\";\nimport Renderable from \"./renderable\";\nimport Clickable from \"./clickable\";\nimport edgeDraggable from \"./edge-draggable\";\nimport IndividualGroupable from \"./individual-groupable\";\nimport { camelize, pushSet } from \"../../utility\";\nimport { Able } from \"../types\";\n\nexport const MOVEABLE_ABLES = /*#__PURE__*/ [\n  BeforeRenderable,\n  Default,\n  Snappable,\n  Pinchable,\n  Draggable,\n  edgeDraggable,\n  Resizable,\n  Scalable,\n  Warpable,\n  Rotatable,\n  Scrollable,\n  Padding,\n  Origin,\n  OriginDraggable,\n  Clippable,\n  Roundable,\n  Groupable,\n  IndividualGroupable,\n  Clickable,\n  DragArea,\n  Renderable,\n] as const;\n\nexport const MOVEABLE_EVENTS = /*#__PURE__*/ (\n  MOVEABLE_ABLES as readonly Able[]\n).reduce((current, able) => {\n  (able.events || []).forEach((name) => {\n    pushSet(current, name);\n  });\n  return current;\n}, [] as any[]) as Array<(typeof MOVEABLE_ABLES)[number][\"events\"][number]>;\n\nexport const MOVEABLE_PROPS = /*#__PURE__*/ (\n  MOVEABLE_ABLES as readonly Able[]\n).reduce((current, able) => {\n  (able.props || []).forEach((name) => {\n    pushSet(current, name);\n  });\n  return current;\n}, [] as any[]) as Array<(typeof MOVEABLE_ABLES)[number][\"props\"][number]>;\n\nexport const MOVEABLE_REACT_EVENTS = /*#__PURE__*/ MOVEABLE_EVENTS.map(\n  (name) => {\n    return camelize(`on ${name}`);\n  }\n) as Array<`on${Capitalize<\n  (typeof MOVEABLE_ABLES)[number][\"events\"][number]\n>}`>;\n","export function solveConstantsDistance(\n  [a, b, c]: [number, number, number],\n  pos: number[]\n) {\n  return (a * pos[0] + b * pos[1] + c) / Math.sqrt(a * a + b * b);\n}\n\nexport function solveC([a, b]: [number, number], pos: number[]) {\n  // ax + by + c = 0\n  // -ax -by;\n  return -a * pos[0] - b * pos[1];\n}\n","import MoveableManager from \"./moveable-manager\";\nimport {\n  GroupableProps,\n  GroupRect,\n  MoveableManagerInterface,\n  MoveableTargetGroupsType,\n  RectInfo,\n} from \"./types\";\nimport ChildrenDiffer from \"../differ/children-differ\";\nimport {\n  getControlAbleGesto,\n  getTargetAbleGesto,\n} from \"./gesto/get-able-gesto\";\nimport Groupable from \"./ables/groupable\";\nimport { MIN_NUM, MAX_NUM, TINY_NUM } from \"./consts\";\nimport {\n  getAbsolutePosesByState,\n  equals,\n  unsetGesto,\n  rotatePosesInfo,\n  convertTransformOriginArray,\n  isDeepArrayEquals,\n  sign,\n  getRefTarget,\n} from \"./utils\";\nimport { minus, plus } from \"../matrix\";\nimport { getIntersectionPointsByConstants, getMinMaxs } from \"../overlap-area\";\nimport { find, isArray, throttle } from \"../utility\";\nimport { getMoveableTargetInfo } from \"./utils/get-moveable-target-info\";\nimport { solveC, solveConstantsDistance } from \"./snappable/utils\";\nimport { setStoreCache } from \"./store/store\";\n\nfunction getMaxPos(poses: number[][][], index: number) {\n  return Math.max(\n    ...poses.map(([pos1, pos2, pos3, pos4]) => {\n      return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\n    })\n  );\n}\nfunction getMinPos(poses: number[][][], index: number) {\n  return Math.min(\n    ...poses.map(([pos1, pos2, pos3, pos4]) => {\n      return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\n    })\n  );\n}\n\nfunction getGroupRect(parentPoses: number[][][], rotation: number): GroupRect {\n  let pos1 = [0, 0];\n  let pos2 = [0, 0];\n  let pos3 = [0, 0];\n  let pos4 = [0, 0];\n  let width = 0;\n  let height = 0;\n\n  if (!parentPoses.length) {\n    return {\n      pos1,\n      pos2,\n      pos3,\n      pos4,\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0,\n      width,\n      height,\n      rotation,\n    };\n  }\n  const fixedRotation = throttle(rotation, TINY_NUM);\n\n  if (fixedRotation % 90) {\n    const rad = (fixedRotation / 180) * Math.PI;\n    const a1 = Math.tan(rad);\n    const a2 = -1 / a1;\n    // ax = y  // -ax + y = 0 // 0 => 1\n    // -ax = y // ax + y = 0  // 0 => 3\n    const a1MinMax = [MAX_NUM, MIN_NUM];\n    const a1MinMaxPos = [\n      [0, 0],\n      [0, 0],\n    ];\n    const a2MinMax = [MAX_NUM, MIN_NUM];\n    const a2MinMaxPos = [\n      [0, 0],\n      [0, 0],\n    ];\n\n    parentPoses.forEach((poses) => {\n      poses.forEach((pos) => {\n        // const b1 = pos[1] - a1 * pos[0];\n        // const b2 = pos[1] - a2 * pos[0];\n\n        const a1Dist = solveConstantsDistance([-a1, 1, 0], pos);\n        const a2Dist = solveConstantsDistance([-a2, 1, 0], pos);\n\n        if (a1MinMax[0] > a1Dist) {\n          a1MinMaxPos[0] = pos;\n          a1MinMax[0] = a1Dist;\n        }\n        if (a1MinMax[1] < a1Dist) {\n          a1MinMaxPos[1] = pos;\n          a1MinMax[1] = a1Dist;\n        }\n        if (a2MinMax[0] > a2Dist) {\n          a2MinMaxPos[0] = pos;\n          a2MinMax[0] = a2Dist;\n        }\n        if (a2MinMax[1] < a2Dist) {\n          a2MinMaxPos[1] = pos;\n          a2MinMax[1] = a2Dist;\n        }\n      });\n    });\n\n    const [a1MinPos, a1MaxPos] = a1MinMaxPos;\n    const [a2MinPos, a2MaxPos] = a2MinMaxPos;\n\n    const minHorizontalLine = [-a1, 1, solveC([-a1, 1], a1MinPos)];\n    const maxHorizontalLine = [-a1, 1, solveC([-a1, 1], a1MaxPos)];\n\n    const minVerticalLine = [-a2, 1, solveC([-a2, 1], a2MinPos)];\n    const maxVerticalLine = [-a2, 1, solveC([-a2, 1], a2MaxPos)];\n\n    [pos1, pos2, pos3, pos4] = [\n      [minHorizontalLine, minVerticalLine],\n      [minHorizontalLine, maxVerticalLine],\n      [maxHorizontalLine, minVerticalLine],\n      [maxHorizontalLine, maxVerticalLine],\n    ].map(\n      ([line1, line2]) => getIntersectionPointsByConstants(line1, line2)[0]\n    );\n\n    width = a2MinMax[1] - a2MinMax[0];\n    height = a1MinMax[1] - a1MinMax[0];\n  } else {\n    const minX = getMinPos(parentPoses, 0);\n    const minY = getMinPos(parentPoses, 1);\n    const maxX = getMaxPos(parentPoses, 0);\n    const maxY = getMaxPos(parentPoses, 1);\n\n    pos1 = [minX, minY];\n    pos2 = [maxX, minY];\n    pos3 = [minX, maxY];\n    pos4 = [maxX, maxY];\n    width = maxX - minX;\n    height = maxY - minY;\n    if (fixedRotation % 180) {\n      // 0\n      // 1 2\n      // 3 4\n      // 90\n      // 3 1\n      // 4 2\n      // 180\n      // 4 3\n      // 2 1\n      // 270\n      // 2 4\n      // 1 3\n      // 1, 2, 3,4 = 3 1 4 2\n      const changedX = [pos3, pos1, pos4, pos2];\n\n      [pos1, pos2, pos3, pos4] = changedX;\n      width = maxY - minY;\n      height = maxX - minX;\n    }\n  }\n  if (fixedRotation % 360 > 180) {\n    // 1 2   4 3\n    // 3 4   2 1\n    const changedX = [pos4, pos3, pos2, pos1];\n\n    [pos1, pos2, pos3, pos4] = changedX;\n  }\n  const { minX, minY, maxX, maxY } = getMinMaxs([pos1, pos2, pos3, pos4]);\n\n  return {\n    pos1,\n    pos2,\n    pos3,\n    pos4,\n    width,\n    height,\n    minX,\n    minY,\n    maxX,\n    maxY,\n    rotation,\n  };\n}\ntype SelfGroup = Array<MoveableManager | null | SelfGroup>;\ntype CheckedMoveableManager = { finded: boolean; manager: MoveableManager };\n\nfunction findMoveableGroups(\n  moveables: CheckedMoveableManager[],\n  childTargetGroups: MoveableTargetGroupsType\n): SelfGroup {\n  const groups = childTargetGroups\n    .map((targetGroup) => {\n      if (isArray(targetGroup)) {\n        const childMoveableGroups = findMoveableGroups(moveables, targetGroup);\n        const length = childMoveableGroups.length;\n\n        if (length > 1) {\n          return childMoveableGroups;\n        } else if (length === 1) {\n          return childMoveableGroups[0];\n        } else {\n          return null;\n        }\n      } else {\n        const checked = find(\n          moveables,\n          ({ manager }) => manager.props.target === targetGroup\n        )!;\n\n        if (checked) {\n          checked.finded = true;\n          return checked.manager;\n        }\n        return null;\n      }\n    })\n    .filter(Boolean);\n\n  if (groups.length === 1 && isArray(groups[0])) {\n    return groups[0];\n  }\n  return groups;\n}\n\n/**\n * @namespace Moveable.Group\n * @description You can make targets moveable.\n */\nclass MoveableGroup extends MoveableManager<GroupableProps> {\n  public static defaultProps = {\n    ...MoveableManager.defaultProps,\n    transformOrigin: [\"50%\", \"50%\"],\n    groupable: true,\n    dragArea: true,\n    keepRatio: true,\n    targets: [],\n    defaultGroupRotate: 0,\n    defaultGroupOrigin: \"50% 50%\",\n  };\n  public differ: ChildrenDiffer<HTMLElement | SVGElement> =\n    new ChildrenDiffer();\n  public moveables: MoveableManager[] = [];\n  public transformOrigin = \"50% 50%\";\n  public renderGroupRects: GroupRect[] = [];\n  private _targetGroups: MoveableTargetGroupsType = [];\n  private _hasFirstTargets = false;\n\n  public componentDidMount() {\n    super.componentDidMount();\n  }\n  public checkUpdate() {\n    this._isPropTargetChanged = false;\n    this.updateAbles();\n  }\n  public getTargets() {\n    return this.props.targets!;\n  }\n  public updateRect(\n    type?: \"Start\" | \"\" | \"End\",\n    isTarget?: boolean,\n    isSetState = true\n  ) {\n    const state = this.state;\n\n    if (!this.controlBox || state.isPersisted) {\n      return;\n    }\n    setStoreCache(true);\n    this.moveables.forEach((moveable) => {\n      moveable.updateRect(type, false, false);\n    });\n\n    const props = this.props;\n    const moveables = this.moveables;\n    const target = state.target! || props.target!;\n    const checkeds = moveables.map((moveable) => ({\n      finded: false,\n      manager: moveable,\n    }));\n    const targetGroups = this.props.targetGroups || [];\n    const moveableGroups = findMoveableGroups(checkeds, targetGroups);\n    const useDefaultGroupRotate = props.useDefaultGroupRotate;\n\n    moveableGroups.push(\n      ...checkeds.filter(({ finded }) => !finded).map(({ manager }) => manager)\n    );\n\n    const renderGroupRects: GroupRect[] = [];\n    const isReset = !isTarget || (type !== \"\" && props.updateGroup);\n    let defaultGroupRotate = props.defaultGroupRotate || 0;\n\n    if (!this._hasFirstTargets) {\n      const persistedRoatation = props.persistData?.rotation;\n\n      if (persistedRoatation != null) {\n        defaultGroupRotate = persistedRoatation;\n      }\n    }\n\n    function getMoveableGroupRect(\n      group: SelfGroup,\n      parentRotation: number,\n      isRoot?: boolean\n    ): GroupRect {\n      const posesRotations = group.map((moveable) => {\n        if (isArray(moveable)) {\n          const rect = getMoveableGroupRect(moveable, parentRotation);\n          const poses = [rect.pos1, rect.pos2, rect.pos3, rect.pos4];\n\n          renderGroupRects.push(rect);\n          return { poses, rotation: rect.rotation };\n        } else {\n          return {\n            poses: getAbsolutePosesByState(moveable!.state),\n            rotation: moveable!.getRotation(),\n          };\n        }\n      });\n      const rotations = posesRotations.map(({ rotation }) => rotation);\n\n      let groupRotation = 0;\n      const firstRotation = rotations[0];\n      const isSameRotation = rotations.every((nextRotation) => {\n        return Math.abs(firstRotation - nextRotation) < 0.1;\n      });\n\n      if (isReset) {\n        groupRotation =\n          !useDefaultGroupRotate && isSameRotation\n            ? firstRotation\n            : defaultGroupRotate;\n      } else {\n        groupRotation =\n          !useDefaultGroupRotate && !isRoot && isSameRotation\n            ? firstRotation\n            : parentRotation;\n      }\n      const groupPoses = posesRotations.map(({ poses }) => poses);\n      const groupRect = getGroupRect(groupPoses, groupRotation);\n\n      return groupRect;\n    }\n    const rootGroupRect = getMoveableGroupRect(\n      moveableGroups,\n      this.rotation,\n      true\n    );\n\n    if (isReset) {\n      // reset rotataion\n      this.rotation = rootGroupRect.rotation;\n      this.transformOrigin = props.defaultGroupOrigin || \"50% 50%\";\n      this.scale = [1, 1];\n    }\n\n    this._targetGroups = targetGroups;\n    this.renderGroupRects = renderGroupRects;\n    const transformOrigin = this.transformOrigin;\n    const rotation = this.rotation;\n    const scale = this.scale;\n    const { width, height, minX, minY } = rootGroupRect;\n    const posesInfo = rotatePosesInfo(\n      [\n        [0, 0],\n        [width, 0],\n        [0, height],\n        [width, height],\n      ],\n      convertTransformOriginArray(transformOrigin, width, height),\n      (this.rotation / 180) * Math.PI\n    );\n\n    const { minX: deltaX, minY: deltaY } = getMinMaxs(posesInfo.result);\n    const rotateScale =\n      ` rotate(${rotation}deg)` +\n      ` scale(${sign(scale[0])}, ${sign(scale[1])})`;\n    const transform = `translate(${-deltaX}px, ${-deltaY}px)${rotateScale}`;\n\n    this.controlBox.style.transform = `translate3d(${minX}px, ${minY}px, ${\n      this.props.translateZ || 0\n    })`;\n\n    target.style.cssText +=\n      `left:0px;top:0px;` +\n      `transform-origin:${transformOrigin};` +\n      `width:${width}px;height:${height}px;` +\n      `transform: ${transform}`;\n    state.width = width;\n    state.height = height;\n\n    const container = this.getContainer();\n    const info = getMoveableTargetInfo(\n      this.controlBox,\n      target,\n      this.controlBox,\n      this.getContainer(),\n      this._rootContainer || container,\n      []\n    );\n    const pos = [info.left!, info.top!];\n    const [pos1, pos2, pos3, pos4] = getAbsolutePosesByState(info); // info.left + info.pos(1 ~ 4)\n\n    const minPos = getMinMaxs([pos1, pos2, pos3, pos4]);\n    const delta = [minPos.minX, minPos.minY];\n    const direction = sign(scale[0] * scale[1]);\n\n    info.pos1 = minus(pos1, delta);\n    info.pos2 = minus(pos2, delta);\n    info.pos3 = minus(pos3, delta);\n    info.pos4 = minus(pos4, delta);\n    // info.left = info.left + delta[0];\n    // info.top = info.top + delta[1];\n    info.left = minX - info.left! + delta[0];\n    info.top = minY - info.top! + delta[1];\n    info.origin = minus(plus(pos, info.origin!), delta);\n    info.beforeOrigin = minus(plus(pos, info.beforeOrigin!), delta);\n    info.originalBeforeOrigin = plus(pos, info.originalBeforeOrigin!);\n    info.transformOrigin = minus(plus(pos, info.transformOrigin!), delta);\n    target.style.transform =\n      `translate(${-deltaX - delta[0]}px, ${-deltaY - delta[1]}px)` +\n      rotateScale;\n\n    setStoreCache();\n    this.updateState(\n      {\n        ...info,\n        posDelta: delta,\n        direction,\n        beforeDirection: direction,\n      },\n      isSetState\n    );\n  }\n  public getRect(): RectInfo {\n    return {\n      ...super.getRect(),\n      children: this.moveables.map((child) => child.getRect()),\n    };\n  }\n  public triggerEvent(name: string, e: any, isManager?: boolean): any {\n    if (isManager || name.indexOf(\"Group\") > -1) {\n      return super.triggerEvent(name as any, e);\n    } else {\n      this._emitter.trigger(name, e);\n    }\n  }\n  public getRequestChildStyles() {\n    const styleNames = this.getEnabledAbles().reduce((names, able) => {\n      const ableStyleNames = (able.requestChildStyle?.() ?? []) as Array<\n        keyof CSSStyleDeclaration\n      >;\n\n      return [...names, ...ableStyleNames];\n    }, [] as Array<keyof CSSStyleDeclaration>);\n\n    return styleNames;\n  }\n\n  public getMoveables(): MoveableManagerInterface[] {\n    return [...this.moveables];\n  }\n  protected updateAbles() {\n    super.updateAbles([...this.props.ables!, Groupable], \"Group\");\n  }\n  protected _updateTargets() {\n    super._updateTargets();\n    this._originalDragTarget = this.props.dragTarget || this.areaElement;\n    this._dragTarget = getRefTarget(this._originalDragTarget, true);\n  }\n  protected _updateEvents() {\n    const state = this.state;\n    const props = this.props;\n\n    const prevTarget = this._prevDragTarget;\n    const nextTarget = props.dragTarget || this.areaElement;\n    const targets = props.targets!;\n    const { added, changed, removed } = this.differ.update(targets);\n    const isTargetChanged = added.length || removed.length;\n\n    if (\n      isTargetChanged ||\n      this._prevOriginalDragTarget !== this._originalDragTarget\n    ) {\n      unsetGesto(this, false);\n      unsetGesto(this, true);\n      this.updateState({ gestos: {} });\n    }\n    if (prevTarget !== nextTarget) {\n      state.target = null;\n    }\n    if (!state.target) {\n      state.target = this.areaElement;\n      this.controlBox.style.display = \"block\";\n    }\n    if (state.target) {\n      if (!this.targetGesto) {\n        this.targetGesto = getTargetAbleGesto(this, this._dragTarget!, \"Group\");\n      }\n      if (!this.controlGesto) {\n        this.controlGesto = getControlAbleGesto(this, \"GroupControl\");\n      }\n    }\n    const isContainerChanged = !equals(state.container, props.container);\n\n    if (isContainerChanged) {\n      state.container = props.container;\n    }\n\n    if (\n      isContainerChanged ||\n      isTargetChanged ||\n      this.transformOrigin !== (props.defaultGroupOrigin || \"50% 50%\") ||\n      changed.length ||\n      (targets.length &&\n        !isDeepArrayEquals(this._targetGroups, props.targetGroups || []))\n    ) {\n      this.updateRect();\n      this._hasFirstTargets = true;\n    }\n    this._isPropTargetChanged = !!isTargetChanged;\n  }\n  protected _updateObserver() {}\n}\n\n/**\n * Sets the initial rotation of the group.\n * @name Moveable.Group#defaultGroupRotate\n * @default 0\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   defaultGroupRotate: 0,\n * });\n *\n * moveable.defaultGroupRotate = 40;\n */\n\n/**\n * Sets the initial origin of the group.\n * @name Moveable.Group#defaultGroupOrigin\n * @default 0\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   defaultGroupOrigin: \"50% 50%\",\n * });\n *\n * moveable.defaultGroupOrigin = \"20% 40%\";\n */\n\n/**\n * Whether to hide the line in child moveable for group corresponding to the rect of the target.\n * @name Moveable.Group#hideChildMoveableDefaultLines\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   hideChildMoveableDefaultLines: false,\n * });\n *\n * moveable.hideChildMoveableDefaultLines = true;\n */\nexport default MoveableGroup;\n","import { ref, refs } from \"../utility/framework\";\nimport MoveableManager from \"./moveable-manager\";\nimport {\n  GroupableProps,\n  IndividualGroupableProps,\n  MoveableManagerInterface,\n  RectInfo,\n  Requester,\n} from \"./types\";\nimport { prefix } from \"./utils\";\nimport { setStoreCache } from \"./store/store\";\nimport { find } from \"../utility\";\n\n/**\n * @namespace Moveable.IndividualGroup\n * @description Create targets individually, not as a group.Create targets individually, not as a group.\n */\nclass MoveableIndividualGroup extends MoveableManager<\n  GroupableProps & IndividualGroupableProps\n> {\n  public moveables: MoveableManager[] = [];\n  public render() {\n    const props = this.props;\n    const { cspNonce, cssStyled: ControlBoxElement, persistData } = props;\n\n    let targets: Array<HTMLElement | SVGElement | null | undefined> =\n      props.targets || [];\n    const length = targets.length;\n    const canPersist = this.isUnmounted || !length;\n    let persistDatChildren = persistData?.children ?? [];\n\n    if (canPersist && !length && persistDatChildren.length) {\n      targets = persistDatChildren.map(() => null);\n    } else if (!canPersist) {\n      persistDatChildren = [];\n    }\n\n    return (\n      <ControlBoxElement\n        cspNonce={cspNonce}\n        ref={ref(this, \"controlBox\")}\n        className={prefix(\"control-box\")}\n      >\n        {targets!.map((target, i) => {\n          const individualProps =\n            props.individualGroupableProps?.(target, i) ?? {};\n          return (\n            <MoveableManager\n              key={\"moveable\" + i}\n              ref={refs(this, \"moveables\", i)}\n              {...props}\n              {...individualProps}\n              target={target}\n              wrapperMoveable={this}\n              isWrapperMounted={this.isMoveableMounted}\n              persistData={persistDatChildren[i]}\n            />\n          );\n        })}\n      </ControlBoxElement>\n    );\n  }\n  public componentDidMount() {}\n  public componentDidUpdate() {}\n  public getTargets() {\n    return this.props.targets!;\n  }\n  public updateRect(\n    type?: \"Start\" | \"\" | \"End\",\n    isTarget?: boolean,\n    isSetState: boolean = true\n  ) {\n    setStoreCache(true);\n    this.moveables.forEach((moveable) => {\n      moveable.updateRect(type, isTarget, isSetState);\n    });\n    setStoreCache();\n  }\n  public getRect(): RectInfo {\n    return {\n      ...super.getRect(),\n      children: this.moveables.map((child) => child.getRect()),\n    };\n  }\n  public request(\n    ableName: string,\n    param: Record<string, any> = {},\n    isInstant?: boolean\n  ): Requester {\n    const results = this.moveables.map((m) =>\n      m.request(ableName, { ...param, isInstant: false }, false)\n    );\n    const requestInstant = isInstant || param.isInstant;\n    const requester: Requester = {\n      request(ableParam: Record<string, any>) {\n        results.forEach((r) => r.request(ableParam));\n        return this;\n      },\n      requestEnd() {\n        results.forEach((r) => r.requestEnd());\n        return this;\n      },\n    };\n    return requestInstant ? requester.request(param).requestEnd() : requester;\n  }\n  public dragStart(\n    e: MouseEvent | TouchEvent,\n    target: EventTarget | null = e.target\n  ) {\n    const inputTarget = target as HTMLElement;\n    const childMoveable = find(this.moveables, (child) => {\n      const target = child.getTargets()[0];\n      const controlBoxElement = child.getControlBoxElement();\n      const dragElement = child.getDragElement();\n\n      if (!target || !dragElement) {\n        return false;\n      }\n      return (\n        dragElement === inputTarget ||\n        dragElement.contains(inputTarget) ||\n        (dragElement !== target && target === inputTarget) ||\n        target.contains(inputTarget) ||\n        controlBoxElement === inputTarget ||\n        controlBoxElement.contains(inputTarget)\n      );\n    });\n\n    if (childMoveable) {\n      childMoveable.dragStart(e, target);\n    }\n    return this;\n  }\n  public hitTest() {\n    return 0;\n  }\n  public isInside() {\n    return false;\n  }\n  public isDragging() {\n    return false;\n  }\n  public getDragElement() {\n    return null;\n  }\n  public getMoveables(): MoveableManagerInterface[] {\n    return [...this.moveables];\n  }\n  public updateRenderPoses() {}\n  public checkUpdate() {}\n  public triggerEvent() {}\n  protected updateAbles() {}\n  protected _updateEvents() {}\n  protected _updateObserver() {}\n}\n\n/**\n * Create targets individually, not as a group.\n * @name Moveable.IndividualGroup#individualGroupable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   individualGroupable: true,\n * });\n */\nexport default MoveableIndividualGroup;\n","import * as React from \"react\";\nimport {\n  Able,\n  MoveableInterface,\n  GroupableProps,\n  MoveableDefaultProps,\n  IndividualGroupableProps,\n  MoveableManagerInterface,\n  MoveableRefTargetsResultType,\n  MoveableTargetGroupsType,\n  BeforeRenderableProps,\n  RenderableProps,\n  MoveableManagerState,\n} from \"./types\";\nimport MoveableManager from \"./moveable-manager\";\nimport MoveableGroup from \"./moveable-group\";\nimport { ref, prefixCSS } from \"../utility/framework\";\nimport { find, getKeys, IObject, isArray, isString } from \"../utility\";\nimport { MOVEABLE_METHODS, PREFIX, MOVEABLE_CSS } from \"./consts\";\nimport Default from \"./ables/default\";\nimport Groupable from \"./ables/groupable\";\nimport DragArea from \"./ables/drag-area\";\nimport { styled } from \"../react-css-styled\";\nimport { getRefTargets } from \"./utils\";\nimport IndividualGroupable from \"./ables/individual-groupable\";\nimport MoveableIndividualGroup from \"./moveable-individual-group\";\nimport ChildrenDiffer from \"../differ/children-differ\";\n\nfunction getElementTargets(\n  refTargets: MoveableRefTargetsResultType,\n  selectorMap: IObject<Array<HTMLElement | SVGElement>>\n): Array<SVGElement | HTMLElement> {\n  const elementTargets: Array<SVGElement | HTMLElement> = [];\n\n  refTargets.forEach((target) => {\n    if (!target) {\n      return;\n    }\n    if (isString(target)) {\n      if (selectorMap[target]) {\n        elementTargets.push(...selectorMap[target]);\n      }\n      return;\n    }\n    if (isArray(target)) {\n      elementTargets.push(...getElementTargets(target, selectorMap));\n    } else {\n      elementTargets.push(target);\n    }\n  });\n\n  return elementTargets;\n}\n\nfunction getTargetGroups(\n  refTargets: MoveableRefTargetsResultType,\n  selectorMap: IObject<Array<HTMLElement | SVGElement>>\n) {\n  const targetGroups: MoveableTargetGroupsType = [];\n\n  refTargets.forEach((target) => {\n    if (!target) {\n      return;\n    }\n    if (isString(target)) {\n      if (selectorMap[target]) {\n        targetGroups.push(...selectorMap[target]);\n      }\n      return;\n    }\n    if (isArray(target)) {\n      targetGroups.push(getTargetGroups(target, selectorMap));\n    } else {\n      targetGroups.push(target);\n    }\n  });\n\n  return targetGroups;\n}\n\nfunction compareRefTargets(\n  prevRefTargets: MoveableRefTargetsResultType,\n  nextRefTargets: MoveableRefTargetsResultType\n): boolean {\n  return (\n    prevRefTargets.length !== nextRefTargets.length ||\n    prevRefTargets.some((target, i) => {\n      const nextTarget = nextRefTargets[i];\n\n      if (!target && !nextTarget) {\n        return false;\n      } else if (target != nextTarget) {\n        if (isArray(target) && isArray(nextTarget)) {\n          return compareRefTargets(target, nextTarget);\n        }\n        return true;\n      }\n      return false;\n    })\n  );\n}\n\ntype DefaultAbles = GroupableProps &\n  IndividualGroupableProps &\n  BeforeRenderableProps &\n  RenderableProps;\n\n/* Property Decorator */\nfunction withMethods(\n  methods: readonly string[],\n  duplicate: { [name: string]: string } = {}\n) {\n  return (prototype: any, propertyName: string) => {\n    methods.forEach((name) => {\n      const methodName = duplicate[name] || name;\n\n      if (methodName in prototype) {\n        return;\n      }\n      prototype[methodName] = function (...args: any) {\n        const result = this[propertyName][name](...args);\n\n        if (result === this[propertyName]) {\n          return this;\n        } else {\n          return result;\n        }\n      };\n    });\n  };\n}\n\nfunction applyMethods(\n  instance: any,\n  methods: readonly string[],\n  propertyName: string\n) {\n  methods.forEach((name) => {\n    if (name in instance) {\n      return;\n    }\n    instance[name] = function (...args: any) {\n      const result = this[propertyName][name](...args);\n\n      if (result === this[propertyName]) {\n        return this;\n      } else {\n        return result;\n      }\n    };\n  });\n}\n\nexport class InitialMoveable<T = {}> extends React.PureComponent<\n  MoveableDefaultProps & DefaultAbles & T\n> {\n  public static defaultAbles: readonly Able<any>[] = [];\n  public static customStyledMap: Record<string, any> = {};\n  public static defaultStyled: any = null;\n  public static makeStyled() {\n    const cssMap: IObject<boolean> = {};\n\n    const ables = this.getTotalAbles();\n    ables.forEach(({ css }: Able) => {\n      if (!css) {\n        return;\n      }\n      css.forEach((text) => {\n        cssMap[text] = true;\n      });\n    });\n    const style = getKeys(cssMap).join(\"\\n\");\n\n    this.defaultStyled = styled(\"div\", prefixCSS(PREFIX, MOVEABLE_CSS + style));\n  }\n  public static getTotalAbles(): Able[] {\n    return [\n      Default,\n      Groupable,\n      IndividualGroupable,\n      DragArea,\n      ...this.defaultAbles,\n    ];\n  }\n\n  public moveable!: MoveableManager | MoveableGroup | MoveableIndividualGroup;\n  public refTargets: MoveableRefTargetsResultType = [];\n  public selectorMap: IObject<Array<HTMLElement | SVGElement>> = {};\n  private _differ: ChildrenDiffer<HTMLElement | SVGElement> =\n    new ChildrenDiffer();\n  private _elementTargets: Array<HTMLElement | SVGElement> = [];\n  private _tmpRefTargets: MoveableRefTargetsResultType = [];\n  private _tmpSelectorMap: IObject<Array<HTMLElement | SVGElement>> = {};\n  private _onChangeTargets: (() => void) | null = null;\n  public render() {\n    const moveableContructor = this.constructor as typeof InitialMoveable;\n\n    if (!moveableContructor.defaultStyled) {\n      moveableContructor.makeStyled();\n    }\n    const { ables: userAbles, props: userProps, ...props } = this.props;\n    const [refTargets, nextSelectorMap] = this._updateRefs(true);\n    const elementTargets = getElementTargets(refTargets, nextSelectorMap);\n\n    let isGroup = elementTargets.length > 1;\n    const totalAbles = moveableContructor.getTotalAbles();\n    const ables = [...totalAbles, ...((userAbles as any) || [])];\n    const nextProps = {\n      ...props,\n      ...(userProps || {}),\n      ables,\n      cssStyled: moveableContructor.defaultStyled,\n      customStyledMap: moveableContructor.customStyledMap,\n    };\n\n    this._elementTargets = elementTargets;\n\n    let firstRenderState: MoveableManagerState | null = null;\n    const prevMoveable = this.moveable;\n\n    const persistData = props.persistData;\n\n    if (persistData?.children) {\n      isGroup = true;\n    }\n    // Even one child is treated as a group if individualGroupable is enabled. #867\n    if (props.individualGroupable) {\n      return (\n        <MoveableIndividualGroup\n          key=\"individual-group\"\n          ref={ref(this, \"moveable\")}\n          {...nextProps}\n          target={null}\n          targets={elementTargets}\n        />\n      );\n    }\n    if (isGroup) {\n      const targetGroups = getTargetGroups(refTargets, nextSelectorMap);\n\n      // manager\n      if (\n        prevMoveable &&\n        !prevMoveable.props.groupable &&\n        !(prevMoveable.props as any).individualGroupable\n      ) {\n        const target = prevMoveable.props.target!;\n\n        if (target && elementTargets.indexOf(target) > -1) {\n          firstRenderState = { ...prevMoveable.state };\n        }\n      }\n\n      return (\n        <MoveableGroup\n          key=\"group\"\n          ref={ref(this, \"moveable\")}\n          {...nextProps}\n          {...(props.groupableProps ?? {})}\n          target={null}\n          targets={elementTargets}\n          targetGroups={targetGroups}\n          firstRenderState={firstRenderState}\n        />\n      );\n    } else {\n      const target = elementTargets[0];\n      // manager\n      if (\n        prevMoveable &&\n        (prevMoveable.props.groupable ||\n          (prevMoveable.props as any).individualGroupable)\n      ) {\n        const moveables =\n          (prevMoveable as MoveableGroup | MoveableIndividualGroup).moveables ||\n          [];\n        const prevTargetMoveable = find(\n          moveables,\n          (mv) => mv.props.target === target\n        );\n\n        if (prevTargetMoveable) {\n          firstRenderState = { ...prevTargetMoveable.state };\n        }\n      }\n\n      return (\n        <MoveableManager<any>\n          key=\"single\"\n          ref={ref(this, \"moveable\")}\n          {...nextProps}\n          target={target}\n          firstRenderState={firstRenderState}\n        />\n      );\n    }\n  }\n  public componentDidMount() {\n    applyMethods(this, MOVEABLE_METHODS, \"moveable\");\n    this._checkChangeTargets();\n  }\n  public componentDidUpdate() {\n    this._checkChangeTargets();\n  }\n  public componentWillUnmount() {\n    this.selectorMap = {};\n    this.refTargets = [];\n  }\n  /**\n   * Get targets set in moveable through target or targets of props.\n   * @method Moveable#getTargets\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body, {\n   *    target: [targetRef, \".target\", document.querySelectorAll(\".target\")],\n   * });\n   *\n   * console.log(moveable.getTargets());\n   */\n  public getTargets() {\n    return this.moveable?.getTargets() ?? [];\n  }\n  /**\n   * If the element list corresponding to the selector among the targets is changed, it is updated.\n   * @method Moveable#updateSelectors\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body, {\n   *    target: \".target\",\n   * });\n   *\n   * moveable.updateSelectors();\n   */\n  public updateSelectors() {\n    this.selectorMap = {};\n    this._updateRefs();\n    this.forceUpdate();\n  }\n  /**\n   * User changes target and waits for target to change.\n   * @method Moveable#waitToChangeTarget\n   * @story combination-with-other-components--components-selecto\n   * @example\n   * document.querySelector(\".target\").addEventListener(\"mousedown\", e => {\n   *   moveable.waitToChangeTarget().then(() => {\n   *      moveable.dragStart(e, e.currentTarget);\n   *   });\n   *   moveable.target = e.currentTarget;\n   * });\n   */\n  public waitToChangeTarget(): Promise<void> {\n    // let resolvePromise: (e: OnChangeTarget) => void;\n\n    // this._onChangeTargets = () => {\n    //     this._onChangeTargets = null;\n    //     resolvePromise({\n    //         moveable: this.getManager(),\n    //         targets: this._elementTargets,\n    //     });\n    // };\n\n    // return new Promise<OnChangeTarget>(resolve => {\n    //     resolvePromise = resolve;\n    // });\n    let resolvePromise: () => void;\n\n    this._onChangeTargets = () => {\n      this._onChangeTargets = null;\n      resolvePromise();\n    };\n\n    return new Promise((resolve) => {\n      resolvePromise = resolve;\n    });\n  }\n  public waitToChangeTargets(): Promise<void> {\n    return this.waitToChangeTarget();\n  }\n  public getManager(): MoveableManagerInterface<any, any> {\n    return this.moveable;\n  }\n  public getMoveables(): MoveableManagerInterface[] {\n    return this.moveable.getMoveables();\n  }\n  public getDragElement(): HTMLElement | SVGElement | null | undefined {\n    return this.moveable.getDragElement();\n  }\n  private _updateRefs(isRender?: boolean) {\n    const prevRefTargets = this.refTargets;\n    const nextRefTargets = getRefTargets(\n      (this.props.target || this.props.targets) as any\n    );\n    const isBrowser = typeof document !== \"undefined\";\n\n    let isUpdate = compareRefTargets(prevRefTargets, nextRefTargets);\n    const selectorMap = this.selectorMap;\n    const nextSelectorMap: IObject<Array<HTMLElement | SVGElement>> = {};\n\n    this.refTargets.forEach(function updateSelectorMap(target) {\n      if (isString(target)) {\n        const selectorTarget = selectorMap[target];\n\n        if (selectorTarget) {\n          nextSelectorMap[target] = selectorMap[target];\n        } else if (isBrowser) {\n          isUpdate = true;\n          nextSelectorMap[target] = [].slice.call(\n            document.querySelectorAll(target)\n          );\n        }\n      } else if (isArray(target)) {\n        target.forEach(updateSelectorMap);\n      }\n    });\n\n    this._tmpRefTargets = nextRefTargets;\n    this._tmpSelectorMap = nextSelectorMap;\n\n    return [nextRefTargets, nextSelectorMap, !isRender && isUpdate] as const;\n  }\n  private _checkChangeTargets() {\n    this.refTargets = this._tmpRefTargets;\n    this.selectorMap = this._tmpSelectorMap;\n\n    const { added, removed } = this._differ.update(this._elementTargets);\n    const isTargetChanged = added.length || removed.length;\n\n    if (isTargetChanged) {\n      this.props.onChangeTargets?.({\n        moveable: this.moveable,\n        targets: this._elementTargets,\n      });\n      this._onChangeTargets?.();\n    }\n    const [refTargets, selectorMap, isUpdate] = this._updateRefs();\n\n    this.refTargets = refTargets;\n    this.selectorMap = selectorMap;\n\n    if (isUpdate) {\n      this.forceUpdate();\n    }\n  }\n}\nexport interface InitialMoveable<T = {}>\n  extends React.PureComponent<MoveableDefaultProps & DefaultAbles & T>,\n    MoveableInterface {\n  setState(state: any, callback?: () => any): any;\n  forceUpdate(callback?: () => any): any;\n}\n","import { MoveableProps, Able } from \"./types\";\nimport { MOVEABLE_ABLES } from \"./ables/consts\";\nimport { InitialMoveable } from \"./initial-moveable\";\n\nexport default class Moveable<T = {}> extends InitialMoveable<\n  MoveableProps & T\n> {\n  public static defaultAbles: Able[] = MOVEABLE_ABLES as any;\n}\n","import styled from \"../css-styled\";\nimport getAgent from \"@egjs/agent\";\nimport { prefixCSS } from \"../utility/framework\";\n\nexport const agent = getAgent();\nexport const IS_SAFARI = agent.browser.name === \"safari\";\n\nexport const PREFIX = \"infinite-viewer-\";\n\nexport const WRAPPER_CLASS_NAME = `${PREFIX}wrapper`;\nexport const SCROLL_AREA_CLASS_NAME = `${PREFIX}scroll-area`;\n\nexport const SCROLL_BAR_CLASS_NAME = `${PREFIX}scroll-bar`;\nexport const HORIZONTAL_SCROLL_BAR_CLASS_NAME = `${PREFIX}horizontal-scroll-bar`;\nexport const VERTICAL_SCROLL_BAR_CLASS_NAME = `${PREFIX}vertical-scroll-bar`;\nexport const SCROLL_THUMB_CLASS_NAME = `${PREFIX}scroll-thumb`;\n\nexport const injector = styled(\n  prefixCSS(\n    PREFIX,\n    `\n{\n    position: relative;\n    overscroll-behavior: none;\n}\n.wrapper {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    overflow: auto;\n    scrollbar-width: none;\n    top: 0;\n    left: 0;\n    will-change: scroll-position;\n}\n.restrict-wrapper {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n}\n.wrapper::-webkit-scrollbar {\n    display: none;\n}\n.scroll-area {\n    position:absolute;\n    top:0;\n    left:0;\n    transform-origin: 0 0;\n}\n.scroll-bar {\n    position:absolute;\n    width: 10px;\n    height: 10px;\n    box-sizing: border-box;\n    right: 0;\n    bottom: 0;\n    overflow: hidden;\n}\n.horizontal-scroll-bar {\n    width: calc(100% - 20px);\n    right: 10px;\n    height: 14px;\n}\n.vertical-scroll-bar {\n    height: calc(100% - 20px);\n    bottom: 10px;\n    width: 14px;\n}\n.scroll-thumb {\n    position:relative;\n    opacity: 0.7;\n    background: #333;\n    border-radius: 3px;\n    left: 0px;\n    top: 0px;\n    z-index: 10;\n    width: 6px;\n    height: 6px;\n    transition: all ease 0.2s;\n    opacity: 0;\n}\n.scroll-bar:hover .scroll-thumb {\n    border-radius: 5px;\n    opacity: 1;\n}\n.horizontal-scroll-bar .scroll-thumb {\n    margin: 4px 0px;\n    transition-property: opacity, margin, height, border-radius;\n}\n.vertical-scroll-bar .scroll-thumb {\n    margin: 0px 4px;\n    transition-property: opacity, margin, width, border-radius;\n}\n.horizontal-scroll-bar:hover .scroll-thumb {\n    height: 10px;\n    margin: 2px 0px;\n}\n.vertical-scroll-bar:hover .scroll-thumb {\n    width: 10px;\n    margin: 0px 2px;\n}\n`\n  )\n);\n\nexport const DEFAULT_OPTIONS = {\n  margin: 500,\n  threshold: 100,\n  zoom: 1,\n  zoomX: 1,\n  zoomY: 1,\n  rangeX: [-Infinity, Infinity],\n  rangeY: [-Infinity, Infinity],\n  rangeOffsetX: [0, 0],\n  rangeOffsetY: [0, 0],\n  wrapperElement: null,\n  scrollAreaElement: null,\n  horizontalScrollElement: null,\n  verticalScrollElement: null,\n  usePinch: false,\n  useAutoZoom: false,\n  useMouseDrag: false,\n  pinchThreshold: 30,\n  cspNonce: \"\",\n  maxPinchWheel: Infinity,\n  wheelScale: 0.01,\n  displayHorizontalScroll: true,\n  displayVerticalScroll: true,\n  useTransform: true,\n  useWheelPinch: true,\n  zoomRange: [0.001, Infinity],\n  wheelPinchKey: \"ctrl\" as const,\n  useWheelScroll: IS_SAFARI,\n  zoomOffsetX: \"50%\",\n  zoomOffsetY: \"50%\",\n  translateZ: 0,\n  useGesture: true,\n  useResizeObserver: false,\n  pinchDirection: \"all\" as const,\n  preventWheelClick: true,\n  useBounceScrollBar: false,\n  useOverflowScroll: false,\n};\n\nexport const DEFAULT_EASING = (x: number) => 1 - Math.pow(1 - x, 3);\nexport const NAMES = {\n  horizontal: {\n    pos: \"Left\",\n    coord: \"X\",\n    size: \"Width\",\n  },\n  vertical: {\n    pos: \"Top\",\n    coord: \"Y\",\n    size: \"Height\",\n  },\n} as const;\n/**\n * @memberof InfiniteViewer\n */\nexport const CLASS_NAME = injector.className;\n\n/**\n * @memberof InfiniteViewer\n */\nexport const PROPERTIES = [\n  \"margin\",\n  \"threshold\",\n  \"zoomOffsetX\",\n  \"zoomOffsetY\",\n  \"zoom\",\n  \"zoomX\",\n  \"zoomY\",\n  \"rangeX\",\n  \"rangeY\",\n  \"rangeOffsetX\",\n  \"rangeOffsetY\",\n  \"usePinch\",\n  \"useMouseDrag\",\n  \"pinchThreshold\",\n  \"maxPinchWheel\",\n  \"wheelScale\",\n  \"displayVerticalScroll\",\n  \"displayHorizontalScroll\",\n  \"translateZ\",\n  \"useAutoZoom\",\n  \"wheelPinchKey\",\n  \"zoomRange\",\n  \"zoomRangeX\",\n  \"zoomRangeY\",\n  \"pinchDirection\",\n  \"useOverflowScroll\",\n] as const;\n\n/**\n * @memberof InfiniteViewer\n */\nexport const OPTIONS = [\n  // ignore target, container,\n  ...PROPERTIES,\n  \"preventWheelClick\",\n  \"useWheelPinch\",\n  \"useWheelScroll\",\n  \"useGesture\",\n  \"cspNonce\",\n  \"wrapperElement\",\n  \"scrollAreaElement\",\n  \"verticalScrollElement\",\n  \"horizontalScrollElement\",\n  \"useResizeObserver\",\n  \"wheelContainer\",\n  \"useBounceScrollBar\",\n] as const;\n\n/**\n * @memberof InfiniteViewer\n */\nexport const EVENTS = [\n  \"scroll\",\n  \"abortPinch\",\n  \"dragStart\",\n  \"dragEnd\",\n  \"pinchStart\",\n  \"pinch\",\n] as const;\n\n/**\n * @memberof InfiniteViewer\n */\nexport const METHODS = [\n  \"getScrollLeft\",\n  \"getScrollTop\",\n  \"getScrollWidth\",\n  \"getScrollHeight\",\n  \"getContainerWidth\",\n  \"getContainerHeight\",\n  \"getViewportWidth\",\n  \"getViewportHeight\",\n  \"getViewportScrollWidth\",\n  \"getViewportScrollHeight\",\n  \"scrollTo\",\n  \"scrollBy\",\n  \"zoomBy\",\n  \"scrollCenter\",\n  \"getContainer\",\n  \"getViewport\",\n  \"getWrapper\",\n  \"setZoom\",\n  \"getRangeX\",\n  \"getRangeY\",\n  \"resize\",\n  \"getZoom\",\n  \"getZoomX\",\n  \"getZoomY\",\n  \"getWheelContainer\",\n  \"setTo\",\n  \"setBy\",\n] as const;\n\nexport const TINY_NUM = 0.000001;\n","import { OnDrag } from \"../gesto\";\nimport { TINY_NUM } from \"./consts\";\nimport { AnimationOptions } from \"./types\";\n\nexport function measureSpeed(e: OnDrag) {\n  const { deltaX, deltaY, datas } = e;\n  const time = Date.now();\n  const prevSpeed = datas.speed;\n\n  if (!prevSpeed) {\n    datas.speed = [0, 0];\n    datas.time = time;\n    return;\n  }\n  const dt = time - datas.time;\n  datas.speed = [\n    prevSpeed[0] / 2 + deltaX / dt,\n    prevSpeed[1] / 2 + deltaY / dt,\n  ];\n}\n\nexport function getDuration(speed: number[], a: number) {\n  const normalSpeed = Math.sqrt(speed[0] * speed[0] + speed[1] * speed[1]);\n\n  return Math.abs(normalSpeed / a);\n}\nexport function getDestPos(speed: number[], a: number) {\n  const duration = getDuration(speed, a);\n\n  return [(-speed[0] / 2) * duration, (-speed[1] / 2) * duration];\n}\nexport function minmax(value: number, min: number, max: number) {\n  return Math.min(max, Math.max(min, value));\n}\n\nexport function abs(v: number) {\n  return Math.abs(v);\n}\n\nexport function getRange(\n  pos: number,\n  margin: number,\n  range: number[],\n  threshold: number,\n  isReal: boolean\n) {\n  const min =\n    isReal || isFinite(range[0])\n      ? range[0]\n      : Math.min(-1, Math.floor(pos / margin)) * margin - threshold;\n  const max =\n    isReal || isFinite(range[1])\n      ? range[1]\n      : Math.max(1, Math.ceil(pos / margin)) * margin + threshold;\n\n  return [min, max];\n}\n\nexport function throttle(value: number) {\n  return Math.round(value / TINY_NUM) * TINY_NUM;\n}\n\nexport function checkDefault<T>(\n  value: T | undefined | null,\n  defaultValue: T\n): T {\n  return value != null ? value : defaultValue;\n}\n\nexport function startAnimation(\n  callback: (ratioDist: number) => void,\n  timerCallback: (next: () => void) => void,\n  options: AnimationOptions\n) {\n  const duration = options.duration!;\n  const easing = options.easing || ((x: number) => 1 - Math.pow(1 - x, 3));\n  const startTime = Date.now();\n  let prevTime = startTime;\n\n  const next = () => {\n    const now = Date.now();\n    let t = now - startTime;\n\n    if (duration < t) {\n      t = duration;\n    }\n    const ratio = easing(t / duration);\n    const prevRatio = easing((prevTime - startTime) / duration);\n\n    prevTime = now;\n\n    callback(ratio - prevRatio);\n\n    if (t >= duration) {\n      return;\n    }\n    timerCallback(next);\n  };\n  timerCallback(next);\n}\n","import Gesto, { OnDrag, OnDragStart } from \"../gesto\";\nimport {\n  SCROLL_BAR_CLASS_NAME,\n  SCROLL_THUMB_CLASS_NAME,\n  HORIZONTAL_SCROLL_BAR_CLASS_NAME,\n  VERTICAL_SCROLL_BAR_CLASS_NAME,\n} from \"./consts\";\nimport {\n  addClass,\n  removeEvent,\n  addEvent,\n  throttle,\n  getDocument,\n  getWindow,\n} from \"../utility\";\nimport EventEmitter from \"../event-emitter\";\n\nexport default class ScrollBar extends EventEmitter {\n  public isAppend: boolean = false;\n  public thumbElement!: HTMLElement;\n  public barElement!: HTMLElement;\n  protected gesto!: Gesto;\n  protected size: number = 0;\n  protected scrollSize: number = 0;\n  protected isHorizontal = false;\n\n  constructor(\n    containerElement: HTMLElement,\n    public type: \"horizontal\" | \"vertical\",\n    container?: HTMLElement\n  ) {\n    super();\n    const isHorizontal = type === \"horizontal\";\n    const doc = getDocument(containerElement);\n\n    let thumbElement: HTMLElement;\n    let barElement: HTMLElement = container!;\n\n    if (!container) {\n      barElement = doc.createElement(\"div\");\n      thumbElement = doc.createElement(\"div\");\n\n      barElement.insertBefore(thumbElement, null);\n      this.isAppend = true;\n    } else {\n      thumbElement = container.querySelector(`.${SCROLL_THUMB_CLASS_NAME}`)!;\n    }\n    addClass(\n      barElement,\n      isHorizontal\n        ? HORIZONTAL_SCROLL_BAR_CLASS_NAME\n        : VERTICAL_SCROLL_BAR_CLASS_NAME\n    );\n    addClass(barElement, SCROLL_BAR_CLASS_NAME);\n    addClass(thumbElement, SCROLL_THUMB_CLASS_NAME);\n\n    this.thumbElement = thumbElement;\n    this.barElement = barElement;\n    this.isHorizontal = isHorizontal;\n    this.gesto = new Gesto(barElement, {\n      container: getWindow(doc),\n    })\n      .on(\"dragStart\", (e) => this._onDragStart(e))\n      .on(\"drag\", (e) => this._onDrag(e));\n    addEvent(this.barElement, \"wheel\", this._onWheel, {\n      passive: false,\n    });\n  }\n  public scrollBy(delta: number, isAbsolute?: boolean) {\n    const ratio = delta / this.size;\n\n    this.trigger(\"scroll\", {\n      delta: isAbsolute ? delta : this.scrollSize * ratio,\n    });\n  }\n  public render(\n    isDisplay: boolean,\n    pos: number,\n    size: number,\n    scrollSize: number\n  ) {\n    this.size = size;\n    this.scrollSize = scrollSize;\n\n    const opacity = isDisplay && throttle(scrollSize - size, 0.001) > 0 ? 1 : 0;\n    const [dirName1, sizeName] = this.isHorizontal\n      ? [\"X\", \"width\"]\n      : [\"Y\", \"height\"];\n    const sizeP = (size / scrollSize) * 100;\n    const posP = (Math.max(0, pos) / scrollSize) * 100;\n\n    this.thumbElement.style.cssText +=\n      `${sizeName}: ${sizeP}%;opacity: ${opacity};` +\n      `transform: translate${dirName1}(${(100 / sizeP) * posP}%)`;\n  }\n  public destroy() {\n    removeEvent(this.barElement, \"wheel\", this._onWheel);\n    this.gesto.off();\n    this.off();\n  }\n  protected _onDragStart = (e: OnDragStart<Gesto>) => {\n    const isHorizontal = this.isHorizontal;\n    const target = e.inputEvent.target;\n    const datas = e.datas;\n    const isThumb = this.thumbElement === target;\n\n    if (!isThumb) {\n      setTimeout(() => {\n        requestAnimationFrame(() => {\n          const thumbRect = this.thumbElement.getBoundingClientRect();\n          const pos1 = thumbRect[isHorizontal ? \"left\" : \"top\"];\n          const thumbSize = thumbRect[isHorizontal ? \"width\" : \"height\"];\n          const pos2 = pos1 + thumbSize;\n          const clientPos = e[isHorizontal ? \"clientX\" : \"clientY\"];\n\n          if (pos1 <= clientPos && clientPos <= pos2) {\n            return;\n          }\n          const size = this.size;\n          const delta = (size * size) / this.scrollSize;\n\n          this.scrollBy(pos1 < clientPos ? delta : -delta);\n        });\n      }, 100);\n    }\n    datas.isThumb = isThumb;\n    e.inputEvent.stopPropagation();\n    e.inputEvent.preventDefault();\n  };\n  protected _onDrag = (e: OnDrag) => {\n    if (!e.datas.isThumb) {\n      return;\n    }\n    this.scrollBy(this.isHorizontal ? e.deltaX : e.deltaY);\n  };\n  protected _onWheel = (e: WheelEvent) => {\n    const delta = this.isHorizontal ? e.deltaX : e.deltaY;\n\n    if (delta) {\n      e.preventDefault();\n    }\n    this.trigger(\"scroll\", {\n      delta,\n    });\n  };\n}\n","import EventEmitter from \"../event-emitter\";\nimport Gesto from \"../gesto\";\nimport { InjectResult } from \"../css-styled\";\nimport {\n  camelize,\n  IObject,\n  addEvent,\n  removeEvent,\n  addClass,\n  convertUnitSize,\n  between,\n  isObject,\n  isArray,\n  isString,\n  isNode,\n  getDocument,\n  getWindow,\n} from \"../utility\";\nimport {\n  InfiniteViewerOptions,\n  InfiniteViewerProperties,\n  InfiniteViewerEvents,\n  OnPinch,\n  AnimationOptions,\n  ScrollOptions,\n  ZoomOptions,\n  GetScollPosOptions,\n  InnerScrollOptions,\n  ScrollCenterOptions,\n  SetOptions,\n} from \"./types\";\nimport {\n  PROPERTIES,\n  injector,\n  CLASS_NAME,\n  TINY_NUM,\n  DEFAULT_OPTIONS,\n  WRAPPER_CLASS_NAME,\n  SCROLL_AREA_CLASS_NAME,\n  HORIZONTAL_SCROLL_BAR_CLASS_NAME,\n  VERTICAL_SCROLL_BAR_CLASS_NAME,\n  NAMES,\n  DEFAULT_EASING,\n} from \"./consts\";\nimport {\n  measureSpeed,\n  getDuration,\n  getDestPos,\n  abs,\n  getRange,\n  checkDefault,\n  startAnimation,\n} from \"./utils\";\nimport ScrollBar from \"./scroll-bar\";\n\n/* Class Decorator */\nexport function Properties(\n  properties: any[],\n  action: (prototype: any, property: string) => any\n) {\n  return (component: any) => {\n    const prototype = component.prototype;\n\n    properties.forEach((property) => {\n      action(prototype, property);\n    });\n  };\n}\n\n// Define the function that applies properties\nfunction applyProperties(targetClass: any, properties: any[]) {\n  const prototype = targetClass.prototype;\n\n  properties.forEach((property) => {\n    const attributes: IObject<any> = {\n      enumerable: true,\n      configurable: true,\n      get() {\n        return this.options[property];\n      },\n    };\n\n    const setter = camelize(`set ${property}`);\n    if (prototype[setter]) {\n      attributes.set = function (value: unknown) {\n        this[setter](value);\n      };\n    } else {\n      attributes.set = function (value: unknown) {\n        this.options[property] = value;\n      };\n    }\n\n    Object.defineProperty(prototype, property, attributes);\n  });\n}\n\n/**\n * @sort 1\n */\nclass InfiniteViewer extends EventEmitter<InfiniteViewerEvents> {\n  public options: InfiniteViewerOptions;\n  private injectResult!: InjectResult;\n  private wrapperElement!: HTMLElement;\n  private scrollAreaElement!: HTMLElement;\n  private horizontalScrollbar: ScrollBar;\n  private verticalScrollbar: ScrollBar;\n  private gesto!: Gesto;\n  private offsetX: number = 0;\n  private offsetY: number = 0;\n  private containerWidth: number = 0;\n  private containerHeight: number = 0;\n  private viewportWidth: number = 0;\n  private viewportHeight: number = 0;\n  private viewportScrollWidth: number = 0;\n  private viewportScrollHeight: number = 0;\n  private scrollLeft: number = 0;\n  private scrollTop: number = 0;\n  private _scrollTimer = 0;\n  private _zoomTimer = 0;\n\n  private _viewportElement: HTMLElement | null = null;\n  private _wheelContainerElement: HTMLElement | null = null;\n  private dragFlag: boolean = false;\n  private isLoop: boolean = false;\n  private _tempScale: number[] = [1, 1];\n  private _tempRect: {\n    top: number;\n    left: number;\n    width: number;\n    height: number;\n  } | null = null;\n  private _tempRectTimer: number | null = null;\n  private _onDestroys: Array<() => void> = [];\n  private _asLeft = 0;\n  private _asTop = 0;\n  /**\n   * @sort 1\n   */\n  constructor(\n    private _containerElement: HTMLElement,\n    viewportElement: HTMLElement | Partial<InfiniteViewerOptions> = {},\n    options: Partial<InfiniteViewerOptions> = {}\n  ) {\n    super();\n\n    if (isNode(viewportElement)) {\n      this._viewportElement = viewportElement;\n      this.options = {\n        ...DEFAULT_OPTIONS,\n        ...options,\n      };\n    } else {\n      this._viewportElement = _containerElement.children[0] as HTMLElement;\n      this.options = {\n        ...DEFAULT_OPTIONS,\n        ...viewportElement,\n      };\n    }\n    this.init();\n  }\n  /**\n   * Get Container Element\n   */\n  public getContainer(): HTMLElement {\n    return this._containerElement;\n  }\n  /**\n   * Get Wheel Container Element\n   */\n  public getWheelContainer(): HTMLElement {\n    return this._wheelContainerElement;\n  }\n  /**\n   * Get Viewport Element\n   */\n  public getViewport(): HTMLElement {\n    return this._viewportElement;\n  }\n  /**\n   * Get Wrapper Element\n   */\n  public getWrapper(): HTMLElement {\n    return this.wrapperElement;\n  }\n  /**\n   * Get Scroll Area Element\n   */\n  public geScrollArea(): HTMLElement {\n    return this.scrollAreaElement;\n  }\n  /**\n   * Destroy elements, properties, and events.\n   */\n  public destroy(): void {\n    this.off();\n    this.gesto.unset();\n    this.verticalScrollbar.destroy();\n    this.horizontalScrollbar.destroy();\n    this.injectResult.destroy();\n    const containerElement = this._containerElement;\n\n    this._onDestroys.forEach((callback) => {\n      callback();\n    });\n    removeEvent(this.wrapperElement, \"scroll\", this._onScroll);\n    removeEvent(this._wheelContainerElement, \"wheel\", this.onWheel);\n    removeEvent(containerElement, \"gesturestart\", this.onGestureStart);\n    removeEvent(containerElement, \"gesturechange\", this.onGestureChange);\n    removeEvent(containerElement, \"gesturesend\", this.onGestureEnd);\n\n    this.gesto = null;\n    this.injectResult = null;\n    this._containerElement = null;\n    // @ts-ignore\n    this._viewportEPropertieslement = null;\n    this.options = null;\n  }\n  /**\n   * Gets the number of pixels that an element's content is scrolled vertically.\n   */\n  public getScrollTop(options: GetScollPosOptions | boolean = {}) {\n    let range = false;\n    let absolute = false;\n\n    if (isObject(options)) {\n      range = options.range;\n      absolute = options.absolute;\n    } else {\n      range = options;\n    }\n    const zoom = this.zoomY;\n    const pos =\n      this.scrollTop / zoom +\n      this.offsetY +\n      (range ? abs(this.getRangeY()[0]) : 0);\n\n    return absolute ? pos * zoom : pos;\n  }\n  /**\n   * Gets the number of pixels that an element's content is scrolled vertically.\n   */\n  public getScrollLeft(options: GetScollPosOptions | boolean = {}) {\n    let range = false;\n    let absolute = false;\n\n    if (isObject(options)) {\n      range = options.range;\n      absolute = options.absolute;\n    } else {\n      range = options;\n    }\n    const zoom = this.zoomX;\n    const pos =\n      this.scrollLeft / zoom +\n      this.offsetX +\n      (range ? abs(this.getRangeX()[0]) : 0);\n\n    return absolute ? pos * zoom : pos;\n  }\n  /**\n   * Gets measurement of the width of an element's content with overflow\n   */\n  public getScrollWidth(isZoom?: boolean) {\n    const range = this._getScrollRangeX();\n    const zoom = this.zoomX;\n    const size = this.containerWidth / zoom + abs(range[0]) + range[1];\n\n    return isZoom ? size : size * zoom;\n  }\n  /**\n   * Gets measurement of the height of an element's content with overflow\n   */\n  public getScrollHeight(isZoom?: boolean) {\n    const range = this._getScrollRangeY();\n    const zoom = this.zoomY;\n    const size = this.containerHeight / zoom + abs(range[0]) + range[1];\n\n    return isZoom ? size : size * zoom;\n  }\n\n  /**\n   * Scroll the element to the center\n   */\n  public scrollCenter(options: ScrollCenterOptions = {}) {\n    this.resize();\n\n    const zoomX = this.zoomX;\n    const zoomY = this.zoomY;\n\n    let left = -(this.containerWidth / zoomX - this.viewportWidth) / 2;\n    let top = -(this.containerHeight / zoomY - this.viewportHeight) / 2;\n\n    if (options.absolute) {\n      left *= zoomX;\n      top *= zoomY;\n    }\n    if (options.horizontal === false) {\n      left = this.getScrollLeft();\n    }\n    if (options.vertical === false) {\n      top = this.getScrollTop();\n    }\n\n    return this.scrollTo(left, top, options);\n  }\n  /**\n   * Update Viewer Sizes\n   * @method\n   */\n  public resize = () => {\n    const { offsetWidth: containerWidth, offsetHeight: containerHeight } =\n      this._containerElement;\n    const {\n      offsetWidth: viewportWidth,\n      offsetHeight: viewportHeight,\n      scrollWidth: viewportScrollWidth,\n      scrollHeight: viewportScrollHeight,\n    } = this._viewportElement;\n\n    this.containerWidth = containerWidth;\n    this.containerHeight = containerHeight;\n    this.viewportWidth = viewportWidth;\n    this.viewportHeight = viewportHeight;\n    this.viewportScrollWidth = Math.max(viewportWidth, viewportScrollWidth);\n    this.viewportScrollHeight = Math.max(viewportHeight, viewportScrollHeight);\n\n    this.render();\n    this._scrollBy(0, 0);\n  };\n  /**\n   * Move to that position or zoom.\n   * @since 0.25.0\n   */\n  public setTo(options: SetOptions) {\n    const {\n      x = this.getScrollLeft(),\n      y = this.getScrollTop(),\n      zoom = [this.getZoomX(), this.getZoomY()],\n      duration,\n    } = options;\n    const { zoomX: prevZoomX, zoomY: prevZoomY, zoomRange } = this;\n    let {\n      zoomOffsetX = DEFAULT_OPTIONS.zoomOffsetX,\n      zoomOffsetY = DEFAULT_OPTIONS.zoomOffsetY,\n    } = this;\n    if (\"zoomOffsetX\" in options) {\n      zoomOffsetX = options.zoomOffsetX;\n    }\n    if (\"zoomOffsetY\" in options) {\n      zoomOffsetY = options.zoomOffsetY;\n    }\n\n    const [zoomX, zoomY] = isArray(zoom) ? zoom : [zoom, zoom];\n    const zoomRangeX = this.zoomRangeX || zoomRange;\n    const zoomRangeY = this.zoomRangeY || zoomRange;\n    const nextZoomX = between(zoomX, zoomRangeX[0], zoomRangeX[1]);\n    const nextZoomY = between(zoomY, zoomRangeY[0], zoomRangeY[1]);\n    const zoomXPos =\n      convertUnitSize(`${zoomOffsetX}`, this.viewportWidth) *\n      (1 / prevZoomX - 1 / nextZoomX);\n    const zoomYPos =\n      convertUnitSize(`${zoomOffsetY}`, this.viewportHeight) *\n      (1 / prevZoomY - 1 / nextZoomY);\n\n    this.scrollTo(x - zoomXPos, y - zoomYPos, {\n      duration,\n    });\n    this.setZoom(zoom, {\n      zoomOffsetX,\n      zoomOffsetY,\n      duration,\n      zoomBase: \"fixed\",\n    });\n  }\n  /**\n   * Move by the position or zoom delta value.\n   * @since 0.25.0\n   */\n  public setBy(options: SetOptions) {\n    const { x = 0, y = 0, zoom = [0, 0] } = options;\n    const [zoomX, zoomY] = isArray(zoom) ? zoom : [zoom, zoom];\n\n    this.setTo({\n      ...options,\n      x: this.getScrollLeft() + x,\n      y: this.getScrollTop() + y,\n      zoom: [this.zoomX + zoomX, this.zoomY + zoomY],\n    });\n  }\n  /**\n   * Scrolls the container by the given amount.\n   */\n  public scrollBy(deltaX: number, deltaY: number, options?: ScrollOptions) {\n    this._pauseScrollAnimation();\n    if (!options || !options.duration) {\n      let scrollLeft = this.getScrollLeft();\n      let scrollTop = this.getScrollTop();\n\n      if (options?.absolute) {\n        scrollLeft *= this.zoomX;\n        scrollTop *= this.zoomY;\n      }\n      return this._scrollTo(scrollLeft + deltaX, scrollTop + deltaY, options);\n    } else {\n      this._startScrollAnimation([deltaX, deltaY], options);\n      return true;\n    }\n  }\n  /**\n   * Scrolls the container to set of coordinates.\n   * @param scrollLeft\n   * @param scrollTop\n   */\n  public scrollTo(x: number, y: number, options?: ScrollOptions) {\n    this._pauseScrollAnimation();\n    if (!options || !options.duration) {\n      return this._scrollTo(x, y, options);\n    } else {\n      let scrollLeft = this.getScrollLeft();\n      let scrollTop = this.getScrollTop();\n\n      if (options?.absolute) {\n        scrollLeft *= this.zoomX;\n        scrollTop *= this.zoomY;\n      }\n      return this.scrollBy(x - scrollLeft, y - scrollTop, options);\n    }\n  }\n  /**\n   * Set viewer zoom by the given amount\n   */\n  public zoomBy(deltaZoom: number | number[], options?: ZoomOptions) {\n    this._pauseZoomAnimation();\n    const [deltaX, deltaY] = isArray(deltaZoom)\n      ? deltaZoom\n      : [deltaZoom, deltaZoom];\n\n    if (!options || !options.duration) {\n      this._setZoom([this.zoomX + deltaX, this.zoomY + deltaY], options);\n    } else {\n      this._startZoomAnimation([deltaX, deltaY], options);\n    }\n  }\n  /**\n   * Set viewer zoom\n   */\n  public setZoom(zoom: number | number[], options?: ZoomOptions) {\n    this._pauseZoomAnimation();\n\n    if (!options || !options.duration) {\n      this._setZoom(zoom, options);\n    } else {\n      const [zoomX, zoomY] = isArray(zoom) ? zoom : [zoom, zoom];\n      this._startZoomAnimation(\n        [zoomX - this.zoomX, zoomY - this.zoomY],\n        options\n      );\n    }\n  }\n  public getViewportWidth() {\n    return this.viewportWidth;\n  }\n  public getViewportHeight() {\n    return this.viewportWidth;\n  }\n  public getViewportScrollWidth() {\n    return this.viewportScrollWidth;\n  }\n  public getViewportScrollHeight() {\n    return this.viewportScrollHeight;\n  }\n  public getContainerWidth() {\n    return this.containerWidth;\n  }\n  public getContainerHeight() {\n    return this.containerHeight;\n  }\n  /**\n   * Get viewer zoom\n   */\n  public getZoom() {\n    return (this.zoomX + this.zoomY) / 2;\n  }\n  /**\n   * Get viewer zoomX\n   * @since 0.20.0\n   */\n  public getZoomX() {\n    return this.zoomX;\n  }\n  /**\n   * Get viewer zoom\n   * @since 0.20.0\n   */\n  public getZoomY() {\n    return this.zoomY;\n  }\n  /**\n   * get x ranges\n   */\n  public getRangeX(isZoom?: boolean, isReal?: boolean) {\n    return this._getRangeCoord(\"horizontal\", isZoom, isReal);\n  }\n  /**\n   * get y ranges\n   */\n  public getRangeY(isZoom?: boolean, isReal?: boolean) {\n    return this._getRangeCoord(\"vertical\", isZoom, isReal);\n  }\n\n  private init() {\n    // infinite-viewer(container)\n    // viewportㅌ\n    // children\n    const containerElement = this._containerElement;\n    const options = this.options;\n    const doc = getDocument(containerElement);\n    const win = getWindow(containerElement);\n\n    // vanilla\n    let wrapperElement =\n      options.wrapperElement ||\n      containerElement.querySelector(`.${WRAPPER_CLASS_NAME}`);\n    let scrollAreaElement =\n      options.scrollAreaElement ||\n      containerElement.querySelector(`.${SCROLL_AREA_CLASS_NAME}`);\n    const horizontalScrollElement =\n      options.horizontalScrollElement ||\n      containerElement.querySelector(`.${HORIZONTAL_SCROLL_BAR_CLASS_NAME}`);\n    const verticalScrollElement =\n      options.verticalScrollElement ||\n      containerElement.querySelector(`.${VERTICAL_SCROLL_BAR_CLASS_NAME}`);\n\n    if (!wrapperElement) {\n      wrapperElement = doc.createElement(\"div\");\n      wrapperElement.insertBefore(this._viewportElement, null);\n      containerElement.insertBefore(wrapperElement, null);\n    }\n    this.wrapperElement = wrapperElement;\n\n    if (!scrollAreaElement) {\n      scrollAreaElement = doc.createElement(\"div\");\n\n      wrapperElement.insertBefore(scrollAreaElement, wrapperElement.firstChild);\n    }\n    this.scrollAreaElement = scrollAreaElement;\n\n    addClass(containerElement, CLASS_NAME);\n    addClass(wrapperElement, WRAPPER_CLASS_NAME);\n    // addClass(restrictElement, RESTRICT_WRAPPER_CLASS_NAME);\n    addClass(scrollAreaElement, SCROLL_AREA_CLASS_NAME);\n\n    const horizontalBar = new ScrollBar(\n      containerElement,\n      \"horizontal\",\n      horizontalScrollElement\n    );\n    const verticalBar = new ScrollBar(\n      containerElement,\n      \"vertical\",\n      verticalScrollElement\n    );\n\n    this.horizontalScrollbar = horizontalBar;\n    this.verticalScrollbar = verticalBar;\n    horizontalBar.on(\"scroll\", (e) => {\n      this.scrollBy(e.delta / this.zoomX, 0);\n    });\n    verticalBar.on(\"scroll\", (e) => {\n      this.scrollBy(0, e.delta / this.zoomY);\n    });\n\n    if (horizontalBar.isAppend) {\n      containerElement.insertBefore(horizontalBar.barElement, null);\n    }\n    if (verticalBar.isAppend) {\n      containerElement.insertBefore(verticalBar.barElement, null);\n    }\n    this.injectResult = injector.inject(containerElement, {\n      nonce: this.options.cspNonce,\n    });\n\n    const wheelContainerOption = options.wheelContainer;\n    let wheelContainerElement: HTMLElement | null = null;\n\n    if (wheelContainerOption) {\n      if (isString(wheelContainerOption)) {\n        wheelContainerElement = doc.querySelector(wheelContainerOption);\n      } else if (isNode(wheelContainerOption)) {\n        wheelContainerElement = wheelContainerOption;\n      } else if (\n        \"value\" in wheelContainerOption ||\n        \"current\" in wheelContainerOption\n      ) {\n        wheelContainerElement =\n          wheelContainerOption.current || wheelContainerOption.value;\n      }\n    }\n    wheelContainerElement ||= containerElement;\n    this._wheelContainerElement = wheelContainerElement;\n\n    /**\n     * the `dragStart` event fires when `touchstart` does occur.\n     * @memberof InfiniteViewer\n     * @event dragStart\n     * @param {InfiniteViewer.OnDragStart} - Parameters for the `dragStart` event\n     * @example\n     * import InfiniteViewer from \"infinite-viewer\";\n     *\n     * const viewer = new InfiniteViewer(\n     *   document.querySelector(\".container\"),\n     *   document.querySelector(\".viewport\"),\n     * ).on(\"dragStart\", e => {\n     *   console.log(e.inputEvent);\n     * });\n     */\n    /**\n     * the `drag` event fires when `touch` does occur.\n     * @memberof InfiniteViewer\n     * @event drag\n     * @param {InfiniteViewer.OnDrag} - Parameters for the `drag` event\n     * @example\n     * import InfiniteViewer from \"infinite-viewer\";\n     *\n     * const viewer = new InfiniteViewer(\n     *   document.querySelector(\".container\"),\n     *   document.querySelector(\".viewport\"),\n     * ).on(\"drag\", e => {\n     *   console.log(e.inputEvent);\n     * });\n     */\n    /**\n     * the `dragEnd` event fires when `touchend` does occur.\n     * @memberof InfiniteViewer\n     * @event dragEnd\n     * @param {InfiniteViewer.OnDragEnd} - Parameters for the `dragEnd` event\n     * @example\n     * import InfiniteViewer from \"infinite-viewer\";\n     *\n     * const viewer = new InfiniteViewer(\n     *   document.querySelector(\".container\"),\n     *   document.querySelector(\".viewport\"),\n     * ).on(\"dragEnd\", e => {\n     *   console.log(e.inputEvent);\n     * });\n     */\n    /**\n     * the `abortPinch` event fires when `pinch` event does not occur by dragging a certain area.\n     * @memberof InfiniteViewer\n     * @event abortPinch\n     * @param {InfiniteViewer.OnAbortPinch} - Parameters for the abortPinch event\n     * @example\n     * import InfiniteViewer from \"infinite-viewer\";\n     *\n     * const viewer = new InfiniteViewer(\n     *   document.querySelector(\".container\"),\n     *   document.querySelector(\".viewport\"),\n     *   {\n     *     usePinch: true,\n     *   }\n     * ).on(\"abortPinch\", e => {\n     *   console.log(e.inputEvent);\n     * });\n     */\n    /**\n     * the `pinch` event fires when two points pinch the viewer\n     * The pinchStart and abortPinch events do not occur when pinching through the wheel.\n     * @memberof InfiniteViewer\n     * @event pinch\n     * @param {InfiniteViewer.OnPinch} - Parameters for the `pinch` event\n     * @example\n     * import InfiniteViewer from \"infinite-viewer\";\n     *\n     * const viewer = new InfiniteViewer(\n     *   document.querySelector(\".container\"),\n     *   document.querySelector(\".viewport\"),\n     *   {\n     *     usePinch: true,\n     *   }\n     * ).on(\"pinch\", e => {\n     *   console.log(e.zoom, e.inputEvent);\n     * });\n     */\n    this.gesto = new Gesto(containerElement, {\n      container: getWindow(containerElement),\n      events: [\"touch\", \"mouse\"],\n      preventWheelClick: this.options.preventWheelClick ?? true,\n    })\n      .on(\"dragStart\", (e) => {\n        const { inputEvent, stop, datas } = e;\n        if (!this.useMouseDrag && e.isMouseEvent) {\n          stop();\n          return;\n        }\n        this._pauseScrollAnimation();\n        this.dragFlag = false;\n        const result = this.trigger(\"dragStart\", e);\n\n        if (result === false) {\n          stop();\n          return;\n        }\n        inputEvent.preventDefault();\n        datas.startEvent = inputEvent;\n      })\n      .on(\"drag\", (e) => {\n        if (\n          !this.options.usePinch ||\n          e.isPinch ||\n          (this.useMouseDrag && e.isMouseEvent)\n        ) {\n          this.trigger(\"drag\", {\n            ...e,\n            inputEvent: e.inputEvent,\n          });\n          measureSpeed(e);\n          this.scrollBy(-e.deltaX / this.zoomX, -e.deltaY / this.zoomY);\n        } else if (!this.dragFlag && e.movement > options.pinchThreshold) {\n          this.dragFlag = true;\n\n          this.trigger(\"abortPinch\", {\n            inputEvent: e.datas.startEvent || e.inputEvent,\n          });\n        }\n      })\n      .on(\"dragEnd\", (e) => {\n        this.trigger(\"dragEnd\", {\n          isDrag: e.isDrag,\n          isDouble: e.isDouble,\n          inputEvent: e.inputEvent,\n        });\n        this._startScrollAnimationBySpeed(e.datas.speed);\n      })\n      .on(\"pinchStart\", ({ inputEvent, datas, stop }) => {\n        inputEvent.preventDefault();\n        this._pauseScrollAnimation();\n        datas.startZoom = [this.zoomX, this.zoomY];\n\n        const result = this.trigger(\"pinchStart\", {\n          inputEvent,\n        });\n        if (result === false) {\n          stop();\n        }\n        this._setClientRect();\n      })\n      .on(\"pinch\", (e) => {\n        const scale = e.scale;\n        const pinchDirection = this.options.pinchDirection;\n\n        this._triggerPinch({\n          rotation: e.rotation,\n          distance: e.distance,\n          scale: e.scale,\n          inputEvent: e.inputEvent,\n          isWheel: false,\n          zoom: e.datas.startZoom * scale,\n          zoomX: this.zoomX * (pinchDirection === \"vertical\" ? 1 : scale),\n          zoomY: this.zoomY * (pinchDirection === \"horizontal\" ? 1 : scale),\n          clientX: e.clientX,\n          clientY: e.clientY,\n          ratioX: 0,\n          ratioY: 0,\n        });\n      })\n      .on(\"pinchEnd\", () => {\n        this._tempRect = null;\n      });\n\n    addEvent(wrapperElement, \"scroll\", this._onScroll);\n\n    if (options.useResizeObserver) {\n      const observer = new win.ResizeObserver(() => {\n        this.resize();\n      });\n\n      observer.observe(this._viewportElement);\n      observer.observe(this._containerElement);\n\n      this._onDestroys.push(() => {\n        observer.disconnect();\n      });\n    } else {\n      addEvent(win, \"resize\", this.resize);\n\n      this._onDestroys.push(() => {\n        removeEvent(win, \"resize\", this.resize);\n      });\n    }\n\n    if (options.useWheelPinch || options.useWheelScroll) {\n      addEvent(wheelContainerElement, \"wheel\", this.onWheel, {\n        passive: false,\n      });\n    }\n    if (options.useGesture) {\n      addEvent(containerElement, \"gesturestart\", this.onGestureStart, {\n        passive: false,\n      });\n      addEvent(containerElement, \"gesturechange\", this.onGestureChange, {\n        passive: false,\n      });\n    }\n    this.resize();\n  }\n  private render() {\n    const {\n      offsetX,\n      offsetY,\n      zoomX = DEFAULT_OPTIONS.zoomX,\n      zoomY = DEFAULT_OPTIONS.zoomY,\n      translateZ = 0,\n      rangeX,\n      rangeY,\n      containerWidth,\n      containerHeight,\n    } = this;\n    const { useTransform = DEFAULT_OPTIONS.useTransform } = this.options;\n    let nextOffsetX = -offsetX * zoomX;\n    let nextOffsetY = -offsetY * zoomY;\n\n    this.scrollAreaElement.style.cssText =\n      `width:calc(100% + ${this.getScrollAreaWidth()}px);` +\n      `height:calc(100% + ${this.getScrollAreaHeight()}px);`;\n\n    const viewportStyle = this._viewportElement.style;\n\n    if (useTransform === false) {\n      viewportStyle.cssText += `position: relative; left: ${nextOffsetX}px; top: ${nextOffsetY}px; `;\n\n      // if (restrictOffsetX || restrictOffsetY) {\n      //     viewportStyle.cssText += `position: relative; left: ${restrictOffsetX}px; top: ${restrictOffsetY}px`;\n      // }\n    } else {\n      viewportStyle.cssText +=\n        `transform-origin: 0 0;` +\n        `transform:translate3d(${nextOffsetX}px, ${nextOffsetY}px, ${translateZ}px) scale(${zoomX}, ${zoomY});`;\n\n      // if (restrictOffsetX || restrictOffsetY) {\n      //     viewportStyle.cssText += `transform:translate3d(${restrictOffsetX}px, ${restrictOffsetY}px, 0px)`;\n      // }\n    }\n    this.renderScroll();\n  }\n  private renderScroll() {\n    const { zoomX, zoomY, containerWidth, containerHeight } = this;\n    const horizontalBar = this.horizontalScrollbar;\n    const verticalBar = this.verticalScrollbar;\n\n    if (this.options.useBounceScrollBar) {\n      const scrollLeft = this.getScrollLeft(true) * zoomX;\n      const rangeX = this.getRangeX(true);\n      const scrollWidth = containerWidth + abs(rangeX[0]) + abs(rangeX[1]);\n      const scrollTop = this.getScrollTop(true) * zoomY;\n      const rangeY = this.getRangeY(true);\n      const scrollHeight = containerHeight + abs(rangeY[0]) + abs(rangeY[1]);\n\n      horizontalBar.render(\n        this.displayHorizontalScroll,\n        scrollLeft,\n        containerWidth,\n        scrollWidth\n      );\n      verticalBar.render(\n        this.displayVerticalScroll,\n        scrollTop,\n        containerHeight,\n        scrollHeight\n      );\n    } else {\n      const scrollRangeX = this._getScrollRangeX();\n      const scrollRangeY = this._getScrollRangeY();\n      const scrollLeft = this.getScrollLeft();\n      const scrollTop = this.getScrollTop();\n      const scrollWidth =\n        this.containerWidth + abs(scrollRangeX[0]) + scrollRangeX[1];\n      const scrollHeight =\n        this.containerHeight + abs(scrollRangeY[0]) + scrollRangeY[1];\n\n      horizontalBar.render(\n        this.displayHorizontalScroll,\n        scrollLeft - scrollRangeX[0],\n        containerWidth,\n        scrollWidth\n      );\n      verticalBar.render(\n        this.displayVerticalScroll,\n        scrollTop - scrollRangeY[0],\n        containerHeight,\n        scrollHeight\n      );\n    }\n  }\n  private move(scrollLeft: number, scrollTop: number) {\n    const wrapperElement = this.wrapperElement;\n\n    wrapperElement.scrollLeft = scrollLeft;\n    wrapperElement.scrollTop = scrollTop;\n  }\n  private setDisplayVerticalScroll(displayVerticalScroll: boolean) {\n    this.options.displayVerticalScroll = displayVerticalScroll;\n    this.renderScroll();\n  }\n  private setDisplayHorizontalScroll(displayHorizontalScroll: boolean) {\n    this.options.displayHorizontalScroll = displayHorizontalScroll;\n    this.renderScroll();\n  }\n  private _onScroll = () => {\n    const { scrollLeft, scrollTop } = this.wrapperElement;\n    const { zoom = DEFAULT_OPTIONS.zoom } = this;\n    const deltaX = scrollLeft - this.scrollLeft;\n    const deltaY = scrollTop - this.scrollTop;\n    const viewerScrollLeft = this.getScrollLeft();\n    const viewerScrollTop = this.getScrollTop();\n\n    if (this.isLoop) {\n      this.isLoop = false;\n    }\n    this.scrollLeft = scrollLeft;\n    this.scrollTop = scrollTop;\n    this.scrollTo(\n      viewerScrollLeft + deltaX / zoom,\n      viewerScrollTop + deltaY / zoom\n    );\n  };\n  private onWheel = (e: WheelEvent) => {\n    const options = this.options;\n    const pinchDirection = options.pinchDirection;\n    const maxPinchWheel = options.maxPinchWheel || Infinity;\n\n    const isKeydown = e[`${this.wheelPinchKey}Key`] || e.ctrlKey;\n\n    if (options.useWheelPinch && isKeydown) {\n      let deltaY = e.deltaY;\n      const sign = deltaY >= 0 ? 1 : -1;\n      const distance = Math.min(maxPinchWheel, Math.abs(deltaY));\n\n      deltaY = sign * distance;\n      const delta = -deltaY;\n      const scale = Math.max(\n        1 + delta * (options.wheelScale || 0.01),\n        TINY_NUM\n      );\n\n      clearTimeout(this._tempRectTimer);\n      this._tempRectTimer = window.setTimeout(() => {\n        this._tempRect = null;\n      }, 100);\n      this._triggerPinch({\n        distance,\n        scale,\n        rotation: 0,\n        zoom: this.zoom * scale,\n        zoomX: this.zoomX * (pinchDirection === \"vertical\" ? 1 : scale),\n        zoomY: this.zoomY * (pinchDirection === \"horizontal\" ? 1 : scale),\n        inputEvent: e,\n        isWheel: true,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        ratioX: 0,\n        ratioY: 0,\n      });\n    } else if (options.useWheelScroll) {\n      let deltaX = e.deltaX;\n      let deltaY = e.deltaY;\n\n      if (e.shiftKey && !deltaX) {\n        deltaX = deltaY;\n        deltaY = 0;\n      }\n      this.scrollBy(deltaX / this.zoomX, deltaY / this.zoomY);\n    } else {\n      return;\n    }\n    e.preventDefault();\n  };\n  private onGestureStart = (e: any) => {\n    this._tempScale = [this.zoomX, this.zoomY];\n    this._setClientRect();\n    e.preventDefault();\n  };\n  private onGestureChange = (e: any) => {\n    e.preventDefault();\n    if (this.gesto.isFlag() || !this._tempScale) {\n      this._tempScale = [1, 1];\n      return;\n    }\n    const scale = e.scale;\n    const zoomX = this._tempScale[0];\n    const zoomY = this._tempScale[1];\n    const pinchDirection = this.options.pinchDirection;\n\n    this._triggerPinch({\n      distance: 0,\n      scale,\n      rotation: e.rotation,\n      inputEvent: e,\n      isWheel: true,\n      zoom: ((zoomX + zoomY) * scale) / 2,\n      zoomX: zoomX * (pinchDirection === \"vertical\" ? 1 : scale),\n      zoomY: zoomY * (pinchDirection === \"horizontal\" ? 1 : scale),\n      clientX: e.clientX,\n      clientY: e.clientY,\n      ratioX: 0,\n      ratioY: 0,\n    });\n  };\n  private onGestureEnd = () => {};\n  private _startZoomAnimation(dest: number[], options: ZoomOptions) {\n    if (!dest) {\n      return;\n    }\n    const duration = options.duration;\n    const easing = options.easing || DEFAULT_EASING;\n\n    startAnimation(\n      (distRatio) =>\n        this._setZoom(\n          [this.zoomX + dest[0] * distRatio, this.zoomY + dest[1] * distRatio],\n          options\n        ),\n      (next) => {\n        this._zoomTimer = requestAnimationFrame(next);\n      },\n      {\n        easing,\n        duration,\n      }\n    );\n  }\n  private _startScrollAnimation(dest: number[], options: AnimationOptions) {\n    if (!dest[0] && !dest[1]) {\n      return;\n    }\n    const duration = options.duration;\n    const easing = options.easing || DEFAULT_EASING;\n\n    startAnimation(\n      (distRatio) =>\n        this._scrollBy(dest[0] * distRatio, dest[1] * distRatio, options),\n      (next) => {\n        this._scrollTimer = requestAnimationFrame(next);\n      },\n      {\n        easing,\n        duration,\n      }\n    );\n  }\n  private _startScrollAnimationBySpeed(speed: number[]) {\n    if (!speed || (!speed[0] && !speed[1])) {\n      return;\n    }\n    const a = -0.0006;\n    const duration = getDuration(speed, a);\n    const destPos = getDestPos(speed, a);\n\n    return this._startScrollAnimation(destPos, {\n      duration,\n    });\n  }\n  private _pauseScrollAnimation() {\n    cancelAnimationFrame(this._scrollTimer);\n    this._scrollTimer = 0;\n  }\n  private _pauseZoomAnimation() {\n    cancelAnimationFrame(this._zoomTimer);\n    this._zoomTimer = 0;\n  }\n  private getScrollAreaWidth() {\n    const [min, max] = this.getRangeX(true);\n    return min || max ? this.margin * 2 : 0;\n  }\n  private getScrollAreaHeight() {\n    const [min, max] = this.getRangeY(true);\n    return min || max ? this.margin * 2 : 0;\n  }\n  private _triggerPinch(event: OnPinch) {\n    const { clientX, clientY, zoomX, zoomY } = event;\n    if (this.useAutoZoom) {\n      this._zoomByClient([zoomX, zoomY], clientX, clientY);\n    }\n    if (!this._tempRect) {\n      this._setClientRect();\n    }\n    const zoomRange = this.zoomRange;\n    const zoomRangeX = this.zoomRangeX || zoomRange;\n    const zoomRangeY = this.zoomRangeY || zoomRange;\n    const { left, top, width, height } = this._tempRect;\n    const ratioX = ((clientX - left) / width) * 100;\n    const ratioY = ((clientY - top) / height) * 100;\n\n    this.trigger(\"pinch\", {\n      ...event,\n      zoom: between((zoomX + zoomY) / 2, zoomRange[0], zoomRange[1]),\n      zoomX: between(zoomX, zoomRangeX[0], zoomRangeX[1]),\n      zoomY: between(zoomY, zoomRangeY[0], zoomRangeY[1]),\n      ratioX,\n      ratioY,\n    });\n  }\n  private _setClientRect() {\n    const rect = this.getContainer().getBoundingClientRect();\n    this._tempRect = {\n      left: rect.left,\n      top: rect.top,\n      width: rect.width,\n      height: rect.height,\n    };\n  }\n  private _zoomByClient(zoom: number[], clientX: number, clientY: number) {\n    if (!this._tempRect) {\n      this._setClientRect();\n    }\n    const { left, top, width, height } = this._tempRect;\n    const options = this.options;\n\n    const originalZoomOffsetX = options.zoomOffsetX;\n    const originalZoomOffsetY = options.zoomOffsetY;\n\n    options.zoomOffsetX = `${((clientX - left) / width) * 100}%`;\n    options.zoomOffsetY = `${((clientY - top) / height) * 100}%`;\n\n    this._setZoom(zoom, {\n      zoomBase: \"screen\",\n    });\n\n    options.zoomOffsetX = originalZoomOffsetX;\n    options.zoomOffsetY = originalZoomOffsetY;\n  }\n  private _setZoom(zoom: number | number[], zoomOptions: ZoomOptions = {}) {\n    const zoomBase = zoomOptions.zoomBase;\n    const {\n      containerWidth,\n      containerHeight,\n      zoomX: prevZoomX,\n      zoomY: prevZoomY,\n      zoomRange,\n    } = this;\n    let {\n      zoomOffsetX = DEFAULT_OPTIONS.zoomOffsetX,\n      zoomOffsetY = DEFAULT_OPTIONS.zoomOffsetY,\n    } = this;\n    if (\"zoomOffsetX\" in zoomOptions) {\n      zoomOffsetX = zoomOptions.zoomOffsetX;\n    }\n    if (\"zoomOffsetY\" in zoomOptions) {\n      zoomOffsetY = zoomOptions.zoomOffsetY;\n    }\n\n    const scrollLeft = this.getScrollLeft();\n    const scrollTop = this.getScrollTop();\n\n    const [zoomX, zoomY] = isArray(zoom) ? zoom : [zoom, zoom];\n    const zoomRangeX = this.zoomRangeX || zoomRange;\n    const zoomRangeY = this.zoomRangeY || zoomRange;\n    const nextZoomX = between(zoomX, zoomRangeX[0], zoomRangeX[1]);\n    const nextZoomY = between(zoomY, zoomRangeY[0], zoomRangeY[1]);\n    const options = this.options;\n\n    options.zoomX = nextZoomX;\n    options.zoomY = nextZoomY;\n    options.zoom = (nextZoomX + nextZoomY) / 2;\n\n    const nextScrollLeft = this.getScrollLeft();\n    const nextScrollTop = this.getScrollTop();\n\n    let zoomXPos = 0;\n    let zoomYPos = 0;\n\n    if (zoomBase === \"fixed\") {\n      zoomXPos = convertUnitSize(`${zoomOffsetX}`, this.viewportWidth);\n      zoomYPos = convertUnitSize(`${zoomOffsetY}`, this.viewportHeight);\n    } else if (zoomBase === \"viewport\") {\n      zoomXPos =\n        (-scrollLeft + convertUnitSize(`${zoomOffsetX}`, this.viewportWidth)) *\n        prevZoomX;\n      zoomYPos =\n        (-scrollTop + convertUnitSize(`${zoomOffsetY}`, this.viewportHeight)) *\n        prevZoomY;\n    } else {\n      zoomXPos = convertUnitSize(`${zoomOffsetX}`, containerWidth);\n      zoomYPos = convertUnitSize(`${zoomOffsetY}`, containerHeight);\n    }\n\n    const centerX = scrollLeft + zoomXPos / prevZoomX;\n    const centerY = scrollTop + zoomYPos / prevZoomY;\n\n    const nextCenterX = nextScrollLeft + zoomXPos / nextZoomX;\n    const nextCenterY = nextScrollTop + zoomYPos / nextZoomY;\n\n    this._scrollBy(centerX - nextCenterX, centerY - nextCenterY, {\n      zoom: !!(nextZoomX - prevZoomX || nextZoomY - prevZoomY),\n    });\n    this.render();\n  }\n  private _scrollBy(\n    deltaX: number,\n    deltaY: number,\n    options?: InnerScrollOptions\n  ) {\n    let scrollLeft = this.getScrollLeft();\n    let scrollTop = this.getScrollTop();\n\n    if (options?.absolute) {\n      scrollLeft *= this.zoomX;\n      scrollTop *= this.zoomY;\n    }\n    return this._scrollTo(scrollLeft + deltaX, scrollTop + deltaY, options);\n  }\n  private _scrollTo(x: number, y: number, options?: InnerScrollOptions) {\n    const { scrollLeft: prevScrollLeft, scrollTop: prevScrollTop } = this;\n\n    const isAbsolute = options?.absolute;\n    this._scrollToType(\"horizontal\", x, isAbsolute);\n    this._scrollToType(\"vertical\", y, isAbsolute);\n\n    const scrollLeft = this.scrollLeft;\n    const scrollTop = this.scrollTop;\n    this.render();\n    const nextScrollAbsoluteLeft = this.getScrollLeft();\n    const nextScrollAbsoluteTop = this.getScrollTop();\n\n    this._emitScrollEvent(\n      nextScrollAbsoluteLeft,\n      nextScrollAbsoluteTop,\n      options?.zoom\n    );\n\n    if (\n      Math.round(prevScrollLeft) !== scrollLeft ||\n      Math.round(prevScrollTop) !== scrollTop\n    ) {\n      this.isLoop = true;\n      this.move(scrollLeft, scrollTop);\n      requestAnimationFrame(() => {\n        if (!this.isLoop) {\n          return;\n        }\n        this.isLoop = false;\n        const { scrollLeft: requestScrollLeft, scrollTop: requestScrollTop } =\n          this.wrapperElement;\n\n        this.scrollLeft = requestScrollLeft;\n        this.scrollTop = requestScrollTop;\n\n        if (\n          scrollLeft !== Math.round(requestScrollLeft) ||\n          scrollTop !== Math.round(requestScrollTop)\n        ) {\n          this._scrollTo(nextScrollAbsoluteLeft, nextScrollAbsoluteTop);\n        }\n      });\n      return false;\n    }\n    return true;\n  }\n  private _scrollToType(\n    type: \"horizontal\" | \"vertical\",\n    coord: number,\n    isAbsolute?: boolean\n  ) {\n    const names = NAMES[type];\n    const {\n      margin = DEFAULT_OPTIONS.margin,\n      threshold = DEFAULT_OPTIONS.threshold,\n    } = this;\n    const prevScrollPos = this[`scroll${names.pos}`];\n    const [minCoord, maxCoord] = this[`getRange${names.coord}`](true, true);\n\n    let scrollPos = Math.round(prevScrollPos);\n\n    const scrollAreaSize = this[`getScrollArea${names.size}`]();\n    const zoom = this[`zoom${names.coord}`];\n\n    if (isAbsolute) {\n      coord = coord / zoom;\n    }\n    const zoomCoord = coord * zoom;\n\n    if (minCoord === maxCoord) {\n      scrollPos = minCoord;\n      coord = minCoord / zoom;\n    } else if (zoomCoord - threshold <= minCoord) {\n      const minThreshold = Math.max(0, zoomCoord - minCoord);\n\n      scrollPos = minThreshold;\n      coord = (minCoord + minThreshold) / zoom;\n    } else if (zoomCoord + threshold >= maxCoord) {\n      const maxThreshold = Math.max(0, maxCoord - zoomCoord);\n\n      scrollPos = scrollAreaSize - maxThreshold;\n      coord = (maxCoord - maxThreshold) / zoom;\n    } else if (scrollPos < threshold) {\n      scrollPos += margin;\n    } else if (scrollPos > scrollAreaSize - threshold) {\n      scrollPos -= margin;\n    }\n\n    scrollPos = Math.round(scrollPos);\n\n    this[`scroll${names.pos}`] = scrollPos;\n    this[`offset${names.coord}`] = coord - scrollPos / zoom;\n  }\n  private _getRangeCoord(\n    type: \"vertical\" | \"horizontal\",\n    isZoom?: boolean,\n    isReal?: boolean\n  ) {\n    const { margin = DEFAULT_OPTIONS.margin, threshold } = this;\n\n    const names = NAMES[type];\n    const rangeCoord = checkDefault(\n      this[`range${names.coord}`],\n      DEFAULT_OPTIONS[`range${names.coord}`]\n    );\n    const rangeOffsetCoord = checkDefault(\n      this[`rangeOffset${names.coord}`],\n      DEFAULT_OPTIONS[`rangeOffset${names.coord}`]\n    );\n    const zoom = this[`zoom${names.coord}`];\n    const range = getRange(\n      this[`getScroll${names.pos}`](),\n      margin,\n      rangeCoord,\n      threshold,\n      isReal\n    );\n\n    if (!isZoom) {\n      return [range[0] + rangeOffsetCoord[0], range[1] + rangeOffsetCoord[1]];\n    }\n    return [\n      range[0] * zoom + rangeOffsetCoord[0],\n      this.options.useOverflowScroll\n        ? Math.max(\n            this[`viewport${names.size}`] * zoom -\n              this[`container${names.size}`],\n            range[1] * zoom + rangeOffsetCoord[1]\n          )\n        : range[1] * zoom + rangeOffsetCoord[1],\n    ];\n  }\n  private _emitScrollEvent(\n    scrollLeft: number,\n    scrollTop: number,\n    zoom?: boolean\n  ) {\n    const prevScrollLeft = this._asLeft;\n    const prevScrollTop = this._asTop;\n\n    if (!zoom && prevScrollLeft === scrollLeft && prevScrollTop === scrollTop) {\n      return;\n    }\n    this._asLeft = scrollLeft;\n    this._asTop = scrollTop;\n\n    /**\n     * The `scroll` event fires when the document view or an element has been scrolled.\n     * @memberof InfiniteViewer\n     * @event scroll\n     * @param {InfiniteViewer.OnScroll} - Parameters for the scroll event\n     * @example\n     * import InfiniteViewer from \"infinite-viewer\";\n     *\n     * const viewer = new InfiniteViewer(\n     *   document.querySelector(\".container\"),\n     *   document.querySelector(\".viewport\"),\n     * ).on(\"scroll\", () => {\n     *   console.log(viewer.getScrollLeft(), viewer.getScrollTop());\n     * });\n     */\n    this.trigger(\"scroll\", {\n      scrollLeft,\n      scrollTop,\n      zoomX: this.zoomX,\n      zoomY: this.zoomY,\n    });\n  }\n  private _getScrollRangeX() {\n    const pos = this.getScrollLeft();\n    const rangeX = this.rangeX;\n    const startRange = rangeX[0];\n    let endRange = rangeX[1];\n\n    if (this.useOverflowScroll && isFinite(endRange)) {\n      endRange = Math.max(\n        endRange,\n        this.viewportWidth - this.containerWidth / this.zoomX\n      );\n    }\n\n    const startMargin = Math.min(\n      0,\n      isFinite(startRange) ? Math.min(startRange, pos) : pos\n    );\n    const endMargin = Math.max(\n      0,\n      isFinite(endRange) ? Math.max(endRange, pos) : pos\n    );\n    const viewportSize = this.viewportScrollWidth;\n    const margin =\n      Math.max(this.containerWidth / this.zoomX, viewportSize) - viewportSize;\n    const startSizeOffset = Math.min(0, margin + startMargin);\n\n    return [startSizeOffset, endMargin];\n  }\n  private _getScrollRangeY() {\n    const pos = this.getScrollTop();\n    const rangeY = this.rangeY;\n    const startRange = rangeY[0];\n    let endRange = rangeY[1];\n\n    if (this.useOverflowScroll && isFinite(endRange)) {\n      endRange = Math.max(\n        endRange,\n        this.viewportHeight - this.containerHeight / this.zoomY\n      );\n    }\n\n    const startMargin = Math.min(\n      0,\n      isFinite(startRange) ? Math.min(startRange, pos) : pos\n    );\n    const endMargin = Math.max(\n      0,\n      isFinite(endRange) ? Math.max(endRange, pos) : pos\n    );\n    const viewportSize = this.viewportScrollHeight;\n    const margin =\n      Math.max(this.containerHeight / this.zoomY, viewportSize) - viewportSize;\n    const startSizeOffset = Math.min(0, margin + startMargin);\n\n    return [startSizeOffset, endMargin];\n  }\n}\napplyProperties(InfiniteViewer, [...PROPERTIES]);\n\ninterface InfiniteViewer extends InfiniteViewerProperties {}\n\nexport default InfiniteViewer;\n","import { EVENTS } from \"../infinite-viewer\";\nimport { camelize } from \"../utility\";\n\nexport const REACT_EVENTS = EVENTS.map((name) => camelize(`on ${name}`));\n","import * as React from \"react\";\nimport VanillaInfiniteViewer, {\n  CLASS_NAME,\n  OPTIONS,\n  InfiniteViewerOptions,\n  PROPERTIES,\n  InfiniteViewerProperties,\n  EVENTS,\n  InfiniteViewerMethods,\n  METHODS,\n} from \"../infinite-viewer\";\nimport { InfiniteViewerProps } from \"./types\";\nimport { REACT_EVENTS } from \"./consts\";\nimport { ref, MethodInterface } from \"../utility/framework\";\n\nfunction applyMethods(\n  instance: any,\n  methods: readonly string[],\n  propertyName: string,\n  duplicate: { [name: string]: string } = {}\n) {\n  methods.forEach((name) => {\n    const methodName = duplicate[name] || name;\n\n    if (methodName in instance) {\n      return;\n    }\n    instance[methodName] = function (...args: any) {\n      const result = this[propertyName][name](...args);\n\n      if (result === this[propertyName]) {\n        return this;\n      } else {\n        return result;\n      }\n    };\n  });\n}\n\nexport default class InfiniteViewer extends React.PureComponent<\n  Partial<InfiniteViewerProps>\n> {\n  public infiniteViewer!: VanillaInfiniteViewer;\n  private containerElement!: HTMLElement;\n  private wrapperElement!: HTMLElement;\n  private scrollAreaElement!: HTMLElement;\n  private horizontalScrollElement!: HTMLElement;\n  private verticalScrollElement!: HTMLElement;\n  public render() {\n    const className = this.props.className;\n\n    return (\n      <div\n        className={`${className || \"\"} ${CLASS_NAME}`}\n        ref={ref(this, \"containerElement\")}\n      >\n        <div\n          className=\"infinite-viewer-wrapper\"\n          ref={ref(this, \"wrapperElement\")}\n        >\n          <div\n            className=\"infinite-viewer-scroll-area\"\n            ref={ref(this, \"scrollAreaElement\")}\n          ></div>\n          {this.props.children}\n        </div>\n        <div\n          className=\"infinite-viewer-scroll-bar infinite-viewer-horizontal-scroll-bar\"\n          ref={ref(this, \"horizontalScrollElement\")}\n        >\n          <div className=\"infinite-viewer-scroll-thumb\"></div>\n        </div>\n        <div\n          className=\"infinite-viewer-scroll-bar infinite-viewer-vertical-scroll-bar\"\n          ref={ref(this, \"verticalScrollElement\")}\n        >\n          <div className=\"infinite-viewer-scroll-thumb\"></div>\n        </div>\n      </div>\n    );\n  }\n  public componentDidMount() {\n    const props = this.props;\n    const options: Partial<InfiniteViewerOptions> = {};\n\n    OPTIONS.forEach((name) => {\n      if (name in props && typeof props[name] !== \"undefined\") {\n        (options as any)[name] = props[name];\n      }\n    });\n    this.infiniteViewer = new VanillaInfiniteViewer(\n      this.containerElement,\n      this.scrollAreaElement.nextElementSibling as HTMLElement,\n      {\n        ...options,\n        wrapperElement: this.wrapperElement,\n        scrollAreaElement: this.scrollAreaElement,\n        horizontalScrollElement: this.horizontalScrollElement,\n        verticalScrollElement: this.verticalScrollElement,\n      }\n    );\n\n    applyMethods(this, METHODS as any, \"infiniteViewer\");\n\n    EVENTS.forEach((name, i) => {\n      this.infiniteViewer.on(name, (e: any) => {\n        const selfProps = this.props as any;\n        const result =\n          selfProps[REACT_EVENTS[i]] && selfProps[REACT_EVENTS[i]](e);\n\n        if (result === false) {\n          e.stop();\n        }\n      });\n    });\n  }\n  public componentDidUpdate(prevProps: Partial<InfiniteViewerProperties>) {\n    const props = this.props;\n    const infiniteViewer = this.infiniteViewer;\n\n    PROPERTIES.forEach((name) => {\n      if (name in props && infiniteViewer[name] !== props[name]) {\n        (infiniteViewer as any)[name] = props[name];\n      }\n    });\n  }\n  public componentWillUnmount() {\n    this.infiniteViewer.destroy();\n  }\n  public getElement() {\n    return this.containerElement;\n  }\n}\n// tslint:disable-next-line: max-line-length\nexport default interface InfiniteViewer\n  extends MethodInterface<\n    InfiniteViewerMethods,\n    VanillaInfiniteViewer,\n    InfiniteViewer\n  > {}\n"],"names":["FUNCTION","OBJECT","STRING","NUMBER","UNDEFINED","IS_WINDOW","OPEN_CLOSED_CHARACTERS","TINY_NUM","DEFAULT_UNIT_PRESETS","pos","size","getShapeDirection","points","center","getCenterPoint","pos1Rad","getRad","pos2Rad","i","average","pos1","pos2","distX","distY","rad","nums","length","total","getDist","a","b","findIndex","arr","callback","defaultIndex","throttle","num","unit","reverseUnit","throttleArray","_","find","defalutValue","index","isObject","value","isString","isArray","camelize","str","all","letter","decamelize","separator","letter2","isFunction","isUndefined","isNumber","isEqualSeparator","character","isCharacterSpace","between","min","max","splitUnit","text","matches","prefix","splitComma","splitText","splitBracket","calculateBoundSize","minSize","maxSize","keepRatio","width","height","ratio","minWidth","minHeight","checkBoundSize","maxWidth","maxHeight","targetSize","compareSize","isMax","defaultSize","throttledSize","getKeys","obj","cancelAnimationFrame","caf","handle","requestAnimationFrame","firstTime","now","raf","currTime","findOpen","openCharacter","texts","openCloseCharacters","findIgnore","findClose","otherText","closeCharacter","nextIndex","open","splitOptions","isSeparateFirst","isSeparateOnlyOpenClose","isSeparateOpenClose","openClosedText","close","regexText","regex","chr","values","tempValues","resetTemp","nextOpenCloseCharacters","splitSpace","dot","a1","a2","b1","b2","convertUnitSize","sizeFunction","flat","prev","cur","counter","hasClass","element","className","addClass","removeClass","reg","getDocument","el","getDocumentElement","getDocumentBody","isWindow","val","isNode","getWindow","_a","addEvent","type","listener","options","removeEvent","EventEmitter","__publicField","eventName","name","events","e","resolve","param","isStop","info","getRotatiion","touches","isMultiTouch","getEventClients","getClients","getClient","isMouseEvent","getPosition","clients","prevClients","startClients","clientX","clientY","originalClientX","originalClientY","getAverageClient","prevX","prevY","startX","startY","deltaX","deltaY","sumClient","minLength","client","ClientStore","isAdd","position","positions","movement","currentClient","prevClient","INPUT_TAGNAMES","Gesto","targets","isTrusted","isDragAPI","container","pinchOutside","preventWheelClick","preventRightClick","preventDefault","checkInput","dragFocusedInput","preventClickEventOnDragStart","preventClickEventOnDrag","preventClickEventByCondition","useTouch","isDragStart","activeElement","target","tagName","hasInput","hasContentEditable","activeTagName","timer","isScroll","result","isDrag","currentTime","isDouble","elements","firstTarget","checkWindowBlur","passive","isCallDrag","inputEvent","nextClients","data","currentData","pinchThreshold","store","isPinch","isPrevDrag","isFirstDrag","storePosition","win","PolyMap","key","HashMap","SUPPORT_MAP","Link","prevLink","nextLink","next","link","orderChanged","changed","fixed","fromLinks","toLinks","from","to","fromLink","toLink","fromIndex","toIndex","Result","prevList","list","added","removed","maintained","changedBeforeAdded","ordered","pureChanged","_from","_to","fromBefore","toBefore","diff","findKeyCallback","mapClass","prevKeys","keys","prevKeyMap","keyMap","removedMap","addedCount","removedCount","prevListIndex","listIndex","ListDiffer","newData","childrenCount","ChildrenDiffer","listdiff","getDefaultScrollPosition","checkDefaultScrollEvent","getContainerElement","DragScroll","top","left","rect","threshold","_startRect","_startPos","direction","prevScrollPos","throttleTime","nextScrollPos","offsetX","offsetY","nextDirection","getScrollPosition","useScroll","nowTime","distTime","checkScrollEvent","tinyThrottle","isSameConstants","linearConstants1","linearConstants2","v","isSamePoint","point1","point2","getAreaSize","sum","point","nextPoint","getOverlapPoints","points1","points2","getOverlapPointInfos","convertLines","getLinearConstants","x1","y1","x2","y2","dx","dy","c","targetPoints1","targetPoints2","lines1","lines2","linearConstantsList1","line1","linearConstantsList2","line2","overlapInfos","linePointInfos","j","intersectionPoints","getIntersectionPointsByConstants","getPointsOnLines","isInside","isNext","index2","index1","pointMap","c1","c2","isZeroA","isZeroB","results","y","x","lines","minMaxs","line","order","minMax","right","bottom","pointX","pointY","excludeLine","minX","maxX","getMinMaxs","xLine","xLinearConstants","intersectionPosInfos","linearConstants","standardPoint","linePoint","p","intersectionCount","xMap","prevValue","nextValue","xs","ys","fitPoints","minY","maxY","ratioX","ratioY","getOverlapSize","add","matrix","inverseMatrix","startIndex","n","k","fromX","swap","iv","divide","ignoreDimension","m","newMatrix","invert","createIdentityMatrix","identityIndex","targetStartIndex","targetIndex","transpose","getOrigin","originMatrix","w","fromTranslation","convertPositionMatrix","convertDimension","multiplies","matrixes","multiply","matrix2","l","plus","nextPos","minus","convertCSStoMatrix","is2d","convertMatrixtoCSS","calculate","rotateX3d","rotateY3d","rotateZ3d","createRotateMatrix","scale3d","sx","sy","sz","rotate","translate3d","tx","ty","tz","matrix3d","matrix1","cos","sin","createScaleMatrix","scale","createOriginMatrix","origin","createWarpMatrix","pos0","pos3","nextPos0","nextPos1","nextPos2","nextPos3","x0","y0","x3","y3","u0","v0","u1","v1","u2","v2","u3","v3","h","createMatrix","parseMat","transform","toMat","parse","calculateMatrixDist","res","getDistElementMatrix","matrixInfos","matrixFunction","functionValue","t","functionName","nextSize","posX","posY","posZ","unitValue","touch","filterDuplicated","map","elementFromPoint","baseNode","doc","jsxToObject","jsxElement","createElement","jsxBack","prevTarget","jsx","tag","children","attributes","style","elChildren","child","elStyle","diffValue","func","getRect","boundArea","nextHeight","nextWidth","getDefaultElementRect","passTargets","beforeTargets","afterTargets","continueSelectWithoutDeselect","getLineSize","stringHash","hash","getHash","getShadowRoot","parentElement","rootNode","replaceStyle","css","selector","trimmedSelector","subSelector","trimmedSubSelector","injectStyle","shadowRoot","styled","injectClassName","styleElement","count","injectCount","injector","CLASS_NAME","PROPERTIES","setupProperties","component","prototype","property","getter","setter","Selecto","clickedTarget","selectFromInside","selectByClick","rootContainer","boundContainer","preventDragFromInside","clickBySelectEnd","dragCondition","containerRect","boundInfo","boundElement","rectElement","hitRect","firstPassedTargets","allowClickBySelectEnd","hasInsideTargets","pointTarget","isPreventSelect","offsetPos","scrollOptions","innerScrollOptions","isInnerScroll","innerScrollElement","selectFlag","dragContainer","containers","portalContainer","selectedTargets","beforeSelected","selectedElements","startPoint","endPoint","mousedown","mousemove","mouseup","gesto","getElementRect","selectableElements","selectableTargets","selectablePoints","hasIndexesMap","parentMap","parents","paths","prevParentElement","dragEvent","nextClassName","keyContainer","toggleContinueSelectWithoutDeselect","toggleContinueSelect","selectRect","gestoEvent","hitRate","innerGroups","innerWidth","innerHeight","ignoreClick","rectPoints","isHit","hitRateValue","inArea","overlapPoints","overlapSize","selectableInners","yGroups","group","inner","isMoveInnerScroll","parentInfo","scrollContainer","containerInfo","isStart","isDragStartEnd","startResult","startSelectedTargets","startPassedTargets","afterAdded","afterRemoved","afterPrevList","afterList","containerX","containerY","scaleMatrix","offsetSize","passedTargets","innerScrollContainer","innerScrollPathsList","innerScrollPaths","isAlwaysTrue","groups","makeAble","able","some","getUserAgentString","agent","userAgent","execRegExp","pattern","hasUserAgentData","userAgentData","brands","findVersion","versionTest","convertVersion","findPreset","presets","userPreset","version","preset","findPresetBrand","brandInfo","findBrand","brand","BROWSER_PRESETS","CHROMIUM_PRESETS","WEBKIT_PRESETS","WEBVIEW_PRESETS","OS_PRESETS","isWebView","getLegacyAgent","nextAgent","isMobile","browser","os","browserPreset","browserVersion","_b","osPreset","osVersion","chromiumPreset","webkitPreset","getClientHintsAgent","osData","firstBrand","platform","chromiumBrand","webkitBrand","platfomResult","browserBrand","DIRECTIONS4","DIRECTIONS","getSVGCursor","degree","getCursorCSS","degree45","defaultCursor","getAgent","IS_WEBKIT","IS_WEBKIT605","navi","browserName","IS_CHROME","IS_CHROMIUM","chromiumVersion","IS_CHROMIUM109","IS_FIREFOX","IS_SAFARI_ABOVE15","PREFIX","directionCSS","dir","originX","originY","offset","MOVEABLE_CSS","NEARBY_POS","FLOAT_POINT_NUM","MIN_SCALE","MAX_NUM","MIN_NUM","DIRECTION_REGION_TO_DIRECTION","DIRECTION_INDEXES","DIRECTION_ROTATIONS","MOVEABLE_METHODS","prefixNames","classNames","ref","refs","prefixCSS","setCustomDrag","state","delta","isConvert","ableName","datas","ableDatas","CustomGesto","originalDatas","calculateElementPosition","poses","calculatePoses","x4","y4","calculatePosition","sign","calculatePointerDist","moveable","moveableClientRect","rootMatrix","is3d","calculateInversePosition","getDragDist","setDragStart","allMatrix","beforeMatrix","offsetMatrix","targetMatrix","transformOrigin","getTransformDirection","resolveTransformEvent","event","nextTransforms","nextTransformAppendedIndexes","convertTransformInfo","targetFunction","matFunctionName","convertTransformFormat","dist","getTransformDist","bx","by","getBeforeDragDist","getTransfromMatrix","isAfter","beforeTransform","afterTransform","beforeTransform2","afterTransform2","targetAllTransform","nextTargetMatrix","res1","inverseBeforeMatrix","startDragBeforeDist","absoluteOrigin","isBefore","startDragDist","getInverseDragDist","calculateTransformOrigin","prevWidth","prevHeight","prevOrigin","prevSize","measureRatio","getPosIndexesByDirection","indexes","getPosesByDirection","getPosBySingleDirection","getPosByDirection","startPos","fixedDirection","fixedPos","getNextMatrix","getAbsoluteMatrix","getNextTransformMatrix","isAllTransform","targetTransform","fillTransformStartEvent","getBeforeRenderableDatas","setTransformIndex","setDefaultTransformIndex","startTransforms","fillOriginalTransform","getNextTransforms","getNextTransformText","getNextStyle","fillTransformEvent","nextTransform","drag","Draggable","fillCSSObject","getTranslateFixedPosition","fixedOffset","nextMatrix","getDirectionOffset","getTranslateDist","fixedPosition","nextFixedPosition","groupable","groupLeft","groupTop","getScaleDist","getDirectionByPos","fixedOffsetPosition","getRotateDist","rotateDist","getResizeDist","nextOrigin","getAbsolutePosition","getAbsolutePosesByState","getGestoData","targetGesto","controlGesto","getIndividualTransforms","getStyle","translate","individualTransforms","getMatrixStackInfo","checkContainer","documentElement","requestEnd","isEnd","targetTransformOrigin","hasFixed","offsetContainer","getOffsetInfo","zoom","getCachedStyle","getElementTransform","isFixed","getTransformMatrix","offsetParent","isOffsetEnd","isStatic","parentClientLeft","parentClientTop","fixedClientLeft","fixedClientTop","fixedInfo","getPositionFixedInfo","convert3DMatrixes","hasOffset","isSVG","targetOrigin","getOffsetPosInfo","offsetLeft","offsetTop","getSVGMatrix","targetZoom","offsetInfo","offsetZoom","customOffsetParent","customOffsetLeft","customOffsetTop","margin","getBodyOffset","isElementTarget","scrollLeft","scrollTop","cacheStyleMap","clientRectStyleMap","matrixContainerInfos","setStoreCache","useCache","getCachedClientRect","clientRect","nextClientRect","getClientRect","getCachedMatrixContainerInfo","cache","nextStyle","cached","fillChildEvents","groupableDatas","childDatas","triggerChildGesto","moveables","childEvents","eventParams","ev","childMoveable","gestos","childEvent","triggerChildAbles","eachEvent","startChildDist","parentDatas","startPositions","originalX","originalY","renderDirectionControlsByInfos","renderDirections","React","renderPoses","rotationRad","getProps","degRotation","absDegree","directionMap","renderState","renderDirectionMap","directionSign","directionRotation","dataAttrs","getControlTransform","renderDirectionControls","defaultDirections","directions","displayAroundControls","renderAroundControls","renderLine","rotation","getLineStyle","renderEdgeLines","edge","getRenderDirections","renderDiagonalDirections","renderAllDirections","checkBoundPoses","bounds","verticalPoses","horizontalPoses","nextBounds","checkBounds","getBounds","externalBounds","containerHeight","containerWidth","clientLeft","clientTop","snapOffsetLeft","snapOffsetTop","snapOffsetRight","snapOffsetBottom","isCSS","checkBoundKeepRatio","endPos","endX","endY","abs","isBottom","isRight","verticalInfo","horizontalInfo","isBound","isVertical","startBoundPos","endBoundPos","minPos","maxPos","boundInfos","isBoundRotate","relativePoses","boundRect","boundRotate","vec","boundPos","r","getDistSize","checkRotateBounds","prevPoses","nextPoses","relativeLeft","relativeRight","relativeTop","relativeBottom","relativeRad1","relativeRad2","nextRad","VERTICAL_NAMES","HORIZONTAL_NAMES","SNAP_SKIP_NAMES_MAP","VERTICAL_NAMES_MAP","HORIZONTAL_NAMES_MAP","getInitialBounds","hasGuidelines","snappable","innerBounds","verticalGuidelines","horizontalGuidelines","snapGridWidth","snapGridHeight","guidelines","enableSnap","getSnapDirections","snapDirections","mapSnapDirectionPoses","snapPoses","nextSnapDirections","nextSnapPoses","splitSnapDirectionPoses","horizontalNames","verticalNames","calculateContainerPos","clientPos","solveLineConstants","NAME_snapRotationThreshold","NAME_snapRotationDegrees","NAME_snapHorizontalThreshold","NAME_snapVerticalThreshold","checkMoveableSnapPoses","posesX","posesY","dirXs","dirYs","customSnapVerticalThreshold","customSnapHorizontalThreshold","props","snapThresholdMultiples","snapHorizontalThreshold","selectValue","snapVerticalThreshold","checkSnapPoses","multiples","checkSnap","checkSnapKeepRatio","getTinyDist","verticalSnapInfo","horizontalSnapInfo","isVerticalSnap","verticalGuideline","getNearestSnapGuidelineInfo","isHorizontalSnap","horizontalGuideline","horizontalPos","verticalPos","isSnap","getStringDirection","stringDirection","checkSnaps","horizontalDirection","verticalDirection","snapInfo","posInfo","guidelineInfo","guideline","targetType","targetPoses","snapThreshold","dirs","posType","snapPosInfos","targetPos","guidelineInfos","snapPosInfo","getSnapInfosByDirection","snapDirection","nextDir","checkSnapBoundPriority","aDist","bDist","getNearOffsetInfo","offsets","aSign","bSign","aOffset","bOffset","getCheckSnapDirections","endDirection","signX","signY","isStartLine","cx","cy","hitTestLine","test1","test2","isSameStartLine","dots","centerSign","error","checkInnerBoundDot","start","end","checkInnerBound","verticalSign","horizontalSign","lineConstants","leftLine","topLine","rightLine","bottomLine","topBoundInfo","checkLineBoundCollision","bottomBoundInfo","leftBoundInfo","rightBoundInfo","isAllVerticalBound","isVerticalBound","isAllHorizontalBound","isHorizontalBound","verticalOffset","maxOffset","horizontalOffset","isAllBound","boundLine","isRender","dot1","boundDot1","boundDot2","dy2","dx2","hasDx","hasDy","slope","getInnerBoundInfo","lineInfos","multiple","sizeOffset","getInnerBoundDragInfo","getCheckInnerBoundLineInfos","innerBoundInfo","widthOffsetInfo","heightOffsetInfo","getCheckSnapLineDirections","lineDirections","virtualPoses","dir1","dir2","virtualLine","boundDots","getDistPointLine","solveReverseLine","checkRotateInnerBounds","dotInfos","lineRad","lineDist","dotDist","dotRad","distRad","nextRad1","nextRad2","checkInnerBoundPoses","boundMap","pos4","lineInfo","isHorizontalStart","isVerticalStart","solveEquation","snapOffset","solveNextOffset","dist1","dist2","isOutside","widthOffset","heightOffset","getSnapBound","checkThrottleDragRotate","throttleDragRotate","adjustPoses","adjustPos","prevDistY","checkSnapBoundsDrag","ignoreSnap","getAbsolutePoses","boundPoses","verticalSnapBoundInfo","horizontalSnapBoundInfo","checkMoveableSnapBounds","verticalInnerBoundInfo","horizontalInnerBoundInfo","horizontalBoundInfos","verticalBoundInfos","horizontalDist","verticalDist","checkSnapBounds","guideines","checkSnapRightLine","snapBoundInfo","rad180","isHorizontalLine","isVerticalLine","getSnapBoundInfo","isRequest","startDirection","otherStartPos","otherEndPos","checkSnapBoundsKeepRatio","otherHorizontalOffset","isOtherHorizontalBound","isOtherHorizontalSnap","otherVerticalOffset","isOtherVerticalBound","isOtherVerticalSnap","snapLine","getSnapBoundOffset","horizontalBoundInfo","verticalBoundInfo","checkMaxBounds","otherDirection","isCheckVertical","isCheckHorizontal","otherPos","deg","nextOtherPos","isHeightOutside","isWidthOutside","hideThrottleDragRotateLine","dragInfo","beforeOrigin","parentEvent","parentGesto","startCheckSnapDrag","params","fillParams","triggerEvent","parentFlag","deltaOffset","useSnap","isGroup","parentThrottleDrag","prevDist","prevBeforeDist","startValue","parentMoveable","throttleDrag","dragRotateRad","startDragRotate","ry","rx","beforeTranslate","beforeDist","beforeDelta","fillEndParams","nextParams","passDelta","getFixedDirectionInfo","getOffsetFixedDirectionInfo","nextFixedOffset","getOffsetFixedPositionInfo","offsetFixedPosition","directionCondition","getDirectionCondition","Resizable","getDirectionViewClassName","parentDirection","parentFixedDirection","getTotalDirection","setRatio","setFixedDirection","setFixedPosition","setMin","setMax","nextMaxSize","startWidth","startHeight","parentKeepRatio","dragClient","parentDist","resolveMatrix","isResize","startOffsetWidth","startOffsetHeight","isWidth","startOffsetMatrix","startTransformOrigin","targetN","nextAllMatrix","resizeFormat","throttleResize","keepRatioFinally","sizeDirection","distWidth","distHeight","getNextBoundingSize","getOffsetSizeDist","boundingWidth","boundingHeight","nextFixedDirection","snapDist","checkSnapResize","computeSize","isNoSnap","inverseDelta","fillAfterTransform","errorWidth","errorHeight","isErrorWidth","isErrorHeight","originalEvents","parentStartOffsetWidth","parentStartOffsetHeight","updateGroupMin","originalMinSize","childMinSize","childStartOffsetWidth","childStartOffsetHeight","parentMinWidth","parentMinHeight","updateGroupMax","originalMaxSize","childMaxSize","parentMaxWidth","parentMaxHeight","catchEvent","parentScale","setRotateStartInfo","startAbsoluteOrigin","getAbsoluteDist","defaultDeg","prevDeg","normalizedPrevDeg","loop","getAbsoluteDistByClient","getRotateInfo","moveableRect","throttleRotate","prevSnapDeg","snapRotation","checkSnapRotate","snapDeg","getRotationPositions","rotationPosition","radPoses","getRotationRad","isReverse","dragControlCondition","rotationTarget","getRefTargets","Rotatable","rotatable","rotateAroundControls","resolveAblesWithRotatable","jsxs","ables","resolveMap","directionControlInfos","parentRotate","beforeDirection","resizeStart","startClientX","startClientY","externalRotate","inputTarget","regionDirection","controlDirection","clientPoses","calculateMoveableClientPositions","originalFixedPosition","fixedBeforeOrigin","fixedAfterOrigin","posDelta","dragStart","getTotalOrigin","rotatation","clientDistX","clientDistY","groupDelta","beforeInfo","afterInfo","absoluteInfo","isRotate","targetDirection","beforeRotation","absoluteDelta","absoluteDist","absoluteRotation","startRotation","absoluteStartRotation","nextClientX","nextClientY","nextRotation","inverseDist","transformEvent","parentDistance","resize","resizeEvent","parentLeft","parentTop","parentBeforeOrigin","childClient","startGroupClient","prevClientX","prevClientY","rotateMatrix","distRotate","renderGuideline","isHorizontal","scaleType","renderInnerGuideline","renderSnapPoses","renderPos","renderGuidelines","targetRect","isDisplayInnerSnapDigit","mainNames","targetStart","targetEnd","hide","elementRect","renderDigitLine","lineType","gap","snapDigit","isDisplaySnapDigit","snapDistFormat","sizeName","absGap","snapSize","groupByElementGuidelines","otherIndex","names","groupBy","nextGuidelines","elementRect1","elementRect2","renderDashedGuidelines","rendered","sideNames","sidePos","prevRect","nextRect","size1","size2","renderPos1","renderPos2","renderGapGuidelines","targetSideStart","targetSideEnd","gapRects","sideStartPos","sideEndPos","sideCenterPos","getTotalGuidelines","containerClientRect","overflow","containerClientHeight","containerClientWidth","snapGap","maxSnapElementGuidelineDistance","isDisplayGridGuidelines","totalGuidelines","getElementGuidelines","getGapGuidelines","getGridGuidelines","getDefaultGuidelines","checkBetweenRects","snapThresholds","maxSnapElementGapDistance","elementRects","gapGuidelines","targetCenter","targetStart2","targetEnd2","snapThresholdMap","nextElementRects","snapRect1","snapRect2","rect1","rect2","rect1Start","rect1End","rect2Start","rect2End","isCenter","startGridGroupGuidelines","snapGridAll","snapRenderInfo","hasDirection","posName","clientOffset","rectSize","rectPos","childSizes","firstChildSize","childSnapSizes","rectRatio","childSize","startOffset","snapThresholdInfo","defaultSnapGridWidth","defaultSnapGridHeight","pushGuideline","distance","elementGuidelines","prevValues","snapRect","nextElementGuidelines","getRefTarget","nextValues","prevIndex","getSnapElementRects","elementSnapDirections","topValue","leftValue","rightValue","bottomValue","centerValue","middleValue","horizontal","vertical","rectTop","rectLeft","sizes","getObjectGuidelines","containerSize","posGuideline","snapWidth","snapHeight","offsetDelta","containerLeft","containerTop","elementLeft","elementTop","elementRight","elementBottom","checkSnapInfo","snapContainer","snapContainerTarget","snapContainerRect","offset1","getDragDistByState","offset2","getNextFixedPoses","nextFixedPos","normalized","getSizeOffsetInfo","innerBoundLineInfos","recheckSizeByTwoDirection","snapPos","nextWidthOffset","nextHeightOffset","checkSizeDist","getNextPoses","isWidthBound","isHeightBound","widthDist","heightDist","bumpDegree","baseDeg","deg1","deg2","getMinDegreeDistance","deg3","snapRotationThreshold","snapRotationDegrees","origin2","firstDegree","checkSnapScale","sizeDist","getSnapGuidelines","posInfos","addBoundGuidelines","verticalSnapPoses","horizontalSnapPoses","innerBoundMap","verticalInnerBoundPoses","horizontalInnerBoundPoses","innerPos","Snappable","targetTop","targetLeft","snapRenderThreshold","watchValue","minLeft","minTop","externalPoses","snapInfos","hasExternalPoses","externalRect","verticalPosInfos","horizontalPosInfos","allGuidelines","nextBoundMap","nextInnerBoundMap","rotatableDragControlCondtion","multiply2","defaultSync","fn","measureSVGSize","getSVGViewBox","getBeforeTransformOrigin","getTransformOrigin","getComputedStyle","o","getTransformOriginArray","computedTransform","baseVal","lastParent","isParent","checkZoom","getTargetStyle","hasSlot","parentSlotElement","assignedSlotParentElement","isCustomElement","targetPosition","willChange","slotParentNode","targetParentNode","parentNode","getSVGGraphicsOffset","getBodyStyle","bodyPosition","marginLeft","marginTop","fixedContainer","hasTransform","body","makeMatrixCSS","clientWidth","clientHeight","viewBox","viewBoxWidth","viewBoxHeight","scaleX","scaleY","preserveAspectRatio","align","meetOrSlice","svgOrigin","xAlign","yAlign","scaleDimension","isGTarget","isFillBox","bbox","rectWidth","rectHeight","calculateRect","getSVGOffset","targetInfo","getSize","mat","prevLeft","prevTop","posOrigin","rectOrigin","mat2","nextLeft","nextTop","distLeft","distTop","rootClientRect","rootPoses","getDiagonalSize","self","offsetWidth","offsetHeight","cssWidth","cssHeight","contentWidth","contentHeight","minOffsetWidth","minOffsetHeight","maxOffsetWidth","maxOffsetHeight","inlineCSSWidth","inlineCSSHeight","svg","targetStyle","boxSizing","borderLeft","borderRight","borderTop","borderBottom","paddingLeft","paddingRight","paddingTop","paddingBottom","horizontalPadding","verticalPadding","horizontalBorder","verticalBorder","getParentStyle","resetClientRect","getExtendsRect","isRoot","extendsRect","getClientRectByPosition","base","isExtends","baseTop","baseLeft","convertTransformOriginArray","getDirection","direciton","unsetAbles","isControl","unsetGesto","gestoName","resolvedEvent","prevEvent","nextEvent","isBeforeEvent","isManager","pseudoElt","filterAbles","methods","triggerAblesSimultaneously","enabledAbles","ableGroups","method","equals","groupKeys","groupKey","keyIndex","groupByMap","args","convertDragDist","calculatePadding","xAdded","yAdded","nextAdded","convertCSSSize","isRelative","checkAbles","transforms","beforeFunctionTexts","beforeFunctionTexts2","targetFunctionText","afterFunctionTexts","afterFunctionTexts2","beforeFunctions","beforeFunctions2","afterFunctions","afterFunctions2","targetFunctions","beforeFunctionMatrix","beforeFunctionMatrix2","afterFunctionMatrix","afterFunctionMatrix2","allFunctionMatrix","isArrayFormat","isSelector","getAbsoluteRotation","getSizeDistByDist","startSize","standardRad","signSize","startWidthSize","startHeightSize","secondRad","firstRad","distSize","pinchScale","startFixedDirection","directionsDists","directionRatios","ratioDistance","convertTransformUnit","xy","leftOrigin","rightOrigin","originObject","nextOriginObject","rotatePosesInfo","isDeepArrayEquals","arr1","arr2","value1","value2","isArray1","isArray2","valueKey","defaultValue","countEach","getPaddingBox","padding","Pinchable","angle","pinchable","controlEventName","pinchAbles","ableEvent","Scalable","setMinScaleSize","setMaxScaleSize","isScale","throttleScale","tempScaleValue","getNextScale","stateDirection","nextScale","distSign","isSelfPinch","startOffsetSize","scaleSize","distText","scaleText","isZeroScale","scaleEndParam","moveableScale","getMiddleLinePos","getTriangleRad","rad1","isValidPos","poses1","poses2","rad2","pi","Warpable","resizable","scalable","warpable","linePosFrom1","linePosFrom2","linePosFrom3","linePosFrom4","linePosTo1","linePosTo2","linePosTo3","linePosTo4","targetInverseMatrix","prevMatrix","isWarp","posIndexes","absolutePoses","selectedPoses","nearByPoses","afterMatrix","totalMatrix","AREA_PIECES","AREA_PIECE","AVOID","VIEW_DRAGGING","restoreStyle","renderPieces","DragArea","dragArea","passDragArea","areaElement","rects","Origin","originStyle","Scrollable","dragScroll","scrollContainerElement","scrollThreshold","scrollThrottleTime","Default","Padding","paddingDirections","paddingPos1","paddingPos2","paddingPos3","paddingPos4","RADIUS_DIRECTIONS","calculateRatio","sumSize","sumRatio","HORIZONTAL_RADIUS_ORDER","VERTICAL_RADIUS_ORDER","HORIZONTAL_RADIUS_DIRECTIONS","VERTICAL_RADIUS_DIRECTIONS","getRadiusStyles","clipStyles","radiusPoses","raws","rawPos","getRadiusRange","controlPoses","horizontalRange","verticalRange","clipPose","getRadiusValues","minCounts","full","splitIndex","splitLength","horizontalValues","verticalValues","horizontalValuesLength","verticalValuesLength","hasVerticalValues","nwValue","neValue","seValue","swValue","wnValue","enValue","esValue","wsValue","horizontalRawPoses","verticalRawPoses","nextHorizontalPoses","nextVerticalPoses","removeRadiusPos","radiuslIndex","deleteCount","addRadiusPos","horizontalIndex","verticalIndex","radiusX","radiusY","startVerticalIndex","splitRadiusPoses","horizontals","verticals","CLIP_DIRECTIONS","CLIP_RECT_DIRECTIONS","getClipStyles","clipPath","clipRelative","clipType","clipPoses","isRect","isCircle","subWidth","subHeight","getRectPoses","dirx","diry","getControlSize","xRange","yRange","getClipPath","defaultClip","customClip","clipText","clipPrefix","splitter","xPos","yPos","radius","xRadius","yRadius","centerPos","roundIndex","rectLength","radiusValues","nextRight","nextBottom","posValue","moveControlPos","sub","dists","verticalDirections","horizontalDirections","fixedIndex","nextDist","nextControlPoses","controlPose","controlDir","dirDir","dirHorizontal","dirVertical","addClipPath","clipIndex","clipStyle","removeClipPath","Clippable","customClipPath","defaultClipPath","clipArea","clipPathState","snapBoundInfos","calculatedPos","controls","isInset","isPolygon","linePoses","clipLeft","clipTop","ellipseClipPath","piece","areaPoses","allWidth","allHeight","allLeft","allTop","directionType","snapPos1","snapPos2","dragWithClip","isDragTarget","isLine","isArea","originalDraggable","originalDist","firstDist","isDragWithTarget","isAll","guidePoses","isEllipse","guideRect","guideXPoses","guideYPoses","rectPoses","rectDists","boundDelta","snapOffsetY","snapOffsetX","distSnapX","distSnapY","nextClipStyles","dragDist","isClipStart","OriginDraggable","originRelative","distOrigin","dragDelta","addBorderRadiusByLine","lineIndex","horizontalsLength","virtual","verticalsLength","controlIndex","controlPoseInfo","addBorderRadius","removeBorderRadius","getBorderRadius","borderRadius","triggerRoundEvent","styles","getStyleBorderRadius","firstMoveable","Roundable","roundClickable","borderRadiusState","minRoundControls","maxRoundControls","roundPadding","isDisplayShadowRoundControls","verticalCount","horizontalCount","basePos","originalPos","isDisplayVerticalShadow","isDisplay","indexAttr","roundRelative","selectedControlPose","selectedVertical","selectedHorizontal","pose","poseDist","isIdentityMatrix","identityMatrix","BeforeRenderable","inlineTransform","cssMatrix","startTransform","Renderable","transformObject","matrixInfo","triggerAble","moveableAbles","eventOperations","eventAffix","eventType","requestInstant","requestAble","isDragStop","stop","isFirstStart","gestoType","prevGesto","trigger","conditionName","nextDatas","forceEndedCount","updatedCount","eventOperation","eventAbles","isUpdate","isForceEnd","checkMoveableTarget","eventTarget","dragTargetElement","getTargetAbleGesto","moveableTarget","controlBox","dragTarget","checkTarget","getAbleGesto","getControlAbleGesto","checkControlTarget","ableType","conditionFunctions","isTargetAbles","preventClickDefault","dragContaienrOption","isPinchScheduled","EventManager","Tag","cssStyled","cssId","forwardRef","cspNonce","targetRef","useRef","useImperativeHandle","useEffect","injectResult","calculateMatrixStack","isAbsolute3d","prevTargetMatrix","containerZoom","rootMatrixes","isRoot3d","offsetRootContainer","rootZoom","isNext3d","isSVGGraphicElement","nextRootMatrixes","originalRootContainer","endContainer","rootMatrixBeforeOffset","nextInfo","isMatrix3d","originalRootMatrix","calculateElementInfo","allResult","getMoveableTargetInfo","moveableElement","parentContainer","requestStyles","targetClientRect","rootContainerClientRect","beforePosition","absoluteTargetPosition","absoluteContainerPosition","containerClientRectLeft","containerClientRectTop","containterClientLeft","containerClientTop","clientDelta","getPersistState","MoveableManager","parentPosition","propsTarget","translateZ","ControlBoxElement","linePadding","controlPadding","stateTarget","groupTargets","isDragging","ableAttributes","ableClassName","isVisible","prevProps","manager","wrapperMoveable","totalSize","isTarget","isSetState","isSingle","nextState","persistState","statePos","isInstant","allAbles","requsetAble","ableRequester","requester","ableParam","originalBeforeOrigin","stateLeft","stateTop","isPersisted","renderPos3","renderPos4","zoomOffset","stateContainer","isTargetChanged","moveableContainer","customStyleMap","hasControlBox","persistData","firstRenderState","pinchStart","dragControlStart","targetAbles","controlAbles","Renderer","render","ableStyleNames","hasTargetAble","hasControlAble","hideDefaultLines","hideChildMoveableDefaultLines","useDragArea","nextTarget","prevDragArea","eventKeys","hasAbles","viewContainerOption","viewContainer","nextClassNames","prevClassNames","classPrefix","targetGestoData","controlGestoData","_c","observer","records","mutation","Groupable","renderGroupRects","persistDatChildren","Clickable","containsElement","containsTarget","parentTarget","getDraggableEvent","edgeDraggable","IndividualGroupable","MOVEABLE_ABLES","solveConstantsDistance","solveC","getMaxPos","getMinPos","getGroupRect","parentPoses","fixedRotation","a1MinMax","a1MinMaxPos","a2MinMax","a2MinMaxPos","a1Dist","a2Dist","a1MinPos","a1MaxPos","a2MinPos","a2MaxPos","minHorizontalLine","maxHorizontalLine","minVerticalLine","maxVerticalLine","findMoveableGroups","childTargetGroups","targetGroup","childMoveableGroups","checked","MoveableGroup","checkeds","targetGroups","moveableGroups","useDefaultGroupRotate","finded","isReset","defaultGroupRotate","persistedRoatation","getMoveableGroupRect","parentRotation","posesRotations","rotations","groupRotation","firstRotation","isSameRotation","groupPoses","rootGroupRect","posesInfo","rotateScale","isContainerChanged","MoveableIndividualGroup","canPersist","individualProps","controlBoxElement","dragElement","getElementTargets","refTargets","selectorMap","elementTargets","getTargetGroups","compareRefTargets","prevRefTargets","nextRefTargets","applyMethods","instance","propertyName","InitialMoveable","cssMap","moveableContructor","userAbles","userProps","nextSelectorMap","nextProps","prevMoveable","prevTargetMoveable","mv","resolvePromise","isBrowser","updateSelectorMap","Moveable","IS_SAFARI","WRAPPER_CLASS_NAME","SCROLL_AREA_CLASS_NAME","SCROLL_BAR_CLASS_NAME","HORIZONTAL_SCROLL_BAR_CLASS_NAME","VERTICAL_SCROLL_BAR_CLASS_NAME","SCROLL_THUMB_CLASS_NAME","DEFAULT_OPTIONS","DEFAULT_EASING","NAMES","OPTIONS","EVENTS","METHODS","measureSpeed","time","prevSpeed","dt","getDuration","speed","normalSpeed","getDestPos","duration","getRange","range","isReal","checkDefault","startAnimation","timerCallback","easing","startTime","prevTime","prevRatio","ScrollBar","containerElement","isThumb","thumbRect","thumbSize","thumbElement","barElement","isAbsolute","scrollSize","opacity","dirName1","sizeP","posP","applyProperties","targetClass","properties","_containerElement","viewportElement","viewportWidth","viewportHeight","viewportScrollWidth","viewportScrollHeight","viewerScrollLeft","viewerScrollTop","pinchDirection","maxPinchWheel","isKeydown","zoomX","zoomY","absolute","isZoom","prevZoomX","prevZoomY","zoomRange","zoomOffsetX","zoomOffsetY","zoomRangeX","zoomRangeY","nextZoomX","nextZoomY","zoomXPos","zoomYPos","deltaZoom","wrapperElement","scrollAreaElement","horizontalScrollElement","verticalScrollElement","horizontalBar","verticalBar","wheelContainerOption","wheelContainerElement","rangeX","rangeY","useTransform","nextOffsetX","nextOffsetY","viewportStyle","scrollWidth","scrollHeight","scrollRangeX","scrollRangeY","displayVerticalScroll","displayHorizontalScroll","dest","distRatio","destPos","originalZoomOffsetX","originalZoomOffsetY","zoomOptions","zoomBase","nextScrollLeft","nextScrollTop","centerX","centerY","nextCenterX","nextCenterY","prevScrollLeft","prevScrollTop","nextScrollAbsoluteLeft","nextScrollAbsoluteTop","requestScrollLeft","requestScrollTop","coord","minCoord","maxCoord","scrollPos","scrollAreaSize","zoomCoord","minThreshold","maxThreshold","rangeCoord","rangeOffsetCoord","startRange","endRange","startMargin","endMargin","viewportSize","InfiniteViewer","REACT_EVENTS","duplicate","methodName","VanillaInfiniteViewer","selfProps","infiniteViewer"],"mappings":"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","x_google_ignoreList":[21]}