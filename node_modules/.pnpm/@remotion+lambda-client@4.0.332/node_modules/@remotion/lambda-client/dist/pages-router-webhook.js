"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pagesRouterWebhook = exports.addHeaders = void 0;
const validate_webhook_signature_1 = require("./validate-webhook-signature");
const addHeaders = (res, headers) => {
    Object.entries(headers).forEach(([key, value]) => {
        res.setHeader(key, value);
    });
};
exports.addHeaders = addHeaders;
const pagesRouterWebhook = (options) => {
    const { testing, extraHeaders, secret, onSuccess, onTimeout, onError } = options;
    return function (req, res) {
        (0, exports.addHeaders)(res, extraHeaders || {});
        if (testing) {
            const testingheaders = {
                'Access-Control-Allow-Origin': 'https://www.remotion.dev',
                'Access-Control-Allow-Headers': 'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version, X-Remotion-Status, X-Remotion-Signature, X-Remotion-Mode',
                'Access-Control-Allow-Methods': 'OPTIONS,POST',
            };
            (0, exports.addHeaders)(res, testingheaders);
        }
        if (req.method === 'OPTIONS') {
            res.status(200).end();
            return;
        }
        (0, validate_webhook_signature_1.validateWebhookSignature)({
            secret,
            body: req.body,
            signatureHeader: req.headers['x-remotion-signature'],
        });
        // If code reaches this path, the webhook is authentic.
        const payload = req.body;
        if (payload.type === 'success' && onSuccess) {
            onSuccess(payload);
        }
        else if (payload.type === 'timeout' && onTimeout) {
            onTimeout(payload);
        }
        else if (payload.type === 'error' && onError) {
            onError(payload);
        }
        res.status(200).json({
            success: true,
        });
    };
};
exports.pagesRouterWebhook = pagesRouterWebhook;
